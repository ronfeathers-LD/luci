module.exports = [
"[project]/node_modules/jsforce/lib/VERSION.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = '3.10.8';
}),
"[project]/node_modules/jsforce/lib/util/stream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.concatStreamsAsDuplex = exports.readAll = exports.createLazyStream = void 0;
const stream_1 = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
function createLazyStream() {
    const ins = new stream_1.PassThrough();
    const outs = new stream_1.PassThrough();
    const stream = concatStreamsAsDuplex(ins, outs);
    let piped = false;
    const setStream = (str)=>{
        if (piped) {
            throw new Error('stream is already piped to actual stream');
        }
        piped = true;
        ins.pipe(str).pipe(outs);
    };
    return {
        stream,
        setStream
    };
}
exports.createLazyStream = createLazyStream;
class MemoryWriteStream extends stream_1.Writable {
    _buf;
    constructor(){
        super();
        this._buf = Buffer.alloc(0);
    }
    _write(chunk, encoding, callback) {
        this._buf = Buffer.concat([
            this._buf,
            chunk
        ]);
        callback();
    }
    _writev(data, callback) {
        this._buf = Buffer.concat([
            this._buf,
            ...data.map(({ chunk })=>chunk)
        ]);
        callback();
    }
    toString(encoding = 'utf-8') {
        return this._buf.toString(encoding);
    }
}
async function readAll(rs, encoding = 'utf-8') {
    return new Promise((resolve, reject)=>{
        const ws = new MemoryWriteStream();
        rs.on('error', reject).pipe(ws).on('finish', ()=>resolve(ws.toString(encoding)));
    });
}
exports.readAll = readAll;
class DuplexifiedStream extends stream_1.Duplex {
    _writable;
    _readable;
    constructor(ws, rs, opts = {}){
        super({
            writableObjectMode: opts.writableObjectMode ?? ws.writableObjectMode,
            readableObjectMode: opts.readableObjectMode ?? rs.readableObjectMode
        });
        this._writable = ws;
        this._readable = rs;
        ws.once('finish', ()=>{
            this.end();
        });
        this.once('finish', ()=>{
            ws.end();
        });
        rs.on('readable', ()=>{
            this._readStream();
        });
        rs.once('end', ()=>{
            this.push(null);
        });
        ws.on('error', (err)=>this.emit('error', err));
        rs.on('error', (err)=>this.emit('error', err));
    }
    _write(chunk, encoding, callback) {
        this._writable.write(chunk, encoding, callback);
    }
    _read(n) {
        this._readStream(n);
    }
    _readStream(n) {
        let data;
        while((data = this._readable.read(n)) !== null){
            this.push(data);
        }
    }
}
function concatStreamsAsDuplex(ws, rs, opts) {
    return new DuplexifiedStream(ws, rs, opts);
}
exports.concatStreamsAsDuplex = concatStreamsAsDuplex;
}),
"[project]/node_modules/jsforce/lib/request-helper.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.executeWithTimeout = exports.performRedirectRequest = exports.isRedirect = exports.createHttpRequestHandlerStreams = void 0;
const stream_1 = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const stream_2 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/util/stream.js [app-route] (ecmascript)");
const form_data_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/form-data/lib/form_data.js [app-route] (ecmascript)"));
/**
 *
 */ function createHttpRequestHandlerStreams(req, options = {}) {
    const { body: reqBody } = req;
    const input = new stream_1.PassThrough();
    const output = new stream_1.PassThrough();
    const duplex = (0, stream_2.concatStreamsAsDuplex)(input, output);
    if (typeof reqBody !== 'undefined') {
        setTimeout(()=>{
            if (reqBody instanceof form_data_1.default) {
                duplex.end(reqBody.getBuffer());
            } else {
                duplex.end(reqBody, 'utf8');
            }
        }, 0);
    }
    duplex.on('response', async (res)=>{
        if (duplex.listenerCount('complete') > 0) {
            const resBody = await (0, stream_2.readAll)(duplex, options.encoding);
            duplex.emit('complete', {
                ...res,
                body: resBody
            });
        }
    });
    return {
        input,
        output,
        stream: duplex
    };
}
exports.createHttpRequestHandlerStreams = createHttpRequestHandlerStreams;
const redirectStatuses = new Set([
    301,
    302,
    303,
    307,
    308
]);
/**
 *
 */ function isRedirect(status) {
    return redirectStatuses.has(status);
}
exports.isRedirect = isRedirect;
/**
 *
 */ const MAX_REDIRECT_COUNT = 10;
/**
 *
 */ function performRedirectRequest(req, res, followRedirect, counter, redirectCallback) {
    if (counter >= MAX_REDIRECT_COUNT) {
        throw new Error('Reached to maximum redirect count');
    }
    const redirectUrl = res.headers['location'];
    if (!redirectUrl) {
        throw new Error('No redirect URI found');
    }
    const getRedirectRequest = typeof followRedirect === 'function' ? followRedirect : ()=>({
            method: 'GET',
            url: redirectUrl,
            headers: req.headers
        });
    const nextReqParams = getRedirectRequest(redirectUrl);
    if (!nextReqParams) {
        throw new Error('Cannot handle redirect for ' + redirectUrl);
    }
    redirectCallback(nextReqParams);
}
exports.performRedirectRequest = performRedirectRequest;
/**
 *
 */ async function executeWithTimeout(execFn, msec, cancelCallback) {
    let timeout = false;
    const pid = msec != null ? setTimeout(()=>{
        timeout = true;
        cancelCallback?.();
    }, msec) : undefined;
    let res;
    try {
        res = await execFn();
    } finally{
        if (pid) {
            clearTimeout(pid);
        }
    }
    if (timeout) {
        throw new Error('Request Timeout');
    }
    return res;
}
exports.executeWithTimeout = executeWithTimeout;
}),
"[project]/node_modules/jsforce/lib/util/logger.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getLogger = exports.Logger = exports.LogLevels = void 0;
/**
 *
 */ exports.LogLevels = {
    DEBUG: 1,
    INFO: 2,
    WARN: 3,
    ERROR: 4,
    FATAL: 5,
    NONE: 6
};
const LogLevelLabels = [
    '',
    'DEBUG',
    'INFO',
    'WARN',
    'ERROR',
    'FATAL',
    'NONE'
];
const globalLogLevelConfig = (()=>{
    const globalLogLevelStr = process.env.JSFORCE_LOG_LEVEL || /*TURBOPACK member replacement*/ __turbopack_context__.g.__JSFORCE_LOG_LEVEL__ || 'NONE';
    if (/^(DEBUG|INFO|WARN|ERROR|FATAL|NONE)$/i.test(globalLogLevelStr)) {
        return {
            '*': globalLogLevelStr
        };
    }
    try {
        return JSON.parse(globalLogLevelStr);
    } catch (e) {
        return {
            '*': 'NONE'
        };
    }
})();
function getModuleLogLevel(logLevelConfig, moduleName) {
    const logLevel = logLevelConfig[moduleName] || logLevelConfig['*'];
    return typeof logLevel === 'number' ? logLevel : exports.LogLevels[logLevel] || exports.LogLevels.NONE;
}
/**
 *
 */ class Logger {
    _moduleName;
    _logLevel;
    constructor(moduleName, logLevelConfig = globalLogLevelConfig){
        this._moduleName = moduleName;
        this._logLevel = typeof logLevelConfig === 'number' ? logLevelConfig : typeof logLevelConfig === 'string' ? exports.LogLevels[logLevelConfig] || exports.LogLevels.NONE : getModuleLogLevel(logLevelConfig, moduleName);
    }
    createInstance(logLevelConfig = this._logLevel) {
        return new Logger(this._moduleName, logLevelConfig);
    }
    setLogLevel(logLevel) {
        if (typeof logLevel === 'string') {
            this._logLevel = exports.LogLevels[logLevel] || exports.LogLevels.NONE;
        } else {
            this._logLevel = logLevel;
        }
    }
    log(logLevel, ...messages) {
        if (this._logLevel <= logLevel) {
            const msgs = [
                `${LogLevelLabels[logLevel]}\t[${this._moduleName}] `,
                ...messages
            ];
            if (logLevel < exports.LogLevels.ERROR) {
                console.log(...msgs); // eslint-disable-line no-console
            } else {
                console.error(...msgs); // eslint-disable-line no-console
            }
        }
    }
    debug(...messages) {
        this.log(exports.LogLevels.DEBUG, ...messages);
    }
    info(...messages) {
        this.log(exports.LogLevels.INFO, ...messages);
    }
    warn(...messages) {
        this.log(exports.LogLevels.WARN, ...messages);
    }
    error(...messages) {
        this.log(exports.LogLevels.ERROR, ...messages);
    }
    fatal(...messages) {
        this.log(exports.LogLevels.FATAL, ...messages);
    }
}
exports.Logger = Logger;
const loggers = {};
/**
 *
 */ function getLogger(moduleName) {
    const logger = loggers[moduleName] || new Logger(moduleName);
    loggers[moduleName] = logger;
    return logger;
}
exports.getLogger = getLogger;
}),
"[project]/node_modules/jsforce/lib/request.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setDefaults = void 0;
const stream_1 = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const node_fetch_1 = __importStar(__turbopack_context__.r("[project]/node_modules/node-fetch/lib/index.mjs [app-route] (ecmascript)"));
const https_proxy_agent_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/https-proxy-agent/dist/index.js [app-route] (ecmascript)"));
const request_helper_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/request-helper.js [app-route] (ecmascript)");
const logger_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/util/logger.js [app-route] (ecmascript)");
const is_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@sindresorhus/is/dist/index.js [app-route] (ecmascript)"));
/**
 *
 */ let defaults = {};
/**
 *
 */ function setDefaults(defaults_) {
    defaults = defaults_;
}
exports.setDefaults = setDefaults;
/**
 *
 */ async function startFetchRequest(request, options, input, output, emitter, counter = 0) {
    const logger = (0, logger_1.getLogger)('fetch');
    const { httpProxy, followRedirect } = options;
    const agent = httpProxy ? (0, https_proxy_agent_1.default)(httpProxy) : undefined;
    const { url, body, ...rrequest } = request;
    const controller = new AbortController();
    let retryCount = 0;
    const retryOpts = {
        statusCodes: options.retry?.statusCodes ?? [
            420,
            429,
            500,
            502,
            503,
            504
        ],
        maxRetries: options.retry?.maxRetries ?? 5,
        minTimeout: options.retry?.minTimeout ?? 500,
        timeoutFactor: options.retry?.timeoutFactor ?? 2,
        errorCodes: options.retry?.errorCodes ?? [
            'ECONNRESET',
            'ECONNREFUSED',
            'ENOTFOUND',
            'ENETDOWN',
            'ENETUNREACH',
            'EHOSTDOWN',
            'UND_ERR_SOCKET',
            'ETIMEDOUT',
            'EPIPE'
        ],
        methods: options.retry?.methods ?? [
            'GET',
            'PUT',
            'HEAD',
            'OPTIONS',
            'DELETE'
        ]
    };
    const shouldRetryRequest = (maxRetry, resOrErr)=>{
        if (!retryOpts.methods.includes(request.method)) return false;
        if (resOrErr instanceof node_fetch_1.Response) {
            if (retryOpts.statusCodes.includes(resOrErr.status)) {
                if (maxRetry === retryCount) {
                    return false;
                } else {
                    return true;
                }
            }
            return false;
        } else {
            if (maxRetry === retryCount) return false;
            // only retry on operational errors
            // https://github.com/node-fetch/node-fetch/blob/2.x/ERROR-HANDLING.md#error-handling-with-node-fetch
            if (resOrErr.name != 'FetchError') return false;
            if (is_1.default.nodeStream(body) && stream_1.Readable.isDisturbed(body)) {
                logger.debug('Body of type stream was read, unable to retry request.');
                return false;
            }
            if ('code' in resOrErr && resOrErr.code && retryOpts?.errorCodes?.includes(resOrErr.code)) return true;
            return false;
        }
    };
    const fetchWithRetries = async (maxRetry = retryOpts?.maxRetries)=>{
        const fetchOpts = {
            ...rrequest,
            ...input && /^(post|put|patch)$/i.test(request.method) ? {
                body: input
            } : {},
            redirect: 'manual',
            signal: controller.signal,
            agent
        };
        try {
            const res = await (0, node_fetch_1.default)(url, fetchOpts);
            if (shouldRetryRequest(retryOpts.maxRetries, res)) {
                logger.debug(`retrying for the ${retryCount + 1} time`);
                logger.debug('reason: statusCode match');
                await sleep(retryCount === 0 ? retryOpts.minTimeout : retryOpts.minTimeout * retryOpts.timeoutFactor ** retryCount);
                // NOTE: this event is only used by tests and will be removed at any time.
                // jsforce may switch to node's fetch which doesn't emit this event on retries.
                emitter.emit('retry', retryCount);
                retryCount++;
                return await fetchWithRetries(maxRetry);
            }
            // should we throw here if the maxRetry already happened and still got the same statusCode?
            return res;
        } catch (err) {
            logger.debug('Request failed');
            const error = err;
            // request was canceled by consumer (AbortController), skip retry and rethrow.
            if (error.name === 'AbortError') {
                throw error;
            }
            if (shouldRetryRequest(retryOpts.maxRetries, error)) {
                logger.debug(`retrying for the ${retryCount + 1} time`);
                logger.debug(`Error: ${err.message}`);
                await sleep(retryCount === 0 ? retryOpts.minTimeout : retryOpts.minTimeout * retryOpts.timeoutFactor ** retryCount);
                // NOTE: this event is only used by tests and will be removed at any time.
                // jsforce may switch to node's fetch which doesn't emit this event on retries.
                emitter.emit('retry', retryCount);
                retryCount++;
                return fetchWithRetries(maxRetry);
            }
            logger.debug('Skipping retry...');
            if (maxRetry === retryCount) {
                throw err;
            } else {
                throw err;
            }
        }
    };
    let res;
    // Timeout after 30 minutes without a response
    //
    // node-fetch's default timeout is 0 and jsforce consumers can't set this when calling `Connection` methods so we set a long default at the fetch wrapper level.
    const fetchTimeout = options.timeout ?? 1800000;
    try {
        res = await (0, request_helper_1.executeWithTimeout)(fetchWithRetries, fetchTimeout, ()=>controller.abort());
    } catch (err) {
        if (err instanceof node_fetch_1.AbortError) {
            err.message += ' Request was aborted due to timeout of 10 minutes.';
        }
        emitter.emit('error', err);
        return;
    }
    const headers = {};
    for (const headerName of res.headers.keys()){
        headers[headerName.toLowerCase()] = res.headers.get(headerName);
    }
    const response = {
        statusCode: res.status,
        headers
    };
    if (followRedirect && (0, request_helper_1.isRedirect)(response.statusCode)) {
        try {
            (0, request_helper_1.performRedirectRequest)(request, response, followRedirect, counter, (req)=>startFetchRequest(req, options, undefined, output, emitter, counter + 1));
        } catch (err) {
            emitter.emit('error', err);
        }
        return;
    }
    emitter.emit('response', response);
    res.body.pipe(output);
}
/**
 *
 */ function request(req, options_ = {}) {
    const options = {
        ...defaults,
        ...options_
    };
    const { input, output, stream } = (0, request_helper_1.createHttpRequestHandlerStreams)(req, options);
    startFetchRequest(req, options, input, output, stream);
    return stream;
}
exports.default = request;
const sleep = (ms)=>new Promise((r)=>setTimeout(r, ms));
}),
"[project]/node_modules/jsforce/lib/util/promise.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StreamPromise = void 0;
/**
 *
 */ const stream_1 = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
/**
 *
 */ class StreamPromise extends Promise {
    stream() {
        // dummy
        return new stream_1.Duplex();
    }
    static create(builder) {
        const { stream, promise } = builder();
        const streamPromise = new StreamPromise((resolve, reject)=>{
            promise.then(resolve, reject);
        });
        streamPromise.stream = ()=>stream;
        return streamPromise;
    }
}
exports.StreamPromise = StreamPromise;
}),
"[project]/node_modules/jsforce/lib/browser/jsonp.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 *
 */ const stream_1 = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
let _index = 0;
async function processJsonpRequest(params, jsonpParam, timeout) {
    if (params.method.toUpperCase() !== 'GET') {
        throw new Error('JSONP only supports GET request.');
    }
    _index += 1;
    const cbFuncName = `_jsforce_jsonpCallback_${_index}`;
    const callbacks = window;
    let url = params.url;
    url += url.indexOf('?') > 0 ? '&' : '?';
    url += `${jsonpParam}=${cbFuncName}`;
    const script = document.createElement('script');
    script.type = 'text/javascript';
    script.src = url;
    if (document.documentElement) {
        document.documentElement.appendChild(script);
    }
    let pid;
    try {
        const res = await new Promise((resolve, reject)=>{
            pid = setTimeout(()=>{
                reject(new Error('JSONP call time out.'));
            }, timeout);
            callbacks[cbFuncName] = resolve;
        });
        return {
            statusCode: 200,
            headers: {
                'content-type': 'application/json'
            },
            body: JSON.stringify(res)
        };
    } finally{
        clearTimeout(pid);
        if (document.documentElement) {
            document.documentElement.removeChild(script);
        }
        delete callbacks[cbFuncName];
    }
}
function createRequest(jsonpParam = 'callback', timeout = 10000) {
    return (params)=>{
        const stream = new stream_1.Transform({
            transform (chunk, encoding, callback) {
                callback();
            },
            flush () {
                (async ()=>{
                    const response = await processJsonpRequest(params, jsonpParam, timeout);
                    stream.emit('response', response);
                    stream.emit('complete', response);
                    stream.push(response.body);
                    stream.push(null);
                })();
            }
        });
        stream.end();
        return stream;
    };
}
exports.default = {
    supported: ("TURBOPACK compile-time value", "undefined") !== 'undefined' && typeof document !== 'undefined',
    createRequest
};
}),
"[project]/node_modules/jsforce/lib/browser/canvas.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 *
 */ const stream_1 = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
function parseHeaders(hs) {
    const headers = {};
    for (const line of hs.split(/\n/)){
        const [name, value] = line.split(/\s*:\s*/);
        headers[name.toLowerCase()] = value;
    }
    return headers;
}
async function processCanvasRequest(params, signedRequest, requestBody) {
    const settings = {
        client: signedRequest.client,
        method: params.method,
        data: requestBody
    };
    const paramHeaders = params.headers;
    if (paramHeaders) {
        settings.headers = {};
        for (const name of Object.keys(paramHeaders)){
            if (name.toLowerCase() === 'content-type') {
                settings.contentType = paramHeaders[name];
            } else {
                settings.headers[name] = paramHeaders[name];
            }
        }
    }
    const data = await new Promise((resolve, reject)=>{
        settings.success = resolve;
        settings.failure = reject;
        Sfdc.canvas.client.ajax(params.url, settings);
    });
    const headers = parseHeaders(data.responseHeaders);
    let responseBody = data.payload;
    if (typeof responseBody !== 'string') {
        responseBody = JSON.stringify(responseBody);
    }
    return {
        statusCode: data.status,
        headers,
        body: responseBody
    };
}
function createRequest(signedRequest) {
    return (params)=>{
        const buf = [];
        const stream = new stream_1.Transform({
            transform (chunk, encoding, callback) {
                buf.push(typeof chunk === 'string' ? chunk : chunk.toString('utf8'));
                callback();
            },
            flush () {
                (async ()=>{
                    const body = buf.join('');
                    const response = await processCanvasRequest(params, signedRequest, body);
                    stream.emit('response', response);
                    stream.emit('complete', response);
                    stream.push(response.body);
                    stream.push(null);
                })();
            }
        });
        if (params.body) {
            stream.end(params.body);
        }
        return stream;
    };
}
exports.default = {
    supported: typeof Sfdc === 'object' && typeof Sfdc.canvas !== 'undefined',
    createRequest
};
}),
"[project]/node_modules/jsforce/lib/transport.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HttpProxyTransport = exports.XdProxyTransport = exports.CanvasTransport = exports.JsonpTransport = exports.Transport = void 0;
const request_1 = __importStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/request.js [app-route] (ecmascript)"));
const promise_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/util/promise.js [app-route] (ecmascript)");
const jsonp_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/browser/jsonp.js [app-route] (ecmascript)"));
const canvas_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/browser/canvas.js [app-route] (ecmascript)"));
/**
 * Normarize Salesforce API host name
 * @private
 */ function normalizeApiHost(apiHost) {
    const m = /(\w+)\.(visual\.force|salesforce)\.com$/.exec(apiHost);
    if (m) {
        return `${m[1]}.salesforce.com`;
    }
    return apiHost;
}
(0, request_1.setDefaults)({
    httpProxy: process.env.https_proxy ?? process.env.http_proxy ?? process.env.HTTPS_PROXY ?? process.env.HTTP_PROXY ?? undefined,
    timeout: process.env.HTTP_TIMEOUT ? parseInt(process.env.HTTP_TIMEOUT, 10) : undefined,
    followRedirect: true
});
const baseUrl = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : process.env.LOCATION_BASE_URL || '';
/**
 * Class for HTTP request transport
 *
 * @class
 * @protected
 */ class Transport {
    /**
     */ httpRequest(req, options = {}) {
        return promise_1.StreamPromise.create(()=>{
            const createStream = this.getRequestStreamCreator();
            const stream = createStream(req, options);
            const promise = new Promise((resolve, reject)=>{
                stream.on('complete', (res)=>resolve(res)).on('error', reject);
            });
            return {
                stream,
                promise
            };
        });
    }
    /**
     * @protected
     */ getRequestStreamCreator() {
        return request_1.default;
    }
}
exports.Transport = Transport;
/**
 * Class for JSONP request transport
 */ class JsonpTransport extends Transport {
    static supprted = jsonp_1.default.supported;
    _jsonpParam;
    constructor(jsonpParam){
        super();
        this._jsonpParam = jsonpParam;
    }
    getRequestStreamCreator() {
        const jsonpRequest = jsonp_1.default.createRequest(this._jsonpParam);
        return (params)=>jsonpRequest(params);
    }
}
exports.JsonpTransport = JsonpTransport;
/**
 * Class for Sfdc Canvas request transport
 */ class CanvasTransport extends Transport {
    static supported = canvas_1.default.supported;
    _signedRequest;
    constructor(signedRequest){
        super();
        this._signedRequest = signedRequest;
    }
    getRequestStreamCreator() {
        const canvasRequest = canvas_1.default.createRequest(this._signedRequest);
        return (params)=>canvasRequest(params);
    }
}
exports.CanvasTransport = CanvasTransport;
/* @private */ function createXdProxyRequest(req, proxyUrl) {
    const headers = {
        'salesforceproxy-endpoint': req.url
    };
    if (req.headers) {
        for (const name of Object.keys(req.headers)){
            headers[name] = req.headers[name];
        }
    }
    const nocache = `${Date.now()}.${String(Math.random()).substring(2)}`;
    return {
        method: req.method,
        url: `${proxyUrl}?${nocache}`,
        headers,
        ...req.body != null ? {
            body: req.body
        } : {}
    };
}
/**
 * Class for HTTP request transport using cross-domain AJAX proxy service
 */ class XdProxyTransport extends Transport {
    _xdProxyUrl;
    constructor(xdProxyUrl){
        super();
        this._xdProxyUrl = xdProxyUrl;
    }
    /**
     * Make HTTP request via AJAX proxy
     */ httpRequest(req, _options = {}) {
        const xdProxyUrl = this._xdProxyUrl;
        const { url, body, ...rreq } = req;
        const canonicalUrl = url.startsWith('/') ? baseUrl + url : url;
        const xdProxyReq = createXdProxyRequest({
            ...rreq,
            url: canonicalUrl,
            body
        }, xdProxyUrl);
        return super.httpRequest(xdProxyReq, {
            followRedirect: (redirectUrl)=>createXdProxyRequest({
                    ...rreq,
                    method: 'GET',
                    url: redirectUrl
                }, xdProxyUrl)
        });
    }
}
exports.XdProxyTransport = XdProxyTransport;
/**
 * Class for HTTP request transport using a proxy server
 */ class HttpProxyTransport extends Transport {
    _httpProxy;
    constructor(httpProxy){
        super();
        this._httpProxy = httpProxy;
    }
    /**
     * Make HTTP request via proxy server
     */ httpRequest(req, options_ = {}) {
        const options = {
            ...options_,
            httpProxy: this._httpProxy
        };
        return super.httpRequest(req, options);
    }
}
exports.HttpProxyTransport = HttpProxyTransport;
exports.default = Transport;
}),
"[project]/node_modules/jsforce/lib/oauth2.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAuth2 = void 0;
/**
 *
 */ const crypto_1 = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
const querystring_1 = __importDefault(__turbopack_context__.r("[externals]/querystring [external] (querystring, cjs)"));
const transport_1 = __importStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/transport.js [app-route] (ecmascript)"));
const defaultOAuth2Config = {
    loginUrl: 'https://login.salesforce.com'
};
// Makes a nodejs base64 encoded string compatible with rfc4648 alternative encoding for urls.
// @param base64Encoded a nodejs base64 encoded string
function base64UrlEscape(base64Encoded) {
    // builtin node js base 64 encoding is not 64 url compatible.
    // See https://toolsn.ietf.org/html/rfc4648#section-5
    return base64Encoded.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
}
/**
 * OAuth2 class
 */ class OAuth2 {
    loginUrl;
    authzServiceUrl;
    tokenServiceUrl;
    revokeServiceUrl;
    clientId;
    clientSecret;
    redirectUri;
    codeVerifier;
    _transport;
    /**
     *
     */ constructor(config){
        const { loginUrl, authzServiceUrl, tokenServiceUrl, revokeServiceUrl, clientId, clientSecret, redirectUri, proxyUrl, httpProxy, useVerifier } = config;
        if (authzServiceUrl && tokenServiceUrl) {
            this.loginUrl = authzServiceUrl.split('/').slice(0, 3).join('/');
            this.authzServiceUrl = authzServiceUrl;
            this.tokenServiceUrl = tokenServiceUrl;
            this.revokeServiceUrl = revokeServiceUrl || `${this.loginUrl}/services/oauth2/revoke`;
        } else {
            this.loginUrl = loginUrl ?? defaultOAuth2Config.loginUrl;
            const maybeSlash = this.loginUrl.endsWith('/') ? '' : '/';
            this.authzServiceUrl = `${this.loginUrl}${maybeSlash}services/oauth2/authorize`;
            this.tokenServiceUrl = `${this.loginUrl}${maybeSlash}services/oauth2/token`;
            this.revokeServiceUrl = `${this.loginUrl}${maybeSlash}services/oauth2/revoke`;
        }
        this.clientId = clientId;
        this.clientSecret = clientSecret;
        this.redirectUri = redirectUri;
        if (proxyUrl) {
            this._transport = new transport_1.XdProxyTransport(proxyUrl);
        } else if (httpProxy) {
            this._transport = new transport_1.HttpProxyTransport(httpProxy);
        } else {
            this._transport = new transport_1.default();
        }
        if (useVerifier) {
            // Set a code verifier string for OAuth authorization
            this.codeVerifier = base64UrlEscape((0, crypto_1.randomBytes)(Math.ceil(128)).toString('base64'));
        }
    }
    /**
     * Get Salesforce OAuth2 authorization page URL to redirect user agent.
     */ getAuthorizationUrl(params = {}) {
        if (this.codeVerifier) {
            // code verifier must be a base 64 url encoded hash of 128 bytes of random data. Our random data is also
            // base 64 url encoded. See Connection.create();
            params.code_challenge = base64UrlEscape((0, crypto_1.createHash)('sha256').update(this.codeVerifier).digest('base64'));
        }
        const _params = {
            ...params,
            response_type: 'code',
            client_id: this.clientId,
            redirect_uri: this.redirectUri
        };
        return this.authzServiceUrl + (this.authzServiceUrl.includes('?') ? '&' : '?') + querystring_1.default.stringify(_params);
    }
    /**
     * OAuth2 Refresh Token Flow
     */ async refreshToken(refreshToken) {
        if (!this.clientId) {
            throw new Error('No OAuth2 client id information is specified');
        }
        const params = {
            grant_type: 'refresh_token',
            refresh_token: refreshToken,
            client_id: this.clientId
        };
        if (this.clientSecret) {
            params.client_secret = this.clientSecret;
        }
        const ret = await this._postParams(params);
        return ret;
    }
    /**
     * Send access token request to the token endpoint.
     * When a code (string) is passed in first argument, it will use Web Server Authentication Flow (Authorization Code Grant).
     * Otherwise, it will use the specified `grant_type` and pass parameters to the endpoint.
     */ async requestToken(codeOrParams, params = {}) {
        if (typeof codeOrParams === 'string' && (!this.clientId || !this.redirectUri)) {
            throw new Error('No OAuth2 client id or redirect uri configuration is specified');
        }
        const _params = {
            ...params,
            ...typeof codeOrParams === 'string' ? {
                grant_type: 'authorization_code',
                code: codeOrParams
            } : codeOrParams
        };
        if (this.clientId) {
            _params.client_id = this.clientId;
        }
        if (this.clientSecret) {
            _params.client_secret = this.clientSecret;
        }
        if (this.redirectUri) {
            _params.redirect_uri = this.redirectUri;
        }
        const ret = await this._postParams(_params);
        return ret;
    }
    /**
     * OAuth2 Username-Password Flow (Resource Owner Password Credentials)
     */ async authenticate(username, password) {
        if (!this.clientId || !this.clientSecret) {
            throw new Error('No valid OAuth2 client configuration set');
        }
        const ret = await this._postParams({
            grant_type: 'password',
            username,
            password,
            client_id: this.clientId,
            client_secret: this.clientSecret
        });
        return ret;
    }
    /**
     * OAuth2 Revoke Session Token
     */ async revokeToken(token) {
        const response = await this._transport.httpRequest({
            method: 'POST',
            url: this.revokeServiceUrl,
            body: querystring_1.default.stringify({
                token
            }),
            headers: {
                'content-type': 'application/x-www-form-urlencoded'
            }
        });
        if (response.statusCode >= 400) {
            let res = querystring_1.default.parse(response.body);
            if (!res || !res.error) {
                res = {
                    error: `ERROR_HTTP_${response.statusCode}`,
                    error_description: response.body
                };
            }
            throw new class extends Error {
                constructor({ error, error_description }){
                    super(error_description);
                    this.name = error;
                }
            }(res);
        }
    }
    /**
     * @private
     */ async _postParams(params) {
        if (this.codeVerifier) params.code_verifier = this.codeVerifier;
        const response = await this._transport.httpRequest({
            method: 'POST',
            url: this.tokenServiceUrl,
            body: querystring_1.default.stringify(params),
            headers: {
                'content-type': 'application/x-www-form-urlencoded'
            }
        });
        let res;
        try {
            res = JSON.parse(response.body);
        } catch (e) {
        /* eslint-disable no-empty */ }
        if (response.statusCode >= 400) {
            res = res || {
                error: `ERROR_HTTP_${response.statusCode}`,
                error_description: response.body
            };
            throw new class extends Error {
                constructor({ error, error_description }){
                    super(error_description);
                    this.name = error;
                }
            }(res);
        }
        return res;
    }
}
exports.OAuth2 = OAuth2;
exports.default = OAuth2;
}),
"[project]/node_modules/jsforce/lib/cache.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Cache = void 0;
/**
 * @file Manages asynchronous method response cache
 * @author Shinichi Tomita <shinichi.tomita@gmail.com>
 */ const events_1 = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
/**
 * Class for managing cache entry
 *
 * @private
 * @class
 * @constructor
 * @template T
 */ class CacheEntry extends events_1.EventEmitter {
    _fetching = false;
    _value = undefined;
    /**
     * Get value in the cache entry
     *
     * @param {() => Promise<T>} [callback] - Callback function callbacked the cache entry updated
     * @returns {T|undefined}
     */ get(callback) {
        if (callback) {
            const cb = callback;
            this.once('value', (v)=>cb(v));
            if (typeof this._value !== 'undefined') {
                this.emit('value', this._value);
            }
        }
        return this._value;
    }
    /**
     * Set value in the cache entry
     */ set(value) {
        this._value = value;
        this.emit('value', this._value);
    }
    /**
     * Clear cached value
     */ clear() {
        this._fetching = false;
        this._value = undefined;
    }
}
/**
 * create and return cache key from namespace and serialized arguments.
 * @private
 */ function createCacheKey(namespace, args) {
    return `${namespace || ''}(${[
        ...args
    ].map((a)=>JSON.stringify(a)).join(',')})`;
}
function generateKeyString(options, scope, args) {
    return typeof options.key === 'string' ? options.key : typeof options.key === 'function' ? options.key.apply(scope, args) : createCacheKey(options.namespace, args);
}
/**
 * Caching manager for async methods
 *
 * @class
 * @constructor
 */ class Cache {
    _entries = {};
    /**
     * retrive cache entry, or create if not exists.
     *
     * @param {String} [key] - Key of cache entry
     * @returns {CacheEntry}
     */ get(key) {
        if (this._entries[key]) {
            return this._entries[key];
        }
        const entry = new CacheEntry();
        this._entries[key] = entry;
        return entry;
    }
    /**
     * clear cache entries prefix matching given key
     */ clear(key) {
        for (const k of Object.keys(this._entries)){
            if (!key || k.startsWith(key)) {
                this._entries[k].clear();
            }
        }
    }
    /**
     * Enable caching for async call fn to lookup the response cache first,
     * then invoke original if no cached value.
     */ createCachedFunction(fn, scope, options = {
        strategy: 'NOCACHE'
    }) {
        const strategy = options.strategy;
        const $fn = (...args)=>{
            const key = generateKeyString(options, scope, args);
            const entry = this.get(key);
            const executeFetch = async ()=>{
                entry._fetching = true;
                try {
                    const result = await fn.apply(scope || this, args);
                    entry.set({
                        error: undefined,
                        result
                    });
                    return result;
                } catch (error) {
                    entry.set({
                        error: error,
                        result: undefined
                    });
                    throw error;
                }
            };
            let value;
            switch(strategy){
                case 'IMMEDIATE':
                    value = entry.get();
                    if (!value) {
                        throw new Error('Function call result is not cached yet.');
                    }
                    if (value.error) {
                        throw value.error;
                    }
                    return value.result;
                case 'HIT':
                    return (async ()=>{
                        if (!entry._fetching) {
                            // only when no other client is calling function
                            await executeFetch();
                        }
                        return new Promise((resolve, reject)=>{
                            entry.get(({ error, result })=>{
                                if (error) reject(error);
                                else resolve(result);
                            });
                        });
                    })();
                case 'NOCACHE':
                default:
                    return executeFetch();
            }
        };
        $fn.clear = (...args)=>{
            const key = generateKeyString(options, scope, args);
            this.clear(key);
        };
        return $fn;
    }
}
exports.Cache = Cache;
exports.default = Cache;
}),
"[project]/node_modules/jsforce/lib/csv.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.serializeCSVStream = exports.parseCSVStream = exports.toCSV = exports.parseCSV = void 0;
const csv_parse_1 = __turbopack_context__.r("[project]/node_modules/csv-parse/dist/cjs/index.cjs [app-route] (ecmascript)");
const sync_1 = __turbopack_context__.r("[project]/node_modules/csv-parse/dist/cjs/sync.cjs [app-route] (ecmascript)");
const csv_stringify_1 = __turbopack_context__.r("[project]/node_modules/csv-stringify/dist/cjs/index.cjs [app-route] (ecmascript)");
const sync_2 = __turbopack_context__.r("[project]/node_modules/csv-stringify/dist/cjs/sync.cjs [app-route] (ecmascript)");
// The following column delimiters are supported by the Bulk V2 API:
// https://developer.salesforce.com/docs/atlas.en-us.api_asynch.meta/api_asynch/create_job.htm
//
// BACKQUOTE, CARET, COMMA, PIPE, SEMICOLON, TAB
const csvDelimiters = [
    '`',
    '^',
    ',',
    '|',
    ';',
    '	'
];
/**
 * @private
 */ function parseCSV(str, options) {
    return (0, sync_1.parse)(str, {
        ...options,
        columns: true,
        delimiter: csvDelimiters
    });
}
exports.parseCSV = parseCSV;
/**
 * @private
 */ function toCSV(records, options) {
    return (0, sync_2.stringify)(records, {
        ...options,
        header: true
    });
}
exports.toCSV = toCSV;
/**
 * @private
 */ function parseCSVStream(options) {
    return new csv_parse_1.Parser({
        ...options,
        columns: true
    });
}
exports.parseCSVStream = parseCSVStream;
/**
 * @private
 */ function serializeCSVStream(options) {
    return (0, csv_stringify_1.stringify)({
        ...options,
        header: true
    });
}
exports.serializeCSVStream = serializeCSVStream;
}),
"[project]/node_modules/jsforce/lib/util/get-body-size.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getBodySize = void 0;
const is_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@sindresorhus/is/dist/index.js [app-route] (ecmascript)"));
function getBodySize(body, headers = {}) {
    function isFormData(body) {
        return is_1.default.nodeStream(body) && is_1.default.function_(body.getBoundary);
    }
    if (headers && 'content-length' in headers) {
        return Number(headers['content-length']);
    }
    if (!body) {
        return 0;
    }
    if (is_1.default.string(body)) {
        return Buffer.byteLength(body);
    }
    if (is_1.default.urlSearchParams(body)) {
        return Buffer.byteLength(body.toString());
    }
    if (is_1.default.buffer(body)) {
        return body.length;
    }
    try {
        // `getLengthSync` will throw if body has a stream:
        // https://github.com/form-data/form-data#integer-getlengthsync
        if (isFormData(body)) {
            return body.getLengthSync();
        }
    } catch  {
        return undefined;
    }
    return undefined;
}
exports.getBodySize = getBodySize;
}),
"[project]/node_modules/jsforce/lib/http-api.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isBrowser = exports.HttpApi = void 0;
/**
 *
 */ const events_1 = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
const xml2js_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/xml2js/lib/xml2js.js [app-route] (ecmascript)"));
const logger_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/util/logger.js [app-route] (ecmascript)");
const promise_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/util/promise.js [app-route] (ecmascript)");
const csv_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/csv.js [app-route] (ecmascript)");
const stream_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/util/stream.js [app-route] (ecmascript)");
const get_body_size_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/util/get-body-size.js [app-route] (ecmascript)");
/** @private */ function parseJSON(str) {
    return JSON.parse(str);
}
/** @private */ async function parseXML(str) {
    return xml2js_1.default.parseStringPromise(str, {
        explicitArray: false
    });
}
/** @private */ function parseText(str) {
    return str;
}
/**
 * HTTP based API class with authorization hook
 */ class HttpApi extends events_1.EventEmitter {
    static _logger = (0, logger_1.getLogger)('http-api');
    _conn;
    _logger;
    _transport;
    _responseType;
    _noContentResponse;
    _options;
    constructor(conn, options){
        super();
        this._conn = conn;
        this._logger = conn._logLevel ? HttpApi._logger.createInstance(conn._logLevel) : HttpApi._logger;
        this._responseType = options.responseType;
        this._transport = options.transport || conn._transport;
        this._noContentResponse = options.noContentResponse;
        this._options = options;
    }
    /**
     * Callout to API endpoint using http
     */ request(request) {
        return promise_1.StreamPromise.create(()=>{
            const { stream, setStream } = (0, stream_1.createLazyStream)();
            const promise = (async ()=>{
                const refreshDelegate = this.getRefreshDelegate();
                /* TODO decide remove or not this section */ /*
                // remember previous instance url in case it changes after a refresh
                const lastInstanceUrl = conn.instanceUrl;
        
                // check to see if the token refresh has changed the instance url
                if(lastInstanceUrl !== conn.instanceUrl){
                  // if the instance url has changed
                  // then replace the current request urls instance url fragment
                  // with the updated instance url
                  request.url = request.url.replace(lastInstanceUrl,conn.instanceUrl);
                }
                */ if (refreshDelegate && refreshDelegate.isRefreshing()) {
                    await refreshDelegate.waitRefresh();
                    const bodyPromise = this.request(request);
                    setStream(bodyPromise.stream());
                    const body = await bodyPromise;
                    return body;
                }
                // hook before sending
                this.beforeSend(request);
                this.emit('request', request);
                this._logger.debug(`<request> method=${request.method}, url=${request.url}`);
                const requestTime = Date.now();
                const requestPromise = this._transport.httpRequest(request, this._options);
                setStream(requestPromise.stream());
                let response;
                try {
                    response = await requestPromise;
                } catch (err) {
                    this._logger.error(err);
                    throw err;
                } finally{
                    const responseTime = Date.now();
                    this._logger.debug(`elapsed time: ${responseTime - requestTime} msec`);
                }
                if (!response) {
                    return;
                }
                this._logger.debug(`<response> status=${String(response.statusCode)}, url=${request.url}`);
                this.emit('response', response);
                // Refresh token if session has been expired and requires authentication
                // when session refresh delegate is available
                if (this.isSessionExpired(response) && refreshDelegate) {
                    await refreshDelegate.refresh(requestTime);
                    /* remove the `content-length` header after token refresh
                     *
                     * SOAP requests include the access token their the body,
                     * if the first req had an invalid token and jsforce successfully
                     * refreshed it we need to remove the `content-length` header
                     * so that it get's re-calculated again with the new body.
                     *
                     * REST request aren't affected by this because the access token
                     * is sent via HTTP headers
                     *
                     * `_message` is only present in SOAP requests
                     */ if ('_message' in request && request.headers && 'content-length' in request.headers) {
                        delete request.headers['content-length'];
                    }
                    return this.request(request);
                }
                if (this.isErrorResponse(response)) {
                    const err = await this.getError(response);
                    throw err;
                }
                const body = await this.getResponseBody(response);
                return body;
            })();
            return {
                stream,
                promise
            };
        });
    }
    /**
     * @protected
     */ getRefreshDelegate() {
        return this._conn._refreshDelegate;
    }
    /**
     * @protected
     */ beforeSend(request) {
        /* eslint-disable no-param-reassign */ const headers = request.headers || {};
        if (this._conn.accessToken) {
            headers.Authorization = `Bearer ${this._conn.accessToken}`;
        }
        if (this._conn._callOptions) {
            const callOptions = [];
            for (const name of Object.keys(this._conn._callOptions)){
                callOptions.push(`${name}=${this._conn._callOptions[name]}`);
            }
            headers['Sforce-Call-Options'] = callOptions.join(', ');
        }
        const bodySize = (0, get_body_size_1.getBodySize)(request.body, headers);
        const cannotHaveBody = [
            'GET',
            'HEAD',
            'OPTIONS'
        ].includes(request.method);
        // Don't set content-length in browsers as it's not allowed
        const isBrowser = 'window' in globalThis || 'self' in globalThis;
        if (!isBrowser && // Don't set content-length in browsers as it's not allowed
        !cannotHaveBody && !!request.body && !('transfer-encoding' in headers) && !('content-length' in headers) && !!bodySize) {
            this._logger.debug(`missing 'content-length' header, setting it to: ${bodySize}`);
            headers['content-length'] = String(bodySize);
        }
        request.headers = headers;
    }
    /**
     * Detect response content mime-type
     * @protected
     */ getResponseContentType(response) {
        return this._responseType || response.headers && response.headers['content-type'];
    }
    /**
     * @private
     */ // eslint-disable-next-line @typescript-eslint/require-await
    async parseResponseBody(response) {
        const contentType = this.getResponseContentType(response) || '';
        const parseBody = /^(text|application)\/xml(;|$)/.test(contentType) ? parseXML : /^application\/json(;|$)/.test(contentType) ? parseJSON : /^text\/csv(;|$)/.test(contentType) ? csv_1.parseCSV : parseText;
        try {
            return parseBody(response.body);
        } catch (e) {
            // TODO(next major): we could throw a new "invalid response body" error instead.
            this._logger.debug(`Failed to parse body of content-type: ${contentType}. Error: ${e.message}`);
            return response.body;
        }
    }
    /**
     * Get response body
     * @protected
     */ async getResponseBody(response) {
        if (response.statusCode === 204) {
            // No Content
            return this._noContentResponse;
        }
        const body = await this.parseResponseBody(response);
        let err;
        if (this.hasErrorInResponseBody(body)) {
            err = await this.getError(response, body);
            throw err;
        }
        if (response.statusCode === 300) {
            // Multiple Choices
            throw new HttpApiError('Multiple records found', 'MULTIPLE_CHOICES', body);
        }
        return body;
    }
    /**
     * Detect session expiry
     * @protected
     */ isSessionExpired(response) {
        // TODO:
        // The connected app msg only applies to Agent API requests, we should move this to a separate SFAP/Agent API class later.
        return response.statusCode === 401 && !response.body.includes('Connected app is not attached to Agent');
    }
    /**
     * Detect error response
     * @protected
     */ isErrorResponse(response) {
        return response.statusCode >= 400;
    }
    /**
     * Detect error in response body
     * @protected
     */ hasErrorInResponseBody(_body) {
        return false;
    }
    /**
     * Parsing error message in response
     * @protected
     */ parseError(body) {
        const errors = body;
        // XML response
        if (errors.Errors) {
            return errors.Errors.Error;
        }
        return errors;
    }
    /**
     * Get error message in response
     * @protected
     */ async getError(response, body) {
        let error;
        try {
            error = this.parseError(body || await this.parseResponseBody(response));
        } catch (e) {
        // eslint-disable no-empty
        }
        if (Array.isArray(error)) {
            if (error.length === 1) {
                error = error[0];
            } else {
                return new HttpApiError(`Multiple errors returned.
  Check \`error.data\` for the error details`, 'MULTIPLE_API_ERRORS', error);
            }
        }
        error = typeof error === 'object' && error !== null && typeof error.message === 'string' ? error : {
            errorCode: `ERROR_HTTP_${response.statusCode}`,
            message: response.body
        };
        if (response.headers['content-type'] === 'text/html') {
            this._logger.debug(`html response.body: ${response.body}`);
            return new HttpApiError(`HTTP response contains html content.
Check that the org exists and can be reached.
See \`error.data\` for the full html response.`, error.errorCode, error.message);
        }
        return error instanceof HttpApiError ? error : new HttpApiError(error.message, error.errorCode, error);
    }
}
exports.HttpApi = HttpApi;
/**
 *
 */ class HttpApiError extends Error {
    /**
     * This contains error-specific details, usually returned from the API.
     */ data;
    errorCode;
    constructor(message, errorCode, data){
        super(message);
        this.name = errorCode || this.name;
        this.errorCode = this.name;
        this.data = data;
    }
    /**
     * This will be removed in the next major (v4)
     *
     * @deprecated use `error.data` instead
     */ get content() {
        return this.data;
    }
}
exports.default = HttpApi;
exports.isBrowser = 'window' in globalThis || 'self' in globalThis;
}),
"[project]/node_modules/jsforce/lib/session-refresh-delegate.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SessionRefreshDelegate = void 0;
/**
 *
 */ const logger_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/util/logger.js [app-route] (ecmascript)");
/**
 *
 */ class SessionRefreshDelegate {
    static _logger = (0, logger_1.getLogger)('session-refresh-delegate');
    _refreshFn;
    _conn;
    _logger;
    _lastRefreshedAt = undefined;
    _refreshPromise = undefined;
    constructor(conn, refreshFn){
        this._conn = conn;
        this._logger = conn._logLevel ? SessionRefreshDelegate._logger.createInstance(conn._logLevel) : SessionRefreshDelegate._logger;
        this._refreshFn = refreshFn;
    }
    /**
     * Refresh access token
     * @private
     */ async refresh(since) {
        // Callback immediately When refreshed after designated time
        if (this._lastRefreshedAt && this._lastRefreshedAt > since) {
            return;
        }
        if (this._refreshPromise) {
            await this._refreshPromise;
            return;
        }
        try {
            this._logger.info('<refresh token>');
            this._refreshPromise = new Promise((resolve, reject)=>{
                this._refreshFn(this._conn, (err, accessToken, res)=>{
                    if (!err) {
                        this._logger.debug('Connection refresh completed.');
                        this._conn.accessToken = accessToken;
                        this._conn.emit('refresh', accessToken, res);
                        resolve();
                    } else {
                        reject(err);
                    }
                });
            });
            await this._refreshPromise;
            this._logger.info('<refresh complete>');
        } catch (err) {
            throw new Error(`Unable to refresh session due to: ${err.message}`);
        } finally{
            this._refreshPromise = undefined;
            this._lastRefreshedAt = Date.now();
        }
    }
    isRefreshing() {
        return !!this._refreshPromise;
    }
    async waitRefresh() {
        return this._refreshPromise;
    }
}
exports.SessionRefreshDelegate = SessionRefreshDelegate;
exports.default = SessionRefreshDelegate;
}),
"[project]/node_modules/jsforce/lib/record-stream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Parsable = exports.Serializable = exports.RecordStream = void 0;
/**
 * @file Represents stream that handles Salesforce record as stream data
 * @author Shinichi Tomita <shinichi.tomita@gmail.com>
 */ const stream_1 = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const csv_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/csv.js [app-route] (ecmascript)");
const stream_2 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/util/stream.js [app-route] (ecmascript)");
/**
 * @private
 */ function evalMapping(value, mapping) {
    if (typeof value === 'string') {
        const m = /^\$\{(\w+)\}$/.exec(value);
        if (m) {
            return mapping[m[1]];
        }
        return value.replace(/\$\{(\w+)\}/g, ($0, prop)=>{
            const v = mapping[prop];
            return typeof v === 'undefined' || v === null ? '' : String(v);
        });
    }
    return value;
}
/**
 * @private
 */ function convertRecordForSerialization(record, options = {}) {
    return Object.keys(record).reduce((rec, key)=>{
        const value = rec[key];
        let urec;
        if (key === 'attributes') {
            // 'attributes' prop will be ignored
            urec = {
                ...rec
            };
            delete urec[key];
            return urec;
        } else if (options.nullValue && value === null) {
            return {
                ...rec,
                [key]: options.nullValue
            };
        } else if (value !== null && typeof value === 'object') {
            const precord = convertRecordForSerialization(value, options);
            return Object.keys(precord).reduce((prec, pkey)=>{
                prec[`${key}.${pkey}`] = precord[pkey]; // eslint-disable-line no-param-reassign
                return prec;
            }, {
                ...rec
            });
        }
        return rec;
    }, record);
}
/**
 * @private
 */ function createPipelineStream(s1, s2) {
    s1.pipe(s2);
    return (0, stream_2.concatStreamsAsDuplex)(s1, s2, {
        writableObjectMode: true
    });
}
/**
 * @private
 */ const CSVStreamConverter = {
    serialize (options = {}) {
        const { nullValue, ...csvOpts } = options;
        return createPipelineStream(// eslint-disable-next-line no-use-before-define
        RecordStream.map((record)=>convertRecordForSerialization(record, options)), (0, csv_1.serializeCSVStream)(csvOpts));
    },
    parse (options = {}) {
        return (0, csv_1.parseCSVStream)(options);
    }
};
/**
 * @private
 */ const DataStreamConverters = {
    csv: CSVStreamConverter
};
/**
 * Class for Record Stream
 *
 * @class
 * @constructor
 * @extends stream.Transform
 */ class RecordStream extends stream_1.PassThrough {
    /**
     *
     */ constructor(){
        super({
            objectMode: true
        });
    }
    /**
     * Get record stream of queried records applying the given mapping function
     */ map(fn) {
        return this.pipe(RecordStream.map(fn));
    }
    /**
     * Get record stream of queried records, applying the given filter function
     */ filter(fn) {
        return this.pipe(RecordStream.filter(fn));
    }
    /* @override */ on(ev, fn) {
        return super.on(ev === 'record' ? 'data' : ev, fn);
    }
    /* @override */ addListener = this.on;
    /* --------------------------------------------------- */ /**
     * Create a record stream which maps records and pass them to downstream
     */ static map(fn) {
        const mapStream = new stream_1.Transform({
            objectMode: true,
            transform (record, enc, callback) {
                const rec = fn(record) || record; // if not returned record, use same record
                mapStream.push(rec);
                callback();
            }
        });
        return mapStream;
    }
    /**
     * Create mapping stream using given record template
     */ static recordMapStream(record, noeval) {
        return RecordStream.map((rec)=>{
            const mapped = {
                Id: rec.Id
            };
            for (const prop of Object.keys(record)){
                mapped[prop] = noeval ? record[prop] : evalMapping(record[prop], rec);
            }
            return mapped;
        });
    }
    /**
     * Create a record stream which filters records and pass them to downstream
     *
     * @param {RecordFilterFunction} fn - Record filtering function
     * @returns {RecordStream.Serializable}
     */ static filter(fn) {
        const filterStream = new stream_1.Transform({
            objectMode: true,
            transform (record, enc, callback) {
                if (fn(record)) {
                    filterStream.push(record);
                }
                callback();
            }
        });
        return filterStream;
    }
}
exports.RecordStream = RecordStream;
/**
 * @class RecordStream.Serializable
 * @extends {RecordStream}
 */ class Serializable extends RecordStream {
    _dataStreams = {};
    /**
     * Get readable data stream which emits serialized record data
     */ stream(type = 'csv', options = {}) {
        if (this._dataStreams[type]) {
            return this._dataStreams[type];
        }
        const converter = DataStreamConverters[type];
        if (!converter) {
            throw new Error(`Converting [${type}] data stream is not supported.`);
        }
        const dataStream = new stream_1.PassThrough();
        this.pipe(converter.serialize(options)).pipe(dataStream);
        this._dataStreams[type] = dataStream;
        return dataStream;
    }
}
exports.Serializable = Serializable;
/**
 * @class RecordStream.Parsable
 * @extends {RecordStream}
 */ class Parsable extends RecordStream {
    _dataStreams = {};
    _execParse = false;
    _incomings = [];
    /**
     * Get writable data stream which accepts serialized record data
     */ stream(type = 'csv', options = {}) {
        if (this._dataStreams[type]) {
            return this._dataStreams[type];
        }
        const converter = DataStreamConverters[type];
        if (!converter) {
            throw new Error(`Converting [${type}] data stream is not supported.`);
        }
        const dataStream = new stream_1.PassThrough();
        const parserStream = converter.parse(options);
        parserStream.on('error', (err)=>this.emit('error', err));
        parserStream.pipe(this).pipe(new stream_1.PassThrough({
            objectMode: true,
            highWaterMark: 500 * 1000
        }));
        if (this._execParse) {
            dataStream.pipe(parserStream);
        } else {
            this._incomings.push([
                dataStream,
                parserStream
            ]);
        }
        this._dataStreams[type] = dataStream;
        return dataStream;
    }
    /* @override */ on(ev, fn) {
        if (ev === 'readable' || ev === 'record') {
            if (!this._execParse) {
                this._execParse = true;
                for (const [dataStream, parserStream] of this._incomings){
                    dataStream.pipe(parserStream);
                }
            }
        }
        return super.on(ev, fn);
    }
    /* @override */ addListener = this.on;
}
exports.Parsable = Parsable;
exports.default = RecordStream;
}),
"[project]/node_modules/jsforce/lib/util/formatter.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.formatDate = exports.zeroPad = void 0;
/**
 *
 */ function zeroPad(num, digits = 2) {
    let nstr = '';
    for(let d = digits - 1; d > 0; d--){
        if (num >= 10 ** d) {
            break;
        }
        nstr += '0';
    }
    return nstr + String(num);
}
exports.zeroPad = zeroPad;
/**
 *
 */ function formatDate(date) {
    return `${date.getUTCFullYear()}-${zeroPad(date.getUTCMonth() + 1)}-${zeroPad(date.getUTCDate())}T${zeroPad(date.getUTCHours())}:${zeroPad(date.getUTCMinutes())}:${zeroPad(date.getUTCSeconds())}+00:00`;
}
exports.formatDate = formatDate;
}),
"[project]/node_modules/jsforce/lib/date.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SfDate = void 0;
/**
 *
 */ const formatter_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/util/formatter.js [app-route] (ecmascript)");
/** @private **/ function createLiteralBuilder(literal) {
    return (num)=>new SfDate(`${literal}:${String(num)}`); // eslint-disable-line no-use-before-define
}
/**
 * A date object to keep Salesforce date literal
 *
 * @class
 * @constructor
 * @see http://www.salesforce.com/us/developer/docs/soql_sosl/Content/sforce_api_calls_soql_select_dateformats.htm
 */ class SfDate {
    _literal;
    /**
     *
     */ constructor(literal){
        this._literal = literal;
    }
    /**
     * Returns literal when converted to string
     */ toJSON() {
        return this._literal;
    }
    toString = this.toJSON;
    /**
     * Convert JavaScript date object to ISO8601 Date format (e.g. 2012-10-31)
     *
     * @param {String|Number|Date} date - Input date
     * @returns {SfDate} - Salesforce date literal with ISO8601 date format
     */ static toDateLiteral(date) {
        let _date;
        if (typeof date === 'number') {
            _date = new Date(date);
        } else if (typeof date === 'string') {
            _date = SfDate.parseDate(date);
        } else {
            _date = date;
        }
        const yy = _date.getFullYear();
        const mm = _date.getMonth() + 1;
        const dd = _date.getDate();
        const dstr = [
            yy,
            (0, formatter_1.zeroPad)(mm),
            (0, formatter_1.zeroPad)(dd)
        ].join('-');
        return new SfDate(dstr);
    }
    /**
     * Convert JavaScript date object to ISO8601 DateTime format
     * (e.g. 2012-10-31T12:34:56Z)
     */ static toDateTimeLiteral(date) {
        let _date;
        if (typeof date === 'number') {
            _date = new Date(date);
        } else if (typeof date === 'string') {
            _date = SfDate.parseDate(date);
        } else {
            _date = date;
        }
        const yy = _date.getUTCFullYear();
        const mm = _date.getUTCMonth() + 1;
        const dd = _date.getUTCDate();
        const hh = _date.getUTCHours();
        const mi = _date.getUTCMinutes();
        const ss = _date.getUTCSeconds();
        const dtstr = `${[
            yy,
            (0, formatter_1.zeroPad)(mm),
            (0, formatter_1.zeroPad)(dd)
        ].join('-')}T${[
            (0, formatter_1.zeroPad)(hh),
            (0, formatter_1.zeroPad)(mi),
            (0, formatter_1.zeroPad)(ss)
        ].join(':')}Z`;
        return new SfDate(dtstr);
    }
    /**
     * Convert JavaScript date object to ISO8601 time format
     * (e.g. 12:34:56.789Z)
     */ static toTimeLiteral(time) {
        let _date = new Date(0);
        if (typeof time === 'string') {
            _date = SfDate.parseTime(time);
        } else if (typeof time === 'number') {
            _date = new Date(time);
        } else {
            _date = time;
        }
        const hh = _date.getUTCHours();
        const mi = _date.getUTCMinutes();
        const ss = _date.getUTCSeconds();
        const sss = _date.getUTCMilliseconds();
        const tstr = `${(0, formatter_1.zeroPad)(hh)}:${(0, formatter_1.zeroPad)(mi)}:${(0, formatter_1.zeroPad)(ss)}.${(0, formatter_1.zeroPad)(sss, 3)}Z`;
        return new SfDate(tstr);
    }
    /**
     * Parse IS08601 date(time) formatted string and return date instance
     */ static parseDate(str) {
        let d = new Date();
        const regexp = /^([\d]{4})-?([\d]{2})-?([\d]{2})(T([\d]{2}):?([\d]{2}):?([\d]{2})(.([\d]{3}))?(Z|([+-])([\d]{2}):?([\d]{2})))?$/;
        const m = str.match(regexp);
        if (m) {
            d = new Date(0);
            if (!m[4]) {
                d.setFullYear(parseInt(m[1], 10));
                d.setDate(parseInt(m[3], 10));
                d.setMonth(parseInt(m[2], 10) - 1);
                d.setHours(0);
                d.setMinutes(0);
                d.setSeconds(0);
                d.setMilliseconds(0);
            } else {
                d.setUTCFullYear(parseInt(m[1], 10));
                d.setUTCDate(parseInt(m[3], 10));
                d.setUTCMonth(parseInt(m[2], 10) - 1);
                d.setUTCHours(parseInt(m[5], 10));
                d.setUTCMinutes(parseInt(m[6], 10));
                d.setUTCSeconds(parseInt(m[7], 10));
                d.setUTCMilliseconds(parseInt(m[9] || '0', 10));
                if (m[10] && m[10] !== 'Z') {
                    const offset = parseInt(m[12], 10) * 60 + parseInt(m[13], 10);
                    d.setTime((m[11] === '+' ? -1 : 1) * offset * 60 * 1000 + d.getTime());
                }
            }
            return d;
        }
        throw new Error(`Invalid date format is specified : ${str}`);
    }
    /**
     * Parse IS08601 time formatted string and convert to parse string
     */ static parseTime(str) {
        const regexp = /^([\d]{2}):?([\d]{2}):?([\d]{2})(.([\d]{3}))?Z?$/;
        const m = str.match(regexp);
        if (m) {
            const d = new Date(0);
            const hh = parseInt(m[1], 10);
            const mi = parseInt(m[2], 10);
            const ss = parseInt(m[3], 10);
            const sss = parseInt(m[5] || '0', 10);
            d.setUTCHours(hh);
            d.setUTCMinutes(mi);
            d.setUTCSeconds(ss);
            d.setUTCMilliseconds(sss);
            return d;
        }
        throw new Error(`Invalid time format is specified : ${str}`);
    }
    static YESTERDAY = new SfDate('YESTERDAY');
    static TODAY = new SfDate('TODAY');
    static TOMORROW = new SfDate('TOMORROW');
    static LAST_WEEK = new SfDate('LAST_WEEK');
    static THIS_WEEK = new SfDate('THIS_WEEK');
    static NEXT_WEEK = new SfDate('NEXT_WEEK');
    static LAST_MONTH = new SfDate('LAST_MONTH');
    static THIS_MONTH = new SfDate('THIS_MONTH');
    static NEXT_MONTH = new SfDate('NEXT_MONTH');
    static LAST_90_DAYS = new SfDate('LAST_90_DAYS');
    static NEXT_90_DAYS = new SfDate('NEXT_90_DAYS');
    static LAST_N_DAYS = createLiteralBuilder('LAST_N_DAYS');
    static NEXT_N_DAYS = createLiteralBuilder('NEXT_N_DAYS');
    static NEXT_N_WEEKS = createLiteralBuilder('NEXT_N_WEEKS');
    static LAST_N_WEEKS = createLiteralBuilder('LAST_N_WEEKS');
    static NEXT_N_MONTHS = createLiteralBuilder('NEXT_N_MONTHS');
    static LAST_N_MONTHS = createLiteralBuilder('LAST_N_MONTHS');
    static THIS_QUARTER = new SfDate('THIS_QUARTER');
    static LAST_QUARTER = new SfDate('LAST_QUARTER');
    static NEXT_QUARTER = new SfDate('NEXT_QUARTER');
    static NEXT_N_QUARTERS = createLiteralBuilder('NEXT_N_QUARTERS');
    static LAST_N_QUARTERS = createLiteralBuilder('LAST_N_QUARTERS');
    static THIS_YEAR = new SfDate('THIS_YEAR');
    static LAST_YEAR = new SfDate('LAST_YEAR');
    static NEXT_YEAR = new SfDate('NEXT_YEAR');
    static NEXT_N_YEARS = createLiteralBuilder('NEXT_N_YEARS');
    static LAST_N_YEARS = createLiteralBuilder('LAST_N_YEARS');
    static THIS_FISCAL_QUARTER = new SfDate('THIS_FISCAL_QUARTER');
    static LAST_FISCAL_QUARTER = new SfDate('LAST_FISCAL_QUARTER');
    static NEXT_FISCAL_QUARTER = new SfDate('NEXT_FISCAL_QUARTER');
    static THIS_FISCAL_YEAR = new SfDate('THIS_FISCAL_YEAR');
    static NEXT_N_FISCAL_QUARTERS = createLiteralBuilder('NEXT_N_FISCAL_QUARTERS');
    static LAST_N_FISCAL_QUARTERS = createLiteralBuilder('LAST_N_FISCAL_QUARTERS');
    static LAST_FISCAL_YEAR = new SfDate('LAST_FISCAL_YEAR');
    static NEXT_FISCAL_YEAR = new SfDate('NEXT_FISCAL_YEAR');
    static NEXT_N_FISCAL_YEARS = createLiteralBuilder('NEXT_N_FISCAL_YEARS');
    static LAST_N_FISCAL_YEARS = createLiteralBuilder('LAST_N_FISCAL_YEARS');
}
exports.SfDate = SfDate;
exports.default = SfDate;
}),
"[project]/node_modules/jsforce/lib/soql-builder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createSOQL = void 0;
/**
 * @file Create and build SOQL string from configuration
 * @author Shinichi Tomita <shinichi.tomita@gmail.com>
 */ const date_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/date.js [app-route] (ecmascript)"));
/** @private **/ function escapeSOQLString(str) {
    return String(str || '').replace(/'/g, "\\'");
}
/** @private **/ function createFieldsClause(fields, childQueries = {}) {
    const cqueries = Object.values(childQueries);
    // eslint-disable-next-line no-use-before-define
    return [
        ...fields || [
            'Id'
        ],
        ...cqueries.map((cquery)=>`(${createSOQL(cquery)})`)
    ].join(', ');
}
/** @private **/ function createValueExpression(value) {
    if (Array.isArray(value)) {
        return value.length > 0 ? `(${value.map(createValueExpression).join(', ')})` : undefined;
    }
    if (value instanceof date_1.default) {
        return value.toString();
    }
    if (typeof value === 'string') {
        return `'${escapeSOQLString(value)}'`;
    }
    if (typeof value === 'number') {
        return value.toString();
    }
    if (value === null) {
        return 'null';
    }
    return value;
}
const opMap = {
    '=': '=',
    $eq: '=',
    '!=': '!=',
    $ne: '!=',
    '>': '>',
    $gt: '>',
    '<': '<',
    $lt: '<',
    '>=': '>=',
    $gte: '>=',
    '<=': '<=',
    $lte: '<=',
    $like: 'LIKE',
    $nlike: 'NOT LIKE',
    $in: 'IN',
    $nin: 'NOT IN',
    $includes: 'INCLUDES',
    $excludes: 'EXCLUDES',
    $exists: 'EXISTS'
};
/** @private **/ function createFieldExpression(field, value) {
    let op = '$eq';
    let _value = value;
    // Assume the `$in` operator if value is an array and none was supplied.
    if (Array.isArray(value)) {
        op = '$in';
    } else if (typeof value === 'object' && value !== null) {
        // Otherwise, if an object was passed then process the supplied ops.
        for (const k of Object.keys(value)){
            if (k.startsWith('$')) {
                op = k;
                _value = value[k];
                break;
            }
        }
    }
    const sfop = opMap[op];
    if (!sfop || typeof _value === 'undefined') {
        return null;
    }
    const valueExpr = createValueExpression(_value);
    if (typeof valueExpr === 'undefined') {
        return null;
    }
    switch(sfop){
        case 'NOT LIKE':
            return `(${[
                'NOT',
                field,
                'LIKE',
                valueExpr
            ].join(' ')})`;
        case 'EXISTS':
            return [
                field,
                _value ? '!=' : '=',
                'null'
            ].join(' ');
        default:
            return [
                field,
                sfop,
                valueExpr
            ].join(' ');
    }
}
/** @private **/ function createOrderByClause(sort = []) {
    let _sort = [];
    if (typeof sort === 'string') {
        if (/,|\s+(asc|desc)\s*$/.test(sort)) {
            // must be specified in pure "order by" clause. Return raw config.
            return sort;
        }
        // sort order in mongoose-style expression.
        // e.g. "FieldA -FieldB" => "ORDER BY FieldA ASC, FieldB DESC"
        _sort = sort.split(/\s+/).map((field)=>{
            let dir = 'ASC'; // ascending
            const flag = field[0];
            if (flag === '-') {
                dir = 'DESC';
                field = field.substring(1); // eslint-disable-line no-param-reassign
            } else if (flag === '+') {
                field = field.substring(1); // eslint-disable-line no-param-reassign
            }
            return [
                field,
                dir
            ];
        });
    } else if (Array.isArray(sort)) {
        _sort = sort;
    } else {
        _sort = Object.entries(sort).map(([field, dir])=>[
                field,
                dir
            ]);
    }
    return _sort.map(([field, dir])=>{
        /* eslint-disable no-param-reassign */ switch(String(dir)){
            case 'DESC':
            case 'desc':
            case 'descending':
            case '-':
            case '-1':
                dir = 'DESC';
                break;
            default:
                dir = 'ASC';
        }
        return `${field} ${dir}`;
    }).join(', ');
}
/** @private **/ function createConditionClause(conditions = {}, operator = 'AND', depth = 0) {
    if (typeof conditions === 'string') {
        return conditions;
    }
    let conditionList = [];
    if (!Array.isArray(conditions)) {
        // if passed in hash object
        const conditionsMap = conditions;
        conditionList = Object.keys(conditionsMap).map((key)=>({
                key,
                value: conditionsMap[key]
            }));
    } else {
        conditionList = conditions.map((cond)=>{
            const conds = Object.keys(cond).map((key)=>({
                    key,
                    value: cond[key]
                }));
            return conds.length > 1 ? {
                key: '$and',
                value: conds.map((c)=>({
                        [c.key]: c.value
                    }))
            } : conds[0];
        });
    }
    const conditionClauses = conditionList.map((cond)=>{
        let d = depth + 1;
        let op;
        switch(cond.key){
            case '$or':
            case '$and':
            case '$not':
                if (operator !== 'NOT' && conditionList.length === 1) {
                    d = depth; // not change tree depth
                }
                op = cond.key === '$or' ? 'OR' : cond.key === '$and' ? 'AND' : 'NOT';
                return createConditionClause(cond.value, op, d);
            default:
                return createFieldExpression(cond.key, cond.value);
        }
    }).filter((expr)=>expr);
    let hasParen;
    if (operator === 'NOT') {
        hasParen = depth > 0;
        return `${hasParen ? '(' : ''}NOT ${conditionClauses[0]}${hasParen ? ')' : ''}`;
    }
    hasParen = depth > 0 && conditionClauses.length > 1;
    return (hasParen ? '(' : '') + conditionClauses.join(` ${operator} `) + (hasParen ? ')' : '');
}
/**
 * Create SOQL
 * @private
 */ function createSOQL(query) {
    let soql = [
        'SELECT ',
        createFieldsClause(query.fields, query.includes),
        ' FROM ',
        query.table
    ].join('');
    const cond = createConditionClause(query.conditions);
    if (cond) {
        soql += ` WHERE ${cond}`;
    }
    const orderby = createOrderByClause(query.sort);
    if (orderby) {
        soql += ` ORDER BY ${orderby}`;
    }
    if (query.limit) {
        soql += ` LIMIT ${query.limit}`;
    }
    if (query.offset) {
        soql += ` OFFSET ${query.offset}`;
    }
    return soql;
}
exports.createSOQL = createSOQL;
}),
"[project]/node_modules/jsforce/lib/query.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SubQuery = exports.Query = exports.ResponseTargets = void 0;
/**
 * @file Manages query for records in Salesforce
 * @author Shinichi Tomita <shinichi.tomita@gmail.com>
 */ const events_1 = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
const logger_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/util/logger.js [app-route] (ecmascript)");
const record_stream_1 = __importStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/record-stream.js [app-route] (ecmascript)"));
const soql_builder_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/soql-builder.js [app-route] (ecmascript)");
const ResponseTargetValues = [
    'QueryResult',
    'Records',
    'SingleRecord',
    'Count'
];
exports.ResponseTargets = ResponseTargetValues.reduce((values, target)=>({
        ...values,
        [target]: target
    }), {});
/**
 *
 */ const DEFAULT_BULK_THRESHOLD = 200;
const DEFAULT_BULK_API_VERSION = 1;
/**
 * Query
 */ class Query extends events_1.EventEmitter {
    static _logger = (0, logger_1.getLogger)('query');
    _conn;
    _logger;
    _soql;
    _locator;
    _config = {};
    _children = [];
    _options;
    _executed = false;
    _finished = false;
    _chaining = false;
    _promise;
    _stream;
    totalSize = 0;
    totalFetched = 0;
    records = [];
    /**
     *
     */ constructor(conn, config, options){
        super();
        this._conn = conn;
        this._logger = conn._logLevel ? Query._logger.createInstance(conn._logLevel) : Query._logger;
        if (typeof config === 'string') {
            this._soql = config;
            this._logger.debug(`config is soql: ${config}`);
        } else if (typeof config.locator === 'string') {
            const locator = config.locator;
            this._logger.debug(`config is locator: ${locator}`);
            this._locator = locator.includes('/') ? this.urlToLocator(locator) : locator;
        } else {
            this._logger.debug(`config is QueryConfig: ${JSON.stringify(config)}`);
            const { fields, includes, sort, ..._config } = config;
            this._config = _config;
            this.select(fields);
            if (includes) {
                this.includeChildren(includes);
            }
            if (sort) {
                this.sort(sort);
            }
        }
        this._options = {
            headers: {},
            maxFetch: 10000,
            autoFetch: false,
            scanAll: false,
            responseTarget: 'QueryResult',
            ...options || {}
        };
        // promise instance
        this._promise = new Promise((resolve, reject)=>{
            this.on('response', resolve);
            this.on('error', reject);
        });
        this._stream = new record_stream_1.Serializable();
        this.on('record', (record)=>this._stream.push(record));
        this.on('end', ()=>this._stream.push(null));
        this.on('error', (err)=>{
            try {
                this._stream.emit('error', err);
            } catch (e) {
            // eslint-disable-line no-empty
            }
        });
    }
    /**
     * Select fields to include in the returning result
     */ select(fields = '*') {
        if (this._soql) {
            throw Error('Cannot set select fields for the query which has already built SOQL.');
        }
        function toFieldArray(fields) {
            return typeof fields === 'string' ? fields.split(/\s*,\s*/) : Array.isArray(fields) ? fields.map(toFieldArray).reduce((fs, f)=>[
                    ...fs,
                    ...f
                ], []) : Object.entries(fields).map(([f, v])=>{
                if (typeof v === 'number' || typeof v === 'boolean') {
                    return v ? [
                        f
                    ] : [];
                } else {
                    return toFieldArray(v).map((p)=>`${f}.${p}`);
                }
            }).reduce((fs, f)=>[
                    ...fs,
                    ...f
                ], []);
        }
        if (fields) {
            this._config.fields = toFieldArray(fields);
        }
        // force convert query record type without changing instance;
        return this;
    }
    /**
     * Set query conditions to filter the result records
     */ where(conditions) {
        if (this._soql) {
            throw Error('Cannot set where conditions for the query which has already built SOQL.');
        }
        this._config.conditions = conditions;
        return this;
    }
    /**
     * Limit the returning result
     */ limit(limit) {
        if (this._soql) {
            throw Error('Cannot set limit for the query which has already built SOQL.');
        }
        this._config.limit = limit;
        return this;
    }
    /**
     * Skip records
     */ skip(offset) {
        if (this._soql) {
            throw Error('Cannot set skip/offset for the query which has already built SOQL.');
        }
        this._config.offset = offset;
        return this;
    }
    /**
     * Synonym of Query#skip()
     */ offset = this.skip;
    sort(sort, dir) {
        if (this._soql) {
            throw Error('Cannot set sort for the query which has already built SOQL.');
        }
        if (typeof sort === 'string' && typeof dir !== 'undefined') {
            this._config.sort = [
                [
                    sort,
                    dir
                ]
            ];
        } else {
            this._config.sort = sort;
        }
        return this;
    }
    /**
     * Synonym of Query#sort()
     */ orderby = this.sort;
    include(childRelName, conditions, fields, options = {}) {
        if (this._soql) {
            throw Error('Cannot include child relationship into the query which has already built SOQL.');
        }
        const childConfig = {
            fields: fields === null ? undefined : fields,
            table: childRelName,
            conditions: conditions === null ? undefined : conditions,
            limit: options.limit,
            offset: options.offset,
            sort: options.sort
        };
        // eslint-disable-next-line no-use-before-define
        const childQuery = new SubQuery(this._conn, childRelName, childConfig, this);
        this._children.push(childQuery);
        return childQuery;
    }
    /**
     * Include child relationship queries, but not moving down to the children context
     */ includeChildren(includes) {
        if (this._soql) {
            throw Error('Cannot include child relationship into the query which has already built SOQL.');
        }
        for (const crname of Object.keys(includes)){
            const { conditions, fields, ...options } = includes[crname];
            this.include(crname, conditions, fields, options);
        }
        return this;
    }
    /**
     * Setting maxFetch query option
     */ maxFetch(maxFetch) {
        this._options.maxFetch = maxFetch;
        return this;
    }
    /**
     * Switching auto fetch mode
     */ autoFetch(autoFetch) {
        this._options.autoFetch = autoFetch;
        return this;
    }
    /**
     * Set flag to scan all records including deleted and archived.
     */ scanAll(scanAll) {
        this._options.scanAll = scanAll;
        return this;
    }
    /**
     *
     */ setResponseTarget(responseTarget) {
        if (responseTarget in exports.ResponseTargets) {
            this._options.responseTarget = responseTarget;
        }
        // force change query response target without changing instance
        return this;
    }
    /**
     * Execute query and fetch records from server.
     */ execute(options_ = {}) {
        if (this._executed) {
            throw new Error('re-executing already executed query');
        }
        if (this._finished) {
            throw new Error('executing already closed query');
        }
        const options = {
            headers: options_.headers || this._options.headers,
            responseTarget: options_.responseTarget || this._options.responseTarget,
            autoFetch: options_.autoFetch || this._options.autoFetch,
            maxFetch: options_.maxFetch || this._options.maxFetch,
            scanAll: options_.scanAll || this._options.scanAll
        };
        // collect fetched records in array
        // only when response target is Records and
        // either callback or chaining promises are available to this query.
        this.once('fetch', ()=>{
            if (options.responseTarget === exports.ResponseTargets.Records && this._chaining) {
                this._logger.debug('--- collecting all fetched records ---');
                const records = [];
                const onRecord = (record)=>records.push(record);
                this.on('record', onRecord);
                this.once('end', ()=>{
                    this.removeListener('record', onRecord);
                    this.emit('response', records, this);
                });
            }
        });
        // flag to prevent re-execution
        this._executed = true;
        (async ()=>{
            // start actual query
            this._logger.debug('>>> Query start >>>');
            try {
                await this._execute(options);
                this._logger.debug('*** Query finished ***');
            } catch (error) {
                this._logger.debug('--- Query error ---', error);
                this.emit('error', error);
            }
        })();
        // return Query instance for chaining
        return this;
    }
    /**
     * Synonym of Query#execute()
     */ exec = this.execute;
    /**
     * Synonym of Query#execute()
     */ run = this.execute;
    locatorToUrl() {
        return this._locator ? [
            this._conn._baseUrl(),
            '/query/',
            this._locator
        ].join('') : '';
    }
    urlToLocator(url) {
        return url.split('/').pop();
    }
    constructResponse(rawDone, responseTarget) {
        switch(responseTarget){
            case 'Count':
                return this.totalSize;
            case 'SingleRecord':
                return this.records?.[0] ?? null;
            case 'Records':
                return this.records;
            // QueryResult is default response target
            default:
                return {
                    ...{
                        records: this.records,
                        totalSize: this.totalSize,
                        done: rawDone ?? true
                    },
                    ...this._locator ? {
                        nextRecordsUrl: this.locatorToUrl()
                    } : {}
                };
        }
    }
    /**
     * @private
     */ async _execute(options) {
        const { headers, responseTarget, autoFetch, maxFetch, scanAll } = options;
        this._logger.debug('execute with options', options);
        let url;
        if (this._locator) {
            url = this.locatorToUrl();
        } else {
            const soql = await this.toSOQL();
            this._logger.debug(`SOQL = ${soql}`);
            url = [
                this._conn._baseUrl(),
                '/',
                scanAll ? 'queryAll' : 'query',
                '?q=',
                encodeURIComponent(soql)
            ].join('');
        }
        const data = await this._conn.request({
            method: 'GET',
            url,
            headers
        });
        this.emit('fetch');
        this.totalSize = data.totalSize;
        // If autoFetch is true, fetch all records for any subqueries
        if (autoFetch && data.records.length > 0) {
            const recordKeys = Object.keys(data.records[0]);
            for (const record of data.records){
                for (const key of recordKeys){
                    const field = record[key];
                    if (field && typeof field === 'object' && 'records' in field && 'nextRecordsUrl' in field) {
                        record[key] = {
                            ...field,
                            records: await this._fetchAllSubqueryRecords(record, key, headers),
                            done: true,
                            nextRecordsUrl: undefined
                        };
                    }
                }
            }
        }
        this.records = this.records?.concat(maxFetch - this.records.length > data.records.length ? data.records : data.records.slice(0, maxFetch - this.records.length));
        this._locator = data.nextRecordsUrl ? this.urlToLocator(data.nextRecordsUrl) : undefined;
        this._finished = this._finished || data.done || !autoFetch || this.records.length === maxFetch || data.records.length === 0 && data.done === undefined;
        // streaming record instances
        const numRecords = data.records?.length ?? 0;
        let totalFetched = this.totalFetched;
        for(let i = 0; i < numRecords; i++){
            if (totalFetched >= maxFetch) {
                this._finished = true;
                break;
            }
            const record = data.records[i];
            this.emit('record', record, totalFetched, this);
            totalFetched += 1;
        }
        this.totalFetched = totalFetched;
        if (this._finished) {
            const response = this.constructResponse(data.done, responseTarget);
            // only fire response event when it should be notified per fetch
            if (responseTarget !== exports.ResponseTargets.Records) {
                this.emit('response', response, this);
            }
            this.emit('end');
            return response;
        } else {
            return this._execute(options);
        }
    }
    stream(type = 'csv') {
        if (!this._finished && !this._executed) {
            this.execute({
                autoFetch: true
            });
        }
        return type === 'record' ? this._stream : this._stream.stream(type);
    }
    /**
     * Pipe the queried records to another stream
     * This is for backward compatibility; Query is not a record stream instance anymore in 2.0.
     * If you want a record stream instance, use `Query#stream('record')`.
     */ pipe(stream) {
        return this.stream('record').pipe(stream);
    }
    /**
     * @protected
     */ async _expandFields(sobject_) {
        if (this._soql) {
            throw new Error('Cannot expand fields for the query which has already built SOQL.');
        }
        const { fields = [], table = '' } = this._config;
        const sobject = sobject_ || table;
        this._logger.debug(`_expandFields: sobject = ${sobject}, fields = ${fields.join(', ')}`);
        const [efields] = await Promise.all([
            this._expandAsteriskFields(sobject, fields),
            ...this._children.map(async (childQuery)=>{
                await childQuery._expandFields();
                return [];
            })
        ]);
        this._config.fields = efields;
        this._config.includes = this._children.map((cquery)=>{
            const cconfig = cquery._query._config;
            return [
                cconfig.table,
                cconfig
            ];
        }).reduce((includes, [ctable, cconfig])=>({
                ...includes,
                [ctable]: cconfig
            }), {});
    }
    /**
     *
     */ async _findRelationObject(relName) {
        const table = this._config.table;
        if (!table) {
            throw new Error('No table information provided in the query');
        }
        this._logger.debug(`finding table for relation "${relName}" in "${table}"...`);
        const sobject = await this._conn.describe$(table);
        const upperRname = relName.toUpperCase();
        for (const cr of sobject.childRelationships){
            if ((cr.relationshipName || '').toUpperCase() === upperRname && cr.childSObject) {
                return cr.childSObject;
            }
        }
        throw new Error(`No child relationship found: ${relName}`);
    }
    /**
     *
     */ async _expandAsteriskFields(sobject, fields) {
        const expandedFields = await Promise.all(fields.map(async (field)=>this._expandAsteriskField(sobject, field)));
        return expandedFields.reduce((eflds, flds)=>[
                ...eflds,
                ...flds
            ], []);
    }
    /**
     *
     */ async _expandAsteriskField(sobject, field) {
        this._logger.debug(`expanding field "${field}" in "${sobject}"...`);
        const fpath = field.split('.');
        if (fpath[fpath.length - 1] === '*') {
            const so = await this._conn.describe$(sobject);
            this._logger.debug(`table ${sobject} has been described`);
            if (fpath.length > 1) {
                const rname = fpath.shift();
                for (const f of so.fields){
                    if (f.relationshipName && rname && f.relationshipName.toUpperCase() === rname.toUpperCase()) {
                        const rfield = f;
                        const referenceTo = rfield.referenceTo || [];
                        const rtable = referenceTo.length === 1 ? referenceTo[0] : 'Name';
                        const fpaths = await this._expandAsteriskField(rtable, fpath.join('.'));
                        return fpaths.map((fp)=>`${rname}.${fp}`);
                    }
                }
                return [];
            }
            return so.fields.map((f)=>f.name);
        }
        return [
            field
        ];
    }
    /**
     * Explain plan for executing query
     */ async explain() {
        const soql = await this.toSOQL();
        this._logger.debug(`SOQL = ${soql}`);
        const url = `/query/?explain=${encodeURIComponent(soql)}`;
        return this._conn.request(url);
    }
    /**
     * Return SOQL expression for the query
     */ async toSOQL() {
        if (this._soql) {
            return this._soql;
        }
        await this._expandFields();
        return (0, soql_builder_1.createSOQL)(this._config);
    }
    /**
     * Promise/A+ interface
     * http://promises-aplus.github.io/promises-spec/
     *
     * Delegate to deferred promise, return promise instance for query result
     */ then(onResolve, onReject) {
        this._chaining = true;
        if (!this._finished && !this._executed) {
            this.execute();
        }
        if (!this._promise) {
            throw new Error('invalid state: promise is not set after query execution');
        }
        return this._promise.then(onResolve, onReject);
    }
    catch(onReject) {
        return this.then(null, onReject);
    }
    promise() {
        // TODO(cristian): verify this is correct
        return Promise.resolve(this);
    }
    destroy(type, options) {
        if (typeof type === 'object' && type !== null) {
            options = type;
            type = undefined;
        }
        options = options || {};
        const type_ = type || this._config.table;
        if (!type_) {
            throw new Error('SOQL based query needs SObject type information to bulk delete.');
        }
        // Set the threshold number to pass to bulk API
        const thresholdNum = options.allowBulk === false ? -1 : typeof options.bulkThreshold === 'number' ? options.bulkThreshold : this._conn._ensureVersion(42) ? DEFAULT_BULK_THRESHOLD : this._conn._maxRequest / 2;
        const bulkApiVersion = options.bulkApiVersion ?? DEFAULT_BULK_API_VERSION;
        return new Promise((resolve, reject)=>{
            const createBatch = ()=>this._conn.sobject(type_).deleteBulk().on('response', resolve).on('error', reject);
            let records = [];
            let batch = null;
            const handleRecord = (rec)=>{
                if (!rec.Id) {
                    const err = new Error('Queried record does not include Salesforce record ID.');
                    this.emit('error', err);
                    return;
                }
                const record = {
                    Id: rec.Id
                };
                if (batch) {
                    batch.write(record);
                } else {
                    records.push(record);
                    if (thresholdNum >= 0 && records.length > thresholdNum && bulkApiVersion === 1) {
                        // Use bulk delete instead of SObject REST API
                        batch = createBatch();
                        for (const record of records){
                            batch.write(record);
                        }
                        records = [];
                    }
                }
            };
            const handleEnd = ()=>{
                if (batch) {
                    batch.end();
                } else {
                    const ids = records.map((record)=>record.Id);
                    if (records.length > thresholdNum && bulkApiVersion === 2) {
                        this._conn.bulk2.loadAndWaitForResults({
                            object: type_,
                            operation: 'delete',
                            input: records
                        }).then((allResults)=>resolve(this.mapBulkV2ResultsToSaveResults(allResults)), reject);
                    } else {
                        this._conn.sobject(type_).destroy(ids, {
                            allowRecursive: true
                        }).then(resolve, reject);
                    }
                }
            };
            this.stream('record').on('data', handleRecord).on('end', handleEnd).on('error', reject);
        });
    }
    /**
     * Synonym of Query#destroy()
     */ delete = this.destroy;
    /**
     * Synonym of Query#destroy()
     */ del = this.destroy;
    update(mapping, type, options) {
        if (typeof type === 'object' && type !== null) {
            options = type;
            type = undefined;
        }
        options = options || {};
        const type_ = type || this._config && this._config.table;
        if (!type_) {
            throw new Error('SOQL based query needs SObject type information to bulk update.');
        }
        const updateStream = typeof mapping === 'function' ? record_stream_1.default.map(mapping) : record_stream_1.default.recordMapStream(mapping, options.skipRecordTemplateEval);
        // Set the threshold number to pass to bulk API
        const thresholdNum = options.allowBulk === false ? -1 : typeof options.bulkThreshold === 'number' ? options.bulkThreshold : this._conn._ensureVersion(42) ? DEFAULT_BULK_THRESHOLD : this._conn._maxRequest / 2;
        const bulkApiVersion = options.bulkApiVersion ?? DEFAULT_BULK_API_VERSION;
        return new Promise((resolve, reject)=>{
            const createBatch = ()=>this._conn.sobject(type_).updateBulk().on('response', resolve).on('error', reject);
            let records = [];
            let batch = null;
            const handleRecord = (record)=>{
                if (batch) {
                    batch.write(record);
                } else {
                    records.push(record);
                }
                if (thresholdNum >= 0 && records.length > thresholdNum && bulkApiVersion === 1) {
                    // Use bulk update instead of SObject REST API
                    batch = createBatch();
                    for (const record of records){
                        batch.write(record);
                    }
                    records = [];
                }
            };
            const handleEnd = ()=>{
                if (batch) {
                    batch.end();
                } else {
                    if (records.length > thresholdNum && bulkApiVersion === 2) {
                        this._conn.bulk2.loadAndWaitForResults({
                            object: type_,
                            operation: 'update',
                            input: records
                        }).then((allResults)=>resolve(this.mapBulkV2ResultsToSaveResults(allResults)), reject);
                    } else {
                        this._conn.sobject(type_).update(records, {
                            allowRecursive: true
                        }).then(resolve, reject);
                    }
                }
            };
            this.stream('record').on('error', reject).pipe(updateStream).on('data', handleRecord).on('end', handleEnd).on('error', reject);
        });
    }
    mapBulkV2ResultsToSaveResults(bulkJobAllResults) {
        const successSaveResults = bulkJobAllResults.successfulResults.map((r)=>{
            const saveResult = {
                id: r.sf__Id,
                success: true,
                errors: []
            };
            return saveResult;
        });
        const failedSaveResults = bulkJobAllResults.failedResults.map((r)=>{
            const saveResult = {
                success: false,
                errors: [
                    {
                        errorCode: r.sf__Error,
                        message: r.sf__Error
                    }
                ]
            };
            return saveResult;
        });
        return [
            ...successSaveResults,
            ...failedSaveResults
        ];
    }
    /**
     * Fetches all records for a subquery field by following nextRecordsUrl
     * @private
     */ async _fetchAllSubqueryRecords(record, fieldName, headers) {
        const subqueryField = record[fieldName];
        if (!subqueryField || !subqueryField.records) {
            return [];
        }
        let allRecords = [
            ...subqueryField.records
        ];
        let nextRecordsUrl = subqueryField.nextRecordsUrl;
        while(nextRecordsUrl){
            // When following nextRecordsUrl for a subquery, we need to preserve the relationship context
            // by using the full URL as-is rather than trying to reconstruct it
            const data = await this._conn.request({
                method: 'GET',
                url: nextRecordsUrl,
                headers
            });
            allRecords = allRecords.concat(data.records);
            nextRecordsUrl = data.nextRecordsUrl;
        }
        return allRecords;
    }
}
exports.Query = Query;
/*--------------------------------------------*/ /**
 * SubQuery object for representing child relationship query
 */ class SubQuery {
    _relName;
    _query;
    _parent;
    /**
     *
     */ constructor(conn, relName, config, parent){
        this._relName = relName;
        this._query = new Query(conn, config);
        this._parent = parent;
    }
    /**
     *
     */ select(fields) {
        // force convert query record type without changing instance
        this._query = this._query.select(fields);
        return this;
    }
    /**
     *
     */ where(conditions) {
        this._query = this._query.where(conditions);
        return this;
    }
    /**
     * Limit the returning result
     */ limit(limit) {
        this._query = this._query.limit(limit);
        return this;
    }
    /**
     * Skip records
     */ skip(offset) {
        this._query = this._query.skip(offset);
        return this;
    }
    /**
     * Synonym of SubQuery#skip()
     */ offset = this.skip;
    sort(sort, dir) {
        this._query = this._query.sort(sort, dir);
        return this;
    }
    /**
     * Synonym of SubQuery#sort()
     */ orderby = this.sort;
    /**
     *
     */ async _expandFields() {
        const sobject = await this._parent._findRelationObject(this._relName);
        return this._query._expandFields(sobject);
    }
    /**
     * Back the context to parent query object
     */ end() {
        return this._parent;
    }
}
exports.SubQuery = SubQuery;
exports.default = Query;
}),
"[project]/node_modules/jsforce/lib/record-reference.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RecordReference = void 0;
/**
 * Remote reference to record information
 */ class RecordReference {
    type;
    id;
    _conn;
    /**
     *
     */ constructor(conn, type, id){
        this._conn = conn;
        this.type = type;
        this.id = id;
    }
    /**
     * Retrieve record field information
     */ async retrieve(options) {
        const rec = await this._conn.retrieve(this.type, this.id, options);
        return rec;
    }
    /**
     * Update record field information
     */ async update(record, options) {
        const record_ = {
            ...record,
            Id: this.id
        };
        return this._conn.update(this.type, record_, options);
    }
    /**
     * Delete record field
     */ destroy(options) {
        return this._conn.destroy(this.type, this.id, options);
    }
    /**
     * Synonym of Record#destroy()
     */ delete = this.destroy;
    /**
     * Synonym of Record#destroy()
     */ del = this.destroy;
    /**
     * Get blob field as stream
     *
     * @param {String} fieldName - Blob field name
     * @returns {stream.Stream}
     */ blob(fieldName) {
        const url = [
            this._conn._baseUrl(),
            'sobjects',
            this.type,
            this.id,
            fieldName
        ].join('/');
        return this._conn.request(url).stream();
    }
}
exports.RecordReference = RecordReference;
exports.default = RecordReference;
}),
"[project]/node_modules/jsforce/lib/quick-action.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QuickAction = void 0;
/**
 * A class for quick action
 */ class QuickAction {
    _conn;
    _path;
    /**
     *
     */ constructor(conn, path){
        this._conn = conn;
        this._path = path;
    }
    /**
     * Describe the action's information (including layout, etc.)
     */ async describe() {
        const url = `${this._path}/describe`;
        const body = await this._conn.request(url);
        return body;
    }
    /**
     * Retrieve default field values in the action (for given record, if specified)
     */ async defaultValues(contextId) {
        let url = `${this._path}/defaultValues`;
        if (contextId) {
            url += `/${contextId}`;
        }
        const body = await this._conn.request(url);
        return body;
    }
    /**
     * Execute the action for given context Id and record information
     */ async execute(contextId, record) {
        const requestBody = {
            contextId,
            record
        };
        const resBody = await this._conn.requestPost(this._path, requestBody);
        return resBody;
    }
}
exports.QuickAction = QuickAction;
exports.default = QuickAction;
}),
"[project]/node_modules/jsforce/lib/sobject.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SObject = void 0;
/**
 *
 */ const logger_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/util/logger.js [app-route] (ecmascript)");
const record_reference_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/record-reference.js [app-route] (ecmascript)"));
const query_1 = __importStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/query.js [app-route] (ecmascript)"));
const quick_action_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/quick-action.js [app-route] (ecmascript)"));
/**
 * A class for organizing all SObject access
 */ class SObject {
    static _logger = (0, logger_1.getLogger)('sobject');
    type;
    _conn;
    _logger;
    // layouts: (ln?: string) => Promise<DescribeLayoutResult>;
    layouts$;
    layouts$$;
    // compactLayouts: () => Promise<DescribeCompactLayoutsResult>;
    compactLayouts$;
    compactLayouts$$;
    // approvalLayouts: () => Promise<DescribeApprovalLayoutsResult>;
    approvalLayouts$;
    approvalLayouts$$;
    /**
     *
     */ constructor(conn, type){
        this.type = type;
        this._conn = conn;
        this._logger = conn._logLevel ? SObject._logger.createInstance(conn._logLevel) : SObject._logger;
        const cache = this._conn.cache;
        const layoutCacheKey = (layoutName)=>layoutName ? `layouts.namedLayouts.${layoutName}` : `layouts.${this.type}`;
        const layouts = SObject.prototype.layouts;
        this.layouts = cache.createCachedFunction(layouts, this, {
            key: layoutCacheKey,
            strategy: 'NOCACHE'
        });
        this.layouts$ = cache.createCachedFunction(layouts, this, {
            key: layoutCacheKey,
            strategy: 'HIT'
        });
        this.layouts$$ = cache.createCachedFunction(layouts, this, {
            key: layoutCacheKey,
            strategy: 'IMMEDIATE'
        });
        const compactLayoutCacheKey = `compactLayouts.${this.type}`;
        const compactLayouts = SObject.prototype.compactLayouts;
        this.compactLayouts = cache.createCachedFunction(compactLayouts, this, {
            key: compactLayoutCacheKey,
            strategy: 'NOCACHE'
        });
        this.compactLayouts$ = cache.createCachedFunction(compactLayouts, this, {
            key: compactLayoutCacheKey,
            strategy: 'HIT'
        });
        this.compactLayouts$$ = cache.createCachedFunction(compactLayouts, this, {
            key: compactLayoutCacheKey,
            strategy: 'IMMEDIATE'
        });
        const approvalLayoutCacheKey = `approvalLayouts.${this.type}`;
        const approvalLayouts = SObject.prototype.approvalLayouts;
        this.approvalLayouts = cache.createCachedFunction(approvalLayouts, this, {
            key: approvalLayoutCacheKey,
            strategy: 'NOCACHE'
        });
        this.approvalLayouts$ = cache.createCachedFunction(approvalLayouts, this, {
            key: approvalLayoutCacheKey,
            strategy: 'HIT'
        });
        this.approvalLayouts$$ = cache.createCachedFunction(approvalLayouts, this, {
            key: approvalLayoutCacheKey,
            strategy: 'IMMEDIATE'
        });
    }
    create(records, options) {
        return this._conn.create(this.type, records, options);
    }
    /**
     * Synonym of SObject#create()
     */ insert = this.create;
    retrieve(ids, options) {
        return this._conn.retrieve(this.type, ids, options);
    }
    update(records, options) {
        return this._conn.update(this.type, records, options);
    }
    upsert(records, extIdField, options) {
        return this._conn.upsert(this.type, records, extIdField, options);
    }
    destroy(ids, options) {
        return this._conn.destroy(this.type, ids, options);
    }
    /**
     * Synonym of SObject#destroy()
     */ delete = this.destroy;
    /**
     * Synonym of SObject#destroy()
     */ del = this.destroy;
    /**
     * Call Bulk#load() to execute bulkload, returning batch object
     */ bulkload(operation, optionsOrInput, input) {
        return this._conn.bulk.load(this.type, operation, optionsOrInput, input);
    }
    /**
     * Bulkly insert input data using bulk API
     */ createBulk(input) {
        return this.bulkload('insert', input);
    }
    /**
     * Synonym of SObject#createBulk()
     */ insertBulk = this.createBulk;
    /**
     * Bulkly update records by input data using bulk API
     */ updateBulk(input) {
        return this.bulkload('update', input);
    }
    /**
     * Bulkly upsert records by input data using bulk API
     */ upsertBulk(input, extIdField) {
        return this.bulkload('upsert', {
            extIdField
        }, input);
    }
    /**
     * Bulkly delete records specified by input data using bulk API
     */ destroyBulk(input) {
        return this.bulkload('delete', input);
    }
    /**
     * Synonym of SObject#destroyBulk()
     */ deleteBulk = this.destroyBulk;
    /**
     * Bulkly hard delete records specified in input data using bulk API
     */ destroyHardBulk(input) {
        return this.bulkload('hardDelete', input);
    }
    /**
     * Synonym of SObject#destroyHardBulk()
     */ deleteHardBulk = this.destroyHardBulk;
    /**
     * Describe SObject metadata
     */ describe() {
        return this._conn.describe(this.type);
    }
    /**
     *
     */ describe$() {
        return this._conn.describe$(this.type);
    }
    /**
     *
     */ describe$$() {
        return this._conn.describe$$(this.type);
    }
    /**
     * Get record representation instance by given id
     */ record(id) {
        return new record_reference_1.default(this._conn, this.type, id);
    }
    /**
     * Retrieve recently accessed records
     */ recent() {
        return this._conn.recent(this.type);
    }
    /**
     * Retrieve the updated records
     */ updated(start, end) {
        return this._conn.updated(this.type, start, end);
    }
    /**
     * Retrieve the deleted records
     */ deleted(start, end) {
        return this._conn.deleted(this.type, start, end);
    }
    /**
     * Describe layout information for SObject
     */ async layouts(layoutName) {
        const url = `/sobjects/${this.type}/describe/${layoutName ? `namedLayouts/${layoutName}` : 'layouts'}`;
        const body = await this._conn.request(url);
        return body;
    }
    /**
     * @typedef {Object} CompactLayoutInfo
     * @prop {Array.<Object>} compactLayouts - Array of compact layouts
     * @prop {String} defaultCompactLayoutId - ID of default compact layout
     * @prop {Array.<Object>} recordTypeCompactLayoutMappings - Array of record type mappings
     */ /**
     * Describe compact layout information defined for SObject
     *
     * @param {Callback.<CompactLayoutInfo>} [callback] - Callback function
     * @returns {Promise.<CompactLayoutInfo>}
     */ async compactLayouts() {
        const url = `/sobjects/${this.type}/describe/compactLayouts`;
        const body = await this._conn.request(url);
        return body;
    }
    /**
     * Describe compact layout information defined for SObject
     *
     * @param {Callback.<ApprovalLayoutInfo>} [callback] - Callback function
     * @returns {Promise.<ApprovalLayoutInfo>}
     */ async approvalLayouts() {
        const url = `/sobjects/${this.type}/describe/approvalLayouts`;
        const body = await this._conn.request(url);
        return body;
    }
    find(conditions, fields, options = {}) {
        const { sort, limit, offset, ...qoptions } = options;
        const config = {
            fields: fields == null ? undefined : fields,
            includes: options.includes,
            table: this.type,
            conditions: conditions == null ? undefined : conditions,
            sort,
            limit,
            offset
        };
        const query = new query_1.default(this._conn, config, qoptions);
        return query.setResponseTarget(query_1.ResponseTargets.Records);
    }
    findOne(conditions, fields, options = {}) {
        const query = this.find(conditions, fields, {
            ...options,
            limit: 1
        });
        return query.setResponseTarget(query_1.ResponseTargets.SingleRecord);
    }
    /**
     * Find and fetch records only by specifying fields to fetch.
     */ select(fields) {
        return this.find(null, fields);
    }
    /**
     * Count num of records which matches given conditions
     */ count(conditions) {
        const query = this.find(conditions, 'count()');
        return query.setResponseTarget(query_1.ResponseTargets.Count);
    }
    /**
     * Returns the list of list views for the SObject
     *
     * @param {Callback.<ListViewsInfo>} [callback] - Callback function
     * @returns {Promise.<ListViewsInfo>}
     */ listviews() {
        const url = `${this._conn._baseUrl()}/sobjects/${this.type}/listviews`;
        return this._conn.request(url);
    }
    /**
     * Returns the list view info in specifed view id
     *
     * @param {String} id - List view ID
     * @returns {ListView}
     */ listview(id) {
        return new ListView(this._conn, this.type, id); // eslint-disable-line no-use-before-define
    }
    /**
     * Returns all registered quick actions for the SObject
     *
     * @param {Callback.<Array.<QuickAction~QuickActionInfo>>} [callback] - Callback function
     * @returns {Promise.<Array.<QuickAction~QuickActionInfo>>}
     */ quickActions() {
        return this._conn.request(`/sobjects/${this.type}/quickActions`);
    }
    /**
     * Get reference for specified quick aciton in the SObject
     *
     * @param {String} actionName - Name of the quick action
     * @returns {QuickAction}
     */ quickAction(actionName) {
        return new quick_action_1.default(this._conn, `/sobjects/${this.type}/quickActions/${actionName}`);
    }
}
exports.SObject = SObject;
/**
 * A class for organizing list view information
 *
 * @protected
 * @class ListView
 * @param {Connection} conn - Connection instance
 * @param {SObject} type - SObject type
 * @param {String} id - List view ID
 */ class ListView {
    _conn;
    type;
    id;
    /**
     *
     */ constructor(conn, type, id){
        this._conn = conn;
        this.type = type;
        this.id = id;
    }
    /**
     * Executes query for the list view and returns the resulting data and presentation information.
     */ results() {
        const url = `${this._conn._baseUrl()}/sobjects/${this.type}/listviews/${this.id}/results`;
        return this._conn.request(url);
    }
    /**
     * Returns detailed information about a list view
     */ describe(options = {}) {
        const url = `${this._conn._baseUrl()}/sobjects/${this.type}/listviews/${this.id}/describe`;
        return this._conn.request({
            method: 'GET',
            url,
            headers: options.headers
        });
    }
    /**
     * Explain plan for executing list view
     */ explain() {
        const url = `/query/?explain=${this.id}`;
        return this._conn.request(url);
    }
}
exports.default = SObject; // TODO Bulk
}),
"[project]/node_modules/jsforce/lib/process.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Process = exports.ApprovalProcess = exports.ProcessRule = void 0;
/**
 * A class which manages process (workflow) rules
 */ class ProcessRule {
    _conn;
    /**
     *
     */ constructor(conn){
        this._conn = conn;
    }
    /**
     * Get all process rule definitions registered to sobjects
     */ async list() {
        const res = await this._conn.request('/process/rules');
        return res.rules;
    }
    /**
     * Trigger process rule for given entities
     */ trigger(contextIds) {
        const contextIds_ = Array.isArray(contextIds) ? contextIds : [
            contextIds
        ];
        // https://developer.salesforce.com/docs/atlas.en-us.api_rest.meta/api_rest/dome_process_rules_trigger.htm
        return this._conn.request({
            method: 'POST',
            url: '/process/rules/',
            body: JSON.stringify({
                contextIds: contextIds_
            }),
            headers: {
                'content-type': 'application/json'
            }
        });
    }
}
exports.ProcessRule = ProcessRule;
/**
 * A class which manages approval processes
 */ class ApprovalProcess {
    _conn;
    /**
     *
     */ constructor(conn){
        this._conn = conn;
    }
    /**
     * Get all approval process definitions registered to sobjects
     */ async list() {
        const res = await this._conn.request('/process/approvals');
        return res.approvals;
    }
    /**
     * Send bulk requests for approval process
     */ request(requests) {
        const requests_ = requests.map((req)=>'_request' in req ? req._request : req);
        return this._conn.request({
            method: 'POST',
            url: '/process/approvals',
            headers: {
                'content-type': 'application/json'
            },
            body: JSON.stringify({
                requests: requests_
            })
        });
    }
    /**
     * Create approval process request
     *
     * @private
     */ _createRequest(actionType, contextId, comments, options = {}) {
        return new ApprovalProcessRequest(this, {
            actionType,
            contextId,
            comments,
            ...options
        });
    }
    /**
     * Submit approval request for an item
     */ submit(contextId, comments, options) {
        return this._createRequest('Submit', contextId, comments, options);
    }
    /**
     * Approve approval request for an item
     */ approve(workitemId, comments, options = {}) {
        return this._createRequest('Approve', workitemId, comments, options);
    }
    /**
     * Reject approval request for an item
     */ reject(workitemId, comments, options = {}) {
        return this._createRequest('Reject', workitemId, comments, options);
    }
}
exports.ApprovalProcess = ApprovalProcess;
/**
 * A class representing approval process request
 */ class ApprovalProcessRequest {
    _process;
    _request;
    _promise;
    constructor(process, request){
        this._process = process;
        this._request = request;
    }
    /**
     * Promise/A+ interface
     * http://promises-aplus.github.io/promises-spec/
     */ then(onResolve, onReject) {
        if (!this._promise) {
            this._promise = this._process.request([
                this
            ]).then((rets)=>rets[0]);
        }
        this._promise.then(onResolve, onReject);
    }
}
/**
 * A class which manages process rules and approval processes
 */ class Process {
    rule;
    approval;
    /**
     *
     */ constructor(conn){
        this.rule = new ProcessRule(conn);
        this.approval = new ApprovalProcess(conn);
    }
}
exports.Process = Process;
exports.default = Process;
}),
"[project]/node_modules/jsforce/lib/connection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Connection = void 0;
/**
 *
 */ const events_1 = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
const jsforce_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/jsforce.js [app-route] (ecmascript)"));
const transport_1 = __importStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/transport.js [app-route] (ecmascript)"));
const logger_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/util/logger.js [app-route] (ecmascript)");
const oauth2_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/oauth2.js [app-route] (ecmascript)"));
const cache_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/cache.js [app-route] (ecmascript)"));
const http_api_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/http-api.js [app-route] (ecmascript)"));
const session_refresh_delegate_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/session-refresh-delegate.js [app-route] (ecmascript)"));
const query_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/query.js [app-route] (ecmascript)"));
const sobject_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/sobject.js [app-route] (ecmascript)"));
const quick_action_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/quick-action.js [app-route] (ecmascript)"));
const process_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/process.js [app-route] (ecmascript)"));
const formatter_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/util/formatter.js [app-route] (ecmascript)");
const form_data_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/form-data/lib/form_data.js [app-route] (ecmascript)"));
/**
 *
 */ const defaultConnectionConfig = {
    loginUrl: 'https://login.salesforce.com',
    instanceUrl: '',
    version: '50.0',
    logLevel: 'NONE',
    maxRequest: 10
};
/**
 *
 */ function esc(str) {
    return String(str || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}
/**
 *
 */ function parseSignedRequest(sr) {
    if (typeof sr === 'string') {
        if (sr.startsWith('{')) {
            // might be JSON
            return JSON.parse(sr);
        } // might be original base64-encoded signed request
        const msg = sr.split('.').pop(); // retrieve latter part
        if (!msg) {
            throw new Error('Invalid signed request');
        }
        const json = Buffer.from(msg, 'base64').toString('utf-8');
        return JSON.parse(json);
    }
    return sr;
}
/** @private **/ function parseIdUrl(url) {
    const [organizationId, id] = url.split('/').slice(-2);
    return {
        id,
        organizationId,
        url
    };
}
/**
 * Session Refresh delegate function for OAuth2 authz code flow
 * @private
 */ async function oauthRefreshFn(conn, callback) {
    try {
        if (!conn.refreshToken) {
            throw new Error('No refresh token found in the connection');
        }
        const res = await conn.oauth2.refreshToken(conn.refreshToken);
        const userInfo = parseIdUrl(res.id);
        conn._establish({
            instanceUrl: res.instance_url,
            accessToken: res.access_token,
            userInfo
        });
        callback(undefined, res.access_token, res);
    } catch (err) {
        if (err instanceof Error) {
            callback(err);
        } else {
            throw err;
        }
    }
}
/**
 * Session Refresh delegate function for username/password login
 * @private
 */ function createUsernamePasswordRefreshFn(username, password) {
    return async (conn, callback)=>{
        try {
            await conn.login(username, password);
            if (!conn.accessToken) {
                throw new Error('Access token not found after login');
            }
            callback(null, conn.accessToken);
        } catch (err) {
            if (err instanceof Error) {
                callback(err);
            } else {
                throw err;
            }
        }
    };
}
/**
 * @private
 */ function toSaveResult(err) {
    return {
        success: false,
        errors: [
            err
        ]
    };
}
/**
 *
 */ function raiseNoModuleError(name) {
    throw new Error(`API module '${name}' is not loaded, load 'jsforce/api/${name}' explicitly`);
}
/*
 * Constant of maximum records num in DML operation (update/delete)
 */ const MAX_DML_COUNT = 200;
/**
 *
 */ class Connection extends events_1.EventEmitter {
    static _logger = (0, logger_1.getLogger)('connection');
    version;
    loginUrl;
    instanceUrl;
    accessToken;
    refreshToken;
    userInfo;
    limitInfo = {};
    oauth2;
    sobjects = {};
    cache;
    _callOptions;
    _maxRequest;
    _logger;
    _logLevel;
    _transport;
    _sessionType;
    _refreshDelegate;
    // describe: (name: string) => Promise<DescribeSObjectResult>;
    describe$;
    describe$$;
    describeSObject;
    describeSObject$;
    describeSObject$$;
    // describeGlobal: () => Promise<DescribeGlobalResult>;
    describeGlobal$;
    describeGlobal$$;
    // API libs are not instantiated here so that core module to remain without dependencies to them
    // It is responsible for developers to import api libs explicitly if they are using 'jsforce/core' instead of 'jsforce'.
    get analytics() {
        return raiseNoModuleError('analytics');
    }
    get apex() {
        return raiseNoModuleError('apex');
    }
    get bulk() {
        return raiseNoModuleError('bulk');
    }
    get bulk2() {
        return raiseNoModuleError('bulk2');
    }
    get chatter() {
        return raiseNoModuleError('chatter');
    }
    get metadata() {
        return raiseNoModuleError('metadata');
    }
    get soap() {
        return raiseNoModuleError('soap');
    }
    get streaming() {
        return raiseNoModuleError('streaming');
    }
    get tooling() {
        return raiseNoModuleError('tooling');
    }
    /**
     *
     */ constructor(config = {}){
        super();
        const { loginUrl, instanceUrl, version, oauth2, maxRequest, logLevel, proxyUrl, httpProxy } = config;
        this.loginUrl = loginUrl || defaultConnectionConfig.loginUrl;
        this.instanceUrl = instanceUrl || defaultConnectionConfig.instanceUrl;
        if (this.isLightningInstance()) {
            throw new Error('lightning URLs are not valid as instance URLs');
        }
        this.version = version || defaultConnectionConfig.version;
        this.oauth2 = oauth2 instanceof oauth2_1.default ? oauth2 : new oauth2_1.default({
            loginUrl: this.loginUrl,
            proxyUrl,
            httpProxy,
            ...oauth2
        });
        let refreshFn = config.refreshFn;
        if (!refreshFn && this.oauth2.clientId) {
            refreshFn = oauthRefreshFn;
        }
        if (refreshFn) {
            this._refreshDelegate = new session_refresh_delegate_1.default(this, refreshFn);
        }
        this._maxRequest = maxRequest || defaultConnectionConfig.maxRequest;
        this._logger = logLevel ? Connection._logger.createInstance(logLevel) : Connection._logger;
        this._logLevel = logLevel;
        this._transport = proxyUrl ? new transport_1.XdProxyTransport(proxyUrl) : httpProxy ? new transport_1.HttpProxyTransport(httpProxy) : new transport_1.default();
        this._callOptions = config.callOptions;
        this.cache = new cache_1.default();
        const describeCacheKey = (type)=>type ? `describe.${type}` : 'describe';
        const describe = Connection.prototype.describe;
        this.describe = this.cache.createCachedFunction(describe, this, {
            key: describeCacheKey,
            strategy: 'NOCACHE'
        });
        this.describe$ = this.cache.createCachedFunction(describe, this, {
            key: describeCacheKey,
            strategy: 'HIT'
        });
        this.describe$$ = this.cache.createCachedFunction(describe, this, {
            key: describeCacheKey,
            strategy: 'IMMEDIATE'
        });
        this.describeSObject = this.describe;
        this.describeSObject$ = this.describe$;
        this.describeSObject$$ = this.describe$$;
        const describeGlobal = Connection.prototype.describeGlobal;
        this.describeGlobal = this.cache.createCachedFunction(describeGlobal, this, {
            key: 'describeGlobal',
            strategy: 'NOCACHE'
        });
        this.describeGlobal$ = this.cache.createCachedFunction(describeGlobal, this, {
            key: 'describeGlobal',
            strategy: 'HIT'
        });
        this.describeGlobal$$ = this.cache.createCachedFunction(describeGlobal, this, {
            key: 'describeGlobal',
            strategy: 'IMMEDIATE'
        });
        const { accessToken, refreshToken, sessionId, serverUrl, signedRequest } = config;
        this._establish({
            accessToken,
            refreshToken,
            instanceUrl,
            sessionId,
            serverUrl,
            signedRequest
        });
        jsforce_1.default.emit('connection:new', this);
    }
    /* @private */ _establish(options) {
        const { accessToken, refreshToken, instanceUrl, sessionId, serverUrl, signedRequest, userInfo } = options;
        this.instanceUrl = serverUrl ? serverUrl.split('/').slice(0, 3).join('/') : instanceUrl || this.instanceUrl;
        this.accessToken = sessionId || accessToken || this.accessToken;
        this.refreshToken = refreshToken || this.refreshToken;
        if (this.refreshToken && !this._refreshDelegate) {
            throw new Error('Refresh token is specified without oauth2 client information or refresh function');
        }
        const signedRequestObject = signedRequest && parseSignedRequest(signedRequest);
        if (signedRequestObject) {
            this.accessToken = signedRequestObject.client.oauthToken;
            if (transport_1.CanvasTransport.supported) {
                this._transport = new transport_1.CanvasTransport(signedRequestObject);
            }
        }
        this.userInfo = userInfo || this.userInfo;
        this._sessionType = sessionId ? 'soap' : 'oauth2';
        this._resetInstance();
    }
    /* @priveate */ _clearSession() {
        this.accessToken = null;
        this.refreshToken = null;
        this.instanceUrl = defaultConnectionConfig.instanceUrl;
        this.userInfo = null;
        this._sessionType = null;
    }
    /* @priveate */ _resetInstance() {
        this.limitInfo = {};
        this.sobjects = {};
        // TODO impl cache
        this.cache.clear();
        this.cache.get('describeGlobal').removeAllListeners('value');
        this.cache.get('describeGlobal').on('value', ({ result })=>{
            if (result) {
                for (const so of result.sobjects){
                    this.sobject(so.name);
                }
            }
        });
    /*
        if (this.tooling) {
          this.tooling._resetInstance();
        }
        */ }
    /**
     * Authorize the connection using OAuth2 flow.
     * Typically, just pass the code returned from authorization server in the first argument to complete authorization.
     * If you want to authorize with grant types other than `authorization_code`, you can also pass params object with the grant type.
     *
     * @returns {Promise<UserInfo>} An object that contains the user ID, org ID and identity URL.
     *
     */ async authorize(codeOrParams, params = {}) {
        const res = await this.oauth2.requestToken(codeOrParams, params);
        const userInfo = parseIdUrl(res.id);
        this._establish({
            instanceUrl: res.instance_url,
            accessToken: res.access_token,
            refreshToken: res.refresh_token,
            userInfo
        });
        this._logger.debug(`<login> completed. user id = ${userInfo.id}, org id = ${userInfo.organizationId}`);
        return userInfo;
    }
    /**
     *
     */ async login(username, password) {
        this._refreshDelegate = new session_refresh_delegate_1.default(this, createUsernamePasswordRefreshFn(username, password));
        if (this.oauth2?.clientId && this.oauth2.clientSecret) {
            return this.loginByOAuth2(username, password);
        }
        return this.loginBySoap(username, password);
    }
    /**
     * Login by OAuth2 username & password flow
     */ async loginByOAuth2(username, password) {
        const res = await this.oauth2.authenticate(username, password);
        const userInfo = parseIdUrl(res.id);
        this._establish({
            instanceUrl: res.instance_url,
            accessToken: res.access_token,
            userInfo
        });
        this._logger.info(`<login> completed. user id = ${userInfo.id}, org id = ${userInfo.organizationId}`);
        return userInfo;
    }
    /**
     * Login by SOAP protocol
     * @deprecated The SOAP login() API will be retired in Summer '27 (API version 65.0).
     * Please use OAuth 2.0 Username-Password Flow instead.
     * For more information, see https://help.salesforce.com/s/articleView?id=release-notes.rn_api_upcoming_retirement_258rn.htm&release=258&type=5
     */ async loginBySoap(username, password) {
        this._logger.warn('DEPRECATION WARNING: The SOAP login() API will be retired in Summer \'27 (API version 65.0). ' + 'Please use OAuth 2.0 Username-Password Flow instead. ' + 'For more information, see https://help.salesforce.com/s/articleView?id=release-notes.rn_api_upcoming_retirement_258rn.htm&release=258&type=5');
        if (!username || !password) {
            return Promise.reject(new Error('no username password given'));
        }
        const body = [
            '<se:Envelope xmlns:se="http://schemas.xmlsoap.org/soap/envelope/">',
            '<se:Header/>',
            '<se:Body>',
            '<login xmlns="urn:partner.soap.sforce.com">',
            `<username>${esc(username)}</username>`,
            `<password>${esc(password)}</password>`,
            '</login>',
            '</se:Body>',
            '</se:Envelope>'
        ].join('');
        const soapLoginEndpoint = [
            this.loginUrl,
            'services/Soap/u',
            this.version
        ].join('/');
        const response = await this._transport.httpRequest({
            method: 'POST',
            url: soapLoginEndpoint,
            body,
            headers: {
                'Content-Type': 'text/xml',
                SOAPAction: '""'
            }
        });
        let m;
        if (response.statusCode >= 400) {
            m = response.body.match(/<faultstring>([^<]+)<\/faultstring>/);
            const faultstring = m && m[1];
            throw new Error(faultstring || response.body);
        }
        // the API will return 200 and a restriced token when using an expired password:
        // https://developer.salesforce.com/docs/atlas.en-us.api.meta/api/sforce_api_calls_login_loginresult.htm
        //
        // we need to throw here to avoid a possible infinite loop with session refresh where:
        //  1. login happens, `this.accessToken` is set to the restricted token
        //  2. requests happen, get back 401
        //  3. trigger session-refresh (username/password login has a default session refresh delegate function)
        //  4. gets stuck refreshing a restricted token
        if (response.body.match(/<passwordExpired>true<\/passwordExpired>/g)) {
            throw new Error('Unable to login because the used password has expired.');
        }
        this._logger.debug(`SOAP response = ${response.body}`);
        m = response.body.match(/<serverUrl>([^<]+)<\/serverUrl>/);
        const serverUrl = m && m[1];
        m = response.body.match(/<sessionId>([^<]+)<\/sessionId>/);
        const sessionId = m && m[1];
        m = response.body.match(/<userId>([^<]+)<\/userId>/);
        const userId = m && m[1];
        m = response.body.match(/<organizationId>([^<]+)<\/organizationId>/);
        const organizationId = m && m[1];
        if (!serverUrl || !sessionId || !userId || !organizationId) {
            throw new Error('could not extract session information from login response');
        }
        const idUrl = [
            this.loginUrl,
            'id',
            organizationId,
            userId
        ].join('/');
        const userInfo = {
            id: userId,
            organizationId,
            url: idUrl
        };
        this._establish({
            serverUrl: serverUrl.split('/').slice(0, 3).join('/'),
            sessionId,
            userInfo
        });
        this._logger.info(`<login> completed. user id = ${userId}, org id = ${organizationId}`);
        return userInfo;
    }
    /**
     * Logout the current session
     */ async logout(revoke) {
        this._refreshDelegate = undefined;
        if (this._sessionType === 'oauth2') {
            return this.logoutByOAuth2(revoke);
        }
        return this.logoutBySoap(revoke);
    }
    /**
     * Logout the current session by revoking access token via OAuth2 session revoke
     */ async logoutByOAuth2(revoke) {
        const token = revoke ? this.refreshToken : this.accessToken;
        if (token) {
            await this.oauth2.revokeToken(token);
        }
        // Destroy the session bound to this connection
        this._clearSession();
        this._resetInstance();
    }
    /**
     * Logout the session by using SOAP web service API
     */ async logoutBySoap(revoke) {
        const body = [
            '<se:Envelope xmlns:se="http://schemas.xmlsoap.org/soap/envelope/">',
            '<se:Header>',
            '<SessionHeader xmlns="urn:partner.soap.sforce.com">',
            `<sessionId>${esc(revoke ? this.refreshToken : this.accessToken)}</sessionId>`,
            '</SessionHeader>',
            '</se:Header>',
            '<se:Body>',
            '<logout xmlns="urn:partner.soap.sforce.com"/>',
            '</se:Body>',
            '</se:Envelope>'
        ].join('');
        const response = await this._transport.httpRequest({
            method: 'POST',
            url: [
                this.instanceUrl,
                'services/Soap/u',
                this.version
            ].join('/'),
            body,
            headers: {
                'Content-Type': 'text/xml',
                SOAPAction: '""'
            }
        });
        this._logger.debug(`SOAP statusCode = ${response.statusCode}, response = ${response.body}`);
        if (response.statusCode >= 400) {
            const m = response.body.match(/<faultstring>([^<]+)<\/faultstring>/);
            const faultstring = m && m[1];
            throw new Error(faultstring || response.body);
        }
        // Destroy the session bound to this connection
        this._clearSession();
        this._resetInstance();
    }
    /**
     * Send REST API request with given HTTP request info, with connected session information.
     *
     * Endpoint URL can be absolute URL ('https://na1.salesforce.com/services/data/v32.0/sobjects/Account/describe')
     * , relative path from root ('/services/data/v32.0/sobjects/Account/describe')
     * , or relative path from version root ('/sobjects/Account/describe').
     */ request(request, options = {}) {
        // if request is simple string, regard it as url in GET method
        let request_ = typeof request === 'string' ? {
            method: 'GET',
            url: request
        } : request;
        // if url is given in relative path, prepend base url or instance url before.
        request_ = {
            ...request_,
            url: this._normalizeUrl(request_.url)
        };
        const httpApi = new http_api_1.default(this, options);
        // log api usage and its quota
        httpApi.on('response', (response)=>{
            if (response.headers && response.headers['sforce-limit-info']) {
                const apiUsage = response.headers['sforce-limit-info'].match(/api-usage=(\d+)\/(\d+)/);
                if (apiUsage) {
                    this.limitInfo = {
                        apiUsage: {
                            used: parseInt(apiUsage[1], 10),
                            limit: parseInt(apiUsage[2], 10)
                        }
                    };
                }
            }
        });
        return httpApi.request(request_);
    }
    /**
     * Send HTTP GET request
     *
     * Endpoint URL can be absolute URL ('https://na1.salesforce.com/services/data/v32.0/sobjects/Account/describe')
     * , relative path from root ('/services/data/v32.0/sobjects/Account/describe')
     * , or relative path from version root ('/sobjects/Account/describe').
     */ requestGet(url, options) {
        const request = {
            method: 'GET',
            url
        };
        return this.request(request, options);
    }
    /**
     * Send HTTP POST request with JSON body, with connected session information
     *
     * Endpoint URL can be absolute URL ('https://na1.salesforce.com/services/data/v32.0/sobjects/Account/describe')
     * , relative path from root ('/services/data/v32.0/sobjects/Account/describe')
     * , or relative path from version root ('/sobjects/Account/describe').
     */ requestPost(url, body, options) {
        const request = {
            method: 'POST',
            url,
            body: JSON.stringify(body),
            headers: {
                'content-type': 'application/json'
            }
        };
        return this.request(request, options);
    }
    /**
     * Send HTTP PUT request with JSON body, with connected session information
     *
     * Endpoint URL can be absolute URL ('https://na1.salesforce.com/services/data/v32.0/sobjects/Account/describe')
     * , relative path from root ('/services/data/v32.0/sobjects/Account/describe')
     * , or relative path from version root ('/sobjects/Account/describe').
     */ requestPut(url, body, options) {
        const request = {
            method: 'PUT',
            url,
            body: JSON.stringify(body),
            headers: {
                'content-type': 'application/json'
            }
        };
        return this.request(request, options);
    }
    /**
     * Send HTTP PATCH request with JSON body
     *
     * Endpoint URL can be absolute URL ('https://na1.salesforce.com/services/data/v32.0/sobjects/Account/describe')
     * , relative path from root ('/services/data/v32.0/sobjects/Account/describe')
     * , or relative path from version root ('/sobjects/Account/describe').
     */ requestPatch(url, body, options) {
        const request = {
            method: 'PATCH',
            url,
            body: JSON.stringify(body),
            headers: {
                'content-type': 'application/json'
            }
        };
        return this.request(request, options);
    }
    /**
     * Send HTTP DELETE request
     *
     * Endpoint URL can be absolute URL ('https://na1.salesforce.com/services/data/v32.0/sobjects/Account/describe')
     * , relative path from root ('/services/data/v32.0/sobjects/Account/describe')
     * , or relative path from version root ('/sobjects/Account/describe').
     */ requestDelete(url, options) {
        const request = {
            method: 'DELETE',
            url
        };
        return this.request(request, options);
    }
    /** @private **/ _baseUrl() {
        return [
            this.instanceUrl,
            'services/data',
            `v${this.version}`
        ].join('/');
    }
    /**
     * Convert path to absolute url
     * @private
     */ _normalizeUrl(url) {
        if (url.startsWith('/')) {
            if (url.startsWith(this.instanceUrl + '/services/')) {
                return url;
            }
            if (url.startsWith('/services/')) {
                return this.instanceUrl + url;
            }
            return this._baseUrl() + url;
        }
        return url;
    }
    /**
     *
     */ query(soql, options) {
        return new query_1.default(this, soql, options);
    }
    /**
     * Execute search by SOSL
     *
     * @param {String} sosl - SOSL string
     * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function
     * @returns {Promise.<Array.<RecordResult>>}
     */ search(sosl) {
        const url = this._baseUrl() + '/search?q=' + encodeURIComponent(sosl);
        return this.request(url);
    }
    /**
     *
     */ queryMore(locator, options) {
        return new query_1.default(this, {
            locator
        }, options);
    }
    /* */ _ensureVersion(majorVersion) {
        const versions = this.version.split('.');
        return parseInt(versions[0], 10) >= majorVersion;
    }
    /* */ _supports(feature) {
        switch(feature){
            case 'sobject-collection':
                return this._ensureVersion(42);
            default:
                return false;
        }
    }
    async retrieve(type, ids, options = {}) {
        return Array.isArray(ids) ? this._ensureVersion(42) ? this._retrieveMany(type, ids, options) : this._retrieveParallel(type, ids, options) : this._retrieveSingle(type, ids, options);
    }
    /** @private */ async _retrieveSingle(type, id, options) {
        if (!id) {
            throw new Error('Invalid record ID. Specify valid record ID value');
        }
        let url = [
            this._baseUrl(),
            'sobjects',
            type,
            id
        ].join('/');
        const { fields, headers } = options;
        if (fields) {
            url += `?fields=${fields.join(',')}`;
        }
        return this.request({
            method: 'GET',
            url,
            headers
        });
    }
    /** @private */ async _retrieveParallel(type, ids, options) {
        if (ids.length > this._maxRequest) {
            throw new Error('Exceeded max limit of concurrent call');
        }
        return Promise.all(ids.map((id)=>this._retrieveSingle(type, id, options).catch((err)=>{
                if (options.allOrNone || err.errorCode !== 'NOT_FOUND') {
                    throw err;
                }
                return null;
            })));
    }
    /** @private */ async _retrieveMany(type, ids, options) {
        if (ids.length === 0) {
            return [];
        }
        const url = [
            this._baseUrl(),
            'composite',
            'sobjects',
            type
        ].join('/');
        const fields = options.fields || (await this.describe$(type)).fields.map((field)=>field.name);
        return this.request({
            method: 'POST',
            url,
            body: JSON.stringify({
                ids,
                fields
            }),
            headers: {
                ...options.headers || {},
                'content-type': 'application/json'
            }
        });
    }
    /**
     * @param type
     * @param records
     * @param options
     */ async create(type, records, options = {}) {
        const ret = Array.isArray(records) ? this._ensureVersion(42) ? await this._createMany(type, records, options) : await this._createParallel(type, records, options) : await this._createSingle(type, records, options);
        return ret;
    }
    /** @private */ async _createSingle(type, record, options) {
        const { Id, type: rtype, attributes, ...rec } = record;
        const sobjectType = type || attributes?.type || rtype;
        if (!sobjectType) {
            throw new Error('No SObject Type defined in record');
        }
        const url = [
            this._baseUrl(),
            'sobjects',
            sobjectType
        ].join('/');
        let contentType, body;
        if (options?.multipartFileFields) {
            // Send the record as a multipart/form-data request. Useful for fields containing large binary blobs.
            const form = new form_data_1.default();
            // Extract the fields requested to be sent separately from the JSON
            Object.entries(options.multipartFileFields).forEach(([fieldName, fileDetails])=>{
                form.append(fieldName, Buffer.from(rec[fieldName], 'base64'), fileDetails);
                delete rec[fieldName];
            });
            // Serialize the remaining fields as JSON
            form.append(type, JSON.stringify(rec), {
                contentType: 'application/json'
            });
            contentType = form.getHeaders()['content-type']; // This is necessary to ensure the 'boundary' is present
            body = form;
        } else {
            // Default behavior: send the request as JSON
            contentType = 'application/json';
            body = JSON.stringify(rec);
        }
        return this.request({
            method: 'POST',
            url,
            body: body,
            headers: {
                ...options.headers || {},
                'content-type': contentType
            }
        });
    }
    /** @private */ async _createParallel(type, records, options) {
        if (records.length > this._maxRequest) {
            throw new Error('Exceeded max limit of concurrent call');
        }
        return Promise.all(records.map((record)=>this._createSingle(type, record, options).catch((err)=>{
                // be aware that allOrNone in parallel mode will not revert the other successful requests
                // it only raises error when met at least one failed request.
                if (options.allOrNone || !err.errorCode) {
                    throw err;
                }
                return toSaveResult(err);
            })));
    }
    /** @private */ async _createMany(type, records, options) {
        if (records.length === 0) {
            return Promise.resolve([]);
        }
        if (records.length > MAX_DML_COUNT && options.allowRecursive) {
            return [
                ...await this._createMany(type, records.slice(0, MAX_DML_COUNT), options),
                ...await this._createMany(type, records.slice(MAX_DML_COUNT), options)
            ];
        }
        const _records = records.map((record)=>{
            const { Id, type: rtype, attributes, ...rec } = record;
            const sobjectType = type || attributes?.type || rtype;
            if (!sobjectType) {
                throw new Error('No SObject Type defined in record');
            }
            return {
                attributes: {
                    type: sobjectType
                },
                ...rec
            };
        });
        const url = [
            this._baseUrl(),
            'composite',
            'sobjects'
        ].join('/');
        return this.request({
            method: 'POST',
            url,
            body: JSON.stringify({
                allOrNone: options.allOrNone || false,
                records: _records
            }),
            headers: {
                ...options.headers || {},
                'content-type': 'application/json'
            }
        });
    }
    /**
     * Synonym of Connection#create()
     */ insert = this.create;
    /**
     * @param type
     * @param records
     * @param options
     */ update(type, records, options = {}) {
        return Array.isArray(records) ? this._ensureVersion(42) ? this._updateMany(type, records, options) : this._updateParallel(type, records, options) : this._updateSingle(type, records, options);
    }
    /** @private */ async _updateSingle(type, record, options) {
        const { Id: id, type: rtype, attributes, ...rec } = record;
        if (!id) {
            throw new Error('Record id is not found in record.');
        }
        const sobjectType = type || attributes?.type || rtype;
        if (!sobjectType) {
            throw new Error('No SObject Type defined in record');
        }
        const url = [
            this._baseUrl(),
            'sobjects',
            sobjectType,
            id
        ].join('/');
        return this.request({
            method: 'PATCH',
            url,
            body: JSON.stringify(rec),
            headers: {
                ...options.headers || {},
                'content-type': 'application/json'
            }
        }, {
            noContentResponse: {
                id,
                success: true,
                errors: []
            }
        });
    }
    /** @private */ async _updateParallel(type, records, options) {
        if (records.length > this._maxRequest) {
            throw new Error('Exceeded max limit of concurrent call');
        }
        return Promise.all(records.map((record)=>this._updateSingle(type, record, options).catch((err)=>{
                // be aware that allOrNone in parallel mode will not revert the other successful requests
                // it only raises error when met at least one failed request.
                if (options.allOrNone || !err.errorCode) {
                    throw err;
                }
                return toSaveResult(err);
            })));
    }
    /** @private */ async _updateMany(type, records, options) {
        if (records.length === 0) {
            return [];
        }
        if (records.length > MAX_DML_COUNT && options.allowRecursive) {
            return [
                ...await this._updateMany(type, records.slice(0, MAX_DML_COUNT), options),
                ...await this._updateMany(type, records.slice(MAX_DML_COUNT), options)
            ];
        }
        const _records = records.map((record)=>{
            const { Id: id, type: rtype, attributes, ...rec } = record;
            if (!id) {
                throw new Error('Record id is not found in record.');
            }
            const sobjectType = type || attributes?.type || rtype;
            if (!sobjectType) {
                throw new Error('No SObject Type defined in record');
            }
            return {
                id,
                attributes: {
                    type: sobjectType
                },
                ...rec
            };
        });
        const url = [
            this._baseUrl(),
            'composite',
            'sobjects'
        ].join('/');
        return this.request({
            method: 'PATCH',
            url,
            body: JSON.stringify({
                allOrNone: options.allOrNone || false,
                records: _records
            }),
            headers: {
                ...options.headers || {},
                'content-type': 'application/json'
            }
        });
    }
    /**
     *
     * @param type
     * @param records
     * @param extIdField
     * @param options
     */ async upsert(type, records, extIdField, options = {}) {
        return Array.isArray(records) ? this._ensureVersion(46) ? this._upsertMany(type, records, extIdField, options) : this._upsertParallel(type, records, extIdField, options) : this._upsertParallel(type, records, extIdField, options);
    }
    /** @private */ async _upsertMany(type, records, extIdField, options = {}) {
        if (records.length === 0) {
            return [];
        }
        if (records.length > MAX_DML_COUNT && options.allowRecursive) {
            return [
                ...await this._upsertMany(type, records.slice(0, MAX_DML_COUNT), extIdField, options),
                ...await this._upsertMany(type, records.slice(MAX_DML_COUNT), extIdField, options)
            ];
        }
        const _records = records.map((recordItem)=>{
            const { [extIdField]: extId, type: recordType, attributes, ...rec } = recordItem;
            const sobjectType = recordType || attributes?.type || type;
            if (!extId) {
                throw new Error('External ID is not found in record.');
            }
            if (!sobjectType) {
                throw new Error('No SObject Type defined in record');
            }
            return {
                [extIdField]: extId,
                attributes: {
                    type: sobjectType
                },
                ...rec
            };
        });
        const url = [
            this._baseUrl(),
            'composite',
            'sobjects',
            type,
            extIdField
        ].join('/');
        return this.request({
            method: 'PATCH',
            url,
            body: JSON.stringify({
                allOrNone: options.allOrNone || false,
                records: _records
            }),
            headers: {
                ...options.headers || {},
                'content-type': 'application/json'
            }
        });
    }
    /** @private */ async _upsertParallel(type, records, extIdField, options = {}) {
        const isArray = Array.isArray(records);
        const _records = Array.isArray(records) ? records : [
            records
        ];
        if (_records.length > this._maxRequest) {
            throw new Error('Exceeded max limit of concurrent call');
        }
        const results = await Promise.all(_records.map((record)=>{
            const { [extIdField]: extId, type: rtype, attributes, ...rec } = record;
            const url = [
                this._baseUrl(),
                'sobjects',
                type,
                extIdField,
                extId
            ].join('/');
            return this.request({
                method: 'PATCH',
                url,
                body: JSON.stringify(rec),
                headers: {
                    ...options.headers || {},
                    'content-type': 'application/json'
                }
            }, {
                noContentResponse: {
                    success: true,
                    errors: []
                }
            }).catch((err)=>{
                // Be aware that `allOrNone` option in upsert method
                // will not revert the other successful requests.
                // It only raises error when met at least one failed request.
                if (!isArray || options.allOrNone || !err.errorCode) {
                    throw err;
                }
                return toSaveResult(err);
            });
        }));
        return isArray ? results : results[0];
    }
    /**
     * @param type
     * @param ids
     * @param options
     */ async destroy(type, ids, options = {}) {
        return Array.isArray(ids) ? this._ensureVersion(42) ? this._destroyMany(type, ids, options) : this._destroyParallel(type, ids, options) : this._destroySingle(type, ids, options);
    }
    /** @private */ async _destroySingle(type, id, options) {
        const url = [
            this._baseUrl(),
            'sobjects',
            type,
            id
        ].join('/');
        return this.request({
            method: 'DELETE',
            url,
            headers: options.headers || {}
        }, {
            noContentResponse: {
                id,
                success: true,
                errors: []
            }
        });
    }
    /** @private */ async _destroyParallel(type, ids, options) {
        if (ids.length > this._maxRequest) {
            throw new Error('Exceeded max limit of concurrent call');
        }
        return Promise.all(ids.map((id)=>this._destroySingle(type, id, options).catch((err)=>{
                // Be aware that `allOrNone` option in parallel mode
                // will not revert the other successful requests.
                // It only raises error when met at least one failed request.
                if (options.allOrNone || !err.errorCode) {
                    throw err;
                }
                return toSaveResult(err);
            })));
    }
    /** @private */ async _destroyMany(type, ids, options) {
        if (ids.length === 0) {
            return [];
        }
        if (ids.length > MAX_DML_COUNT && options.allowRecursive) {
            return [
                ...await this._destroyMany(type, ids.slice(0, MAX_DML_COUNT), options),
                ...await this._destroyMany(type, ids.slice(MAX_DML_COUNT), options)
            ];
        }
        let url = [
            this._baseUrl(),
            'composite',
            'sobjects?ids='
        ].join('/') + ids.join(',');
        if (options.allOrNone) {
            url += '&allOrNone=true';
        }
        return this.request({
            method: 'DELETE',
            url,
            headers: options.headers || {}
        });
    }
    /**
     * Synonym of Connection#destroy()
     */ delete = this.destroy;
    /**
     * Synonym of Connection#destroy()
     */ del = this.destroy;
    /**
     * Describe SObject metadata
     */ async describe(type) {
        const url = [
            this._baseUrl(),
            'sobjects',
            type,
            'describe'
        ].join('/');
        const body = await this.request(url);
        return body;
    }
    /**
     * Describe global SObjects
     */ async describeGlobal() {
        const url = `${this._baseUrl()}/sobjects`;
        const body = await this.request(url);
        return body;
    }
    sobject(type) {
        const so = this.sobjects[type] || new sobject_1.default(this, type);
        this.sobjects[type] = so;
        return so;
    }
    /**
     * Get identity information of current user
     */ async identity(options = {}) {
        let url = this.userInfo?.url;
        if (!url) {
            const res = await this.request({
                method: 'GET',
                url: this._baseUrl(),
                headers: options.headers
            });
            url = res.identity;
        }
        url += '?format=json';
        if (this.accessToken) {
            url += `&oauth_token=${encodeURIComponent(this.accessToken)}`;
        }
        const res = await this.request({
            method: 'GET',
            url
        });
        this.userInfo = {
            id: res.user_id,
            organizationId: res.organization_id,
            url: res.id
        };
        return res;
    }
    /**
     * List recently viewed records
     */ async recent(type, limit) {
        /* eslint-disable no-param-reassign */ if (typeof type === 'number') {
            limit = type;
            type = undefined;
        }
        let url;
        if (type) {
            url = [
                this._baseUrl(),
                'sobjects',
                type
            ].join('/');
            const { recentItems } = await this.request(url);
            return limit ? recentItems.slice(0, limit) : recentItems;
        }
        url = `${this._baseUrl()}/recent`;
        if (limit) {
            url += `?limit=${limit}`;
        }
        return this.request(url);
    }
    /**
     * Retrieve updated records
     */ async updated(type, start, end) {
        /* eslint-disable no-param-reassign */ let url = [
            this._baseUrl(),
            'sobjects',
            type,
            'updated'
        ].join('/');
        if (typeof start === 'string') {
            start = new Date(start);
        }
        start = (0, formatter_1.formatDate)(start);
        url += `?start=${encodeURIComponent(start)}`;
        if (typeof end === 'string') {
            end = new Date(end);
        }
        end = (0, formatter_1.formatDate)(end);
        url += `&end=${encodeURIComponent(end)}`;
        const body = await this.request(url);
        return body;
    }
    /**
     * Retrieve deleted records
     */ async deleted(type, start, end) {
        /* eslint-disable no-param-reassign */ let url = [
            this._baseUrl(),
            'sobjects',
            type,
            'deleted'
        ].join('/');
        if (typeof start === 'string') {
            start = new Date(start);
        }
        start = (0, formatter_1.formatDate)(start);
        url += `?start=${encodeURIComponent(start)}`;
        if (typeof end === 'string') {
            end = new Date(end);
        }
        end = (0, formatter_1.formatDate)(end);
        url += `&end=${encodeURIComponent(end)}`;
        const body = await this.request(url);
        return body;
    }
    /**
     * Returns a list of all tabs
     */ async tabs() {
        const url = [
            this._baseUrl(),
            'tabs'
        ].join('/');
        const body = await this.request(url);
        return body;
    }
    /**
     * Returns current system limit in the organization
     */ async limits() {
        const url = [
            this._baseUrl(),
            'limits'
        ].join('/');
        const body = await this.request(url);
        return body;
    }
    /**
     * Returns a theme info
     */ async theme() {
        const url = [
            this._baseUrl(),
            'theme'
        ].join('/');
        const body = await this.request(url);
        return body;
    }
    /**
     * Returns all registered global quick actions
     */ async quickActions() {
        const body = await this.request('/quickActions');
        return body;
    }
    /**
     * Get reference for specified global quick action
     */ quickAction(actionName) {
        return new quick_action_1.default(this, `/quickActions/${actionName}`);
    }
    /**
     * Module which manages process rules and approval processes
     */ process = new process_1.default(this);
    isLightningInstance() {
        return this.instanceUrl.includes('.lightning.force.com') || this.instanceUrl.includes('.lightning.crmforce.mil') || this.instanceUrl.includes('.lightning.sfcrmapps.cn');
    }
}
exports.Connection = Connection;
exports.default = Connection;
}),
"[project]/node_modules/jsforce/lib/registry/base.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BaseRegistry = void 0;
const connection_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/connection.js [app-route] (ecmascript)"));
/**
 *
 */ class BaseRegistry {
    _registryConfig = {};
    _saveConfig() {
        throw new Error('_saveConfig must be implemented in subclass');
    }
    _getClients() {
        return this._registryConfig.clients || (this._registryConfig.clients = {});
    }
    _getConnections() {
        return this._registryConfig.connections || (this._registryConfig.connections = {});
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async getConnectionNames() {
        return Object.keys(this._getConnections());
    }
    async getConnection(name) {
        const config = await this.getConnectionConfig(name);
        return config ? new connection_1.default(config) : null;
    }
    async getConnectionConfig(name) {
        if (!name) {
            name = this._registryConfig['default'];
        }
        const connections = this._getConnections();
        const connConfig = name ? connections[name] : undefined;
        if (!connConfig) {
            return null;
        }
        const { client, ...connConfig_ } = connConfig;
        if (client) {
            return {
                ...connConfig_,
                oauth2: {
                    ...await this.getClientConfig(client)
                }
            };
        }
        return connConfig_;
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async saveConnectionConfig(name, connConfig) {
        const connections = this._getConnections();
        const { oauth2, ...connConfig_ } = connConfig;
        let persistConnConfig = connConfig_;
        if (oauth2) {
            const clientName = this._findClientName(oauth2);
            if (clientName) {
                persistConnConfig = {
                    ...persistConnConfig,
                    client: clientName
                };
            }
            delete connConfig.oauth2;
        }
        connections[name] = persistConnConfig;
        this._saveConfig();
    }
    _findClientName({ clientId, loginUrl }) {
        const clients = this._getClients();
        for (const name of Object.keys(clients)){
            const client = clients[name];
            if (client.clientId === clientId && (client.loginUrl || 'https://login.salesforce.com') === loginUrl) {
                return name;
            }
        }
        return null;
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async setDefaultConnection(name) {
        this._registryConfig['default'] = name;
        this._saveConfig();
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async removeConnectionConfig(name) {
        const connections = this._getConnections();
        delete connections[name];
        this._saveConfig();
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async getClientConfig(name) {
        const clients = this._getClients();
        const clientConfig = clients[name];
        return clientConfig && {
            ...clientConfig
        };
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async getClientNames() {
        return Object.keys(this._getClients());
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async registerClientConfig(name, clientConfig) {
        const clients = this._getClients();
        clients[name] = clientConfig;
        this._saveConfig();
    }
}
exports.BaseRegistry = BaseRegistry;
}),
"[project]/node_modules/jsforce/lib/registry/file.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FileRegistry = void 0;
const fs_1 = __importDefault(__turbopack_context__.r("[externals]/fs [external] (fs, cjs)"));
const path_1 = __importDefault(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const base_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/registry/base.js [app-route] (ecmascript)");
/**
 *
 */ function getDefaultConfigFilePath() {
    const homeDir = process.env[("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : 'HOME'];
    if (!homeDir) {
        throw new Error('cannot find user home directory to store configuration files');
    }
    return path_1.default.join(homeDir, '.jsforce', 'config.json');
}
/**
 *
 */ class FileRegistry extends base_1.BaseRegistry {
    _configFilePath;
    constructor({ configFilePath }){
        super();
        this._configFilePath = configFilePath || getDefaultConfigFilePath();
        try {
            const data = fs_1.default.readFileSync(this._configFilePath, 'utf-8');
            this._registryConfig = JSON.parse(data);
        } catch (e) {
        //
        }
    }
    _saveConfig() {
        const data = JSON.stringify(this._registryConfig, null, 4);
        try {
            fs_1.default.writeFileSync(this._configFilePath, data);
            fs_1.default.chmodSync(this._configFilePath, '600');
        } catch (e) {
            const configDir = path_1.default.dirname(this._configFilePath);
            fs_1.default.mkdirSync(configDir);
            fs_1.default.chmodSync(configDir, '700');
            fs_1.default.writeFileSync(this._configFilePath, data);
            fs_1.default.chmodSync(this._configFilePath, '600');
        }
    }
}
exports.FileRegistry = FileRegistry;
}),
"[project]/node_modules/jsforce/lib/registry/sfdx.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SfdxRegistry = void 0;
const child_process_1 = __turbopack_context__.r("[externals]/child_process [external] (child_process, cjs)");
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const connection_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/connection.js [app-route] (ecmascript)"));
function isNotNullOrUndefined(v) {
    return v != null;
}
/**
 *
 */ class SfdxRegistry {
    _cliPath;
    _orgList;
    _orgInfoMap = {};
    _defaultOrgInfo;
    constructor({ cliPath }){
        this._cliPath = cliPath;
    }
    _createCommand(command, options = {}, args = []) {
        return `${this._cliPath ? this._cliPath + '/' : ''}sfdx ${command} ${Object.keys(options).map((option)=>`${option.length > 1 ? '--' : '-'}${option}${options[option] != null ? ' ' + options[option] : ''}`).join(' ')} --json ${args.join(' ')}`;
    }
    async _execCommand(command, options = {}, args = []) {
        const cmd = this._createCommand(command, options, args);
        const buf = await new Promise((resolve, reject)=>{
            (0, child_process_1.exec)(cmd, (err, ret)=>{
                if (err && !ret) {
                    reject(err);
                } else {
                    resolve(ret);
                }
            });
        });
        const body = (0, util_1.stripVTControlCharacters)(buf.toString());
        let ret;
        try {
            ret = JSON.parse(body);
        } catch (e) {
            throw new Error(`Unexpectedd output from Sfdx cli: ${body}`);
        }
        if (ret.status === 0 && ret.result) {
            return ret.result;
        } else {
            const err = new Error(ret.message);
            err.name = ret.name;
            throw err;
        }
    }
    async _getOrgList() {
        if (!this._orgList) {
            this._orgList = this._execCommand('force:org:list');
        }
        return this._orgList;
    }
    async getConnectionNames() {
        const { nonScratchOrgs, scratchOrgs } = await this._getOrgList();
        return [
            ...nonScratchOrgs.map((o)=>o.alias).filter(isNotNullOrUndefined),
            ...scratchOrgs.map((o)=>o.alias).filter(isNotNullOrUndefined),
            ...nonScratchOrgs.map((o)=>o.username),
            ...scratchOrgs.map((o)=>o.username)
        ];
    }
    async getConnection(name) {
        const config = await this.getConnectionConfig(name);
        return config ? new connection_1.default(config) : null;
    }
    async _getOrgInfo(username) {
        const options = username ? {
            u: username
        } : {};
        if (!username || !this._orgInfoMap[username]) {
            const pOrgInfo = this._execCommand('force:org:display', options);
            this._memoOrgInfo(pOrgInfo, username);
        }
        const orgInfo = username ? this._orgInfoMap[username] : this._defaultOrgInfo;
        if (!orgInfo) {
            throw new Error('no orginfo found');
        }
        return orgInfo;
    }
    _memoOrgInfo(pOrgInfo, username) {
        const pOrgInfo_ = pOrgInfo.then((orgInfo)=>{
            this._orgInfoMap[orgInfo.username] = pOrgInfo_;
            if (orgInfo.alias) {
                this._orgInfoMap[orgInfo.alias] = pOrgInfo_;
            }
            return orgInfo;
        });
        if (username) {
            this._orgInfoMap[username] = pOrgInfo_;
        } else {
            this._defaultOrgInfo = pOrgInfo_;
        }
    }
    async getConnectionConfig(name) {
        const orgInfo = await this._getOrgInfo(name);
        if (!orgInfo) {
            return null;
        }
        const { accessToken, instanceUrl, loginUrl } = orgInfo;
        return {
            accessToken,
            instanceUrl,
            loginUrl
        };
    }
    async saveConnectionConfig(_name, _connConfig) {
    // nothing to do
    }
    async setDefaultConnection(_name) {
    // nothing to do
    }
    async removeConnectionConfig(name) {
        await this._execCommand('force:org:delete', {
            u: name
        });
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async getClientConfig(_name) {
        return null;
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async getClientNames() {
        return [];
    }
    async registerClientConfig(_name, _clientConfig) {
    // nothing to do
    }
}
exports.SfdxRegistry = SfdxRegistry;
}),
"[project]/node_modules/jsforce/lib/registry/empty.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EmptyRegistry = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/registry/base.js [app-route] (ecmascript)");
/**
 *
 */ class EmptyRegistry extends base_1.BaseRegistry {
    _saveConfig() {
    // ignore all call requests
    }
}
exports.EmptyRegistry = EmptyRegistry;
}),
"[project]/node_modules/jsforce/lib/registry/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EmptyRegistry = exports.SfdxRegistry = exports.FileRegistry = void 0;
const file_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/registry/file.js [app-route] (ecmascript)");
Object.defineProperty(exports, "FileRegistry", {
    enumerable: true,
    get: function() {
        return file_1.FileRegistry;
    }
});
const sfdx_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/registry/sfdx.js [app-route] (ecmascript)");
Object.defineProperty(exports, "SfdxRegistry", {
    enumerable: true,
    get: function() {
        return sfdx_1.SfdxRegistry;
    }
});
const empty_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/registry/empty.js [app-route] (ecmascript)");
Object.defineProperty(exports, "EmptyRegistry", {
    enumerable: true,
    get: function() {
        return empty_1.EmptyRegistry;
    }
});
const logger_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/util/logger.js [app-route] (ecmascript)");
let registry;
try {
    registry = process.env.JSFORCE_CONNECTION_REGISTRY === 'sfdx' ? new sfdx_1.SfdxRegistry({}) : new file_1.FileRegistry({});
} catch (e) {
    (0, logger_1.getLogger)('registry').error(e);
    registry = new empty_1.EmptyRegistry();
}
exports.default = registry;
}),
"[project]/node_modules/jsforce/lib/browser/client.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BrowserClient = void 0;
/**
 * @file Browser client connection management class
 * @author Shinichi Tomita <shinichi.tomita@gmail.com>
 */ const events_1 = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
const connection_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/connection.js [app-route] (ecmascript)"));
const oauth2_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/oauth2.js [app-route] (ecmascript)"));
/**
 * @private
 */ function popupWin(url, w, h) {
    const left = screen.width / 2 - w / 2;
    const top = screen.height / 2 - h / 2;
    return window.open(url, undefined, `location=yes,toolbar=no,status=no,menubar=no,width=${w},height=${h},top=${top},left=${left}`);
}
/**
 * @private
 */ function handleCallbackResponse() {
    const res = checkCallbackResponse();
    const state = localStorage.getItem('jsforce_state');
    if (res && state && res.body.get('state') === state) {
        localStorage.removeItem('jsforce_state');
        const [prefix, promptType] = state.split('.');
        const cli = new BrowserClient(prefix);
        if (res.success) {
            cli._storeTokens(Object.fromEntries(res.body));
            location.hash = '';
        } else {
            cli._storeError(res.body);
        }
        if (promptType === 'popup') {
            window.close();
        }
        return true;
    }
}
/**
 * @private
 */ function checkCallbackResponse() {
    let params;
    if (window.location.hash) {
        params = new URLSearchParams(window.location.hash.substring(1));
        if (params.get('access_token')) {
            return {
                success: true,
                body: params
            };
        }
    } else if (window.location.search) {
        params = new URLSearchParams(window.location.search.substring(1));
        if (params.get('error')) {
            return {
                success: false,
                body: params
            };
        }
    }
}
/**
 *
 */ const DEFAULT_POPUP_WIN_WIDTH = 912;
const DEFAULT_POPUP_WIN_HEIGHT = 513;
/** @private **/ let clientIdx = 0;
/**
 *
 */ class BrowserClient extends events_1.EventEmitter {
    _prefix;
    _config;
    _connection;
    /**
     *
     */ constructor(prefix){
        super();
        this._prefix = prefix || 'jsforce' + clientIdx++;
    }
    get connection() {
        if (!this._connection) {
            this._connection = new connection_1.default(this._config);
        }
        return this._connection;
    }
    /**
     *
     */ init(config) {
        if (handleCallbackResponse()) {
            return;
        }
        this._config = config;
        const tokens = this._getTokens();
        if (tokens) {
            this.connection._establish(tokens);
            setTimeout(()=>{
                this.emit('connect', this.connection);
            }, 10);
        }
    }
    /**
     *
     */ login(options = {}) {
        const { scope, size } = options;
        const oauth2 = new oauth2_1.default(this._config ?? {});
        const rand = Math.random().toString(36).substring(2);
        const state = [
            this._prefix,
            'popup',
            rand
        ].join('.');
        localStorage.setItem('jsforce_state', state);
        const authzUrl = oauth2.getAuthorizationUrl({
            response_type: 'token',
            state,
            ...scope ? {
                scope
            } : {}
        });
        const pw = popupWin(authzUrl, size?.width ?? DEFAULT_POPUP_WIN_WIDTH, size?.height ?? DEFAULT_POPUP_WIN_HEIGHT);
        return new Promise((resolve, reject)=>{
            if (!pw) {
                const state = [
                    this._prefix,
                    'redirect',
                    rand
                ].join('.');
                localStorage.setItem('jsforce_state', state);
                const authzUrl = oauth2.getAuthorizationUrl({
                    response_type: 'token',
                    state,
                    ...scope ? {
                        scope
                    } : {}
                });
                location.href = authzUrl;
                return;
            }
            this._removeTokens();
            const pid = setInterval(()=>{
                try {
                    if (!pw || pw.closed) {
                        clearInterval(pid);
                        const tokens = this._getTokens();
                        if (tokens) {
                            this.connection._establish(tokens);
                            this.emit('connect', this.connection);
                            resolve({
                                status: 'connect'
                            });
                        } else {
                            const err = this._getError();
                            if (err) {
                                reject(new Error(err.error + ': ' + err.error_description));
                            } else {
                                resolve({
                                    status: 'cancel'
                                });
                            }
                        }
                    }
                } catch (e) {
                //
                }
            }, 1000);
        });
    }
    /**
     *
     */ isLoggedIn() {
        return !!this.connection.accessToken;
    }
    /**
     *
     */ logout() {
        this.connection.logout();
        this._removeTokens();
        this.emit('disconnect');
    }
    /**
     * @private
     */ _getTokens() {
        const regexp = new RegExp('(^|;\\s*)' + this._prefix + '_loggedin=true(;|$)');
        if (document.cookie.match(regexp)) {
            const issuedAt = Number(localStorage.getItem(this._prefix + '_issued_at'));
            // 2 hours
            if (Date.now() < issuedAt + 2 * 60 * 60 * 1000) {
                let userInfo;
                const idUrl = localStorage.getItem(this._prefix + '_id');
                if (idUrl) {
                    const [id, organizationId] = idUrl.split('/').reverse();
                    userInfo = {
                        id,
                        organizationId,
                        url: idUrl
                    };
                }
                return {
                    accessToken: localStorage.getItem(this._prefix + '_access_token'),
                    instanceUrl: localStorage.getItem(this._prefix + '_instance_url'),
                    userInfo
                };
            }
        }
        return null;
    }
    /**
     * @private
     */ _storeTokens(params) {
        localStorage.setItem(this._prefix + '_access_token', params.access_token);
        localStorage.setItem(this._prefix + '_instance_url', params.instance_url);
        localStorage.setItem(this._prefix + '_issued_at', params.issued_at);
        localStorage.setItem(this._prefix + '_id', params.id);
        document.cookie = this._prefix + '_loggedin=true;';
    }
    /**
     * @private
     */ _removeTokens() {
        localStorage.removeItem(this._prefix + '_access_token');
        localStorage.removeItem(this._prefix + '_instance_url');
        localStorage.removeItem(this._prefix + '_issued_at');
        localStorage.removeItem(this._prefix + '_id');
        document.cookie = this._prefix + '_loggedin=';
    }
    /**
     * @private
     */ _getError() {
        try {
            const err = JSON.parse(localStorage.getItem(this._prefix + '_error') ?? '');
            localStorage.removeItem(this._prefix + '_error');
            return err;
        } catch (e) {
        //
        }
    }
    /**
     * @private
     */ _storeError(err) {
        localStorage.setItem(this._prefix + '_error', JSON.stringify(err));
    }
}
exports.BrowserClient = BrowserClient;
/**
 *
 */ const client = new BrowserClient();
exports.default = client;
}),
"[project]/node_modules/jsforce/lib/jsforce.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.registerModule = void 0;
const events_1 = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
const VERSION_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/VERSION.js [app-route] (ecmascript)"));
const connection_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/connection.js [app-route] (ecmascript)"));
const oauth2_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/oauth2.js [app-route] (ecmascript)"));
const date_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/date.js [app-route] (ecmascript)"));
const registry_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/registry/index.js [app-route] (ecmascript)"));
const client_1 = __importStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/browser/client.js [app-route] (ecmascript)"));
/**
 *
 */ class JSforce extends events_1.EventEmitter {
    VERSION = VERSION_1.default;
    Connection = connection_1.default;
    OAuth2 = oauth2_1.default;
    SfDate = date_1.default;
    Date = date_1.default;
    BrowserClient = client_1.BrowserClient;
    registry = registry_1.default;
    browser = client_1.default;
}
function registerModule(name, factory) {
    jsforce.on('connection:new', (conn)=>{
        let obj = undefined;
        Object.defineProperty(conn, name, {
            get () {
                obj = obj ?? factory(conn);
                return obj;
            },
            enumerable: true,
            configurable: true
        });
    });
}
exports.registerModule = registerModule;
const jsforce = new JSforce();
exports.default = jsforce;
}),
"[project]/node_modules/jsforce/lib/api/analytics.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Analytics = exports.Dashboard = exports.Report = exports.ReportInstance = void 0;
/**
 * @file Manages Salesforce Analytics API
 * @author Shinichi Tomita <shinichi.tomita@gmail.com>
 */ const jsforce_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/jsforce.js [app-route] (ecmascript)");
/*----------------------------------------------------------------------------------*/ /**
 * Report object class in Analytics API
 */ class ReportInstance {
    _report;
    _conn;
    id;
    /**
     *
     */ constructor(report, id){
        this._report = report;
        this._conn = report._conn;
        this.id = id;
    }
    /**
     * Retrieve report result asynchronously executed
     */ retrieve() {
        const url = [
            this._conn._baseUrl(),
            'analytics',
            'reports',
            this._report.id,
            'instances',
            this.id
        ].join('/');
        return this._conn.request(url);
    }
}
exports.ReportInstance = ReportInstance;
/*----------------------------------------------------------------------------------*/ /**
 * Report object class in Analytics API
 */ class Report {
    _conn;
    id;
    /**
     *
     */ constructor(conn, id){
        this._conn = conn;
        this.id = id;
    }
    /**
     * Describe report metadata
     */ describe() {
        const url = [
            this._conn._baseUrl(),
            'analytics',
            'reports',
            this.id,
            'describe'
        ].join('/');
        return this._conn.request(url);
    }
    /**
     * Destroy a report
     */ destroy() {
        const url = [
            this._conn._baseUrl(),
            'analytics',
            'reports',
            this.id
        ].join('/');
        return this._conn.request({
            method: 'DELETE',
            url
        });
    }
    /**
     * Synonym of Analytics~Report#destroy()
     */ delete = this.destroy;
    /**
     * Synonym of Analytics~Report#destroy()
     */ del = this.destroy;
    /**
     * Clones a given report
     */ clone(name) {
        const url = [
            this._conn._baseUrl(),
            'analytics',
            'reports'
        ].join('/') + '?cloneId=' + this.id;
        const config = {
            reportMetadata: {
                name
            }
        };
        return this._conn.request({
            method: 'POST',
            url,
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(config)
        });
    }
    /**
     * Explain plan for executing report
     */ explain() {
        const url = '/query/?explain=' + this.id;
        return this._conn.request(url);
    }
    /**
     * Run report synchronously
     */ execute(options = {}) {
        const url = [
            this._conn._baseUrl(),
            'analytics',
            'reports',
            this.id
        ].join('/') + '?includeDetails=' + (options.details ? 'true' : 'false');
        return this._conn.request({
            url,
            ...options.metadata ? {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(options.metadata)
            } : {
                method: 'GET'
            }
        });
    }
    /**
     * Synonym of Analytics~Report#execute()
     */ run = this.execute;
    /**
     * Synonym of Analytics~Report#execute()
     */ exec = this.execute;
    /**
     * Run report asynchronously
     */ executeAsync(options = {}) {
        const url = [
            this._conn._baseUrl(),
            'analytics',
            'reports',
            this.id,
            'instances'
        ].join('/') + (options.details ? '?includeDetails=true' : '');
        return this._conn.request({
            method: 'POST',
            url,
            ...options.metadata ? {
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(options.metadata)
            } : {
                body: ''
            }
        });
    }
    /**
     * Get report instance for specified instance ID
     */ instance(id) {
        return new ReportInstance(this, id);
    }
    /**
     * List report instances which had been executed asynchronously
     */ instances() {
        const url = [
            this._conn._baseUrl(),
            'analytics',
            'reports',
            this.id,
            'instances'
        ].join('/');
        return this._conn.request(url);
    }
}
exports.Report = Report;
/*----------------------------------------------------------------------------------*/ /**
 * Dashboard object class in the Analytics API
 */ class Dashboard {
    _conn;
    id;
    /**
     *
     */ constructor(conn, id){
        this._conn = conn;
        this.id = id;
    }
    /**
     * Describe dashboard metadata
     *
     * @method Analytics~Dashboard#describe
     * @param {Callback.<Analytics-DashboardMetadata>} [callback] - Callback function
     * @returns {Promise.<Analytics-DashboardMetadata>}
     */ describe() {
        const url = [
            this._conn._baseUrl(),
            'analytics',
            'dashboards',
            this.id,
            'describe'
        ].join('/');
        return this._conn.request(url);
    }
    /**
     * Get details about dashboard components
     */ components(componentIds) {
        const url = [
            this._conn._baseUrl(),
            'analytics',
            'dashboards',
            this.id
        ].join('/');
        const config = {
            componentIds: Array.isArray(componentIds) ? componentIds : typeof componentIds === 'string' ? [
                componentIds
            ] : undefined
        };
        return this._conn.request({
            method: 'POST',
            url,
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(config)
        });
    }
    /**
     * Get dashboard status
     */ status() {
        const url = [
            this._conn._baseUrl(),
            'analytics',
            'dashboards',
            this.id,
            'status'
        ].join('/');
        return this._conn.request(url);
    }
    /**
     * Refresh a dashboard
     */ refresh() {
        const url = [
            this._conn._baseUrl(),
            'analytics',
            'dashboards',
            this.id
        ].join('/');
        return this._conn.request({
            method: 'PUT',
            url,
            body: ''
        });
    }
    /**
     * Clone a dashboard
     */ clone(config, folderId) {
        const url = [
            this._conn._baseUrl(),
            'analytics',
            'dashboards'
        ].join('/') + '?cloneId=' + this.id;
        if (typeof config === 'string') {
            config = {
                name: config,
                folderId
            };
        }
        return this._conn.request({
            method: 'POST',
            url,
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(config)
        });
    }
    /**
     * Destroy a dashboard
     */ destroy() {
        const url = [
            this._conn._baseUrl(),
            'analytics',
            'dashboards',
            this.id
        ].join('/');
        return this._conn.request({
            method: 'DELETE',
            url
        });
    }
    /**
     * Synonym of Analytics~Dashboard#destroy()
     */ delete = this.destroy;
    /**
     * Synonym of Analytics~Dashboard#destroy()
     */ del = this.destroy;
}
exports.Dashboard = Dashboard;
/*----------------------------------------------------------------------------------*/ /**
 * API class for Analytics API
 */ class Analytics {
    _conn;
    /**
     *
     */ constructor(conn){
        this._conn = conn;
    }
    /**
     * Get report object of Analytics API
     */ report(id) {
        return new Report(this._conn, id);
    }
    /**
     * Get recent report list
     */ reports() {
        const url = [
            this._conn._baseUrl(),
            'analytics',
            'reports'
        ].join('/');
        return this._conn.request(url);
    }
    /**
     * Get dashboard object of Analytics API
     */ dashboard(id) {
        return new Dashboard(this._conn, id);
    }
    /**
     * Get recent dashboard list
     */ dashboards() {
        const url = [
            this._conn._baseUrl(),
            'analytics',
            'dashboards'
        ].join('/');
        return this._conn.request(url);
    }
}
exports.Analytics = Analytics;
/*--------------------------------------------*/ /*
 * Register hook in connection instantiation for dynamically adding this API module features
 */ (0, jsforce_1.registerModule)('analytics', (conn)=>new Analytics(conn));
exports.default = Analytics;
}),
"[project]/node_modules/jsforce/lib/api/apex.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Apex = void 0;
/**
 * @file Manages Salesforce Apex REST endpoint calls
 * @author Shinichi Tomita <shinichi.tomita@gmail.com>
 */ const jsforce_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/jsforce.js [app-route] (ecmascript)");
/**
 * API class for Apex REST endpoint call
 */ class Apex {
    _conn;
    /**
     *
     */ constructor(conn){
        this._conn = conn;
    }
    /* @private */ _baseUrl() {
        return `${this._conn.instanceUrl}/services/apexrest`;
    }
    /**
     * @private
     */ _createRequestParams(method, path, body, options = {}) {
        const headers = typeof options.headers === 'object' ? options.headers : {};
        if (!/^(GET|DELETE)$/i.test(method)) {
            headers['content-type'] = 'application/json';
        }
        const params = {
            method,
            url: this._baseUrl() + path,
            headers
        };
        if (body) {
            params.body = JSON.stringify(body);
        }
        return params;
    }
    /**
     * Call Apex REST service in GET request
     */ get(path, options) {
        return this._conn.request(this._createRequestParams('GET', path, undefined, options));
    }
    /**
     * Call Apex REST service in POST request
     */ post(path, body, options) {
        const params = this._createRequestParams('POST', path, body, options);
        return this._conn.request(params);
    }
    /**
     * Call Apex REST service in PUT request
     */ put(path, body, options) {
        const params = this._createRequestParams('PUT', path, body, options);
        return this._conn.request(params);
    }
    /**
     * Call Apex REST service in PATCH request
     */ patch(path, body, options) {
        const params = this._createRequestParams('PATCH', path, body, options);
        return this._conn.request(params);
    }
    /**
     * Call Apex REST service in DELETE request
     */ delete(path, options) {
        return this._conn.request(this._createRequestParams('DELETE', path, undefined, options));
    }
    /**
     * Synonym of Apex#delete()
     */ del = this.delete;
}
exports.Apex = Apex;
/*--------------------------------------------*/ /*
 * Register hook in connection instantiation for dynamically adding this API module features
 */ (0, jsforce_1.registerModule)('apex', (conn)=>new Apex(conn));
exports.default = Apex;
}),
"[project]/node_modules/jsforce/lib/api/bulk.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Bulk = exports.Batch = exports.Job = void 0;
/**
 * @file Manages Salesforce Bulk API related operations
 * @author Shinichi Tomita <shinichi.tomita@gmail.com>
 */ const events_1 = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
const stream_1 = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const multistream_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/multistream/index.js [app-route] (ecmascript)"));
const record_stream_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/record-stream.js [app-route] (ecmascript)");
const http_api_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/http-api.js [app-route] (ecmascript)"));
const jsforce_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/jsforce.js [app-route] (ecmascript)");
const stream_2 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/util/stream.js [app-route] (ecmascript)");
const is_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@sindresorhus/is/dist/index.js [app-route] (ecmascript)"));
/**
 * Class for Bulk API Job
 */ class Job extends events_1.EventEmitter {
    type;
    operation;
    options;
    id;
    state;
    _bulk;
    _batches;
    _jobInfo;
    _error;
    /**
     *
     */ constructor(bulk, type, operation, options, jobId){
        super();
        this._bulk = bulk;
        this.type = type;
        this.operation = operation;
        this.options = options || {};
        this.id = jobId ?? null;
        this.state = this.id ? 'Open' : 'Unknown';
        this._batches = {};
        // default error handler to keep the latest error
        this.on('error', (error)=>this._error = error);
    }
    /**
     * Return latest jobInfo from cache
     */ info() {
        // if cache is not available, check the latest
        if (!this._jobInfo) {
            this._jobInfo = this.check();
        }
        return this._jobInfo;
    }
    /**
     * Open new job and get jobinfo
     */ open() {
        const bulk = this._bulk;
        const options = this.options;
        // if sobject type / operation is not provided
        if (!this.type || !this.operation) {
            throw new Error('type / operation is required to open a new job');
        }
        // if not requested opening job
        if (!this._jobInfo) {
            let operation = this.operation.toLowerCase();
            if (operation === 'harddelete') {
                operation = 'hardDelete';
            }
            if (operation === 'queryall') {
                operation = 'queryAll';
            }
            const body = `
<?xml version="1.0" encoding="UTF-8"?>
<jobInfo  xmlns="http://www.force.com/2009/06/asyncapi/dataload">
  <operation>${operation}</operation>
  <object>${this.type}</object>
  ${options.extIdField ? `<externalIdFieldName>${options.extIdField}</externalIdFieldName>` : ''}
  ${options.concurrencyMode ? `<concurrencyMode>${options.concurrencyMode}</concurrencyMode>` : ''}
  ${options.assignmentRuleId ? `<assignmentRuleId>${options.assignmentRuleId}</assignmentRuleId>` : ''}
  <contentType>CSV</contentType>
</jobInfo>
      `.trim();
            this._jobInfo = (async ()=>{
                try {
                    const res = await bulk._request({
                        method: 'POST',
                        path: '/job',
                        body,
                        headers: {
                            'Content-Type': 'application/xml; charset=utf-8'
                        },
                        responseType: 'application/xml'
                    });
                    this.emit('open', res.jobInfo);
                    this.id = res.jobInfo.id;
                    this.state = res.jobInfo.state;
                    return res.jobInfo;
                } catch (err) {
                    this.emit('error', err);
                    throw err;
                }
            })();
        }
        return this._jobInfo;
    }
    /**
     * Create a new batch instance in the job
     */ createBatch() {
        const batch = new Batch(this);
        batch.on('queue', ()=>{
            this._batches[batch.id] = batch;
        });
        return batch;
    }
    /**
     * Get a batch instance specified by given batch ID
     */ batch(batchId) {
        let batch = this._batches[batchId];
        if (!batch) {
            batch = new Batch(this, batchId);
            this._batches[batchId] = batch;
        }
        return batch;
    }
    /**
     * Check the latest job status from server
     */ check() {
        const bulk = this._bulk;
        const logger = bulk._logger;
        this._jobInfo = (async ()=>{
            const jobId = await this.ready();
            const res = await bulk._request({
                method: 'GET',
                path: '/job/' + jobId,
                responseType: 'application/xml'
            });
            logger.debug(res.jobInfo);
            this.id = res.jobInfo.id;
            this.type = res.jobInfo.object;
            this.operation = res.jobInfo.operation;
            this.state = res.jobInfo.state;
            return res.jobInfo;
        })();
        return this._jobInfo;
    }
    /**
     * Wait till the job is assigned to server
     */ ready() {
        return this.id ? Promise.resolve(this.id) : this.open().then(({ id })=>id);
    }
    /**
     * List all registered batch info in job
     */ async list() {
        const bulk = this._bulk;
        const logger = bulk._logger;
        const jobId = await this.ready();
        const res = await bulk._request({
            method: 'GET',
            path: '/job/' + jobId + '/batch',
            responseType: 'application/xml'
        });
        logger.debug(res.batchInfoList.batchInfo);
        const batchInfoList = Array.isArray(res.batchInfoList.batchInfo) ? res.batchInfoList.batchInfo : [
            res.batchInfoList.batchInfo
        ];
        return batchInfoList;
    }
    /**
     * Close opened job
     */ async close() {
        if (!this.id) {
            return;
        }
        try {
            const jobInfo = await this._changeState('Closed');
            this.id = null;
            this.emit('close', jobInfo);
            return jobInfo;
        } catch (err) {
            this.emit('error', err);
            throw err;
        }
    }
    /**
     * Set the status to abort
     */ async abort() {
        if (!this.id) {
            return;
        }
        try {
            const jobInfo = await this._changeState('Aborted');
            this.id = null;
            this.emit('abort', jobInfo);
            return jobInfo;
        } catch (err) {
            this.emit('error', err);
            throw err;
        }
    }
    /**
     * @private
     */ async _changeState(state) {
        const bulk = this._bulk;
        const logger = bulk._logger;
        this._jobInfo = (async ()=>{
            const jobId = await this.ready();
            const body = ` 
<?xml version="1.0" encoding="UTF-8"?>
  <jobInfo xmlns="http://www.force.com/2009/06/asyncapi/dataload">
  <state>${state}</state>
</jobInfo>
      `.trim();
            const res = await bulk._request({
                method: 'POST',
                path: '/job/' + jobId,
                body: body,
                headers: {
                    'Content-Type': 'application/xml; charset=utf-8'
                },
                responseType: 'application/xml'
            });
            logger.debug(res.jobInfo);
            this.state = res.jobInfo.state;
            return res.jobInfo;
        })();
        return this._jobInfo;
    }
}
exports.Job = Job;
/*--------------------------------------------*/ class PollingTimeoutError extends Error {
    jobId;
    batchId;
    /**
     *
     */ constructor(message, jobId, batchId){
        super(message);
        this.name = 'PollingTimeout';
        this.jobId = jobId;
        this.batchId = batchId;
    }
}
/*--------------------------------------------*/ /**
 * Batch (extends Writable)
 */ class Batch extends stream_1.Writable {
    job;
    id;
    _bulk;
    _uploadStream;
    _downloadStream;
    _dataStream;
    _result;
    _error;
    /**
     *
     */ constructor(job, id){
        super({
            objectMode: true
        });
        this.job = job;
        this.id = id;
        this._bulk = job._bulk;
        // default error handler to keep the latest error
        this.on('error', (error)=>this._error = error);
        //
        // setup data streams
        //
        const converterOptions = {
            nullValue: '#N/A'
        };
        const uploadStream = this._uploadStream = new record_stream_1.Serializable();
        const uploadDataStream = uploadStream.stream('csv', converterOptions);
        const downloadStream = this._downloadStream = new record_stream_1.Parsable();
        const downloadDataStream = downloadStream.stream('csv', converterOptions);
        this.on('finish', ()=>uploadStream.end());
        uploadDataStream.once('readable', async ()=>{
            try {
                // ensure the job is opened in server or job id is already assigned
                await this.job.ready();
                // pipe upload data to batch API request stream
                uploadDataStream.pipe(this._createRequestStream());
            } catch (err) {
                this.emit('error', err);
            }
        });
        // duplex data stream, opened access to API programmers by Batch#stream()
        this._dataStream = (0, stream_2.concatStreamsAsDuplex)(uploadDataStream, downloadDataStream);
    }
    /**
     * Connect batch API and create stream instance of request/response
     *
     * @private
     */ _createRequestStream() {
        const bulk = this._bulk;
        const logger = bulk._logger;
        const req = bulk._request({
            method: 'POST',
            path: '/job/' + this.job.id + '/batch',
            headers: {
                'Content-Type': 'text/csv'
            },
            responseType: 'application/xml'
        });
        (async ()=>{
            try {
                const res = await req;
                logger.debug(res.batchInfo);
                this.id = res.batchInfo.id;
                this.emit('queue', res.batchInfo);
            } catch (err) {
                this.emit('error', err);
            }
        })();
        return req.stream();
    }
    /**
     * Implementation of Writable
     */ _write(record_, enc, cb) {
        const { Id, type, attributes, ...rrec } = record_;
        let record;
        switch(this.job.operation){
            case 'insert':
                record = rrec;
                break;
            case 'delete':
            case 'hardDelete':
                record = {
                    Id
                };
                break;
            default:
                record = {
                    Id,
                    ...rrec
                };
        }
        this._uploadStream.write(record, enc, cb);
    }
    /**
     * Returns duplex stream which accepts CSV data input and batch result output
     */ stream() {
        return this._dataStream;
    }
    /**
     * Execute batch operation
     */ execute(input) {
        // if batch is already executed
        if (this._result) {
            throw new Error('Batch already executed.');
        }
        this._result = new Promise((resolve, reject)=>{
            this.once('response', resolve);
            this.once('error', reject);
        });
        if (is_1.default.nodeStream(input)) {
            // if input has stream.Readable interface
            input.pipe(this._dataStream);
        } else {
            const recordData = structuredClone(input);
            if (Array.isArray(recordData)) {
                for (const record of recordData){
                    for (const key of Object.keys(record)){
                        if (typeof record[key] === 'boolean') {
                            record[key] = String(record[key]);
                        }
                    }
                    this.write(record);
                }
                this.end();
            } else if (typeof recordData === 'string') {
                this._dataStream.write(recordData, 'utf8');
                this._dataStream.end();
            }
        }
        // return Batch instance for chaining
        return this;
    }
    run = this.execute;
    exec = this.execute;
    /**
     * Promise/A+ interface
     * Delegate to promise, return promise instance for batch result
     */ then(onResolved, onReject) {
        if (!this._result) {
            this.execute();
        }
        return this._result.then(onResolved, onReject);
    }
    /**
     * Check the latest batch status in server
     */ async check() {
        const bulk = this._bulk;
        const logger = bulk._logger;
        const jobId = this.job.id;
        const batchId = this.id;
        if (!jobId || !batchId) {
            throw new Error('Batch not started.');
        }
        const res = await bulk._request({
            method: 'GET',
            path: '/job/' + jobId + '/batch/' + batchId,
            responseType: 'application/xml'
        });
        logger.debug(res.batchInfo);
        return res.batchInfo;
    }
    /**
     * Polling the batch result and retrieve
     */ poll(interval, timeout) {
        const jobId = this.job.id;
        const batchId = this.id;
        if (!jobId || !batchId) {
            throw new Error('Batch not started.');
        }
        const startTime = new Date().getTime();
        const endTime = startTime + timeout;
        if (timeout === 0) {
            throw new PollingTimeoutError(`Skipping polling because of timeout = 0ms. Job Id = ${jobId} | Batch Id = ${batchId}`, jobId, batchId);
        }
        const poll = async ()=>{
            const now = new Date().getTime();
            if (endTime < now) {
                const err = new PollingTimeoutError('Polling time out. Job Id = ' + jobId + ' , batch Id = ' + batchId, jobId, batchId);
                this.emit('error', err);
                return;
            }
            let res;
            try {
                res = await this.check();
            } catch (err) {
                this.emit('error', err);
                return;
            }
            if (res.state === 'Failed') {
                if (parseInt(res.numberRecordsProcessed, 10) > 0) {
                    this.retrieve();
                } else {
                    this.emit('error', new Error(res.stateMessage));
                }
            } else if (res.state === 'Completed') {
                this.retrieve();
            } else if (res.state === 'NotProcessed') {
                this.emit('error', new Error('Job has been aborted'));
            } else {
                this.emit('inProgress', res);
                setTimeout(poll, interval);
            }
        };
        setTimeout(poll, interval);
    }
    /**
     * Retrieve batch result
     */ async retrieve() {
        const bulk = this._bulk;
        const jobId = this.job.id;
        const job = this.job;
        const batchId = this.id;
        if (!jobId || !batchId) {
            throw new Error('Batch not started.');
        }
        try {
            const resp = await bulk._request({
                method: 'GET',
                path: '/job/' + jobId + '/batch/' + batchId + '/result'
            });
            let results;
            if (job.operation === 'query' || job.operation === 'queryAll') {
                const res = resp;
                const resultId = res['result-list'].result;
                results = (Array.isArray(resultId) ? resultId : [
                    resultId
                ]).map((id)=>({
                        id,
                        batchId,
                        jobId
                    }));
            } else {
                const res = resp;
                results = res.map((ret)=>({
                        id: ret.Id || null,
                        success: ret.Success === 'true',
                        created: ret.Created === 'true',
                        errors: ret.Error ? [
                            ret.Error
                        ] : []
                    }));
            }
            this.emit('response', results);
            return results;
        } catch (err) {
            this.emit('error', err);
            throw err;
        }
    }
    /**
     * Fetch query batch result as a record stream
     *
     * @param {String} resultId - Result id
     * @returns {RecordStream} - Record stream, convertible to CSV data stream
     */ result(resultId) {
        const jobId = this.job.id;
        const batchId = this.id;
        if (!jobId || !batchId) {
            throw new Error('Batch not started.');
        }
        const resultStream = new record_stream_1.Parsable();
        const resultDataStream = resultStream.stream('csv');
        this._bulk._request({
            method: 'GET',
            path: '/job/' + jobId + '/batch/' + batchId + '/result/' + resultId,
            responseType: 'application/octet-stream'
        }).stream().pipe(resultDataStream);
        return resultStream;
    }
}
exports.Batch = Batch;
/*--------------------------------------------*/ /**
 *
 */ class BulkApi extends http_api_1.default {
    beforeSend(request) {
        request.headers = {
            ...request.headers,
            'X-SFDC-SESSION': this._conn.accessToken ?? ''
        };
    }
    isSessionExpired(response) {
        return response.statusCode === 400 && response.body.includes('<exceptionCode>InvalidSessionId</exceptionCode>');
    }
    hasErrorInResponseBody(body) {
        return !!body.error;
    }
    parseError(body) {
        return {
            errorCode: body.error.exceptionCode,
            message: body.error.exceptionMessage
        };
    }
}
/*--------------------------------------------*/ /**
 * Class for Bulk API
 *
 * @class
 */ class Bulk {
    _conn;
    _logger;
    /**
     * Polling interval in milliseconds
     *
     * Default: 1000 (1 second)
     */ pollInterval = 1000;
    /**
     * Polling timeout in milliseconds
     *
     * Default: 30000 (30 seconds)
     */ pollTimeout = 30000;
    /**
     *
     */ constructor(conn){
        this._conn = conn;
        this._logger = conn._logger;
    }
    /**
     *
     */ _request(request_) {
        const conn = this._conn;
        const { path, responseType, ...rreq } = request_;
        const baseUrl = [
            conn.instanceUrl,
            'services/async',
            conn.version
        ].join('/');
        const request = {
            ...rreq,
            url: baseUrl + path
        };
        return new BulkApi(this._conn, {
            responseType
        }).request(request);
    }
    load(type, operation, optionsOrInput, input) {
        let options = {};
        if (typeof optionsOrInput === 'string' || Array.isArray(optionsOrInput) || is_1.default.nodeStream(optionsOrInput)) {
            // when options is not plain hash object, it is omitted
            input = optionsOrInput;
        } else {
            options = optionsOrInput;
        }
        const job = this.createJob(type, operation, options);
        const batch = job.createBatch();
        const cleanup = ()=>job.close();
        const cleanupOnError = (err)=>{
            if (err.name !== 'PollingTimeout') {
                cleanup();
            }
        };
        batch.on('response', cleanup);
        batch.on('error', cleanupOnError);
        batch.on('queue', ()=>{
            batch?.poll(this.pollInterval, this.pollTimeout);
        });
        return batch.execute(input);
    }
    /**
     * Execute bulk query and get record stream
     */ async query(soql) {
        const m = soql.replace(/\([\s\S]+\)/g, '').match(/FROM\s+(\w+)/i);
        if (!m) {
            throw new Error('No sobject type found in query, maybe caused by invalid SOQL.');
        }
        const type = m[1];
        const recordStream = new record_stream_1.Parsable();
        const dataStream = recordStream.stream('csv');
        const results = await this.load(type, 'query', soql);
        const streams = results.map((result)=>this.job(result.jobId).batch(result.batchId).result(result.id).stream());
        (0, multistream_1.default)(streams).pipe(dataStream);
        return recordStream;
    }
    /**
     * Create a new job instance
     */ createJob(type, operation, options = {}) {
        return new Job(this, type, operation, options);
    }
    /**
     * Get a job instance specified by given job ID
     *
     * @param {String} jobId - Job ID
     * @returns {Bulk~Job}
     */ job(jobId) {
        return new Job(this, null, null, null, jobId);
    }
}
exports.Bulk = Bulk;
/*--------------------------------------------*/ /*
 * Register hook in connection instantiation for dynamically adding this API module features
 */ (0, jsforce_1.registerModule)('bulk', (conn)=>new Bulk(conn));
exports.default = Bulk;
}),
"[project]/node_modules/jsforce/lib/api/bulk2.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IngestJobV2 = exports.QueryJobV2 = exports.BulkV2 = void 0;
const events_1 = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
const stream_1 = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const record_stream_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/record-stream.js [app-route] (ecmascript)");
const http_api_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/http-api.js [app-route] (ecmascript)"));
const jsforce_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/jsforce.js [app-route] (ecmascript)");
const logger_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/util/logger.js [app-route] (ecmascript)");
const stream_2 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/util/stream.js [app-route] (ecmascript)");
const is_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@sindresorhus/is/dist/index.js [app-route] (ecmascript)"));
class JobPollingTimeoutError extends Error {
    jobId;
    /**
     *
     */ constructor(message, jobId){
        super(message);
        this.name = 'JobPollingTimeout';
        this.jobId = jobId;
    }
}
class BulkApiV2 extends http_api_1.default {
    hasErrorInResponseBody(body) {
        return Array.isArray(body) && typeof body[0] === 'object' && 'errorCode' in body[0];
    }
    isSessionExpired(response) {
        return response.statusCode === 401 && response.body.includes('INVALID_SESSION_ID');
    }
    parseError(body) {
        return {
            errorCode: body[0].errorCode,
            message: body[0].message
        };
    }
}
class BulkV2 {
    connection;
    logger;
    /**
     * Polling interval in milliseconds
     *
     * Default: 1000 (1 second)
     */ pollInterval = 1000;
    /**
     * Polling timeout in milliseconds
     *
     * Default: 30000 (30 seconds)
     */ pollTimeout = 30000;
    constructor(connection){
        this.connection = connection;
        this.logger = this.connection._logLevel ? (0, logger_1.getLogger)('bulk2').createInstance(this.connection._logLevel) : (0, logger_1.getLogger)('bulk2');
    }
    /**
     * Create an instance of an ingest job object.
     *
     * @params {NewIngestJobOptions} options object
     * @returns {IngestJobV2} An ingest job instance
     * @example
     * // Upsert records to the Account object.
     *
     * const job = connection.bulk2.createJob({
     *   operation: 'insert'
     *   object: 'Account',
     * });
     *
     * // create the job in the org
     * await job.open()
     *
     * // upload data
     * await job.uploadData(csvFile)
     *
     * // finished uploading data, mark it as ready for processing
     * await job.close()
     */ createJob(options) {
        return new IngestJobV2(this.connection, {
            bodyParams: options,
            pollingOptions: this
        });
    }
    job(type = 'ingest', options) {
        if (type === 'ingest') {
            return new IngestJobV2(this.connection, {
                id: options.id,
                pollingOptions: this
            });
        } else {
            return new QueryJobV2(this.connection, {
                id: options.id,
                pollingOptions: this
            });
        }
    }
    /**
     * Create, upload, and start bulkload job
     */ async loadAndWaitForResults(options) {
        if (!options.pollTimeout) options.pollTimeout = this.pollTimeout;
        if (!options.pollInterval) options.pollInterval = this.pollInterval;
        const { pollInterval, pollTimeout, input, ...createJobOpts } = options;
        const job = this.createJob(createJobOpts);
        try {
            await job.open();
            await job.uploadData(input);
            await job.close();
            await job.poll(pollInterval, pollTimeout);
            return await job.getAllResults();
        } catch (error) {
            const err = error;
            this.logger.error(`bulk load failed due to: ${err.message}`);
            if (err.name !== 'JobPollingTimeoutError') {
                // fires off one last attempt to clean up and ignores the result | error
                job.delete().catch((ignored)=>ignored);
            }
            throw err;
        }
    }
    /**
     * Execute bulk query and get a record stream.
     *
     * Default timeout: 10000ms
     *
     * @param soql SOQL query
     * @param options
     *
     * @returns {RecordStream} - Record stream, convertible to a CSV data stream
     */ async query(soql, options) {
        const queryJob = new QueryJobV2(this.connection, {
            bodyParams: {
                query: soql,
                operation: options?.scanAll ? 'queryAll' : 'query',
                columnDelimiter: options?.columnDelimiter,
                lineEnding: options?.lineEnding
            },
            pollingOptions: this
        });
        const recordStream = new record_stream_1.Parsable();
        const dataStream = recordStream.stream('csv');
        try {
            await queryJob.open();
            await queryJob.poll(options?.pollInterval, options?.pollTimeout);
            const queryRecordsStream = await queryJob.result().then((s)=>s.stream());
            queryRecordsStream.pipe(dataStream);
        } catch (error) {
            const err = error;
            this.logger.error(`bulk query failed due to: ${err.message}`);
            if (err.name !== 'JobPollingTimeoutError') {
                // fires off one last attempt to clean up and ignores the result | error
                queryJob.delete().catch((ignored)=>ignored);
            }
            throw err;
        }
        return recordStream;
    }
}
exports.BulkV2 = BulkV2;
class QueryJobV2 extends events_1.EventEmitter {
    connection;
    logger;
    _id;
    bodyParams;
    pollingOptions;
    error;
    jobInfo;
    locator;
    constructor(conn, options){
        super();
        this.connection = conn;
        this.logger = this.connection._logLevel ? (0, logger_1.getLogger)('bulk2:QueryJobV2').createInstance(this.connection._logLevel) : (0, logger_1.getLogger)('bulk2:QueryJobV2');
        if ('id' in options) {
            this._id = options.id;
        } else {
            this.bodyParams = options.bodyParams;
        }
        this.pollingOptions = options.pollingOptions;
        // default error handler to keep the latest error
        this.on('error', (error)=>this.error = error);
    }
    /**
     * Get the query job ID.
     *
     * @returns {string} query job Id.
     */ get id() {
        return this.jobInfo ? this.jobInfo.id : this._id;
    }
    /**
     * Get the query job info.
     *
     * @returns {Promise<QueryJobInfoV2>} query job information.
     */ getInfo() {
        if (this.jobInfo) {
            return this.jobInfo;
        }
        throw new Error('No internal job info. Make sure to call `await job.check`.');
    }
    /**
     * Creates a query job
     *
     * @returns {Promise<QueryJobInfoV2>} job information.
     */ async open() {
        if (!this.bodyParams) {
            throw new Error('Missing required body params to open a new query job.');
        }
        try {
            this.jobInfo = await this.createQueryRequest({
                method: 'POST',
                body: JSON.stringify(this.bodyParams),
                headers: {
                    'Content-Type': 'application/json; charset=utf-8'
                },
                responseType: 'application/json'
            });
            this.logger.debug(`Successfully created job ${this.id}`);
            this.emit('open', this.jobInfo);
        } catch (err) {
            this.emit('error', err);
            throw err;
        }
        return this.jobInfo;
    }
    /**
     * Abort the job
     *
     * The 'aborted' event is emitted when the job successfully aborts.
     * @returns {Promise<QueryJobInfoV2>} job information.
     */ async abort() {
        try {
            const state = 'Aborted';
            this.jobInfo = await this.createQueryRequest({
                method: 'PATCH',
                path: `/${this.id}`,
                body: JSON.stringify({
                    state
                }),
                headers: {
                    'Content-Type': 'application/json; charset=utf-8'
                },
                responseType: 'application/json'
            });
            this.logger.debug(`Successfully aborted job ${this.id}`);
            return this.jobInfo;
        } catch (err) {
            this.emit('error', err);
            throw err;
        }
    }
    /**
     * Poll for the state of the processing for the job.
     *
     * @param interval Polling interval in milliseconds
     * @param timeout Polling timeout in milliseconds
     * @returns {Promise<Record[]>} A promise that resolves when the job finished being processed.
     */ async poll(interval = this.pollingOptions.pollInterval, timeout = this.pollingOptions.pollTimeout) {
        const jobId = this.id;
        const startTime = Date.now();
        const endTime = startTime + timeout;
        this.logger.debug('Start polling for job status');
        this.logger.debug(`Polling options: timeout:${timeout}ms | interval: ${interval}ms.`);
        if (timeout === 0) {
            throw new JobPollingTimeoutError(`Skipping polling because of timeout = 0ms. Job Id = ${jobId}`, jobId);
        }
        while(endTime > Date.now()){
            try {
                const res = await this.check();
                switch(res.state){
                    case 'Aborted':
                        throw new Error('Job has been aborted');
                    case 'UploadComplete':
                    case 'InProgress':
                        this.emit('inProgress', res);
                        await delay(interval);
                        break;
                    case 'Failed':
                        // unlike ingest jobs, the API doesn't return an error msg:
                        // https://developer.salesforce.com/docs/atlas.en-us.api_asynch.meta/api_asynch/query_get_one_job.htm
                        this.logger.debug(res);
                        throw new Error('Query job failed to complete');
                    case 'JobComplete':
                        this.logger.debug(`Job ${this.id} was successfully processed.`);
                        this.emit('jobComplete', res);
                        return;
                }
            } catch (err) {
                this.emit('error', err);
                throw err;
            }
        }
        const timeoutError = new JobPollingTimeoutError(`Polling timed out after ${timeout}ms. Job Id = ${jobId}`, jobId);
        this.emit('error', timeoutError);
        throw timeoutError;
    }
    /**
     * Check the latest job status
     *
     * @returns {Promise<QueryJobInfoV2>} job information.
     */ async check() {
        try {
            const jobInfo = await this.createQueryRequest({
                method: 'GET',
                path: `/${this.id}`,
                responseType: 'application/json'
            });
            this.jobInfo = jobInfo;
            return jobInfo;
        } catch (err) {
            this.emit('error', err);
            throw err;
        }
    }
    /**
     * Get the results for a query job as a record stream
     *
     * This method assumes the job finished being processed
     * @returns {RecordStream} - Record stream, convertible to a CSV data stream
     */ async result() {
        const resultStream = new record_stream_1.Parsable();
        const resultDataStream = resultStream.stream('csv');
        const resultsPath = `/${this.id}/results`;
        while(this.locator !== 'null'){
            const resPromise = this.createQueryRequest({
                method: 'GET',
                path: this.locator ? `${resultsPath}?locator=${this.locator}` : resultsPath,
                headers: {
                    Accept: 'text/csv'
                }
            });
            resPromise.stream().pipe(resultDataStream);
            await resPromise;
        }
        return resultStream;
    }
    /**
     * Deletes a query job.
     */ async delete() {
        return this.createQueryRequest({
            method: 'DELETE',
            path: `/${this.id}`
        });
    }
    createQueryRequest(request) {
        const { path, responseType } = request;
        const basePath = `services/data/v${this.connection.version}/jobs/query`;
        const url = new URL(path ? basePath + path : basePath, this.connection.instanceUrl).toString();
        const httpApi = new BulkApiV2(this.connection, {
            responseType
        });
        httpApi.on('response', (response)=>{
            this.locator = response.headers['sforce-locator'];
            this.logger.debug(`sforce-locator: ${this.locator}`);
        });
        return httpApi.request({
            ...request,
            url
        });
    }
}
exports.QueryJobV2 = QueryJobV2;
/**
 * Class for Bulk API V2 Ingest Job
 */ class IngestJobV2 extends events_1.EventEmitter {
    connection;
    logger;
    _id;
    bodyParams;
    jobData;
    pollingOptions;
    bulkJobSuccessfulResults;
    bulkJobFailedResults;
    bulkJobUnprocessedRecords;
    error;
    jobInfo;
    /**
     *
     */ constructor(conn, options){
        super();
        this.connection = conn;
        this.logger = this.connection._logLevel ? (0, logger_1.getLogger)('bulk2:IngestJobV2').createInstance(this.connection._logLevel) : (0, logger_1.getLogger)('bulk2:IngestJobV2');
        this.pollingOptions = options.pollingOptions;
        if ('id' in options) {
            this._id = options.id;
        } else {
            this.bodyParams = options.bodyParams;
        }
        this.jobData = new JobDataV2({
            createRequest: (request)=>this.createIngestRequest(request),
            job: this
        });
        // default error handler to keep the latest error
        this.on('error', (error)=>this.error = error);
    }
    /**
     * Get the query job ID.
     *
     * @returns {string} query job Id.
     */ get id() {
        return this.jobInfo ? this.jobInfo.id : this._id;
    }
    /**
     * Get the query job info.
     *
     * @returns {Promise<QueryJobInfoV2>} ingest job information.
     */ getInfo() {
        if (this.jobInfo) {
            return this.jobInfo;
        }
        throw new Error('No internal job info. Make sure to call `await job.check`.');
    }
    /**
     * Create a job representing a bulk operation in the org
     *
     * @returns {Promise<QueryJobInfoV2>} job information.
     */ async open() {
        if (!this.bodyParams) {
            throw new Error('Missing required body params to open a new ingest job.');
        }
        try {
            this.jobInfo = await this.createIngestRequest({
                method: 'POST',
                body: JSON.stringify(this.bodyParams),
                headers: {
                    'Content-Type': 'application/json; charset=utf-8'
                },
                responseType: 'application/json'
            });
            this.logger.debug(`Successfully created job ${this.id}`);
            this.emit('open');
        } catch (err) {
            this.emit('error', err);
            throw err;
        }
        return this.jobInfo;
    }
    /** Upload data for a job in CSV format
     *
     *  @param input CSV as a string, or array of records or readable stream
     */ async uploadData(input) {
        await this.jobData.execute(input).result;
        this.logger.debug(`Successfully uploaded data to job ${this.id}`);
    }
    /**
     * Close opened job
     *
     * This method will notify the org  that the upload of job data is complete and is ready for processing.
     */ async close() {
        try {
            const state = 'UploadComplete';
            this.jobInfo = await this.createIngestRequest({
                method: 'PATCH',
                path: `/${this.id}`,
                body: JSON.stringify({
                    state
                }),
                headers: {
                    'Content-Type': 'application/json; charset=utf-8'
                },
                responseType: 'application/json'
            });
            this.logger.debug(`Successfully closed job ${this.id}`);
            this.emit('close');
        } catch (err) {
            this.emit('error', err);
            throw err;
        }
    }
    /**
     * Set the status to abort
     */ async abort() {
        try {
            const state = 'Aborted';
            this.jobInfo = await this.createIngestRequest({
                method: 'PATCH',
                path: `/${this.id}`,
                body: JSON.stringify({
                    state
                }),
                headers: {
                    'Content-Type': 'application/json; charset=utf-8'
                },
                responseType: 'application/json'
            });
            this.logger.debug(`Successfully aborted job ${this.id}`);
            this.emit('aborted');
        } catch (err) {
            this.emit('error', err);
            throw err;
        }
    }
    /**
     * Poll for the state of the processing for the job.
     *
     * This method will only throw after a timeout. To capture a
     * job failure while polling you must set a listener for the
     * `failed` event before calling it:
     *
     * job.on('failed', (err) => console.error(err))
     * await job.poll()
     *
     * @param interval Polling interval in milliseconds
     * @param timeout Polling timeout in milliseconds
     * @returns {Promise<void>} A promise that resolves when the job finishes successfully
     */ async poll(interval = this.pollingOptions.pollInterval, timeout = this.pollingOptions.pollTimeout) {
        const jobId = this.id;
        const startTime = Date.now();
        const endTime = startTime + timeout;
        if (timeout === 0) {
            throw new JobPollingTimeoutError(`Skipping polling because of timeout = 0ms. Job Id = ${jobId}`, jobId);
        }
        this.logger.debug('Start polling for job status');
        this.logger.debug(`Polling options: timeout:${timeout}ms | interval: ${interval}ms.`);
        while(endTime > Date.now()){
            try {
                const res = await this.check();
                switch(res.state){
                    case 'Open':
                        throw new Error('Job is still open. Make sure close the job by `close` method on the job instance before polling.');
                    case 'Aborted':
                        throw new Error('Job has been aborted');
                    case 'UploadComplete':
                    case 'InProgress':
                        this.emit('inProgress', res);
                        await delay(interval);
                        break;
                    case 'Failed':
                        this.logger.debug(res);
                        throw new Error(`Ingest job failed to complete due to: ${res.errorMessage}`);
                    case 'JobComplete':
                        this.logger.debug(`Job ${this.id} was successfully processed.`);
                        this.emit('jobComplete', res);
                        return;
                }
            } catch (err) {
                this.emit('error', err);
                throw err;
            }
        }
        const timeoutError = new JobPollingTimeoutError(`Polling timed out after ${timeout}ms. Job Id = ${jobId}`, jobId);
        this.emit('error', timeoutError);
        throw timeoutError;
    }
    /**
     * Check the latest batch status in server
     */ async check() {
        try {
            const jobInfo = await this.createIngestRequest({
                method: 'GET',
                path: `/${this.id}`,
                responseType: 'application/json'
            });
            this.jobInfo = jobInfo;
            return jobInfo;
        } catch (err) {
            this.emit('error', err);
            throw err;
        }
    }
    /** Return all record results
     *
     * This method will return successful, failed and unprocessed records
     *
     * @returns Promise<IngestJobV2Results>
     */ async getAllResults() {
        const [successfulResults, failedResults, unprocessedRecords] = await Promise.all([
            this.getSuccessfulResults(),
            this.getFailedResults(),
            this.getUnprocessedRecords()
        ]);
        return {
            successfulResults,
            failedResults,
            unprocessedRecords
        };
    }
    async getSuccessfulResults(raw) {
        const reqOpts = {
            method: 'GET',
            path: `/${this.id}/successfulResults`
        };
        if (raw) {
            return this.createIngestRequest({
                ...reqOpts,
                responseType: 'text/plain'
            });
        }
        if (this.bulkJobSuccessfulResults) {
            return this.bulkJobSuccessfulResults;
        }
        const results = await this.createIngestRequest({
            method: 'GET',
            path: `/${this.id}/successfulResults`,
            responseType: 'text/csv'
        });
        this.bulkJobSuccessfulResults = results ?? [];
        return this.bulkJobSuccessfulResults;
    }
    async getFailedResults(raw) {
        const reqOpts = {
            method: 'GET',
            path: `/${this.id}/failedResults`
        };
        if (raw) {
            return this.createIngestRequest({
                ...reqOpts,
                responseType: 'text/plain'
            });
        }
        if (this.bulkJobFailedResults) {
            return this.bulkJobFailedResults;
        }
        const results = await this.createIngestRequest({
            ...reqOpts,
            responseType: 'text/csv'
        });
        this.bulkJobFailedResults = results ?? [];
        return this.bulkJobFailedResults;
    }
    async getUnprocessedRecords(raw) {
        const reqOpts = {
            method: 'GET',
            path: `/${this.id}/unprocessedrecords`
        };
        if (raw) {
            return this.createIngestRequest({
                ...reqOpts,
                responseType: 'text/plain'
            });
        }
        if (this.bulkJobUnprocessedRecords) {
            return this.bulkJobUnprocessedRecords;
        }
        const results = await this.createIngestRequest({
            ...reqOpts,
            responseType: 'text/csv'
        });
        this.bulkJobUnprocessedRecords = results ?? [];
        return this.bulkJobUnprocessedRecords;
    }
    /**
     * Deletes an ingest job.
     */ async delete() {
        return this.createIngestRequest({
            method: 'DELETE',
            path: `/${this.id}`
        });
    }
    createIngestRequest(request) {
        const { path, responseType } = request;
        const basePath = `/services/data/v${this.connection.version}/jobs/ingest`;
        const url = new URL(path ? basePath + path : basePath, this.connection.instanceUrl).toString();
        return new BulkApiV2(this.connection, {
            responseType
        }).request({
            ...request,
            url
        });
    }
}
exports.IngestJobV2 = IngestJobV2;
class JobDataV2 extends stream_1.Writable {
    job;
    uploadStream;
    downloadStream;
    dataStream;
    result;
    /**
     *
     */ constructor(options){
        super({
            objectMode: true
        });
        const createRequest = options.createRequest;
        this.job = options.job;
        this.uploadStream = new record_stream_1.Serializable();
        this.downloadStream = new record_stream_1.Parsable();
        const converterOptions = {
            nullValue: '#N/A'
        };
        const uploadDataStream = this.uploadStream.stream('csv', converterOptions);
        const downloadDataStream = this.downloadStream.stream('csv', converterOptions);
        this.dataStream = (0, stream_2.concatStreamsAsDuplex)(uploadDataStream, downloadDataStream);
        this.on('finish', ()=>this.uploadStream.end());
        uploadDataStream.once('readable', ()=>{
            try {
                // pipe upload data to batch API request stream
                const req = createRequest({
                    method: 'PUT',
                    path: `/${this.job.id}/batches`,
                    headers: {
                        'Content-Type': 'text/csv'
                    },
                    responseType: 'application/json'
                });
                (async ()=>{
                    try {
                        const res = await req;
                        this.emit('response', res);
                    } catch (err) {
                        this.emit('error', err);
                    }
                })();
                uploadDataStream.pipe(req.stream());
            } catch (err) {
                this.emit('error', err);
            }
        });
    }
    _write(record_, enc, cb) {
        const { Id, type, attributes, ...rrec } = record_;
        let record;
        switch(this.job.getInfo().operation){
            case 'insert':
                record = rrec;
                break;
            case 'delete':
            case 'hardDelete':
                record = {
                    Id
                };
                break;
            default:
                record = {
                    Id,
                    ...rrec
                };
        }
        this.uploadStream.write(record, enc, cb);
    }
    /**
     * Returns duplex stream which accepts CSV data input and batch result output
     */ stream() {
        return this.dataStream;
    }
    /**
     * Execute batch operation
     */ execute(input) {
        if (this.result) {
            throw new Error('Data can only be uploaded to a job once.');
        }
        this.result = new Promise((resolve, reject)=>{
            this.once('response', ()=>resolve());
            this.once('error', reject);
        });
        if (is_1.default.nodeStream(input)) {
            // if input has stream.Readable interface
            input.pipe(this.dataStream);
        } else {
            const recordData = structuredClone(input);
            if (Array.isArray(recordData)) {
                for (const record of recordData){
                    for (const key of Object.keys(record)){
                        if (typeof record[key] === 'boolean') {
                            record[key] = String(record[key]);
                        }
                    }
                    this.write(record);
                }
                this.end();
            } else if (typeof recordData === 'string') {
                this.dataStream.write(recordData, 'utf8');
                this.dataStream.end();
            }
        }
        return this;
    }
}
function delay(ms) {
    return new Promise((resolve)=>setTimeout(resolve, ms));
}
/*--------------------------------------------*/ /*
 * Register hook in connection instantiation for dynamically adding this API module features
 */ (0, jsforce_1.registerModule)('bulk2', (conn)=>new BulkV2(conn));
exports.default = BulkV2;
}),
"[project]/node_modules/jsforce/lib/util/function.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.emptyFunc = exports.identityFunc = exports.isPromiseLike = exports.isNumber = exports.isFunction = exports.isMapObject = exports.isObject = void 0;
/**
 *
 */ function isObject(v) {
    const t = typeof v;
    return v != null && (t == 'object' || t == 'function');
}
exports.isObject = isObject;
/**
 *
 */ function isMapObject(v) {
    const t = typeof v;
    return v != null && t == 'object';
}
exports.isMapObject = isMapObject;
/**
 *
 */ function isFunction(v) {
    return typeof v == 'function';
}
exports.isFunction = isFunction;
/**
 *
 */ function isNumber(v) {
    return typeof v == 'number';
}
exports.isNumber = isNumber;
/**
 * Detect whether the value has CommonJS Promise/A+ interface or not
 */ function isPromiseLike(v) {
    return isObject(v) && isFunction(v.then);
}
exports.isPromiseLike = isPromiseLike;
/**
 *
 */ function identityFunc(a) {
    return a;
}
exports.identityFunc = identityFunc;
/**
 *
 */ function emptyFunc() {}
exports.emptyFunc = emptyFunc;
}),
"[project]/node_modules/jsforce/lib/api/chatter.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Chatter = exports.Resource = void 0;
/**
 * @file Manages Salesforce Chatter REST API calls
 * @author Shinichi Tomita <shinichi.tomita@gmail.com>
 */ const jsforce_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/jsforce.js [app-route] (ecmascript)");
const function_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/util/function.js [app-route] (ecmascript)");
/*--------------------------------------------*/ /**
 * A class representing chatter API request
 */ class Request {
    _chatter;
    _request;
    _promise;
    constructor(chatter, request){
        this._chatter = chatter;
        this._request = request;
    }
    /**
     * Retrieve parameters in batch request form
     */ batchParams() {
        const { method, url, body } = this._request;
        return {
            method,
            url: this._chatter._normalizeUrl(url),
            ...typeof body !== 'undefined' ? {
                richInput: body
            } : {}
        };
    }
    /**
     * Retrieve parameters in batch request form
     *
     * @method Chatter~Request#promise
     * @returns {Promise.<Chatter~RequestResult>}
     */ promise() {
        return this._promise || (this._promise = this._chatter._request(this._request));
    }
    /**
     * Returns Node.js Stream object for request
     *
     * @method Chatter~Request#stream
     * @returns {stream.Stream}
     */ stream() {
        return this._chatter._request(this._request).stream();
    }
    /**
     * Promise/A+ interface
     * http://promises-aplus.github.io/promises-spec/
     *
     * Delegate to deferred promise, return promise instance for batch result
     */ then(onResolve, onReject) {
        return this.promise().then(onResolve, onReject);
    }
}
function apppendQueryParamsToUrl(url, queryParams) {
    if (queryParams) {
        const qstring = Object.keys(queryParams).map((name)=>`${name}=${encodeURIComponent(String(queryParams[name] ?? ''))}`).join('&');
        url += (url.indexOf('?') > 0 ? '&' : '?') + qstring;
    }
    return url;
}
/*------------------------------*/ class Resource extends Request {
    _url;
    /**
     *
     */ constructor(chatter, url, queryParams){
        super(chatter, {
            method: 'GET',
            url: apppendQueryParamsToUrl(url, queryParams)
        });
        this._url = this._request.url;
    }
    /**
     * Create a new resource
     */ create(data) {
        return this._chatter.request({
            method: 'POST',
            url: this._url,
            body: data
        });
    }
    /**
     * Retrieve resource content
     */ retrieve() {
        return this._chatter.request({
            method: 'GET',
            url: this._url
        });
    }
    /**
     * Update specified resource
     */ update(data) {
        return this._chatter.request({
            method: 'POST',
            url: this._url,
            body: data
        });
    }
    /**
     * Delete specified resource
     */ destroy() {
        return this._chatter.request({
            method: 'DELETE',
            url: this._url
        });
    }
    /**
     * Synonym of Resource#destroy()
     */ delete = this.destroy;
    /**
     * Synonym of Resource#destroy()
     */ del = this.destroy;
}
exports.Resource = Resource;
/*------------------------------*/ /**
 * API class for Chatter REST API call
 */ class Chatter {
    _conn;
    /**
     *
     */ constructor(conn){
        this._conn = conn;
    }
    /**
     * Sending request to API endpoint
     * @private
     */ _request(req_) {
        const { method, url: url_, headers: headers_, body: body_ } = req_;
        let headers = headers_ ?? {};
        let body;
        if (/^(put|post|patch)$/i.test(method)) {
            if ((0, function_1.isObject)(body_)) {
                headers = {
                    ...headers_,
                    'Content-Type': 'application/json'
                };
                body = JSON.stringify(body_);
            } else {
                body = body_;
            }
        }
        const url = this._normalizeUrl(url_);
        return this._conn.request({
            method,
            url,
            headers,
            body
        });
    }
    /**
     * Convert path to site root relative url
     * @private
     */ _normalizeUrl(url) {
        if (url.startsWith('/chatter/') || url.startsWith('/connect/')) {
            return '/services/data/v' + this._conn.version + url;
        } else if (/^\/v[\d]+\.[\d]+\//.test(url)) {
            return '/services/data' + url;
        } else if (!url.startsWith('/services/') && url.startsWith('/')) {
            return '/services/data/v' + this._conn.version + '/chatter' + url;
        } else {
            return url;
        }
    }
    /**
     * Make a request for chatter API resource
     */ request(req) {
        return new Request(this, req);
    }
    /**
     * Make a resource request to chatter API
     */ resource(url, queryParams) {
        return new Resource(this, url, queryParams);
    }
    /**
     * Make a batch request to chatter API
     */ async batch(requests) {
        const deferreds = requests.map((request)=>{
            const deferred = defer();
            request._promise = deferred.promise;
            return deferred;
        });
        const res = await this.request({
            method: 'POST',
            url: this._normalizeUrl('/connect/batch'),
            body: {
                batchRequests: requests.map((request)=>request.batchParams())
            }
        });
        res.results.forEach((result, i)=>{
            const deferred = deferreds[i];
            if (result.statusCode >= 400) {
                deferred.reject(result.result);
            } else {
                deferred.resolve(result.result);
            }
        });
        return res;
    }
}
exports.Chatter = Chatter;
function defer() {
    let resolve_ = ()=>{};
    let reject_ = ()=>{};
    const promise = new Promise((resolve, reject)=>{
        resolve_ = resolve;
        reject_ = reject;
    });
    return {
        promise,
        resolve: resolve_,
        reject: reject_
    };
}
/*--------------------------------------------*/ /*
 * Register hook in connection instantiation for dynamically adding this API module features
 */ (0, jsforce_1.registerModule)('chatter', (conn)=>new Chatter(conn));
exports.default = Chatter;
}),
"[project]/node_modules/jsforce/lib/util/jwt.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isJWTToken = void 0;
/**
 * Checks if a given access token is a JWT.
 *
 * @param {string} accessToken - The access token to check
 * @returns {boolean} True if the token is a valid JWT token, false otherwise.
 */ function isJWTToken(accessToken) {
    const parts = accessToken.split('.');
    if (parts.length !== 3) return false;
    const header = parts[0];
    try {
        JSON.parse(atob(header));
        return true;
    } catch (err) {
        return false;
    }
}
exports.isJWTToken = isJWTToken;
}),
"[project]/node_modules/jsforce/lib/soap.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SOAP = exports.castTypeUsingSchema = void 0;
/**
 * @file Manages method call to SOAP endpoint
 * @author Shinichi Tomita <shinichi.tomita@gmail.com>
 */ const http_api_1 = __importStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/http-api.js [app-route] (ecmascript)"));
const function_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/util/function.js [app-route] (ecmascript)");
const get_body_size_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/util/get-body-size.js [app-route] (ecmascript)");
const jwt_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/util/jwt.js [app-route] (ecmascript)");
/**
 *
 */ function getPropsSchema(schema, schemaDict) {
    if (schema.extends && schemaDict[schema.extends]) {
        const extendSchema = schemaDict[schema.extends];
        return {
            ...getPropsSchema(extendSchema, schemaDict),
            ...schema.props
        };
    }
    return schema.props;
}
function isNillValue(value) {
    return value == null || (0, function_1.isMapObject)(value) && (0, function_1.isMapObject)(value.$) && value.$['xsi:nil'] === 'true';
}
/**
 *
 */ function castTypeUsingSchema(value, schema, schemaDict = {}) {
    if (Array.isArray(schema)) {
        const nillable = schema.length === 2 && schema[0] === '?';
        const schema_ = nillable ? schema[1] : schema[0];
        if (value == null) {
            return nillable ? null : [];
        }
        return (Array.isArray(value) ? value : [
            value
        ]).map((v)=>castTypeUsingSchema(v, schema_, schemaDict));
    } else if ((0, function_1.isMapObject)(schema)) {
        // if schema is Schema Definition, not schema element
        if ('type' in schema && 'props' in schema && (0, function_1.isMapObject)(schema.props)) {
            const props = getPropsSchema(schema, schemaDict);
            return castTypeUsingSchema(value, props, schemaDict);
        }
        const nillable = '?' in schema;
        const schema_ = '?' in schema ? schema['?'] : schema;
        if (nillable && isNillValue(value)) {
            return null;
        }
        const obj = (0, function_1.isMapObject)(value) ? value : {};
        return Object.keys(schema_).reduce((o, k)=>{
            const s = schema_[k];
            const v = obj[k];
            const nillable = Array.isArray(s) && s.length === 2 && s[0] === '?' || (0, function_1.isMapObject)(s) && '?' in s || typeof s === 'string' && s.startsWith('?');
            if (typeof v === 'undefined' && nillable) {
                return o;
            }
            return {
                ...o,
                [k]: castTypeUsingSchema(v, s, schemaDict)
            };
        }, obj);
    } else {
        const nillable = typeof schema === 'string' && schema.startsWith('?');
        const type = typeof schema === 'string' ? nillable ? schema.substring(1) : schema : 'any';
        switch(type){
            case 'string':
                return isNillValue(value) ? nillable ? null : '' : String(value);
            case 'number':
                return isNillValue(value) ? nillable ? null : 0 : Number(value);
            case 'boolean':
                return isNillValue(value) ? nillable ? null : false : value === 'true';
            case 'null':
                return null;
            default:
                {
                    if (schemaDict[type]) {
                        const cvalue = castTypeUsingSchema(value, schemaDict[type], schemaDict);
                        const isEmpty = (0, function_1.isMapObject)(cvalue) && Object.keys(cvalue).length === 0;
                        return isEmpty && nillable ? null : cvalue;
                    }
                    return value;
                }
        }
    }
}
exports.castTypeUsingSchema = castTypeUsingSchema;
/**
 * @private
 */ function lookupValue(obj, propRegExps) {
    const regexp = propRegExps.shift();
    if (!regexp) {
        return obj;
    }
    if ((0, function_1.isMapObject)(obj)) {
        for (const prop of Object.keys(obj)){
            if (regexp.test(prop)) {
                return lookupValue(obj[prop], propRegExps);
            }
        }
        return null;
    }
}
/**
 * @private
 */ function toXML(name, value) {
    if ((0, function_1.isObject)(name)) {
        value = name;
        name = null;
    }
    if (Array.isArray(value)) {
        return value.map((v)=>toXML(name, v)).join('');
    } else {
        const attrs = [];
        if (value === null) {
            attrs.push('xsi:nil="true"');
            value = '';
        } else if ((0, function_1.isMapObject)(value)) {
            const elems = [];
            for (const k of Object.keys(value)){
                const v = value[k];
                if (k.startsWith('@')) {
                    const kk = k.substring(1);
                    attrs.push(`${kk}="${v}"`);
                } else {
                    elems.push(toXML(k, v));
                }
            }
            value = elems.join('');
        } else {
            value = String(value).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
        }
        const startTag = name ? '<' + name + (attrs.length > 0 ? ' ' + attrs.join(' ') : '') + '>' : '';
        const endTag = name ? '</' + name + '>' : '';
        return startTag + value + endTag;
    }
}
/**
 * Class for SOAP endpoint of Salesforce
 *
 * @protected
 * @class
 * @constructor
 * @param {Connection} conn - Connection instance
 * @param {Object} options - SOAP endpoint setting options
 * @param {String} options.endpointUrl - SOAP endpoint URL
 * @param {String} [options.xmlns] - XML namespace for method call (default is "urn:partner.soap.sforce.com")
 */ class SOAP extends http_api_1.default {
    _endpointUrl;
    _xmlns;
    constructor(conn, options){
        super(conn, options);
        if (this._conn.accessToken && (0, jwt_1.isJWTToken)(this._conn.accessToken)) {
            // We need to block SOAP requests with JWT tokens because the response is:
            // statusCode=500 | body="INVALID_SESSION_ID" (xml), which triggers session refresh and enters in an infinite loop
            throw new Error('SOAP API does not support JWT-based access tokens. You must disable the "Issue JSON Web Token (JWT)-based access tokens" setting in your Connected App or External Client App');
        }
        this._endpointUrl = options.endpointUrl;
        this._xmlns = options.xmlns || 'urn:partner.soap.sforce.com';
    }
    /**
     * Invoke SOAP call using method and arguments
     */ async invoke(method, args, schema, schemaDict) {
        const res = await this.request({
            method: 'POST',
            url: this._endpointUrl,
            headers: {
                'Content-Type': 'text/xml',
                SOAPAction: '""'
            },
            _message: {
                [method]: args
            }
        });
        return schema ? castTypeUsingSchema(res, schema, schemaDict) : res;
    }
    /** @override */ beforeSend(request) {
        request.body = this._createEnvelope(request._message);
        const headers = request.headers || {};
        const bodySize = (0, get_body_size_1.getBodySize)(request.body, request.headers);
        if (!http_api_1.isBrowser && // Don't set content-length in browsers as it's not allowed
        request.method === 'POST' && !('transfer-encoding' in headers) && !('content-length' in headers) && !!bodySize) {
            this._logger.debug(`missing 'content-length' header, setting it to: ${bodySize}`);
            headers['content-length'] = String(bodySize);
        }
        request.headers = headers;
    }
    /** @override **/ isSessionExpired(response) {
        return response.statusCode === 500 && /<faultcode>[a-zA-Z]+:INVALID_SESSION_ID<\/faultcode>/.test(response.body);
    }
    /** @override **/ parseError(body) {
        const error = lookupValue(body, [
            /:Envelope$/,
            /:Body$/,
            /:Fault$/
        ]);
        return {
            errorCode: error.faultcode,
            message: error.faultstring
        };
    }
    /** @override **/ async getResponseBody(response) {
        const body = await super.getResponseBody(response);
        return lookupValue(body, [
            /:Envelope$/,
            /:Body$/,
            /.+/
        ]);
    }
    /**
     * @private
     */ _createEnvelope(message) {
        const header = {};
        const conn = this._conn;
        if (conn.accessToken) {
            header.SessionHeader = {
                sessionId: conn.accessToken
            };
        }
        if (conn._callOptions) {
            header.CallOptions = conn._callOptions;
        }
        return [
            '<?xml version="1.0" encoding="UTF-8"?>',
            '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"',
            ' xmlns:xsd="http://www.w3.org/2001/XMLSchema"',
            ' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">',
            '<soapenv:Header xmlns="' + this._xmlns + '">',
            toXML(header),
            '</soapenv:Header>',
            '<soapenv:Body xmlns="' + this._xmlns + '">',
            toXML(message),
            '</soapenv:Body>',
            '</soapenv:Envelope>'
        ].join('');
    }
}
exports.SOAP = SOAP;
exports.default = SOAP;
}),
"[project]/node_modules/jsforce/lib/api/metadata/schema.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * This file is generated from WSDL file by wsdl2schema.ts.
 * Do not modify directly.
 * To generate the file, run "ts-node path/to/wsdl2schema.ts path/to/wsdl.xml path/to/schema.ts"
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ApiSchemas = void 0;
exports.ApiSchemas = {
    CancelDeployResult: {
        type: 'CancelDeployResult',
        props: {
            done: 'boolean',
            id: 'string'
        }
    },
    DeployResult: {
        type: 'DeployResult',
        props: {
            canceledBy: '?string',
            canceledByName: '?string',
            checkOnly: 'boolean',
            completedDate: '?string',
            createdBy: 'string',
            createdByName: 'string',
            createdDate: 'string',
            details: 'DeployDetails',
            done: 'boolean',
            errorMessage: '?string',
            errorStatusCode: '?string',
            id: 'string',
            ignoreWarnings: 'boolean',
            lastModifiedDate: '?string',
            numberComponentErrors: 'number',
            numberComponentsDeployed: 'number',
            numberComponentsTotal: 'number',
            numberTestErrors: 'number',
            numberTestsCompleted: 'number',
            numberTestsTotal: 'number',
            rollbackOnError: 'boolean',
            runTestsEnabled: 'boolean',
            startDate: '?string',
            stateDetail: '?string',
            status: 'string',
            success: 'boolean'
        }
    },
    DeployDetails: {
        type: 'DeployDetails',
        props: {
            componentFailures: [
                'DeployMessage'
            ],
            componentSuccesses: [
                'DeployMessage'
            ],
            retrieveResult: '?RetrieveResult',
            runTestResult: '?RunTestsResult'
        }
    },
    DeployMessage: {
        type: 'DeployMessage',
        props: {
            changed: 'boolean',
            columnNumber: '?number',
            componentType: '?string',
            created: 'boolean',
            createdDate: 'string',
            deleted: 'boolean',
            fileName: 'string',
            fullName: 'string',
            id: '?string',
            lineNumber: '?number',
            problem: '?string',
            problemType: '?string',
            success: 'boolean'
        }
    },
    RetrieveResult: {
        type: 'RetrieveResult',
        props: {
            done: 'boolean',
            errorMessage: '?string',
            errorStatusCode: '?string',
            fileProperties: [
                'FileProperties'
            ],
            id: 'string',
            messages: [
                'RetrieveMessage'
            ],
            status: 'string',
            success: 'boolean',
            zipFile: 'string'
        }
    },
    FileProperties: {
        type: 'FileProperties',
        props: {
            createdById: 'string',
            createdByName: 'string',
            createdDate: 'string',
            fileName: 'string',
            fullName: 'string',
            id: 'string',
            lastModifiedById: 'string',
            lastModifiedByName: 'string',
            lastModifiedDate: 'string',
            manageableState: '?string',
            namespacePrefix: '?string',
            type: 'string'
        }
    },
    RetrieveMessage: {
        type: 'RetrieveMessage',
        props: {
            fileName: 'string',
            problem: 'string'
        }
    },
    RunTestsResult: {
        type: 'RunTestsResult',
        props: {
            apexLogId: '?string',
            codeCoverage: [
                'CodeCoverageResult'
            ],
            codeCoverageWarnings: [
                'CodeCoverageWarning'
            ],
            failures: [
                'RunTestFailure'
            ],
            flowCoverage: [
                'FlowCoverageResult'
            ],
            flowCoverageWarnings: [
                'FlowCoverageWarning'
            ],
            numFailures: 'number',
            numTestsRun: 'number',
            successes: [
                'RunTestSuccess'
            ],
            totalTime: 'number'
        }
    },
    CodeCoverageResult: {
        type: 'CodeCoverageResult',
        props: {
            dmlInfo: [
                'CodeLocation'
            ],
            id: 'string',
            locationsNotCovered: [
                'CodeLocation'
            ],
            methodInfo: [
                'CodeLocation'
            ],
            name: 'string',
            namespace: '?string',
            numLocations: 'number',
            numLocationsNotCovered: 'number',
            soqlInfo: [
                'CodeLocation'
            ],
            soslInfo: [
                'CodeLocation'
            ],
            type: 'string'
        }
    },
    CodeLocation: {
        type: 'CodeLocation',
        props: {
            column: 'number',
            line: 'number',
            numExecutions: 'number',
            time: 'number'
        }
    },
    CodeCoverageWarning: {
        type: 'CodeCoverageWarning',
        props: {
            id: 'string',
            message: 'string',
            name: '?string',
            namespace: '?string'
        }
    },
    RunTestFailure: {
        type: 'RunTestFailure',
        props: {
            id: 'string',
            message: 'string',
            methodName: '?string',
            name: 'string',
            namespace: '?string',
            packageName: 'string',
            seeAllData: '?boolean',
            stackTrace: '?string',
            time: 'number',
            type: 'string'
        }
    },
    FlowCoverageResult: {
        type: 'FlowCoverageResult',
        props: {
            elementsNotCovered: [
                'string'
            ],
            flowId: 'string',
            flowName: 'string',
            flowNamespace: '?string',
            numElements: 'number',
            numElementsNotCovered: 'number',
            processType: 'string'
        }
    },
    FlowCoverageWarning: {
        type: 'FlowCoverageWarning',
        props: {
            flowId: '?string',
            flowName: '?string',
            flowNamespace: '?string',
            message: 'string'
        }
    },
    RunTestSuccess: {
        type: 'RunTestSuccess',
        props: {
            id: 'string',
            methodName: 'string',
            name: 'string',
            namespace: '?string',
            seeAllData: '?boolean',
            time: 'number'
        }
    },
    Metadata: {
        type: 'Metadata',
        props: {
            fullName: '?string'
        }
    },
    AccountRelationshipShareRule: {
        type: 'AccountRelationshipShareRule',
        props: {
            accessLevel: 'string',
            accountToCriteriaField: 'string',
            description: '?string',
            entityType: 'string',
            masterLabel: 'string',
            staticFormulaCriteria: '?string',
            type: 'string'
        },
        extends: 'Metadata'
    },
    AccountSettings: {
        type: 'AccountSettings',
        props: {
            enableAccountHistoryTracking: '?boolean',
            enableAccountInsightsInMobile: '?boolean',
            enableAccountOwnerReport: '?boolean',
            enableAccountTeams: '?boolean',
            enableContactHistoryTracking: '?boolean',
            enableRelateContactToMultipleAccounts: '?boolean',
            showViewHierarchyLink: '?boolean'
        },
        extends: 'Metadata'
    },
    ActionLinkGroupTemplate: {
        type: 'ActionLinkGroupTemplate',
        props: {
            actionLinkTemplates: [
                'ActionLinkTemplate'
            ],
            category: 'string',
            executionsAllowed: 'string',
            hoursUntilExpiration: '?number',
            isPublished: 'boolean',
            name: 'string'
        },
        extends: 'Metadata'
    },
    ActionLinkTemplate: {
        type: 'ActionLinkTemplate',
        props: {
            actionUrl: 'string',
            headers: '?string',
            isConfirmationRequired: 'boolean',
            isGroupDefault: 'boolean',
            label: '?string',
            labelKey: 'string',
            linkType: 'string',
            method: 'string',
            position: 'number',
            requestBody: '?string',
            userAlias: '?string',
            userVisibility: 'string'
        }
    },
    ActionPlanTemplate: {
        type: 'ActionPlanTemplate',
        props: {
            actionPlanTemplateItem: [
                'ActionPlanTemplateItem'
            ],
            description: '?string',
            name: 'string',
            targetEntityType: 'string',
            uniqueName: 'string'
        },
        extends: 'Metadata'
    },
    ActionPlanTemplateItem: {
        type: 'ActionPlanTemplateItem',
        props: {
            actionPlanTemplateItemValue: [
                'ActionPlanTemplateItemValue'
            ],
            displayOrder: '?number',
            isRequired: '?boolean',
            name: 'string',
            uniqueName: 'string'
        }
    },
    ActionPlanTemplateItemValue: {
        type: 'ActionPlanTemplateItemValue',
        props: {
            name: 'string',
            valueFormula: '?string',
            valueLiteral: '?string'
        }
    },
    ActionsSettings: {
        type: 'ActionsSettings',
        props: {
            enableDefaultQuickActionsOn: '?boolean',
            enableMdpEnabled: '?boolean',
            enableThirdPartyActions: '?boolean'
        },
        extends: 'Metadata'
    },
    ActivitiesSettings: {
        type: 'ActivitiesSettings',
        props: {
            allowUsersToRelateMultipleContactsToTasksAndEvents: '?boolean',
            autoRelateEventAttendees: '?boolean',
            enableActivityReminders: '?boolean',
            enableClickCreateEvents: '?boolean',
            enableDragAndDropScheduling: '?boolean',
            enableEmailTracking: '?boolean',
            enableGroupTasks: '?boolean',
            enableListViewScheduling: '?boolean',
            enableLogNote: '?boolean',
            enableMultidayEvents: '?boolean',
            enableRecurringEvents: '?boolean',
            enableRecurringTasks: '?boolean',
            enableRollUpActivToContactsAcct: '?boolean',
            enableSidebarCalendarShortcut: '?boolean',
            enableSimpleTaskCreateUI: '?boolean',
            enableUNSTaskDelegatedToNotifications: '?boolean',
            enableUserListViewCalendars: '?boolean',
            meetingRequestsLogo: '?string',
            showCustomLogoMeetingRequests: '?boolean',
            showEventDetailsMultiUserCalendar: '?boolean',
            showHomePageHoverLinksForEvents: '?boolean',
            showMyTasksHoverLinks: '?boolean'
        },
        extends: 'Metadata'
    },
    AddressSettings: {
        type: 'AddressSettings',
        props: {
            countriesAndStates: 'CountriesAndStates'
        },
        extends: 'Metadata'
    },
    CountriesAndStates: {
        type: 'CountriesAndStates',
        props: {
            countries: [
                'Country'
            ]
        }
    },
    Country: {
        type: 'Country',
        props: {
            active: 'boolean',
            integrationValue: 'string',
            isoCode: 'string',
            label: 'string',
            orgDefault: 'boolean',
            standard: 'boolean',
            states: [
                'State'
            ],
            visible: 'boolean'
        }
    },
    State: {
        type: 'State',
        props: {
            active: 'boolean',
            integrationValue: 'string',
            isoCode: 'string',
            label: 'string',
            standard: 'boolean',
            visible: 'boolean'
        }
    },
    AnalyticSnapshot: {
        type: 'AnalyticSnapshot',
        props: {
            description: '?string',
            groupColumn: '?string',
            mappings: [
                'AnalyticSnapshotMapping'
            ],
            name: 'string',
            runningUser: '?string',
            sourceReport: 'string',
            targetObject: 'string'
        },
        extends: 'Metadata'
    },
    AnalyticSnapshotMapping: {
        type: 'AnalyticSnapshotMapping',
        props: {
            aggregateType: '?string',
            sourceField: 'string',
            sourceType: 'string',
            targetField: 'string'
        }
    },
    AnalyticsSettings: {
        type: 'AnalyticsSettings',
        props: {
            alwaysGenPreviews: '?boolean',
            analyticsAdoptionMetadata: '?boolean',
            canAccessAnalyticsViaAPI: '?boolean',
            canAnnotateDashboards: '?boolean',
            canEnableSavedView: '?boolean',
            canExploreDataConversationally: '?boolean',
            canShareAppsWithCommunities: '?boolean',
            canSubscribeDashboardWidgets: '?boolean',
            canViewThumbnailAssets: '?boolean',
            enableAnalyticsSubtotals: '?boolean',
            enableAutoCompleteCombo: '?boolean',
            enableDashboardComponentSnapshot: '?boolean',
            enableDashboardFlexiTable: '?boolean',
            enableEmailReportsToPortalUsers: '?boolean',
            enableFloatingReportHeaders: '?boolean',
            enableInsights: '?boolean',
            enableLightningReportBuilder: '?boolean',
            enableLotusNotesImages: '?boolean',
            enableMassEnableReportBuilder: '?boolean',
            enableNewChartsEngine: '?boolean',
            enablePowerInsights: '?boolean',
            enableRemoveFooterForRepDisplay: '?boolean',
            enableRemoveFooterFromRepExp: '?boolean',
            enableReportFieldToFieldPref: '?boolean',
            enableReportUniqueRowCountPref: '?boolean',
            enableSFXJoinedReportsEnable: '?boolean',
            enableSmartDataDiscovery: '?boolean',
            enableUseOldChartsLookAndFeel: '?boolean',
            enableWaveReplication: '?boolean',
            enableWaveSharingInheritance: '?boolean',
            enableWaveTemplate: '?boolean',
            enableWaveTrendedDatasetCleanup: '?boolean'
        },
        extends: 'Metadata'
    },
    AnimationRule: {
        type: 'AnimationRule',
        props: {
            animationFrequency: 'string',
            developerName: 'string',
            isActive: 'boolean',
            masterLabel: 'string',
            recordTypeContext: 'string',
            recordTypeName: '?string',
            sobjectType: 'string',
            targetField: 'string',
            targetFieldChangeToValues: 'string'
        },
        extends: 'Metadata'
    },
    ApexSettings: {
        type: 'ApexSettings',
        props: {
            enableAggregateCodeCoverageOnly: '?boolean',
            enableApexAccessRightsPref: '?boolean',
            enableApexApprovalLockUnlock: '?boolean',
            enableApexCtrlImplicitWithSharingPref: '?boolean',
            enableApexPropertyGetterPref: '?boolean',
            enableAuraApexCtrlAuthUserAccessCheckPref: '?boolean',
            enableAuraApexCtrlGuestUserAccessCheckPref: '?boolean',
            enableCompileOnDeploy: '?boolean',
            enableDisableParallelApexTesting: '?boolean',
            enableDoNotEmailDebugLog: '?boolean',
            enableGaplessTestAutoNum: '?boolean',
            enableMngdCtrlActionAccessPref: '?boolean',
            enableNonCertifiedApexMdCrud: '?boolean'
        },
        extends: 'Metadata'
    },
    ApexTestSuite: {
        type: 'ApexTestSuite',
        props: {
            testClassName: [
                'string'
            ]
        },
        extends: 'Metadata'
    },
    AppExperienceSettings: {
        type: 'AppExperienceSettings',
        props: {
            doesHideAllAppsInAppLauncher: '?boolean'
        },
        extends: 'Metadata'
    },
    AppMenu: {
        type: 'AppMenu',
        props: {
            appMenuItems: [
                'AppMenuItem'
            ]
        },
        extends: 'Metadata'
    },
    AppMenuItem: {
        type: 'AppMenuItem',
        props: {
            name: 'string',
            type: 'string'
        }
    },
    AppointmentSchedulingPolicy: {
        type: 'AppointmentSchedulingPolicy',
        props: {
            appointmentStartTimeInterval: 'string',
            masterLabel: 'string',
            shouldConsiderCalendarEvents: 'boolean',
            shouldEnforceExcludedResource: 'boolean',
            shouldEnforceRequiredResource: 'boolean',
            shouldMatchSkill: 'boolean',
            shouldMatchSkillLevel: 'boolean',
            shouldRespectVisitingHours: 'boolean',
            shouldUsePrimaryMembers: 'boolean',
            shouldUseSecondaryMembers: 'boolean'
        },
        extends: 'Metadata'
    },
    ApprovalProcess: {
        type: 'ApprovalProcess',
        props: {
            active: 'boolean',
            allowRecall: '?boolean',
            allowedSubmitters: [
                'ApprovalSubmitter'
            ],
            approvalPageFields: '?ApprovalPageField',
            approvalStep: [
                'ApprovalStep'
            ],
            description: '?string',
            emailTemplate: '?string',
            enableMobileDeviceAccess: '?boolean',
            entryCriteria: '?ApprovalEntryCriteria',
            finalApprovalActions: '?ApprovalAction',
            finalApprovalRecordLock: '?boolean',
            finalRejectionActions: '?ApprovalAction',
            finalRejectionRecordLock: '?boolean',
            initialSubmissionActions: '?ApprovalAction',
            label: 'string',
            nextAutomatedApprover: '?NextAutomatedApprover',
            postTemplate: '?string',
            recallActions: '?ApprovalAction',
            recordEditability: 'string',
            showApprovalHistory: '?boolean'
        },
        extends: 'Metadata'
    },
    ApprovalSubmitter: {
        type: 'ApprovalSubmitter',
        props: {
            submitter: '?string',
            type: 'string'
        }
    },
    ApprovalPageField: {
        type: 'ApprovalPageField',
        props: {
            field: [
                'string'
            ]
        }
    },
    ApprovalStep: {
        type: 'ApprovalStep',
        props: {
            allowDelegate: '?boolean',
            approvalActions: '?ApprovalAction',
            assignedApprover: 'ApprovalStepApprover',
            description: '?string',
            entryCriteria: '?ApprovalEntryCriteria',
            ifCriteriaNotMet: '?string',
            label: 'string',
            name: 'string',
            rejectBehavior: '?ApprovalStepRejectBehavior',
            rejectionActions: '?ApprovalAction'
        }
    },
    ApprovalAction: {
        type: 'ApprovalAction',
        props: {
            action: [
                'WorkflowActionReference'
            ]
        }
    },
    WorkflowActionReference: {
        type: 'WorkflowActionReference',
        props: {
            name: 'string',
            type: 'string'
        }
    },
    ApprovalStepApprover: {
        type: 'ApprovalStepApprover',
        props: {
            approver: [
                'Approver'
            ],
            whenMultipleApprovers: '?string'
        }
    },
    Approver: {
        type: 'Approver',
        props: {
            name: '?string',
            type: 'string'
        }
    },
    ApprovalEntryCriteria: {
        type: 'ApprovalEntryCriteria',
        props: {
            booleanFilter: '?string',
            criteriaItems: [
                'FilterItem'
            ],
            formula: '?string'
        }
    },
    FilterItem: {
        type: 'FilterItem',
        props: {
            field: 'string',
            operation: 'string',
            value: '?string',
            valueField: '?string'
        }
    },
    DuplicateRuleFilterItem: {
        type: 'DuplicateRuleFilterItem',
        props: {
            sortOrder: 'number',
            table: 'string'
        },
        extends: 'FilterItem'
    },
    ApprovalStepRejectBehavior: {
        type: 'ApprovalStepRejectBehavior',
        props: {
            type: 'string'
        }
    },
    NextAutomatedApprover: {
        type: 'NextAutomatedApprover',
        props: {
            useApproverFieldOfRecordOwner: '?boolean',
            userHierarchyField: 'string'
        }
    },
    ArchiveSettings: {
        type: 'ArchiveSettings',
        props: {
            enableEntityArchivingEnabled: '?boolean'
        },
        extends: 'Metadata'
    },
    AssignmentRule: {
        type: 'AssignmentRule',
        props: {
            active: '?boolean',
            ruleEntry: [
                'RuleEntry'
            ]
        },
        extends: 'Metadata'
    },
    RuleEntry: {
        type: 'RuleEntry',
        props: {
            assignedTo: '?string',
            assignedToType: '?string',
            booleanFilter: '?string',
            businessHours: '?string',
            businessHoursSource: '?string',
            criteriaItems: [
                'FilterItem'
            ],
            disableEscalationWhenModified: '?boolean',
            escalationAction: [
                'EscalationAction'
            ],
            escalationStartTime: '?string',
            formula: '?string',
            notifyCcRecipients: '?boolean',
            overrideExistingTeams: '?boolean',
            replyToEmail: '?string',
            senderEmail: '?string',
            senderName: '?string',
            team: [
                'string'
            ],
            template: '?string'
        }
    },
    EscalationAction: {
        type: 'EscalationAction',
        props: {
            assignedTo: '?string',
            assignedToTemplate: '?string',
            assignedToType: '?string',
            minutesToEscalation: '?number',
            notifyCaseOwner: '?boolean',
            notifyEmail: [
                'string'
            ],
            notifyTo: '?string',
            notifyToTemplate: '?string'
        }
    },
    AssignmentRules: {
        type: 'AssignmentRules',
        props: {
            assignmentRule: [
                'AssignmentRule'
            ]
        },
        extends: 'Metadata'
    },
    Audience: {
        type: 'Audience',
        props: {
            audienceName: 'string',
            container: 'string',
            criteria: 'AudienceCriteria',
            description: '?string',
            formula: '?string',
            formulaFilterType: '?string',
            targets: '?PersonalizationTargetInfos'
        },
        extends: 'Metadata'
    },
    AudienceCriteria: {
        type: 'AudienceCriteria',
        props: {
            criterion: [
                'AudienceCriterion'
            ]
        }
    },
    AudienceCriterion: {
        type: 'AudienceCriterion',
        props: {
            criteriaNumber: '?number',
            criterionValue: '?AudienceCriteriaValue',
            operator: '?string',
            type: 'string'
        }
    },
    AudienceCriteriaValue: {
        type: 'AudienceCriteriaValue',
        props: {
            city: '?string',
            country: '?string',
            domain: '?string',
            entityField: '?string',
            entityType: '?string',
            fieldValue: '?string',
            isEnabled: '?string',
            permissionName: '?string',
            permissionType: '?string',
            profile: '?string',
            subdivision: '?string'
        }
    },
    PersonalizationTargetInfos: {
        type: 'PersonalizationTargetInfos',
        props: {
            target: [
                'PersonalizationTargetInfo'
            ]
        }
    },
    PersonalizationTargetInfo: {
        type: 'PersonalizationTargetInfo',
        props: {
            groupName: 'string',
            priority: '?number',
            targetType: 'string',
            targetValue: 'string'
        }
    },
    AuraDefinitionBundle: {
        type: 'AuraDefinitionBundle',
        props: {
            SVGContent: '?string',
            apiVersion: '?number',
            controllerContent: '?string',
            description: '?string',
            designContent: '?string',
            documentationContent: '?string',
            helperContent: '?string',
            markup: '?string',
            modelContent: '?string',
            packageVersions: [
                'PackageVersion'
            ],
            rendererContent: '?string',
            styleContent: '?string',
            testsuiteContent: '?string',
            type: '?string'
        },
        extends: 'Metadata'
    },
    PackageVersion: {
        type: 'PackageVersion',
        props: {
            majorNumber: 'number',
            minorNumber: 'number',
            namespace: 'string'
        }
    },
    AuthProvider: {
        type: 'AuthProvider',
        props: {
            appleTeam: '?string',
            authorizeUrl: '?string',
            consumerKey: '?string',
            consumerSecret: '?string',
            customMetadataTypeRecord: '?string',
            defaultScopes: '?string',
            ecKey: '?string',
            errorUrl: '?string',
            executionUser: '?string',
            friendlyName: 'string',
            iconUrl: '?string',
            idTokenIssuer: '?string',
            includeOrgIdInIdentifier: '?boolean',
            linkKickoffUrl: '?string',
            logoutUrl: '?string',
            oauthKickoffUrl: '?string',
            plugin: '?string',
            portal: '?string',
            providerType: 'string',
            registrationHandler: '?string',
            sendAccessTokenInHeader: '?boolean',
            sendClientCredentialsInHeader: '?boolean',
            sendSecretInApis: '?boolean',
            ssoKickoffUrl: '?string',
            tokenUrl: '?string',
            userInfoUrl: '?string'
        },
        extends: 'Metadata'
    },
    AutoResponseRule: {
        type: 'AutoResponseRule',
        props: {
            active: '?boolean',
            ruleEntry: [
                'RuleEntry'
            ]
        },
        extends: 'Metadata'
    },
    AutoResponseRules: {
        type: 'AutoResponseRules',
        props: {
            autoResponseRule: [
                'AutoResponseRule'
            ]
        },
        extends: 'Metadata'
    },
    BlockchainSettings: {
        type: 'BlockchainSettings',
        props: {
            enableBcp: '?boolean',
            enableBcpCoin: '?boolean'
        },
        extends: 'Metadata'
    },
    Bot: {
        type: 'Bot',
        props: {
            botMlDomain: '?LocalMlDomain',
            botUser: '?string',
            botVersions: [
                'BotVersion'
            ],
            contextVariables: [
                'ConversationContextVariable'
            ],
            description: '?string',
            label: '?string'
        },
        extends: 'Metadata'
    },
    LocalMlDomain: {
        type: 'LocalMlDomain',
        props: {
            label: 'string',
            mlIntents: [
                'MlIntent'
            ],
            mlSlotClasses: [
                'MlSlotClass'
            ],
            name: 'string'
        }
    },
    MlIntent: {
        type: 'MlIntent',
        props: {
            description: '?string',
            developerName: 'string',
            label: 'string',
            mlIntentUtterances: [
                'MlIntentUtterance'
            ],
            relatedMlIntents: [
                'MlRelatedIntent'
            ]
        }
    },
    MlIntentUtterance: {
        type: 'MlIntentUtterance',
        props: {
            utterance: 'string'
        }
    },
    MlRelatedIntent: {
        type: 'MlRelatedIntent',
        props: {
            relatedMlIntent: 'string'
        }
    },
    MlSlotClass: {
        type: 'MlSlotClass',
        props: {
            dataType: 'string',
            description: '?string',
            developerName: 'string',
            extractionRegex: '?string',
            extractionType: '?string',
            label: 'string',
            mlSlotClassValues: [
                'MlSlotClassValue'
            ]
        }
    },
    MlSlotClassValue: {
        type: 'MlSlotClassValue',
        props: {
            synonymGroup: '?SynonymGroup',
            value: 'string'
        }
    },
    SynonymGroup: {
        type: 'SynonymGroup',
        props: {
            languages: [
                'string'
            ],
            terms: [
                'string'
            ]
        }
    },
    BotVersion: {
        type: 'BotVersion',
        props: {
            botDialogGroups: [
                'BotDialogGroup'
            ],
            botDialogs: [
                'BotDialog'
            ],
            conversationVariables: [
                'ConversationVariable'
            ],
            entryDialog: 'string',
            mainMenuDialog: 'string',
            responseDelayMilliseconds: '?number'
        },
        extends: 'Metadata'
    },
    BotDialogGroup: {
        type: 'BotDialogGroup',
        props: {
            description: '?string',
            developerName: 'string',
            label: 'string'
        }
    },
    BotDialog: {
        type: 'BotDialog',
        props: {
            botDialogGroup: '?string',
            botSteps: [
                'BotStep'
            ],
            description: '?string',
            developerName: 'string',
            label: 'string',
            mlIntent: '?string',
            mlIntentTrainingEnabled: '?boolean',
            showInFooterMenu: '?boolean'
        }
    },
    BotStep: {
        type: 'BotStep',
        props: {
            booleanFilter: '?string',
            botInvocation: '?BotInvocation',
            botMessages: [
                'BotMessage'
            ],
            botNavigation: '?BotNavigation',
            botStepConditions: [
                'BotStepCondition'
            ],
            botSteps: [
                'BotStep'
            ],
            botVariableOperation: '?BotVariableOperation',
            conversationRecordLookup: '?ConversationRecordLookup',
            conversationSystemMessage: '?ConversationSystemMessage',
            type: 'string'
        }
    },
    BotInvocation: {
        type: 'BotInvocation',
        props: {
            invocationActionName: '?string',
            invocationActionType: '?string',
            invocationMappings: [
                'BotInvocationMapping'
            ]
        }
    },
    BotInvocationMapping: {
        type: 'BotInvocationMapping',
        props: {
            parameterName: 'string',
            type: 'string',
            value: '?string',
            variableName: '?string',
            variableType: '?string'
        }
    },
    BotMessage: {
        type: 'BotMessage',
        props: {
            message: 'string'
        }
    },
    BotNavigation: {
        type: 'BotNavigation',
        props: {
            botNavigationLinks: [
                'BotNavigationLink'
            ],
            type: 'string'
        }
    },
    BotNavigationLink: {
        type: 'BotNavigationLink',
        props: {
            label: '?string',
            targetBotDialog: 'string'
        }
    },
    BotStepCondition: {
        type: 'BotStepCondition',
        props: {
            leftOperandName: 'string',
            leftOperandType: 'string',
            operatorType: 'string',
            rightOperandValue: '?string'
        }
    },
    BotVariableOperation: {
        type: 'BotVariableOperation',
        props: {
            botInvocation: '?BotInvocation',
            botMessages: [
                'BotMessage'
            ],
            botQuickReplyOptions: [
                'BotQuickReplyOption'
            ],
            botVariableOperands: [
                'BotVariableOperand'
            ],
            invalidInputBotNavigation: '?BotNavigation',
            quickReplyOptionTemplate: '?string',
            quickReplyType: '?string',
            quickReplyWidgetType: '?string',
            sourceVariableName: '?string',
            sourceVariableType: '?string',
            type: 'string'
        }
    },
    BotQuickReplyOption: {
        type: 'BotQuickReplyOption',
        props: {
            literalValue: 'string'
        }
    },
    BotVariableOperand: {
        type: 'BotVariableOperand',
        props: {
            disableAutoFill: '?boolean',
            sourceName: '?string',
            sourceType: '?string',
            sourceValue: '?string',
            targetName: 'string',
            targetType: 'string'
        }
    },
    ConversationRecordLookup: {
        type: 'ConversationRecordLookup',
        props: {
            SObjectType: 'string',
            lookupFields: [
                'ConversationRecordLookupField'
            ],
            maxLookupResults: 'number',
            sourceVariableName: 'string',
            sourceVariableType: 'string',
            targetVariableName: 'string'
        }
    },
    ConversationRecordLookupField: {
        type: 'ConversationRecordLookupField',
        props: {
            fieldName: 'string'
        }
    },
    ConversationSystemMessage: {
        type: 'ConversationSystemMessage',
        props: {
            systemMessageMappings: [
                'ConversationSystemMessageMapping'
            ],
            type: 'string'
        }
    },
    ConversationSystemMessageMapping: {
        type: 'ConversationSystemMessageMapping',
        props: {
            mappingType: 'string',
            parameterType: 'string',
            variableName: 'string'
        }
    },
    ConversationVariable: {
        type: 'ConversationVariable',
        props: {
            SObjectType: '?string',
            collectionType: '?string',
            dataType: 'string',
            developerName: 'string',
            label: 'string'
        }
    },
    ConversationContextVariable: {
        type: 'ConversationContextVariable',
        props: {
            SObjectType: '?string',
            contextVariableMappings: [
                'ConversationContextVariableMapping'
            ],
            dataType: 'string',
            developerName: 'string',
            label: 'string'
        }
    },
    ConversationContextVariableMapping: {
        type: 'ConversationContextVariableMapping',
        props: {
            SObjectType: 'string',
            fieldName: 'string',
            messageType: 'string'
        }
    },
    BotSettings: {
        type: 'BotSettings',
        props: {
            enableBots: '?boolean'
        },
        extends: 'Metadata'
    },
    BrandingSet: {
        type: 'BrandingSet',
        props: {
            brandingSetProperty: [
                'BrandingSetProperty'
            ],
            description: '?string',
            masterLabel: 'string',
            type: '?string'
        },
        extends: 'Metadata'
    },
    BrandingSetProperty: {
        type: 'BrandingSetProperty',
        props: {
            propertyName: 'string',
            propertyValue: '?string'
        }
    },
    BusinessHoursEntry: {
        type: 'BusinessHoursEntry',
        props: {
            active: '?boolean',
            default: 'boolean',
            fridayEndTime: '?string',
            fridayStartTime: '?string',
            mondayEndTime: '?string',
            mondayStartTime: '?string',
            name: '?string',
            saturdayEndTime: '?string',
            saturdayStartTime: '?string',
            sundayEndTime: '?string',
            sundayStartTime: '?string',
            thursdayEndTime: '?string',
            thursdayStartTime: '?string',
            timeZoneId: '?string',
            tuesdayEndTime: '?string',
            tuesdayStartTime: '?string',
            wednesdayEndTime: '?string',
            wednesdayStartTime: '?string'
        },
        extends: 'Metadata'
    },
    BusinessHoursSettings: {
        type: 'BusinessHoursSettings',
        props: {
            businessHours: [
                'BusinessHoursEntry'
            ],
            holidays: [
                'Holiday'
            ]
        },
        extends: 'Metadata'
    },
    Holiday: {
        type: 'Holiday',
        props: {
            activityDate: '?string',
            businessHours: [
                'string'
            ],
            description: '?string',
            endTime: '?string',
            isRecurring: '?boolean',
            name: '?string',
            recurrenceDayOfMonth: '?number',
            recurrenceDayOfWeek: [
                'string'
            ],
            recurrenceDayOfWeekMask: '?number',
            recurrenceEndDate: '?string',
            recurrenceInstance: '?string',
            recurrenceInterval: '?number',
            recurrenceMonthOfYear: '?string',
            recurrenceStartDate: '?string',
            recurrenceType: '?string',
            startTime: '?string'
        }
    },
    BusinessProcess: {
        type: 'BusinessProcess',
        props: {
            description: '?string',
            isActive: '?boolean',
            values: [
                'PicklistValue'
            ]
        },
        extends: 'Metadata'
    },
    PicklistValue: {
        type: 'PicklistValue',
        props: {
            color: '?string',
            default: 'boolean',
            description: '?string',
            isActive: '?boolean',
            allowEmail: '?boolean',
            closed: '?boolean',
            controllingFieldValues: [
                'string'
            ],
            converted: '?boolean',
            cssExposed: '?boolean',
            forecastCategory: '?string',
            highPriority: '?boolean',
            probability: '?number',
            reverseRole: '?string',
            reviewed: '?boolean',
            won: '?boolean'
        },
        extends: 'Metadata'
    },
    CMSConnectSource: {
        type: 'CMSConnectSource',
        props: {
            cmsConnectAsset: [
                'CMSConnectAsset'
            ],
            cmsConnectLanguage: [
                'CMSConnectLanguage'
            ],
            cmsConnectPersonalization: '?CMSConnectPersonalization',
            cmsConnectResourceType: [
                'CMSConnectResourceType'
            ],
            connectionType: 'string',
            cssScope: '?string',
            developerName: 'string',
            languageEnabled: '?string',
            masterLabel: 'string',
            namedCredential: '?string',
            personalizationEnabled: '?string',
            rootPath: '?string',
            sortOrder: 'number',
            status: 'string',
            type: 'string',
            websiteUrl: '?string'
        },
        extends: 'Metadata'
    },
    CMSConnectAsset: {
        type: 'CMSConnectAsset',
        props: {
            assetPath: 'string',
            assetType: 'string',
            sortOrder: 'number'
        }
    },
    CMSConnectLanguage: {
        type: 'CMSConnectLanguage',
        props: {
            cmsLanguage: 'string',
            language: 'string'
        }
    },
    CMSConnectPersonalization: {
        type: 'CMSConnectPersonalization',
        props: {
            connectorPage: 'string',
            connectorPageAsset: 'string'
        }
    },
    CMSConnectResourceType: {
        type: 'CMSConnectResourceType',
        props: {
            cmsConnectResourceDefinition: [
                'CMSConnectResourceDefinition'
            ],
            developerName: 'string',
            masterLabel: 'string',
            resourceType: 'string'
        }
    },
    CMSConnectResourceDefinition: {
        type: 'CMSConnectResourceDefinition',
        props: {
            developerName: 'string',
            masterLabel: 'string',
            options: 'number',
            payloadType: 'string',
            resourceIdPath: '?string',
            resourceNamePath: '?string',
            resourcePath: 'string',
            rootNodePath: '?string'
        }
    },
    CallCenter: {
        type: 'CallCenter',
        props: {
            adapterUrl: '?string',
            customSettings: '?string',
            displayName: 'string',
            displayNameLabel: 'string',
            internalNameLabel: 'string',
            sections: [
                'CallCenterSection'
            ],
            version: '?string'
        },
        extends: 'Metadata'
    },
    CallCenterSection: {
        type: 'CallCenterSection',
        props: {
            items: [
                'CallCenterItem'
            ],
            label: 'string',
            name: 'string'
        }
    },
    CallCenterItem: {
        type: 'CallCenterItem',
        props: {
            label: 'string',
            name: 'string',
            value: 'string'
        }
    },
    CampaignInfluenceModel: {
        type: 'CampaignInfluenceModel',
        props: {
            isActive: '?boolean',
            isDefaultModel: 'boolean',
            isModelLocked: 'boolean',
            modelDescription: '?string',
            name: 'string',
            recordPreference: '?string'
        },
        extends: 'Metadata'
    },
    CampaignSettings: {
        type: 'CampaignSettings',
        props: {
            enableAutoCampInfluenceDisabled: '?boolean',
            enableB2bmaCampaignInfluence2: '?boolean',
            enableCampaignHistoryTrackEnabled: '?boolean',
            enableCampaignInfluence2: '?boolean',
            enableCampaignMemberTWCF: '?boolean',
            enableSuppressNoValueCI2: '?boolean'
        },
        extends: 'Metadata'
    },
    CanvasMetadata: {
        type: 'CanvasMetadata',
        props: {
            accessMethod: 'string',
            canvasOptions: '?string',
            canvasUrl: 'string',
            lifecycleClass: '?string',
            locationOptions: '?string',
            samlInitiationMethod: '?string'
        },
        extends: 'Metadata'
    },
    CaseClassificationSettings: {
        type: 'CaseClassificationSettings',
        props: {
            caseClassificationRecommendations: '?boolean',
            reRunAttributeBasedRules: '?boolean',
            runAssignmentRules: '?boolean'
        },
        extends: 'Metadata'
    },
    CaseSettings: {
        type: 'CaseSettings',
        props: {
            caseAssignNotificationTemplate: '?string',
            caseAutoProcUser: '?boolean',
            caseCloseNotificationTemplate: '?string',
            caseCommentNotificationTemplate: '?string',
            caseCreateNotificationTemplate: '?string',
            caseFeedItemSettings: [
                'FeedItemSettings'
            ],
            caseFeedReadUnreadLtng: '?boolean',
            caseMergeInLightning: '?boolean',
            closeCaseThroughStatusChange: '?boolean',
            defaultCaseFeedLayoutOn: '?boolean',
            defaultCaseOwner: '?string',
            defaultCaseOwnerType: '?string',
            defaultCaseUser: '?string',
            emailActionDefaultsHandlerClass: '?string',
            emailToCase: '?EmailToCaseSettings',
            enableCaseFeed: '?boolean',
            enableCollapseEmailThread: '?boolean',
            enableDraftEmails: '?boolean',
            enableEarlyEscalationRuleTriggers: '?boolean',
            enableEmailActionDefaultsHandler: '?boolean',
            enableSuggestedArticlesApplication: '?boolean',
            enableSuggestedArticlesCustomerPortal: '?boolean',
            enableSuggestedArticlesPartnerPortal: '?boolean',
            enableSuggestedSolutions: '?boolean',
            escalateCaseBefore: '?boolean',
            genericMessageEnabled: '?boolean',
            keepRecordTypeOnAssignmentRule: '?boolean',
            notifyContactOnCaseComment: '?boolean',
            notifyDefaultCaseOwner: '?boolean',
            notifyOwnerOnCaseComment: '?boolean',
            notifyOwnerOnCaseOwnerChange: '?boolean',
            predictiveSupportEnabled: '?boolean',
            showEmailAttachmentsInCaseAttachmentsRL: '?boolean',
            showFewerCloseActions: '?boolean',
            systemUserEmail: '?string',
            useSystemEmailAddress: '?boolean',
            useSystemUserAsDefaultCaseUser: '?boolean',
            webToCase: '?WebToCaseSettings'
        },
        extends: 'Metadata'
    },
    FeedItemSettings: {
        type: 'FeedItemSettings',
        props: {
            characterLimit: '?number',
            displayFormat: '?string',
            feedItemType: 'string'
        }
    },
    EmailToCaseSettings: {
        type: 'EmailToCaseSettings',
        props: {
            enableE2CAttachmentAsFile: '?boolean',
            enableE2CSourceTracking: '?boolean',
            enableEmailToCase: '?boolean',
            enableHtmlEmail: '?boolean',
            enableOnDemandEmailToCase: '?boolean',
            enableThreadIDInBody: '?boolean',
            enableThreadIDInSubject: '?boolean',
            notifyOwnerOnNewCaseEmail: '?boolean',
            overEmailLimitAction: '?string',
            preQuoteSignature: '?boolean',
            routingAddresses: [
                'EmailToCaseRoutingAddress'
            ],
            unauthorizedSenderAction: '?string'
        }
    },
    EmailToCaseRoutingAddress: {
        type: 'EmailToCaseRoutingAddress',
        props: {
            addressType: '?string',
            authorizedSenders: '?string',
            caseOrigin: '?string',
            caseOwner: '?string',
            caseOwnerType: '?string',
            casePriority: '?string',
            createTask: '?boolean',
            emailAddress: '?string',
            emailServicesAddress: '?string',
            isVerified: '?boolean',
            routingName: '?string',
            saveEmailHeaders: '?boolean',
            taskStatus: '?string'
        }
    },
    WebToCaseSettings: {
        type: 'WebToCaseSettings',
        props: {
            caseOrigin: '?string',
            defaultResponseTemplate: '?string',
            enableWebToCase: '?boolean'
        }
    },
    CaseSubjectParticle: {
        type: 'CaseSubjectParticle',
        props: {
            index: 'number',
            textField: '?string',
            type: 'string'
        },
        extends: 'Metadata'
    },
    ChannelLayout: {
        type: 'ChannelLayout',
        props: {
            enabledChannels: [
                'string'
            ],
            label: 'string',
            layoutItems: [
                'ChannelLayoutItem'
            ],
            recordType: '?string'
        },
        extends: 'Metadata'
    },
    ChannelLayoutItem: {
        type: 'ChannelLayoutItem',
        props: {
            field: 'string'
        }
    },
    ChatterAnswersSettings: {
        type: 'ChatterAnswersSettings',
        props: {
            emailFollowersOnBestAnswer: '?boolean',
            emailFollowersOnReply: '?boolean',
            emailOwnerOnPrivateReply: '?boolean',
            emailOwnerOnReply: '?boolean',
            enableAnswerViaEmail: '?boolean',
            enableChatterAnswers: 'boolean',
            enableFacebookSSO: '?boolean',
            enableInlinePublisher: '?boolean',
            enableReputation: '?boolean',
            enableRichTextEditor: '?boolean',
            facebookAuthProvider: '?string',
            showInPortals: '?boolean'
        },
        extends: 'Metadata'
    },
    ChatterEmailsMDSettings: {
        type: 'ChatterEmailsMDSettings',
        props: {
            enableChatterDigestEmailsApiOnly: '?boolean',
            enableChatterEmailAttachment: '?boolean',
            enableCollaborationEmail: '?boolean',
            enableDisplayAppDownloadBadges: '?boolean',
            enableEmailReplyToChatter: '?boolean',
            enableEmailToChatter: '?boolean'
        },
        extends: 'Metadata'
    },
    ChatterExtension: {
        type: 'ChatterExtension',
        props: {
            compositionComponent: 'string',
            description: 'string',
            extensionName: 'string',
            headerText: '?string',
            hoverText: '?string',
            icon: 'string',
            isProtected: '?boolean',
            masterLabel: 'string',
            renderComponent: 'string',
            type: 'string'
        },
        extends: 'Metadata'
    },
    ChatterSettings: {
        type: 'ChatterSettings',
        props: {
            allowChatterGroupArchiving: '?boolean',
            allowRecordsInChatterGroup: '?boolean',
            allowSharingInChatterGroup: '?boolean',
            enableApprovalRequest: '?boolean',
            enableChatter: '?boolean',
            enableChatterEmoticons: '?boolean',
            enableFeedEdit: '?boolean',
            enableFeedPinning: '?boolean',
            enableFeedsDraftPosts: '?boolean',
            enableFeedsRichText: '?boolean',
            enableInviteCsnUsers: '?boolean',
            enableOutOfOfficeEnabledPref: '?boolean',
            enableRichLinkPreviewsInFeed: '?boolean',
            enableTodayRecsInFeed: '?boolean',
            unlistedGroupsEnabled: '?boolean'
        },
        extends: 'Metadata'
    },
    CleanDataService: {
        type: 'CleanDataService',
        props: {
            cleanRules: [
                'CleanRule'
            ],
            description: 'string',
            masterLabel: 'string',
            matchEngine: 'string'
        },
        extends: 'Metadata'
    },
    CleanRule: {
        type: 'CleanRule',
        props: {
            bulkEnabled: 'boolean',
            bypassTriggers: 'boolean',
            bypassWorkflow: 'boolean',
            description: 'string',
            developerName: 'string',
            fieldMappings: [
                'FieldMapping'
            ],
            masterLabel: 'string',
            matchRule: 'string',
            sourceSobjectType: 'string',
            status: 'string',
            targetSobjectType: 'string'
        }
    },
    FieldMapping: {
        type: 'FieldMapping',
        props: {
            SObjectType: 'string',
            developerName: 'string',
            fieldMappingRows: [
                'FieldMappingRow'
            ],
            masterLabel: 'string'
        }
    },
    FieldMappingRow: {
        type: 'FieldMappingRow',
        props: {
            SObjectType: 'string',
            fieldMappingFields: [
                'FieldMappingField'
            ],
            fieldName: 'string',
            mappingOperation: 'string'
        }
    },
    FieldMappingField: {
        type: 'FieldMappingField',
        props: {
            dataServiceField: 'string',
            dataServiceObjectName: 'string',
            priority: 'number'
        }
    },
    CommandAction: {
        type: 'CommandAction',
        props: {
            actionType: 'string',
            description: '?string',
            intents: [
                'CommandActionIntent'
            ],
            label: 'string',
            parameters: [
                'CommandActionParam'
            ],
            responseTemplates: [
                'CommandActionResponse'
            ],
            target: '?string'
        },
        extends: 'Metadata'
    },
    CommandActionIntent: {
        type: 'CommandActionIntent',
        props: {
            phrase: 'string',
            responseTemplates: [
                'CommandActionResponse'
            ]
        }
    },
    CommandActionResponse: {
        type: 'CommandActionResponse',
        props: {
            template: 'string'
        }
    },
    CommandActionParam: {
        type: 'CommandActionParam',
        props: {
            defaultValue: '?string',
            description: '?string',
            name: 'string',
            required: '?boolean',
            type: 'string'
        }
    },
    CommunitiesSettings: {
        type: 'CommunitiesSettings',
        props: {
            canModerateAllFeedPosts: '?boolean',
            canModerateInternalFeedPosts: '?boolean',
            embeddedVisualforcePages: '?boolean',
            enableCommunityWorkspaces: '?boolean',
            enableCspContactVisibilityPref: '?boolean',
            enableCspNotesOnAccConPref: '?boolean',
            enableEnablePRM: '?boolean',
            enableExternalAccHierPref: '?boolean',
            enableGuestRecordReassignOrgPref: '?boolean',
            enableInviteChatterGuestEnabled: '?boolean',
            enableNetPortalUserReportOpts: '?boolean',
            enableNetworksEnabled: '?boolean',
            enableOotbProfExtUserOpsEnable: '?boolean',
            enablePRMAccRelPref: '?boolean',
            enablePowerCustomerCaseStatus: '?boolean',
            enableRelaxPartnerAccountFieldPref: '?boolean',
            enableUsernameUniqForOrgPref: '?boolean'
        },
        extends: 'Metadata'
    },
    Community: {
        type: 'Community',
        props: {
            active: '?boolean',
            chatterAnswersFacebookSsoUrl: '?string',
            communityFeedPage: '?string',
            dataCategoryName: '?string',
            description: '?string',
            emailFooterDocument: '?string',
            emailHeaderDocument: '?string',
            emailNotificationUrl: '?string',
            enableChatterAnswers: '?boolean',
            enablePrivateQuestions: '?boolean',
            expertsGroup: '?string',
            portal: '?string',
            reputationLevels: '?ReputationLevels',
            showInPortal: '?boolean',
            site: '?string'
        },
        extends: 'Metadata'
    },
    ReputationLevels: {
        type: 'ReputationLevels',
        props: {
            chatterAnswersReputationLevels: [
                'ChatterAnswersReputationLevel'
            ],
            ideaReputationLevels: [
                'IdeaReputationLevel'
            ]
        }
    },
    ChatterAnswersReputationLevel: {
        type: 'ChatterAnswersReputationLevel',
        props: {
            name: 'string',
            value: 'number'
        }
    },
    IdeaReputationLevel: {
        type: 'IdeaReputationLevel',
        props: {
            name: 'string',
            value: 'number'
        }
    },
    CommunityTemplateDefinition: {
        type: 'CommunityTemplateDefinition',
        props: {
            baseTemplate: '?string',
            bundlesInfo: [
                'CommunityTemplateBundleInfo'
            ],
            category: 'string',
            defaultBrandingSet: '?string',
            defaultThemeDefinition: 'string',
            description: '?string',
            enableExtendedCleanUpOnDelete: '?boolean',
            masterLabel: 'string',
            navigationLinkSet: [
                'NavigationLinkSet'
            ],
            pageSetting: [
                'CommunityTemplatePageSetting'
            ],
            publisher: '?string'
        },
        extends: 'Metadata'
    },
    CommunityTemplateBundleInfo: {
        type: 'CommunityTemplateBundleInfo',
        props: {
            description: '?string',
            image: '?string',
            order: 'number',
            title: 'string',
            type: 'string'
        }
    },
    CommunityThemeBundleInfo: {
        type: 'CommunityThemeBundleInfo',
        props: {},
        extends: 'CommunityTemplateBundleInfo'
    },
    NavigationLinkSet: {
        type: 'NavigationLinkSet',
        props: {
            navigationMenuItem: [
                'NavigationMenuItem'
            ]
        }
    },
    NavigationMenuItem: {
        type: 'NavigationMenuItem',
        props: {
            defaultListViewId: '?string',
            label: 'string',
            menuItemBranding: '?NavigationMenuItemBranding',
            position: 'number',
            publiclyAvailable: '?boolean',
            subMenu: '?NavigationSubMenu',
            target: '?string',
            targetPreference: '?string',
            type: 'string'
        }
    },
    NavigationMenuItemBranding: {
        type: 'NavigationMenuItemBranding',
        props: {
            tileImage: '?string'
        }
    },
    NavigationSubMenu: {
        type: 'NavigationSubMenu',
        props: {
            navigationMenuItem: [
                'NavigationMenuItem'
            ]
        }
    },
    CommunityTemplatePageSetting: {
        type: 'CommunityTemplatePageSetting',
        props: {
            page: 'string',
            themeLayout: 'string'
        }
    },
    CommunityThemeDefinition: {
        type: 'CommunityThemeDefinition',
        props: {
            bundlesInfo: [
                'CommunityThemeBundleInfo'
            ],
            customThemeLayoutType: [
                'CommunityCustomThemeLayoutType'
            ],
            defaultBrandingSet: '?string',
            description: '?string',
            enableExtendedCleanUpOnDelete: '?boolean',
            masterLabel: 'string',
            publisher: '?string',
            themeRouteOverride: [
                'CommunityThemeRouteOverride'
            ],
            themeSetting: [
                'CommunityThemeSetting'
            ]
        },
        extends: 'Metadata'
    },
    CommunityCustomThemeLayoutType: {
        type: 'CommunityCustomThemeLayoutType',
        props: {
            description: '?string',
            label: 'string'
        }
    },
    CommunityThemeRouteOverride: {
        type: 'CommunityThemeRouteOverride',
        props: {
            customThemeLayoutType: '?string',
            pageAttributes: 'string',
            pageType: 'string',
            themeLayoutType: '?string'
        }
    },
    CommunityThemeSetting: {
        type: 'CommunityThemeSetting',
        props: {
            customThemeLayoutType: '?string',
            themeLayout: 'string',
            themeLayoutType: '?string'
        }
    },
    CompactLayout: {
        type: 'CompactLayout',
        props: {
            fields: [
                'string'
            ],
            label: 'string'
        },
        extends: 'Metadata'
    },
    CompanySettings: {
        type: 'CompanySettings',
        props: {
            enableCustomFiscalYear: 'boolean',
            fiscalYear: '?FiscalYearSettings'
        },
        extends: 'Metadata'
    },
    FiscalYearSettings: {
        type: 'FiscalYearSettings',
        props: {
            fiscalYearNameBasedOn: '?string',
            startMonth: '?string'
        }
    },
    ConnectedApp: {
        type: 'ConnectedApp',
        props: {
            attributes: [
                'ConnectedAppAttribute'
            ],
            canvas: '?CanvasMetadata',
            canvasConfig: '?ConnectedAppCanvasConfig',
            contactEmail: 'string',
            contactPhone: '?string',
            description: '?string',
            iconUrl: '?string',
            infoUrl: '?string',
            ipRanges: [
                'ConnectedAppIpRange'
            ],
            label: 'string',
            logoUrl: '?string',
            mobileAppConfig: '?ConnectedAppMobileDetailConfig',
            mobileStartUrl: '?string',
            oauthConfig: '?ConnectedAppOauthConfig',
            permissionSetName: [
                'string'
            ],
            plugin: '?string',
            pluginExecutionUser: '?string',
            profileName: [
                'string'
            ],
            samlConfig: '?ConnectedAppSamlConfig',
            startUrl: '?string'
        },
        extends: 'Metadata'
    },
    ConnectedAppAttribute: {
        type: 'ConnectedAppAttribute',
        props: {
            formula: 'string',
            key: 'string'
        }
    },
    ConnectedAppCanvasConfig: {
        type: 'ConnectedAppCanvasConfig',
        props: {
            accessMethod: 'string',
            canvasUrl: 'string',
            lifecycleClass: '?string',
            locations: [
                'string'
            ],
            options: [
                'string'
            ],
            samlInitiationMethod: '?string'
        }
    },
    ConnectedAppIpRange: {
        type: 'ConnectedAppIpRange',
        props: {
            description: '?string',
            end: 'string',
            start: 'string'
        }
    },
    ConnectedAppMobileDetailConfig: {
        type: 'ConnectedAppMobileDetailConfig',
        props: {
            applicationBinaryFile: '?string',
            applicationBinaryFileName: '?string',
            applicationBundleIdentifier: '?string',
            applicationFileLength: '?number',
            applicationIconFile: '?string',
            applicationIconFileName: '?string',
            applicationInstallUrl: '?string',
            devicePlatform: 'string',
            deviceType: '?string',
            minimumOsVersion: '?string',
            privateApp: '?boolean',
            version: 'string'
        }
    },
    ConnectedAppOauthConfig: {
        type: 'ConnectedAppOauthConfig',
        props: {
            callbackUrl: 'string',
            certificate: '?string',
            consumerKey: '?string',
            consumerSecret: '?string',
            idTokenConfig: '?ConnectedAppOauthIdToken',
            isAdminApproved: '?boolean',
            scopes: [
                'string'
            ],
            singleLogoutUrl: '?string'
        }
    },
    ConnectedAppOauthIdToken: {
        type: 'ConnectedAppOauthIdToken',
        props: {
            idTokenAudience: '?string',
            idTokenIncludeAttributes: '?boolean',
            idTokenIncludeCustomPerms: '?boolean',
            idTokenIncludeStandardClaims: '?boolean',
            idTokenValidity: '?number'
        }
    },
    ConnectedAppSamlConfig: {
        type: 'ConnectedAppSamlConfig',
        props: {
            acsUrl: 'string',
            certificate: '?string',
            encryptionCertificate: '?string',
            encryptionType: '?string',
            entityUrl: 'string',
            issuer: '?string',
            samlIdpSLOBindingEnum: '?string',
            samlNameIdFormat: '?string',
            samlSloUrl: '?string',
            samlSubjectCustomAttr: '?string',
            samlSubjectType: 'string'
        }
    },
    ConnectedAppSettings: {
        type: 'ConnectedAppSettings',
        props: {
            enableAdminApprovedAppsOnly: '?boolean',
            enableSkipUserProvisioningWizardWelcomePage: '?boolean'
        },
        extends: 'Metadata'
    },
    ContentSettings: {
        type: 'ContentSettings',
        props: {
            enableChatterFileLink: '?boolean',
            enableContent: '?boolean',
            enableContentAutoAssign: '?boolean',
            enableContentDistForPortalUsers: '?boolean',
            enableContentDistPwOptionsBit1: '?boolean',
            enableContentDistPwOptionsBit2: '?boolean',
            enableContentDistribution: '?boolean',
            enableContentSupportMultiLanguage: '?boolean',
            enableContentWorkspaceAccess: '?boolean',
            enableFileShareSetByRecord: '?boolean',
            enableFilesUsrShareNetRestricted: '?boolean',
            enableJPGPreviews: '?boolean',
            enableLibraryManagedFiles: '?boolean',
            enableSiteGuestUserToUploadFiles: '?boolean',
            enableUploadFilesOnAttachments: '?boolean',
            skipContentAssetTriggers: '?boolean',
            skipContentAssetTriggersOnDeploy: '?boolean'
        },
        extends: 'Metadata'
    },
    ContractSettings: {
        type: 'ContractSettings',
        props: {
            autoCalculateEndDate: '?boolean',
            autoExpirationDelay: '?string',
            autoExpirationRecipient: '?string',
            autoExpireContracts: '?boolean',
            enableContractHistoryTracking: '?boolean',
            notifyOwnersOnContractExpiration: '?boolean'
        },
        extends: 'Metadata'
    },
    CorsWhitelistOrigin: {
        type: 'CorsWhitelistOrigin',
        props: {
            urlPattern: 'string'
        },
        extends: 'Metadata'
    },
    CspTrustedSite: {
        type: 'CspTrustedSite',
        props: {
            context: '?string',
            description: '?string',
            endpointUrl: 'string',
            isActive: 'boolean'
        },
        extends: 'Metadata'
    },
    CurrencySettings: {
        type: 'CurrencySettings',
        props: {
            enableCurrencyEffectiveDates: '?boolean',
            enableCurrencySymbolWithMultiCurrency: '?boolean',
            enableMultiCurrency: '?boolean',
            isMultiCurrencyActivationAllowed: '?boolean',
            isParenCurrencyConvDisabled: '?boolean'
        },
        extends: 'Metadata'
    },
    CustomApplication: {
        type: 'CustomApplication',
        props: {
            actionOverrides: [
                'AppActionOverride'
            ],
            brand: '?AppBrand',
            consoleConfig: '?ServiceCloudConsoleConfig',
            defaultLandingTab: '?string',
            description: '?string',
            formFactors: [
                'string'
            ],
            isNavAutoTempTabsDisabled: '?boolean',
            isNavPersonalizationDisabled: '?boolean',
            isServiceCloudConsole: '?boolean',
            label: '?string',
            logo: '?string',
            navType: '?string',
            preferences: '?AppPreferences',
            profileActionOverrides: [
                'AppProfileActionOverride'
            ],
            setupExperience: '?string',
            subscriberTabs: [
                'string'
            ],
            tabs: [
                'string'
            ],
            uiType: '?string',
            utilityBar: '?string',
            workspaceConfig: '?AppWorkspaceConfig'
        },
        extends: 'Metadata'
    },
    AppActionOverride: {
        type: 'AppActionOverride',
        props: {
            pageOrSobjectType: 'string'
        },
        extends: 'ActionOverride'
    },
    ActionOverride: {
        type: 'ActionOverride',
        props: {
            actionName: '?string',
            comment: '?string',
            content: '?string',
            formFactor: '?string',
            skipRecordTypeSelect: '?boolean',
            type: '?string'
        }
    },
    AppBrand: {
        type: 'AppBrand',
        props: {
            footerColor: '?string',
            headerColor: '?string',
            logo: '?string',
            logoVersion: '?number',
            shouldOverrideOrgTheme: '?boolean'
        }
    },
    ServiceCloudConsoleConfig: {
        type: 'ServiceCloudConsoleConfig',
        props: {
            componentList: '?AppComponentList',
            detailPageRefreshMethod: 'string',
            footerColor: '?string',
            headerColor: '?string',
            keyboardShortcuts: 'KeyboardShortcuts',
            listPlacement: 'ListPlacement',
            listRefreshMethod: 'string',
            liveAgentConfig: '?LiveAgentConfig',
            primaryTabColor: '?string',
            pushNotifications: [
                'PushNotification'
            ],
            tabLimitConfig: '?TabLimitConfig',
            whitelistedDomains: [
                'string'
            ]
        }
    },
    AppComponentList: {
        type: 'AppComponentList',
        props: {
            alignment: 'string',
            components: [
                'string'
            ]
        }
    },
    KeyboardShortcuts: {
        type: 'KeyboardShortcuts',
        props: {
            customShortcuts: [
                'CustomShortcut'
            ],
            defaultShortcuts: [
                'DefaultShortcut'
            ]
        }
    },
    CustomShortcut: {
        type: 'CustomShortcut',
        props: {
            description: '?string',
            eventName: 'string'
        },
        extends: 'DefaultShortcut'
    },
    DefaultShortcut: {
        type: 'DefaultShortcut',
        props: {
            action: 'string',
            active: 'boolean',
            keyCommand: 'string'
        }
    },
    ListPlacement: {
        type: 'ListPlacement',
        props: {
            height: '?number',
            location: 'string',
            units: '?string',
            width: '?number'
        }
    },
    LiveAgentConfig: {
        type: 'LiveAgentConfig',
        props: {
            enableLiveChat: '?boolean',
            openNewAccountSubtab: '?boolean',
            openNewCaseSubtab: '?boolean',
            openNewContactSubtab: '?boolean',
            openNewLeadSubtab: '?boolean',
            openNewVFPageSubtab: '?boolean',
            pageNamesToOpen: [
                'string'
            ],
            showKnowledgeArticles: '?boolean'
        }
    },
    PushNotification: {
        type: 'PushNotification',
        props: {
            fieldNames: [
                'string'
            ],
            objectName: 'string'
        }
    },
    TabLimitConfig: {
        type: 'TabLimitConfig',
        props: {
            maxNumberOfPrimaryTabs: '?string',
            maxNumberOfSubTabs: '?string'
        }
    },
    AppPreferences: {
        type: 'AppPreferences',
        props: {
            enableCustomizeMyTabs: 'boolean',
            enableKeyboardShortcuts: 'boolean',
            enableListViewHover: 'boolean',
            enableListViewReskin: 'boolean',
            enableMultiMonitorComponents: 'boolean',
            enablePinTabs: 'boolean',
            enableTabHover: 'boolean',
            enableTabLimits: 'boolean',
            saveUserSessions: 'boolean'
        }
    },
    AppProfileActionOverride: {
        type: 'AppProfileActionOverride',
        props: {
            profile: 'string'
        },
        extends: 'ProfileActionOverride'
    },
    ProfileActionOverride: {
        type: 'ProfileActionOverride',
        props: {
            actionName: 'string',
            content: '?string',
            formFactor: 'string',
            pageOrSobjectType: 'string',
            recordType: '?string',
            type: 'string'
        }
    },
    AppWorkspaceConfig: {
        type: 'AppWorkspaceConfig',
        props: {
            mappings: [
                'WorkspaceMapping'
            ]
        }
    },
    WorkspaceMapping: {
        type: 'WorkspaceMapping',
        props: {
            fieldName: '?string',
            tab: 'string'
        }
    },
    CustomApplicationComponent: {
        type: 'CustomApplicationComponent',
        props: {
            buttonIconUrl: '?string',
            buttonStyle: '?string',
            buttonText: '?string',
            buttonWidth: '?number',
            height: '?number',
            isHeightFixed: 'boolean',
            isHidden: 'boolean',
            isWidthFixed: 'boolean',
            visualforcePage: 'string',
            width: '?number'
        },
        extends: 'Metadata'
    },
    CustomFeedFilter: {
        type: 'CustomFeedFilter',
        props: {
            criteria: [
                'FeedFilterCriterion'
            ],
            description: '?string',
            isProtected: '?boolean',
            label: 'string'
        },
        extends: 'Metadata'
    },
    FeedFilterCriterion: {
        type: 'FeedFilterCriterion',
        props: {
            feedItemType: 'string',
            feedItemVisibility: '?string',
            relatedSObjectType: '?string'
        }
    },
    CustomField: {
        type: 'CustomField',
        props: {
            businessOwnerGroup: '?string',
            businessOwnerUser: '?string',
            businessStatus: '?string',
            caseSensitive: '?boolean',
            complianceGroup: '?string',
            customDataType: '?string',
            defaultValue: '?string',
            deleteConstraint: '?string',
            deprecated: '?boolean',
            description: '?string',
            displayFormat: '?string',
            encryptionScheme: '?string',
            escapeMarkup: '?boolean',
            externalDeveloperName: '?string',
            externalId: '?boolean',
            fieldManageability: '?string',
            formula: '?string',
            formulaTreatBlanksAs: '?string',
            inlineHelpText: '?string',
            isAIPredictionField: '?boolean',
            isConvertLeadDisabled: '?boolean',
            isFilteringDisabled: '?boolean',
            isNameField: '?boolean',
            isSortingDisabled: '?boolean',
            label: '?string',
            length: '?number',
            lookupFilter: '?LookupFilter',
            maskChar: '?string',
            maskType: '?string',
            metadataRelationshipControllingField: '?string',
            populateExistingRows: '?boolean',
            precision: '?number',
            referenceTargetField: '?string',
            referenceTo: '?string',
            relationshipLabel: '?string',
            relationshipName: '?string',
            relationshipOrder: '?number',
            reparentableMasterDetail: '?boolean',
            required: '?boolean',
            restrictedAdminField: '?boolean',
            scale: '?number',
            securityClassification: '?string',
            startingNumber: '?number',
            stripMarkup: '?boolean',
            summarizedField: '?string',
            summaryFilterItems: [
                'FilterItem'
            ],
            summaryForeignKey: '?string',
            summaryOperation: '?string',
            trackFeedHistory: '?boolean',
            trackHistory: '?boolean',
            trackTrending: '?boolean',
            translateData: '?boolean',
            type: '?string',
            unique: '?boolean',
            valueSet: '?ValueSet',
            visibleLines: '?number',
            writeRequiresMasterRead: '?boolean'
        },
        extends: 'Metadata'
    },
    LookupFilter: {
        type: 'LookupFilter',
        props: {
            active: 'boolean',
            booleanFilter: '?string',
            description: '?string',
            errorMessage: '?string',
            filterItems: [
                'FilterItem'
            ],
            infoMessage: '?string',
            isOptional: 'boolean'
        }
    },
    ValueSet: {
        type: 'ValueSet',
        props: {
            controllingField: '?string',
            restricted: '?boolean',
            valueSetDefinition: '?ValueSetValuesDefinition',
            valueSetName: '?string',
            valueSettings: [
                'ValueSettings'
            ]
        }
    },
    ValueSetValuesDefinition: {
        type: 'ValueSetValuesDefinition',
        props: {
            sorted: 'boolean',
            value: [
                'CustomValue'
            ]
        }
    },
    CustomValue: {
        type: 'CustomValue',
        props: {
            color: '?string',
            default: 'boolean',
            description: '?string',
            isActive: '?boolean',
            label: '?string'
        },
        extends: 'Metadata'
    },
    StandardValue: {
        type: 'StandardValue',
        props: {
            allowEmail: '?boolean',
            closed: '?boolean',
            converted: '?boolean',
            cssExposed: '?boolean',
            forecastCategory: '?string',
            groupingString: '?string',
            highPriority: '?boolean',
            probability: '?number',
            reverseRole: '?string',
            reviewed: '?boolean',
            won: '?boolean'
        },
        extends: 'CustomValue'
    },
    ValueSettings: {
        type: 'ValueSettings',
        props: {
            controllingFieldValue: [
                'string'
            ],
            valueName: 'string'
        }
    },
    CustomHelpMenuSection: {
        type: 'CustomHelpMenuSection',
        props: {
            customHelpMenuItems: [
                'CustomHelpMenuItem'
            ],
            masterLabel: 'string'
        },
        extends: 'Metadata'
    },
    CustomHelpMenuItem: {
        type: 'CustomHelpMenuItem',
        props: {
            linkUrl: 'string',
            masterLabel: 'string',
            sortOrder: 'number'
        }
    },
    CustomLabel: {
        type: 'CustomLabel',
        props: {
            categories: '?string',
            language: 'string',
            protected: 'boolean',
            shortDescription: 'string',
            value: 'string'
        },
        extends: 'Metadata'
    },
    CustomLabels: {
        type: 'CustomLabels',
        props: {
            labels: [
                'CustomLabel'
            ]
        },
        extends: 'Metadata'
    },
    CustomMetadata: {
        type: 'CustomMetadata',
        props: {
            description: '?string',
            label: '?string',
            protected: '?boolean',
            values: [
                'CustomMetadataValue'
            ]
        },
        extends: 'Metadata'
    },
    CustomMetadataValue: {
        type: 'CustomMetadataValue',
        props: {
            field: 'string',
            value: '?any'
        }
    },
    CustomNotificationType: {
        type: 'CustomNotificationType',
        props: {
            customNotifTypeName: 'string',
            description: '?string',
            desktop: 'boolean',
            masterLabel: 'string',
            mobile: 'boolean'
        },
        extends: 'Metadata'
    },
    CustomObject: {
        type: 'CustomObject',
        props: {
            actionOverrides: [
                'ActionOverride'
            ],
            allowInChatterGroups: '?boolean',
            articleTypeChannelDisplay: '?ArticleTypeChannelDisplay',
            businessProcesses: [
                'BusinessProcess'
            ],
            compactLayoutAssignment: '?string',
            compactLayouts: [
                'CompactLayout'
            ],
            customHelp: '?string',
            customHelpPage: '?string',
            customSettingsType: '?string',
            deploymentStatus: '?string',
            deprecated: '?boolean',
            description: '?string',
            enableActivities: '?boolean',
            enableBulkApi: '?boolean',
            enableDataTranslation: '?boolean',
            enableDivisions: '?boolean',
            enableEnhancedLookup: '?boolean',
            enableFeeds: '?boolean',
            enableHistory: '?boolean',
            enableLicensing: '?boolean',
            enableReports: '?boolean',
            enableSearch: '?boolean',
            enableSharing: '?boolean',
            enableStreamingApi: '?boolean',
            eventType: '?string',
            externalDataSource: '?string',
            externalName: '?string',
            externalRepository: '?string',
            externalSharingModel: '?string',
            fieldSets: [
                'FieldSet'
            ],
            fields: [
                'CustomField'
            ],
            gender: '?string',
            historyRetentionPolicy: '?HistoryRetentionPolicy',
            household: '?boolean',
            indexes: [
                'Index'
            ],
            label: '?string',
            listViews: [
                'ListView'
            ],
            nameField: '?CustomField',
            pluralLabel: '?string',
            profileSearchLayouts: [
                'ProfileSearchLayouts'
            ],
            publishBehavior: '?string',
            recordTypeTrackFeedHistory: '?boolean',
            recordTypeTrackHistory: '?boolean',
            recordTypes: [
                'RecordType'
            ],
            searchLayouts: '?SearchLayouts',
            sharingModel: '?string',
            sharingReasons: [
                'SharingReason'
            ],
            sharingRecalculations: [
                'SharingRecalculation'
            ],
            startsWith: '?string',
            validationRules: [
                'ValidationRule'
            ],
            visibility: '?string',
            webLinks: [
                'WebLink'
            ]
        },
        extends: 'Metadata'
    },
    ArticleTypeChannelDisplay: {
        type: 'ArticleTypeChannelDisplay',
        props: {
            articleTypeTemplates: [
                'ArticleTypeTemplate'
            ]
        }
    },
    ArticleTypeTemplate: {
        type: 'ArticleTypeTemplate',
        props: {
            channel: 'string',
            page: '?string',
            template: 'string'
        }
    },
    FieldSet: {
        type: 'FieldSet',
        props: {
            availableFields: [
                'FieldSetItem'
            ],
            description: 'string',
            displayedFields: [
                'FieldSetItem'
            ],
            label: 'string'
        },
        extends: 'Metadata'
    },
    FieldSetItem: {
        type: 'FieldSetItem',
        props: {
            field: '?string',
            isFieldManaged: '?boolean',
            isRequired: '?boolean'
        }
    },
    HistoryRetentionPolicy: {
        type: 'HistoryRetentionPolicy',
        props: {
            archiveAfterMonths: 'number',
            archiveRetentionYears: 'number',
            description: '?string'
        }
    },
    Index: {
        type: 'Index',
        props: {
            fields: [
                'IndexField'
            ],
            label: 'string'
        },
        extends: 'Metadata'
    },
    IndexField: {
        type: 'IndexField',
        props: {
            name: 'string',
            sortDirection: 'string'
        }
    },
    ListView: {
        type: 'ListView',
        props: {
            booleanFilter: '?string',
            columns: [
                'string'
            ],
            division: '?string',
            filterScope: 'string',
            filters: [
                'ListViewFilter'
            ],
            label: 'string',
            language: '?string',
            queue: '?string',
            sharedTo: '?SharedTo'
        },
        extends: 'Metadata'
    },
    ListViewFilter: {
        type: 'ListViewFilter',
        props: {
            field: 'string',
            operation: 'string',
            value: '?string'
        }
    },
    SharedTo: {
        type: 'SharedTo',
        props: {
            allCustomerPortalUsers: '?string',
            allInternalUsers: '?string',
            allPartnerUsers: '?string',
            channelProgramGroup: [
                'string'
            ],
            channelProgramGroups: [
                'string'
            ],
            group: [
                'string'
            ],
            groups: [
                'string'
            ],
            guestUser: [
                'string'
            ],
            managerSubordinates: [
                'string'
            ],
            managers: [
                'string'
            ],
            portalRole: [
                'string'
            ],
            portalRoleAndSubordinates: [
                'string'
            ],
            queue: [
                'string'
            ],
            role: [
                'string'
            ],
            roleAndSubordinates: [
                'string'
            ],
            roleAndSubordinatesInternal: [
                'string'
            ],
            roles: [
                'string'
            ],
            rolesAndSubordinates: [
                'string'
            ],
            territories: [
                'string'
            ],
            territoriesAndSubordinates: [
                'string'
            ],
            territory: [
                'string'
            ],
            territoryAndSubordinates: [
                'string'
            ]
        }
    },
    ProfileSearchLayouts: {
        type: 'ProfileSearchLayouts',
        props: {
            fields: [
                'string'
            ],
            profileName: '?string'
        }
    },
    RecordType: {
        type: 'RecordType',
        props: {
            active: 'boolean',
            businessProcess: '?string',
            compactLayoutAssignment: '?string',
            description: '?string',
            label: 'string',
            picklistValues: [
                'RecordTypePicklistValue'
            ]
        },
        extends: 'Metadata'
    },
    RecordTypePicklistValue: {
        type: 'RecordTypePicklistValue',
        props: {
            picklist: 'string',
            values: [
                'PicklistValue'
            ]
        }
    },
    SearchLayouts: {
        type: 'SearchLayouts',
        props: {
            customTabListAdditionalFields: [
                'string'
            ],
            excludedStandardButtons: [
                'string'
            ],
            listViewButtons: [
                'string'
            ],
            lookupDialogsAdditionalFields: [
                'string'
            ],
            lookupFilterFields: [
                'string'
            ],
            lookupPhoneDialogsAdditionalFields: [
                'string'
            ],
            massQuickActions: [
                'string'
            ],
            searchFilterFields: [
                'string'
            ],
            searchResultsAdditionalFields: [
                'string'
            ],
            searchResultsCustomButtons: [
                'string'
            ]
        }
    },
    SharingReason: {
        type: 'SharingReason',
        props: {
            label: 'string'
        },
        extends: 'Metadata'
    },
    SharingRecalculation: {
        type: 'SharingRecalculation',
        props: {
            className: 'string'
        }
    },
    ValidationRule: {
        type: 'ValidationRule',
        props: {
            active: 'boolean',
            description: '?string',
            errorConditionFormula: 'string',
            errorDisplayField: '?string',
            errorMessage: 'string'
        },
        extends: 'Metadata'
    },
    WebLink: {
        type: 'WebLink',
        props: {
            availability: 'string',
            description: '?string',
            displayType: 'string',
            encodingKey: '?string',
            hasMenubar: '?boolean',
            hasScrollbars: '?boolean',
            hasToolbar: '?boolean',
            height: '?number',
            isResizable: '?boolean',
            linkType: 'string',
            masterLabel: '?string',
            openType: 'string',
            page: '?string',
            position: '?string',
            protected: 'boolean',
            requireRowSelection: '?boolean',
            scontrol: '?string',
            showsLocation: '?boolean',
            showsStatus: '?boolean',
            url: '?string',
            width: '?number'
        },
        extends: 'Metadata'
    },
    CustomObjectTranslation: {
        type: 'CustomObjectTranslation',
        props: {
            caseValues: [
                'ObjectNameCaseValue'
            ],
            fieldSets: [
                'FieldSetTranslation'
            ],
            fields: [
                'CustomFieldTranslation'
            ],
            gender: '?string',
            layouts: [
                'LayoutTranslation'
            ],
            nameFieldLabel: '?string',
            quickActions: [
                'QuickActionTranslation'
            ],
            recordTypes: [
                'RecordTypeTranslation'
            ],
            sharingReasons: [
                'SharingReasonTranslation'
            ],
            standardFields: [
                'StandardFieldTranslation'
            ],
            startsWith: '?string',
            validationRules: [
                'ValidationRuleTranslation'
            ],
            webLinks: [
                'WebLinkTranslation'
            ],
            workflowTasks: [
                'WorkflowTaskTranslation'
            ]
        },
        extends: 'Metadata'
    },
    ObjectNameCaseValue: {
        type: 'ObjectNameCaseValue',
        props: {
            article: '?string',
            caseType: '?string',
            plural: '?boolean',
            possessive: '?string',
            value: 'string'
        }
    },
    FieldSetTranslation: {
        type: 'FieldSetTranslation',
        props: {
            label: 'string',
            name: 'string'
        }
    },
    CustomFieldTranslation: {
        type: 'CustomFieldTranslation',
        props: {
            caseValues: [
                'ObjectNameCaseValue'
            ],
            gender: '?string',
            help: '?string',
            label: '?string',
            lookupFilter: '?LookupFilterTranslation',
            name: 'string',
            picklistValues: [
                'PicklistValueTranslation'
            ],
            relationshipLabel: '?string',
            startsWith: '?string'
        }
    },
    LookupFilterTranslation: {
        type: 'LookupFilterTranslation',
        props: {
            errorMessage: 'string',
            informationalMessage: 'string'
        }
    },
    PicklistValueTranslation: {
        type: 'PicklistValueTranslation',
        props: {
            masterLabel: 'string',
            translation: '?string'
        }
    },
    LayoutTranslation: {
        type: 'LayoutTranslation',
        props: {
            layout: 'string',
            layoutType: '?string',
            sections: [
                'LayoutSectionTranslation'
            ]
        }
    },
    LayoutSectionTranslation: {
        type: 'LayoutSectionTranslation',
        props: {
            label: 'string',
            section: 'string'
        }
    },
    QuickActionTranslation: {
        type: 'QuickActionTranslation',
        props: {
            label: 'string',
            name: 'string'
        }
    },
    RecordTypeTranslation: {
        type: 'RecordTypeTranslation',
        props: {
            description: '?string',
            label: 'string',
            name: 'string'
        }
    },
    SharingReasonTranslation: {
        type: 'SharingReasonTranslation',
        props: {
            label: 'string',
            name: 'string'
        }
    },
    StandardFieldTranslation: {
        type: 'StandardFieldTranslation',
        props: {
            label: '?string',
            name: 'string'
        }
    },
    ValidationRuleTranslation: {
        type: 'ValidationRuleTranslation',
        props: {
            errorMessage: 'string',
            name: 'string'
        }
    },
    WebLinkTranslation: {
        type: 'WebLinkTranslation',
        props: {
            label: 'string',
            name: 'string'
        }
    },
    WorkflowTaskTranslation: {
        type: 'WorkflowTaskTranslation',
        props: {
            description: '?string',
            name: 'string',
            subject: '?string'
        }
    },
    CustomPageWebLink: {
        type: 'CustomPageWebLink',
        props: {
            availability: 'string',
            description: '?string',
            displayType: 'string',
            encodingKey: '?string',
            hasMenubar: '?boolean',
            hasScrollbars: '?boolean',
            hasToolbar: '?boolean',
            height: '?number',
            isResizable: '?boolean',
            linkType: 'string',
            masterLabel: '?string',
            openType: 'string',
            page: '?string',
            position: '?string',
            protected: 'boolean',
            requireRowSelection: '?boolean',
            scontrol: '?string',
            showsLocation: '?boolean',
            showsStatus: '?boolean',
            url: '?string',
            width: '?number'
        },
        extends: 'Metadata'
    },
    CustomPermission: {
        type: 'CustomPermission',
        props: {
            connectedApp: '?string',
            description: '?string',
            label: 'string',
            requiredPermission: [
                'CustomPermissionDependencyRequired'
            ]
        },
        extends: 'Metadata'
    },
    CustomPermissionDependencyRequired: {
        type: 'CustomPermissionDependencyRequired',
        props: {
            customPermission: 'string',
            dependency: 'boolean'
        }
    },
    CustomSite: {
        type: 'CustomSite',
        props: {
            active: 'boolean',
            allowHomePage: 'boolean',
            allowStandardAnswersPages: '?boolean',
            allowStandardIdeasPages: 'boolean',
            allowStandardLookups: 'boolean',
            allowStandardPortalPages: 'boolean',
            allowStandardSearch: 'boolean',
            analyticsTrackingCode: '?string',
            authorizationRequiredPage: '?string',
            bandwidthExceededPage: '?string',
            browserXssProtection: 'boolean',
            changePasswordPage: '?string',
            chatterAnswersForgotPasswordConfirmPage: '?string',
            chatterAnswersForgotPasswordPage: '?string',
            chatterAnswersHelpPage: '?string',
            chatterAnswersLoginPage: '?string',
            chatterAnswersRegistrationPage: '?string',
            clickjackProtectionLevel: 'string',
            contentSniffingProtection: 'boolean',
            cspUpgradeInsecureRequests: 'boolean',
            customWebAddresses: [
                'SiteWebAddress'
            ],
            description: '?string',
            enableAuraRequests: '?boolean',
            favoriteIcon: '?string',
            fileNotFoundPage: '?string',
            forgotPasswordPage: '?string',
            genericErrorPage: '?string',
            guestProfile: '?string',
            inMaintenancePage: '?string',
            inactiveIndexPage: '?string',
            indexPage: 'string',
            masterLabel: 'string',
            myProfilePage: '?string',
            portal: '?string',
            referrerPolicyOriginWhenCrossOrigin: 'boolean',
            requireHttps: 'boolean',
            requireInsecurePortalAccess: 'boolean',
            robotsTxtPage: '?string',
            rootComponent: '?string',
            selfRegPage: '?string',
            serverIsDown: '?string',
            siteAdmin: '?string',
            siteRedirectMappings: [
                'SiteRedirectMapping'
            ],
            siteTemplate: '?string',
            siteType: 'string',
            subdomain: '?string',
            urlPathPrefix: '?string'
        },
        extends: 'Metadata'
    },
    SiteWebAddress: {
        type: 'SiteWebAddress',
        props: {
            certificate: '?string',
            domainName: 'string',
            primary: 'boolean'
        }
    },
    SiteRedirectMapping: {
        type: 'SiteRedirectMapping',
        props: {
            action: 'string',
            isActive: '?boolean',
            source: 'string',
            target: 'string'
        }
    },
    CustomTab: {
        type: 'CustomTab',
        props: {
            actionOverrides: [
                'ActionOverride'
            ],
            auraComponent: '?string',
            customObject: '?boolean',
            description: '?string',
            flexiPage: '?string',
            frameHeight: '?number',
            hasSidebar: '?boolean',
            icon: '?string',
            label: '?string',
            lwcComponent: '?string',
            motif: '?string',
            page: '?string',
            scontrol: '?string',
            splashPageLink: '?string',
            url: '?string',
            urlEncodingKey: '?string'
        },
        extends: 'Metadata'
    },
    Dashboard: {
        type: 'Dashboard',
        props: {
            backgroundEndColor: 'string',
            backgroundFadeDirection: 'string',
            backgroundStartColor: 'string',
            chartTheme: '?string',
            colorPalette: '?string',
            dashboardChartTheme: '?string',
            dashboardColorPalette: '?string',
            dashboardFilters: [
                'DashboardFilter'
            ],
            dashboardGridLayout: '?DashboardGridLayout',
            dashboardResultRefreshedDate: '?string',
            dashboardResultRunningUser: '?string',
            dashboardType: '?string',
            description: '?string',
            folderName: '?string',
            isGridLayout: '?boolean',
            leftSection: '?DashboardComponentSection',
            middleSection: '?DashboardComponentSection',
            numSubscriptions: '?number',
            rightSection: '?DashboardComponentSection',
            runningUser: '?string',
            textColor: 'string',
            title: 'string',
            titleColor: 'string',
            titleSize: 'number'
        },
        extends: 'Metadata'
    },
    DashboardFilter: {
        type: 'DashboardFilter',
        props: {
            dashboardFilterOptions: [
                'DashboardFilterOption'
            ],
            name: 'string'
        }
    },
    DashboardFilterOption: {
        type: 'DashboardFilterOption',
        props: {
            operator: 'string',
            values: [
                'string'
            ]
        }
    },
    DashboardGridLayout: {
        type: 'DashboardGridLayout',
        props: {
            dashboardGridComponents: [
                'DashboardGridComponent'
            ],
            numberOfColumns: 'number',
            rowHeight: 'number'
        }
    },
    DashboardGridComponent: {
        type: 'DashboardGridComponent',
        props: {
            colSpan: 'number',
            columnIndex: 'number',
            dashboardComponent: 'DashboardComponent',
            rowIndex: 'number',
            rowSpan: 'number'
        }
    },
    DashboardComponent: {
        type: 'DashboardComponent',
        props: {
            autoselectColumnsFromReport: '?boolean',
            chartAxisRange: '?string',
            chartAxisRangeMax: '?number',
            chartAxisRangeMin: '?number',
            chartSummary: [
                'ChartSummary'
            ],
            componentChartTheme: '?string',
            componentType: 'string',
            dashboardFilterColumns: [
                'DashboardFilterColumn'
            ],
            dashboardTableColumn: [
                'DashboardTableColumn'
            ],
            decimalPrecision: '?number',
            displayUnits: '?string',
            drillDownUrl: '?string',
            drillEnabled: '?boolean',
            drillToDetailEnabled: '?boolean',
            enableHover: '?boolean',
            expandOthers: '?boolean',
            flexComponentProperties: '?DashboardFlexTableComponentProperties',
            footer: '?string',
            gaugeMax: '?number',
            gaugeMin: '?number',
            groupingColumn: [
                'string'
            ],
            groupingSortProperties: '?DashboardComponentGroupingSortProperties',
            header: '?string',
            indicatorBreakpoint1: '?number',
            indicatorBreakpoint2: '?number',
            indicatorHighColor: '?string',
            indicatorLowColor: '?string',
            indicatorMiddleColor: '?string',
            legendPosition: '?string',
            maxValuesDisplayed: '?number',
            metricLabel: '?string',
            page: '?string',
            pageHeightInPixels: '?number',
            report: '?string',
            scontrol: '?string',
            scontrolHeightInPixels: '?number',
            showPercentage: '?boolean',
            showPicturesOnCharts: '?boolean',
            showPicturesOnTables: '?boolean',
            showRange: '?boolean',
            showTotal: '?boolean',
            showValues: '?boolean',
            sortBy: '?string',
            title: '?string',
            useReportChart: '?boolean'
        }
    },
    ChartSummary: {
        type: 'ChartSummary',
        props: {
            aggregate: '?string',
            axisBinding: '?string',
            column: 'string'
        }
    },
    DashboardFilterColumn: {
        type: 'DashboardFilterColumn',
        props: {
            column: 'string'
        }
    },
    DashboardTableColumn: {
        type: 'DashboardTableColumn',
        props: {
            aggregateType: '?string',
            calculatePercent: '?boolean',
            column: 'string',
            decimalPlaces: '?number',
            showSubTotal: '?boolean',
            showTotal: '?boolean',
            sortBy: '?string'
        }
    },
    DashboardFlexTableComponentProperties: {
        type: 'DashboardFlexTableComponentProperties',
        props: {
            decimalPrecision: '?number',
            flexTableColumn: [
                'DashboardComponentColumn'
            ],
            flexTableSortInfo: '?DashboardComponentSortInfo',
            hideChatterPhotos: '?boolean'
        }
    },
    DashboardComponentColumn: {
        type: 'DashboardComponentColumn',
        props: {
            breakPoint1: '?number',
            breakPoint2: '?number',
            breakPointOrder: '?number',
            highRangeColor: '?number',
            lowRangeColor: '?number',
            midRangeColor: '?number',
            reportColumn: 'string',
            showSubTotal: '?boolean',
            showTotal: '?boolean',
            type: 'string'
        }
    },
    DashboardComponentSortInfo: {
        type: 'DashboardComponentSortInfo',
        props: {
            sortColumn: '?string',
            sortOrder: '?string'
        }
    },
    DashboardComponentGroupingSortProperties: {
        type: 'DashboardComponentGroupingSortProperties',
        props: {
            groupingSorts: [
                'DashboardComponentGroupingSort'
            ]
        }
    },
    DashboardComponentGroupingSort: {
        type: 'DashboardComponentGroupingSort',
        props: {
            groupingLevel: 'string',
            inheritedReportGroupingSort: '?string',
            sortColumn: '?string',
            sortOrder: '?string'
        }
    },
    DashboardComponentSection: {
        type: 'DashboardComponentSection',
        props: {
            columnSize: 'string',
            components: [
                'DashboardComponent'
            ]
        }
    },
    DataCategoryGroup: {
        type: 'DataCategoryGroup',
        props: {
            active: 'boolean',
            dataCategory: 'DataCategory',
            description: '?string',
            label: 'string',
            objectUsage: '?ObjectUsage'
        },
        extends: 'Metadata'
    },
    DataCategory: {
        type: 'DataCategory',
        props: {
            dataCategory: [
                'DataCategory'
            ],
            label: 'string',
            name: 'string'
        }
    },
    ObjectUsage: {
        type: 'ObjectUsage',
        props: {
            object: [
                'string'
            ]
        }
    },
    DataDotComSettings: {
        type: 'DataDotComSettings',
        props: {
            enableAccountExportButtonOff: '?boolean',
            enableAccountImportButtonOff: '?boolean',
            enableAllowDupeContactFromLead: '?boolean',
            enableAllowDupeLeadFromContact: '?boolean',
            enableCleanUpgradeRequested: '?boolean',
            enableContactExportButtonOff: '?boolean',
            enableContactImportButtonOff: '?boolean'
        },
        extends: 'Metadata'
    },
    DelegateGroup: {
        type: 'DelegateGroup',
        props: {
            customObjects: [
                'string'
            ],
            groups: [
                'string'
            ],
            label: 'string',
            loginAccess: 'boolean',
            permissionSets: [
                'string'
            ],
            profiles: [
                'string'
            ],
            roles: [
                'string'
            ]
        },
        extends: 'Metadata'
    },
    DeploymentSettings: {
        type: 'DeploymentSettings',
        props: {
            doesSkipAsyncApexValidation: '?boolean'
        },
        extends: 'Metadata'
    },
    DevHubSettings: {
        type: 'DevHubSettings',
        props: {
            enableShapeExportPref: '?boolean'
        },
        extends: 'Metadata'
    },
    DiscoverySettings: {
        type: 'DiscoverySettings',
        props: {
            enableEinsteinAnswersPref: '?boolean'
        },
        extends: 'Metadata'
    },
    DocumentType: {
        type: 'DocumentType',
        props: {
            description: 'string',
            isActive: 'boolean',
            masterLabel: 'string'
        },
        extends: 'Metadata'
    },
    DuplicateRule: {
        type: 'DuplicateRule',
        props: {
            actionOnInsert: 'string',
            actionOnUpdate: 'string',
            alertText: '?string',
            description: '?string',
            duplicateRuleFilter: '?DuplicateRuleFilter',
            duplicateRuleMatchRules: [
                '?',
                'DuplicateRuleMatchRule'
            ],
            isActive: 'boolean',
            masterLabel: 'string',
            operationsOnInsert: [
                'string'
            ],
            operationsOnUpdate: [
                'string'
            ],
            securityOption: 'string',
            sortOrder: 'number'
        },
        extends: 'Metadata'
    },
    DuplicateRuleFilter: {
        type: 'DuplicateRuleFilter',
        props: {
            booleanFilter: '?string',
            duplicateRuleFilterItems: [
                'DuplicateRuleFilterItem'
            ]
        }
    },
    DuplicateRuleMatchRule: {
        type: 'DuplicateRuleMatchRule',
        props: {
            matchRuleSObjectType: 'string',
            matchingRule: 'string',
            objectMapping: '?ObjectMapping'
        }
    },
    ObjectMapping: {
        type: 'ObjectMapping',
        props: {
            inputObject: 'string',
            mappingFields: [
                'ObjectMappingField'
            ],
            outputObject: 'string'
        }
    },
    ObjectMappingField: {
        type: 'ObjectMappingField',
        props: {
            inputField: 'string',
            outputField: 'string'
        }
    },
    EACSettings: {
        type: 'EACSettings',
        props: {
            enableEACForEveryonePref: '?boolean',
            enableInboxActivitySharing: '?boolean',
            enableInsightsInTimeline: '?boolean',
            enableInsightsInTimelineEacStd: '?boolean'
        },
        extends: 'Metadata'
    },
    EmailAdministrationSettings: {
        type: 'EmailAdministrationSettings',
        props: {
            enableComplianceBcc: '?boolean',
            enableEmailConsentManagement: '?boolean',
            enableEmailSenderIdCompliance: '?boolean',
            enableEmailSpfCompliance: '?boolean',
            enableEmailToSalesforce: '?boolean',
            enableEmailWorkflowApproval: '?boolean',
            enableEnhancedEmailEnabled: '?boolean',
            enableHandleBouncedEmails: '?boolean',
            enableHtmlEmail: '?boolean',
            enableListEmailLogActivities: '?boolean',
            enableResendBouncedEmails: '?boolean',
            enableRestrictTlsToDomains: '?boolean',
            enableSendThroughGmailPref: '?boolean',
            enableSendViaExchangePref: '?boolean',
            enableSendViaGmailPref: '?boolean',
            enableSetMatchingEmailsOnBounce: '?boolean',
            enableUseOrgFootersForExtTrans: '?boolean',
            sendEmailsEvenWhenAutomationUpdatesSameRecord: '?boolean',
            sendMassEmailNotification: '?boolean',
            sendTextOnlySystemEmails: '?boolean'
        },
        extends: 'Metadata'
    },
    EmailIntegrationSettings: {
        type: 'EmailIntegrationSettings',
        props: {
            doesEmailLogAsEmailMessageInOutlook: '?boolean',
            doesGmailStayConnectedToSalesforce: '?boolean',
            enableContactAndEventSync: '?boolean',
            enableEmailTrackingInMobile: '?boolean',
            enableEngageForOutlook: '?boolean',
            enableGmailIntegration: '?boolean',
            enableOutlookIntegration: '?boolean',
            enableProductivityFeatures: '?boolean',
            enableSupplementalContactInfoInMobile: '?boolean',
            isLayoutCustomizationAllowed: '?boolean',
            shouldUseTrustedDomainsList: '?boolean'
        },
        extends: 'Metadata'
    },
    EmailServicesFunction: {
        type: 'EmailServicesFunction',
        props: {
            apexClass: 'string',
            attachmentOption: 'string',
            authenticationFailureAction: 'string',
            authorizationFailureAction: 'string',
            authorizedSenders: '?string',
            emailServicesAddresses: [
                'EmailServicesAddress'
            ],
            errorRoutingAddress: '?string',
            functionInactiveAction: 'string',
            functionName: 'string',
            isActive: '?boolean',
            isAuthenticationRequired: '?boolean',
            isErrorRoutingEnabled: '?boolean',
            isTextAttachmentsAsBinary: '?boolean',
            isTlsRequired: '?boolean',
            overLimitAction: 'string'
        },
        extends: 'Metadata'
    },
    EmailServicesAddress: {
        type: 'EmailServicesAddress',
        props: {
            authorizedSenders: '?string',
            developerName: 'string',
            isActive: '?boolean',
            localPart: 'string',
            runAsUser: 'string'
        }
    },
    EmailTemplateSettings: {
        type: 'EmailTemplateSettings',
        props: {
            enableLwcEmailTemplateBuilder: '?boolean',
            enableTemplateEnhancedFolderPref: '?boolean'
        },
        extends: 'Metadata'
    },
    EmbeddedServiceBranding: {
        type: 'EmbeddedServiceBranding',
        props: {
            contrastInvertedColor: '?string',
            contrastPrimaryColor: '?string',
            embeddedServiceConfig: 'string',
            font: '?string',
            height: '?number',
            masterLabel: 'string',
            navBarColor: '?string',
            primaryColor: '?string',
            secondaryColor: '?string',
            width: '?number'
        },
        extends: 'Metadata'
    },
    EmbeddedServiceConfig: {
        type: 'EmbeddedServiceConfig',
        props: {
            areGuestUsersAllowed: '?boolean',
            authMethod: '?string',
            embeddedServiceAppointmentSettings: '?EmbeddedServiceAppointmentSettings',
            embeddedServiceCustomComponents: [
                'EmbeddedServiceCustomComponent'
            ],
            embeddedServiceCustomLabels: [
                'EmbeddedServiceCustomLabel'
            ],
            embeddedServiceFlowConfig: '?EmbeddedServiceFlowConfig',
            embeddedServiceFlows: [
                'EmbeddedServiceFlow'
            ],
            embeddedServiceLayouts: [
                'EmbeddedServiceLayout'
            ],
            masterLabel: 'string',
            shouldHideAuthDialog: '?boolean',
            site: 'string'
        },
        extends: 'Metadata'
    },
    EmbeddedServiceAppointmentSettings: {
        type: 'EmbeddedServiceAppointmentSettings',
        props: {
            appointmentConfirmImg: '?string',
            enabled: 'boolean',
            homeImg: '?string',
            logoImg: '?string',
            shouldShowExistingAppointment: '?boolean',
            shouldShowNewAppointment: '?boolean'
        }
    },
    EmbeddedServiceCustomComponent: {
        type: 'EmbeddedServiceCustomComponent',
        props: {
            componentBundleType: '?string',
            customComponent: '?string',
            customComponentType: '?string'
        }
    },
    EmbeddedServiceCustomLabel: {
        type: 'EmbeddedServiceCustomLabel',
        props: {
            customLabel: '?string',
            feature: '?string',
            labelKey: '?string'
        }
    },
    EmbeddedServiceFlowConfig: {
        type: 'EmbeddedServiceFlowConfig',
        props: {
            enabled: 'boolean'
        },
        extends: 'Metadata'
    },
    EmbeddedServiceFlow: {
        type: 'EmbeddedServiceFlow',
        props: {
            flow: 'string',
            flowType: 'string',
            isAuthenticationRequired: 'boolean'
        }
    },
    EmbeddedServiceLayout: {
        type: 'EmbeddedServiceLayout',
        props: {
            embeddedServiceLayoutRules: [
                'EmbeddedServiceLayoutRule'
            ],
            layout: 'string',
            layoutType: '?string'
        }
    },
    EmbeddedServiceLayoutRule: {
        type: 'EmbeddedServiceLayoutRule',
        props: {
            appointmentStatus: 'string'
        }
    },
    EmbeddedServiceLiveAgent: {
        type: 'EmbeddedServiceLiveAgent',
        props: {
            avatarImg: '?string',
            embeddedServiceConfig: 'string',
            embeddedServiceQuickActions: [
                'EmbeddedServiceQuickAction'
            ],
            enabled: 'boolean',
            fontSize: 'string',
            headerBackgroundImg: '?string',
            isOfflineCaseEnabled: '?boolean',
            isQueuePositionEnabled: '?boolean',
            liveAgentChatUrl: '?string',
            liveAgentContentUrl: '?string',
            liveChatButton: 'string',
            liveChatDeployment: 'string',
            masterLabel: 'string',
            offlineCaseBackgroundImg: '?string',
            prechatBackgroundImg: '?string',
            prechatEnabled: 'boolean',
            prechatJson: '?string',
            scenario: 'string',
            smallCompanyLogoImg: '?string',
            waitingStateBackgroundImg: '?string'
        },
        extends: 'Metadata'
    },
    EmbeddedServiceQuickAction: {
        type: 'EmbeddedServiceQuickAction',
        props: {
            embeddedServiceLiveAgent: 'string',
            order: 'number',
            quickActionDefinition: 'string',
            quickActionType: '?string'
        }
    },
    EmbeddedServiceMenuSettings: {
        type: 'EmbeddedServiceMenuSettings',
        props: {
            branding: '?string',
            embeddedServiceMenuItems: [
                'EmbeddedServiceMenuItem'
            ],
            isEnabled: '?boolean',
            masterLabel: '?string',
            site: '?string'
        },
        extends: 'Metadata'
    },
    EmbeddedServiceMenuItem: {
        type: 'EmbeddedServiceMenuItem',
        props: {
            channel: '?string',
            channelType: '?string',
            displayOrder: '?number',
            phoneNumber: '?string'
        }
    },
    EncryptionKeySettings: {
        type: 'EncryptionKeySettings',
        props: {
            canOptOutOfDerivationWithBYOK: '?boolean',
            enableCacheOnlyKeys: '?boolean',
            enableReplayDetection: '?boolean'
        },
        extends: 'Metadata'
    },
    EnhancedNotesSettings: {
        type: 'EnhancedNotesSettings',
        props: {
            enableEnhancedNotes: '?boolean',
            enableTasksOnEnhancedNotes: '?boolean'
        },
        extends: 'Metadata'
    },
    EntitlementProcess: {
        type: 'EntitlementProcess',
        props: {
            SObjectType: '?string',
            active: '?boolean',
            businessHours: '?string',
            description: '?string',
            entryStartDateField: '?string',
            exitCriteriaBooleanFilter: '?string',
            exitCriteriaFilterItems: [
                'FilterItem'
            ],
            exitCriteriaFormula: '?string',
            isRecordTypeApplied: '?boolean',
            isVersionDefault: '?boolean',
            milestones: [
                'EntitlementProcessMilestoneItem'
            ],
            name: '?string',
            recordType: '?string',
            versionMaster: '?string',
            versionNotes: '?string',
            versionNumber: '?number'
        },
        extends: 'Metadata'
    },
    EntitlementProcessMilestoneItem: {
        type: 'EntitlementProcessMilestoneItem',
        props: {
            businessHours: '?string',
            criteriaBooleanFilter: '?string',
            milestoneCriteriaFilterItems: [
                'FilterItem'
            ],
            milestoneCriteriaFormula: '?string',
            milestoneName: '?string',
            minutesCustomClass: '?string',
            minutesToComplete: '?number',
            successActions: [
                'WorkflowActionReference'
            ],
            timeTriggers: [
                'EntitlementProcessMilestoneTimeTrigger'
            ],
            useCriteriaStartTime: '?boolean'
        }
    },
    EntitlementProcessMilestoneTimeTrigger: {
        type: 'EntitlementProcessMilestoneTimeTrigger',
        props: {
            actions: [
                'WorkflowActionReference'
            ],
            timeLength: '?number',
            workflowTimeTriggerUnit: 'string'
        }
    },
    EntitlementSettings: {
        type: 'EntitlementSettings',
        props: {
            assetLookupLimitedToActiveEntitlementsOnAccount: '?boolean',
            assetLookupLimitedToActiveEntitlementsOnContact: '?boolean',
            assetLookupLimitedToSameAccount: '?boolean',
            assetLookupLimitedToSameContact: '?boolean',
            enableEntitlementVersioning: 'boolean',
            enableEntitlements: 'boolean',
            enableMilestoneFeedItem: '?boolean',
            enableMilestoneStoppedTime: '?boolean',
            entitlementLookupLimitedToActiveStatus: '?boolean',
            entitlementLookupLimitedToSameAccount: '?boolean',
            entitlementLookupLimitedToSameAsset: '?boolean',
            entitlementLookupLimitedToSameContact: '?boolean',
            ignoreMilestoneBusinessHours: '?boolean'
        },
        extends: 'Metadata'
    },
    EntitlementTemplate: {
        type: 'EntitlementTemplate',
        props: {
            businessHours: '?string',
            casesPerEntitlement: '?number',
            entitlementProcess: '?string',
            isPerIncident: '?boolean',
            term: '?number',
            type: '?string'
        },
        extends: 'Metadata'
    },
    EntityImplements: {
        type: 'EntityImplements',
        props: {
            fieldMap: [
                'FieldImplements'
            ],
            interface: '?string',
            isDefault: '?boolean'
        },
        extends: 'Metadata'
    },
    FieldImplements: {
        type: 'FieldImplements',
        props: {
            field: '?string',
            interfaceField: '?string'
        }
    },
    EscalationRule: {
        type: 'EscalationRule',
        props: {
            active: '?boolean',
            ruleEntry: [
                'RuleEntry'
            ]
        },
        extends: 'Metadata'
    },
    EscalationRules: {
        type: 'EscalationRules',
        props: {
            escalationRule: [
                'EscalationRule'
            ]
        },
        extends: 'Metadata'
    },
    EssentialsSettings: {
        type: 'EssentialsSettings',
        props: {
            emailConnectorEnabled: '?boolean',
            essentialsAppEnabled: '?boolean'
        },
        extends: 'Metadata'
    },
    EssentialsTrialOrgSettings: {
        type: 'EssentialsTrialOrgSettings',
        props: {
            enableSampleDataDeleted: '?boolean'
        },
        extends: 'Metadata'
    },
    EventSettings: {
        type: 'EventSettings',
        props: {
            enableApexLimitEvents: '?boolean',
            enableDeleteMonitoringData: '?boolean',
            enableDynamicStreamingChannel: '?boolean',
            enableEventLogWaveIntegration: '?boolean',
            enableLoginForensics: '?boolean',
            enableStreamingApi: '?boolean',
            enableTerminateOldestSession: '?boolean',
            enableTransactionSecurityPolicies: '?boolean'
        },
        extends: 'Metadata'
    },
    ExperienceBundleSettings: {
        type: 'ExperienceBundleSettings',
        props: {
            enableExperienceBundleMetadata: '?boolean'
        },
        extends: 'Metadata'
    },
    ExternalDataSource: {
        type: 'ExternalDataSource',
        props: {
            authProvider: '?string',
            certificate: '?string',
            customConfiguration: '?string',
            customHttpHeaders: [
                'CustomHttpHeader'
            ],
            endpoint: '?string',
            isWritable: '?boolean',
            label: 'string',
            oauthRefreshToken: '?string',
            oauthScope: '?string',
            oauthToken: '?string',
            password: '?string',
            principalType: 'string',
            protocol: 'string',
            repository: '?string',
            type: 'string',
            username: '?string',
            version: '?string'
        },
        extends: 'Metadata'
    },
    CustomHttpHeader: {
        type: 'CustomHttpHeader',
        props: {
            description: '?string',
            headerFieldName: 'string',
            headerFieldValue: 'string',
            isActive: '?boolean'
        }
    },
    ExternalServiceRegistration: {
        type: 'ExternalServiceRegistration',
        props: {
            description: '?string',
            label: 'string',
            namedCredential: '?string',
            schema: '?string',
            schemaType: '?string',
            schemaUrl: '?string',
            status: 'string'
        },
        extends: 'Metadata'
    },
    ExternalServicesSettings: {
        type: 'ExternalServicesSettings',
        props: {
            enableEnhancedExternalServices: '?boolean'
        },
        extends: 'Metadata'
    },
    FieldServiceSettings: {
        type: 'FieldServiceSettings',
        props: {
            capacityUsageCalcClassId: '?string',
            doesAllowEditSaForCrew: '?boolean',
            doesShareSaParentWoWithAr: '?boolean',
            doesShareSaWithAr: '?boolean',
            enableWorkOrders: '?boolean',
            fieldServiceNotificationsOrgPref: '?boolean',
            fieldServiceOrgPref: '?boolean',
            isGeoCodeSyncEnabled: '?boolean',
            isLocationHistoryEnabled: '?boolean',
            serviceAppointmentsDueDateOffsetOrgValue: '?number',
            workOrderLineItemSearchFields: [
                'string'
            ],
            workOrderSearchFields: [
                'string'
            ]
        },
        extends: 'Metadata'
    },
    FileUploadAndDownloadSecuritySettings: {
        type: 'FileUploadAndDownloadSecuritySettings',
        props: {
            dispositions: [
                'FileTypeDispositionAssignmentBean'
            ],
            noHtmlUploadAsAttachment: 'boolean'
        },
        extends: 'Metadata'
    },
    FileTypeDispositionAssignmentBean: {
        type: 'FileTypeDispositionAssignmentBean',
        props: {
            behavior: 'string',
            fileType: 'string',
            securityRiskFileType: 'boolean'
        }
    },
    FilesConnectSettings: {
        type: 'FilesConnectSettings',
        props: {
            enableContentHubAllowed: '?boolean',
            enableContentHubCvtLinksAllowed: '?boolean',
            enableContentHubEOSearchLayout: '?boolean'
        },
        extends: 'Metadata'
    },
    FlexiPage: {
        type: 'FlexiPage',
        props: {
            description: '?string',
            flexiPageRegions: [
                'FlexiPageRegion'
            ],
            masterLabel: 'string',
            parentFlexiPage: '?string',
            platformActionlist: '?PlatformActionList',
            quickActionList: '?QuickActionList',
            sobjectType: '?string',
            template: 'FlexiPageTemplateInstance',
            type: 'string'
        },
        extends: 'Metadata'
    },
    FlexiPageRegion: {
        type: 'FlexiPageRegion',
        props: {
            appendable: '?string',
            componentInstances: [
                'ComponentInstance'
            ],
            mode: '?string',
            name: 'string',
            prependable: '?string',
            replaceable: '?string',
            type: 'string'
        }
    },
    ComponentInstance: {
        type: 'ComponentInstance',
        props: {
            componentInstanceProperties: [
                'ComponentInstanceProperty'
            ],
            componentName: 'string',
            visibilityRule: '?UiFormulaRule'
        }
    },
    ComponentInstanceProperty: {
        type: 'ComponentInstanceProperty',
        props: {
            name: '?string',
            type: '?string',
            value: '?string'
        }
    },
    UiFormulaRule: {
        type: 'UiFormulaRule',
        props: {
            booleanFilter: '?string',
            criteria: [
                'UiFormulaCriterion'
            ]
        }
    },
    UiFormulaCriterion: {
        type: 'UiFormulaCriterion',
        props: {
            leftValue: 'string',
            operator: 'string',
            rightValue: '?string'
        }
    },
    PlatformActionList: {
        type: 'PlatformActionList',
        props: {
            actionListContext: 'string',
            platformActionListItems: [
                'PlatformActionListItem'
            ],
            relatedSourceEntity: '?string'
        },
        extends: 'Metadata'
    },
    PlatformActionListItem: {
        type: 'PlatformActionListItem',
        props: {
            actionName: 'string',
            actionType: 'string',
            sortOrder: 'number',
            subtype: '?string'
        }
    },
    QuickActionList: {
        type: 'QuickActionList',
        props: {
            quickActionListItems: [
                'QuickActionListItem'
            ]
        }
    },
    QuickActionListItem: {
        type: 'QuickActionListItem',
        props: {
            quickActionName: 'string'
        }
    },
    FlexiPageTemplateInstance: {
        type: 'FlexiPageTemplateInstance',
        props: {
            name: 'string',
            properties: [
                'ComponentInstanceProperty'
            ]
        }
    },
    Flow: {
        type: 'Flow',
        props: {
            actionCalls: [
                'FlowActionCall'
            ],
            apexPluginCalls: [
                'FlowApexPluginCall'
            ],
            assignments: [
                'FlowAssignment'
            ],
            choices: [
                'FlowChoice'
            ],
            constants: [
                'FlowConstant'
            ],
            decisions: [
                'FlowDecision'
            ],
            description: '?string',
            dynamicChoiceSets: [
                'FlowDynamicChoiceSet'
            ],
            formulas: [
                'FlowFormula'
            ],
            interviewLabel: '?string',
            isAdditionalPermissionRequiredToRun: '?boolean',
            isTemplate: '?boolean',
            label: 'string',
            loops: [
                'FlowLoop'
            ],
            processMetadataValues: [
                'FlowMetadataValue'
            ],
            processType: '?string',
            recordCreates: [
                'FlowRecordCreate'
            ],
            recordDeletes: [
                'FlowRecordDelete'
            ],
            recordLookups: [
                'FlowRecordLookup'
            ],
            recordUpdates: [
                'FlowRecordUpdate'
            ],
            screens: [
                'FlowScreen'
            ],
            stages: [
                'FlowStage'
            ],
            start: '?FlowStart',
            startElementReference: '?string',
            status: '?string',
            steps: [
                'FlowStep'
            ],
            subflows: [
                'FlowSubflow'
            ],
            textTemplates: [
                'FlowTextTemplate'
            ],
            variables: [
                'FlowVariable'
            ],
            waits: [
                'FlowWait'
            ]
        },
        extends: 'Metadata'
    },
    FlowActionCall: {
        type: 'FlowActionCall',
        props: {
            actionName: 'string',
            actionType: 'string',
            connector: '?FlowConnector',
            faultConnector: '?FlowConnector',
            inputParameters: [
                'FlowActionCallInputParameter'
            ],
            outputParameters: [
                'FlowActionCallOutputParameter'
            ]
        },
        extends: 'FlowNode'
    },
    FlowNode: {
        type: 'FlowNode',
        props: {
            label: '?string',
            locationX: 'number',
            locationY: 'number'
        },
        extends: 'FlowElement'
    },
    FlowElement: {
        type: 'FlowElement',
        props: {
            description: '?string',
            name: '?string'
        },
        extends: 'FlowBaseElement'
    },
    FlowBaseElement: {
        type: 'FlowBaseElement',
        props: {
            processMetadataValues: [
                'FlowMetadataValue'
            ]
        }
    },
    FlowMetadataValue: {
        type: 'FlowMetadataValue',
        props: {
            name: 'string',
            value: '?FlowElementReferenceOrValue'
        }
    },
    FlowElementReferenceOrValue: {
        type: 'FlowElementReferenceOrValue',
        props: {
            booleanValue: '?boolean',
            dateTimeValue: '?string',
            dateValue: '?string',
            elementReference: '?string',
            numberValue: '?number',
            stringValue: '?string'
        }
    },
    FlowActionCallInputParameter: {
        type: 'FlowActionCallInputParameter',
        props: {
            name: 'string',
            value: '?FlowElementReferenceOrValue'
        },
        extends: 'FlowBaseElement'
    },
    FlowActionCallOutputParameter: {
        type: 'FlowActionCallOutputParameter',
        props: {
            assignToReference: 'string',
            name: 'string'
        },
        extends: 'FlowBaseElement'
    },
    FlowApexPluginCallInputParameter: {
        type: 'FlowApexPluginCallInputParameter',
        props: {
            name: 'string',
            value: '?FlowElementReferenceOrValue'
        },
        extends: 'FlowBaseElement'
    },
    FlowApexPluginCallOutputParameter: {
        type: 'FlowApexPluginCallOutputParameter',
        props: {
            assignToReference: 'string',
            name: 'string'
        },
        extends: 'FlowBaseElement'
    },
    FlowAssignmentItem: {
        type: 'FlowAssignmentItem',
        props: {
            assignToReference: 'string',
            operator: 'string',
            value: '?FlowElementReferenceOrValue'
        },
        extends: 'FlowBaseElement'
    },
    FlowChoiceUserInput: {
        type: 'FlowChoiceUserInput',
        props: {
            isRequired: '?boolean',
            promptText: '?string',
            validationRule: '?FlowInputValidationRule'
        },
        extends: 'FlowBaseElement'
    },
    FlowInputValidationRule: {
        type: 'FlowInputValidationRule',
        props: {
            errorMessage: 'string',
            formulaExpression: 'string'
        }
    },
    FlowCondition: {
        type: 'FlowCondition',
        props: {
            leftValueReference: 'string',
            operator: 'string',
            rightValue: '?FlowElementReferenceOrValue'
        },
        extends: 'FlowBaseElement'
    },
    FlowConnector: {
        type: 'FlowConnector',
        props: {
            targetReference: 'string'
        },
        extends: 'FlowBaseElement'
    },
    FlowInputFieldAssignment: {
        type: 'FlowInputFieldAssignment',
        props: {
            field: 'string',
            value: '?FlowElementReferenceOrValue'
        },
        extends: 'FlowBaseElement'
    },
    FlowOutputFieldAssignment: {
        type: 'FlowOutputFieldAssignment',
        props: {
            assignToReference: 'string',
            field: 'string'
        },
        extends: 'FlowBaseElement'
    },
    FlowRecordFilter: {
        type: 'FlowRecordFilter',
        props: {
            field: 'string',
            operator: 'string',
            value: '?FlowElementReferenceOrValue'
        },
        extends: 'FlowBaseElement'
    },
    FlowScreenFieldInputParameter: {
        type: 'FlowScreenFieldInputParameter',
        props: {
            name: 'string',
            value: '?FlowElementReferenceOrValue'
        },
        extends: 'FlowBaseElement'
    },
    FlowScreenFieldOutputParameter: {
        type: 'FlowScreenFieldOutputParameter',
        props: {
            assignToReference: 'string',
            name: 'string'
        },
        extends: 'FlowBaseElement'
    },
    FlowScreenRule: {
        type: 'FlowScreenRule',
        props: {
            conditionLogic: '?string',
            conditions: [
                'FlowCondition'
            ],
            label: 'string',
            ruleActions: [
                'FlowScreenRuleAction'
            ]
        },
        extends: 'FlowBaseElement'
    },
    FlowScreenRuleAction: {
        type: 'FlowScreenRuleAction',
        props: {
            attribute: 'string',
            fieldReference: 'string',
            value: '?FlowElementReferenceOrValue'
        },
        extends: 'FlowBaseElement'
    },
    FlowSubflowInputAssignment: {
        type: 'FlowSubflowInputAssignment',
        props: {
            name: 'string',
            value: '?FlowElementReferenceOrValue'
        },
        extends: 'FlowBaseElement'
    },
    FlowSubflowOutputAssignment: {
        type: 'FlowSubflowOutputAssignment',
        props: {
            assignToReference: 'string',
            name: 'string'
        },
        extends: 'FlowBaseElement'
    },
    FlowVisibilityRule: {
        type: 'FlowVisibilityRule',
        props: {
            conditionLogic: '?string',
            conditions: [
                'FlowCondition'
            ]
        },
        extends: 'FlowBaseElement'
    },
    FlowWaitEventInputParameter: {
        type: 'FlowWaitEventInputParameter',
        props: {
            name: 'string',
            value: '?FlowElementReferenceOrValue'
        },
        extends: 'FlowBaseElement'
    },
    FlowWaitEventOutputParameter: {
        type: 'FlowWaitEventOutputParameter',
        props: {
            assignToReference: 'string',
            name: 'string'
        },
        extends: 'FlowBaseElement'
    },
    FlowChoice: {
        type: 'FlowChoice',
        props: {
            choiceText: 'string',
            dataType: 'string',
            userInput: '?FlowChoiceUserInput',
            value: '?FlowElementReferenceOrValue'
        },
        extends: 'FlowElement'
    },
    FlowConstant: {
        type: 'FlowConstant',
        props: {
            dataType: 'string',
            value: '?FlowElementReferenceOrValue'
        },
        extends: 'FlowElement'
    },
    FlowDynamicChoiceSet: {
        type: 'FlowDynamicChoiceSet',
        props: {
            dataType: 'string',
            displayField: 'string',
            filters: [
                'FlowRecordFilter'
            ],
            limit: '?number',
            object: 'string',
            outputAssignments: [
                'FlowOutputFieldAssignment'
            ],
            picklistField: '?string',
            picklistObject: '?string',
            sortField: '?string',
            sortOrder: '?string',
            valueField: '?string'
        },
        extends: 'FlowElement'
    },
    FlowFormula: {
        type: 'FlowFormula',
        props: {
            dataType: '?string',
            expression: 'string',
            scale: '?number'
        },
        extends: 'FlowElement'
    },
    FlowRule: {
        type: 'FlowRule',
        props: {
            conditionLogic: 'string',
            conditions: [
                'FlowCondition'
            ],
            connector: '?FlowConnector',
            label: 'string'
        },
        extends: 'FlowElement'
    },
    FlowScreenField: {
        type: 'FlowScreenField',
        props: {
            choiceReferences: [
                'string'
            ],
            dataType: '?string',
            defaultSelectedChoiceReference: '?string',
            defaultValue: '?FlowElementReferenceOrValue',
            extensionName: '?string',
            fieldText: '?string',
            fieldType: 'string',
            helpText: '?string',
            inputParameters: [
                'FlowScreenFieldInputParameter'
            ],
            isRequired: '?boolean',
            isVisible: '?boolean',
            outputParameters: [
                'FlowScreenFieldOutputParameter'
            ],
            scale: '?number',
            storeOutputAutomatically: '?boolean',
            validationRule: '?FlowInputValidationRule',
            visibilityRule: '?FlowVisibilityRule'
        },
        extends: 'FlowElement'
    },
    FlowStage: {
        type: 'FlowStage',
        props: {
            isActive: 'boolean',
            label: 'string',
            stageOrder: 'number'
        },
        extends: 'FlowElement'
    },
    FlowTextTemplate: {
        type: 'FlowTextTemplate',
        props: {
            text: 'string'
        },
        extends: 'FlowElement'
    },
    FlowVariable: {
        type: 'FlowVariable',
        props: {
            apexClass: '?string',
            dataType: 'string',
            isCollection: '?boolean',
            isInput: '?boolean',
            isOutput: '?boolean',
            objectType: '?string',
            scale: '?number',
            value: '?FlowElementReferenceOrValue'
        },
        extends: 'FlowElement'
    },
    FlowWaitEvent: {
        type: 'FlowWaitEvent',
        props: {
            conditionLogic: '?string',
            conditions: [
                'FlowCondition'
            ],
            connector: 'FlowConnector',
            eventType: 'string',
            inputParameters: [
                'FlowWaitEventInputParameter'
            ],
            label: 'string',
            outputParameters: [
                'FlowWaitEventOutputParameter'
            ]
        },
        extends: 'FlowElement'
    },
    FlowApexPluginCall: {
        type: 'FlowApexPluginCall',
        props: {
            apexClass: 'string',
            connector: '?FlowConnector',
            faultConnector: '?FlowConnector',
            inputParameters: [
                'FlowApexPluginCallInputParameter'
            ],
            outputParameters: [
                'FlowApexPluginCallOutputParameter'
            ]
        },
        extends: 'FlowNode'
    },
    FlowAssignment: {
        type: 'FlowAssignment',
        props: {
            assignmentItems: [
                'FlowAssignmentItem'
            ],
            connector: '?FlowConnector'
        },
        extends: 'FlowNode'
    },
    FlowDecision: {
        type: 'FlowDecision',
        props: {
            defaultConnector: '?FlowConnector',
            defaultConnectorLabel: '?string',
            rules: [
                'FlowRule'
            ]
        },
        extends: 'FlowNode'
    },
    FlowLoop: {
        type: 'FlowLoop',
        props: {
            assignNextValueToReference: 'string',
            collectionReference: 'string',
            iterationOrder: '?string',
            nextValueConnector: '?FlowConnector',
            noMoreValuesConnector: '?FlowConnector'
        },
        extends: 'FlowNode'
    },
    FlowRecordCreate: {
        type: 'FlowRecordCreate',
        props: {
            assignRecordIdToReference: '?string',
            connector: '?FlowConnector',
            faultConnector: '?FlowConnector',
            inputAssignments: [
                'FlowInputFieldAssignment'
            ],
            inputReference: '?string',
            object: '?string'
        },
        extends: 'FlowNode'
    },
    FlowRecordDelete: {
        type: 'FlowRecordDelete',
        props: {
            connector: '?FlowConnector',
            faultConnector: '?FlowConnector',
            filters: [
                'FlowRecordFilter'
            ],
            inputReference: '?string',
            object: '?string'
        },
        extends: 'FlowNode'
    },
    FlowRecordLookup: {
        type: 'FlowRecordLookup',
        props: {
            assignNullValuesIfNoRecordsFound: '?boolean',
            connector: '?FlowConnector',
            faultConnector: '?FlowConnector',
            filters: [
                'FlowRecordFilter'
            ],
            getFirstRecordOnly: '?boolean',
            object: 'string',
            outputAssignments: [
                'FlowOutputFieldAssignment'
            ],
            outputReference: '?string',
            queriedFields: [
                'string'
            ],
            sortField: '?string',
            sortOrder: '?string',
            storeOutputAutomatically: '?boolean'
        },
        extends: 'FlowNode'
    },
    FlowRecordUpdate: {
        type: 'FlowRecordUpdate',
        props: {
            connector: '?FlowConnector',
            faultConnector: '?FlowConnector',
            filters: [
                'FlowRecordFilter'
            ],
            inputAssignments: [
                'FlowInputFieldAssignment'
            ],
            inputReference: '?string',
            object: '?string'
        },
        extends: 'FlowNode'
    },
    FlowScreen: {
        type: 'FlowScreen',
        props: {
            allowBack: '?boolean',
            allowFinish: '?boolean',
            allowPause: '?boolean',
            connector: '?FlowConnector',
            fields: [
                'FlowScreenField'
            ],
            helpText: '?string',
            pausedText: '?string',
            rules: [
                'FlowScreenRule'
            ],
            showFooter: '?boolean',
            showHeader: '?boolean'
        },
        extends: 'FlowNode'
    },
    FlowStart: {
        type: 'FlowStart',
        props: {
            connector: '?FlowConnector',
            filters: [
                'FlowRecordFilter'
            ],
            object: '?string',
            schedule: '?FlowSchedule',
            triggerType: '?string'
        },
        extends: 'FlowNode'
    },
    FlowSchedule: {
        type: 'FlowSchedule',
        props: {
            frequency: '?string',
            startDate: '?string',
            startTime: '?string'
        }
    },
    FlowStep: {
        type: 'FlowStep',
        props: {
            connectors: [
                'FlowConnector'
            ]
        },
        extends: 'FlowNode'
    },
    FlowSubflow: {
        type: 'FlowSubflow',
        props: {
            connector: '?FlowConnector',
            flowName: 'string',
            inputAssignments: [
                'FlowSubflowInputAssignment'
            ],
            outputAssignments: [
                'FlowSubflowOutputAssignment'
            ]
        },
        extends: 'FlowNode'
    },
    FlowWait: {
        type: 'FlowWait',
        props: {
            defaultConnector: '?FlowConnector',
            defaultConnectorLabel: 'string',
            faultConnector: '?FlowConnector',
            waitEvents: [
                'FlowWaitEvent'
            ]
        },
        extends: 'FlowNode'
    },
    FlowCategory: {
        type: 'FlowCategory',
        props: {
            description: '?string',
            flowCategoryItems: [
                'FlowCategoryItems'
            ],
            masterLabel: 'string'
        },
        extends: 'Metadata'
    },
    FlowCategoryItems: {
        type: 'FlowCategoryItems',
        props: {
            flow: 'string'
        }
    },
    FlowDefinition: {
        type: 'FlowDefinition',
        props: {
            activeVersionNumber: '?number',
            description: '?string',
            masterLabel: '?string'
        },
        extends: 'Metadata'
    },
    FlowSettings: {
        type: 'FlowSettings',
        props: {
            enableFlowBREncodedFixEnabled: '?boolean',
            enableFlowDeployAsActiveEnabled: '?boolean',
            enableFlowFieldFilterEnabled: '?boolean',
            enableFlowFormulasFixEnabled: '?boolean',
            enableFlowInterviewSharingEnabled: '?boolean',
            enableFlowNullPreviousValueFix: '?boolean',
            enableFlowPauseEnabled: '?boolean',
            enableFlowUseApexExceptionEmail: '?boolean',
            enableInvocableFlowFixEnabled: '?boolean',
            enableLightningRuntimeEnabled: '?boolean',
            enableUseFlowBuilder: '?boolean',
            isAccessToInvokedApexRequired: '?boolean',
            isEnhancedFlowListViewVisible: '?boolean',
            isManageFlowRequiredForAutomationCharts: '?boolean'
        },
        extends: 'Metadata'
    },
    Folder: {
        type: 'Folder',
        props: {
            accessType: '?string',
            folderShares: [
                'FolderShare'
            ],
            name: 'string',
            publicFolderAccess: '?string',
            sharedTo: '?SharedTo'
        },
        extends: 'Metadata'
    },
    FolderShare: {
        type: 'FolderShare',
        props: {
            accessLevel: 'string',
            sharedTo: 'string',
            sharedToType: 'string'
        }
    },
    DashboardFolder: {
        type: 'DashboardFolder',
        props: {},
        extends: 'Folder'
    },
    DocumentFolder: {
        type: 'DocumentFolder',
        props: {},
        extends: 'Folder'
    },
    EmailFolder: {
        type: 'EmailFolder',
        props: {},
        extends: 'Folder'
    },
    ReportFolder: {
        type: 'ReportFolder',
        props: {},
        extends: 'Folder'
    },
    ForecastingSettings: {
        type: 'ForecastingSettings',
        props: {
            defaultToPersonalCurrency: '?boolean',
            enableForecasts: '?boolean',
            forecastingCategoryMappings: [
                'ForecastingCategoryMapping'
            ],
            forecastingDisplayedFamilySettings: [
                'ForecastingDisplayedFamilySettings'
            ],
            forecastingTypeSettings: [
                'ForecastingTypeSettings'
            ]
        },
        extends: 'Metadata'
    },
    ForecastingCategoryMapping: {
        type: 'ForecastingCategoryMapping',
        props: {
            forecastingItemCategoryApiName: 'string',
            weightedSourceCategories: [
                'WeightedSourceCategory'
            ]
        }
    },
    WeightedSourceCategory: {
        type: 'WeightedSourceCategory',
        props: {
            sourceCategoryApiName: 'string',
            weight: 'number'
        }
    },
    ForecastingDisplayedFamilySettings: {
        type: 'ForecastingDisplayedFamilySettings',
        props: {
            productFamily: '?string'
        }
    },
    ForecastingTypeSettings: {
        type: 'ForecastingTypeSettings',
        props: {
            active: 'boolean',
            adjustmentsSettings: 'AdjustmentsSettings',
            displayedCategoryApiNames: [
                'string'
            ],
            forecastRangeSettings: 'ForecastRangeSettings',
            forecastedCategoryApiNames: [
                'string'
            ],
            forecastingDateType: 'string',
            hasProductFamily: 'boolean',
            isAmount: 'boolean',
            isAvailable: 'boolean',
            isQuantity: 'boolean',
            managerAdjustableCategoryApiNames: [
                'string'
            ],
            masterLabel: 'string',
            name: 'string',
            opportunityListFieldsLabelMappings: [
                'OpportunityListFieldsLabelMapping'
            ],
            opportunityListFieldsSelectedSettings: 'OpportunityListFieldsSelectedSettings',
            opportunityListFieldsUnselectedSettings: 'OpportunityListFieldsUnselectedSettings',
            opportunitySplitName: '?string',
            ownerAdjustableCategoryApiNames: [
                'string'
            ],
            quotasSettings: 'QuotasSettings',
            territory2ModelName: '?string'
        }
    },
    AdjustmentsSettings: {
        type: 'AdjustmentsSettings',
        props: {
            enableAdjustments: 'boolean',
            enableOwnerAdjustments: 'boolean'
        }
    },
    ForecastRangeSettings: {
        type: 'ForecastRangeSettings',
        props: {
            beginning: 'number',
            displaying: 'number',
            periodType: 'string'
        }
    },
    OpportunityListFieldsLabelMapping: {
        type: 'OpportunityListFieldsLabelMapping',
        props: {
            field: 'string',
            label: 'string'
        }
    },
    OpportunityListFieldsSelectedSettings: {
        type: 'OpportunityListFieldsSelectedSettings',
        props: {
            field: [
                'string'
            ]
        }
    },
    OpportunityListFieldsUnselectedSettings: {
        type: 'OpportunityListFieldsUnselectedSettings',
        props: {
            field: [
                'string'
            ]
        }
    },
    QuotasSettings: {
        type: 'QuotasSettings',
        props: {
            showQuotas: 'boolean'
        }
    },
    Form: {
        type: 'Form',
        props: {
            description: '?string',
            formSections: [
                'FormSection'
            ],
            masterLabel: 'string'
        },
        extends: 'Metadata'
    },
    FormSection: {
        type: 'FormSection',
        props: {
            formColumns: [
                'FormColumn'
            ],
            masterLabel: 'string',
            tabOrderType: 'string'
        },
        extends: 'Metadata'
    },
    FormColumn: {
        type: 'FormColumn',
        props: {
            formItems: [
                'FormItem'
            ]
        }
    },
    FormItem: {
        type: 'FormItem',
        props: {
            emptySpace: '?boolean',
            expression: '?string',
            formLayoutableItem: '?string',
            helpText: '?string'
        }
    },
    FormulaSettings: {
        type: 'FormulaSettings',
        props: {
            enableDSTAwareDatevalue: '?boolean'
        },
        extends: 'Metadata'
    },
    GlobalValueSet: {
        type: 'GlobalValueSet',
        props: {
            customValue: [
                'CustomValue'
            ],
            description: '?string',
            masterLabel: 'string',
            sorted: 'boolean'
        },
        extends: 'Metadata'
    },
    GlobalValueSetTranslation: {
        type: 'GlobalValueSetTranslation',
        props: {
            valueTranslation: [
                'ValueTranslation'
            ]
        },
        extends: 'Metadata'
    },
    ValueTranslation: {
        type: 'ValueTranslation',
        props: {
            masterLabel: 'string',
            translation: '?string'
        }
    },
    GoogleAppsSettings: {
        type: 'GoogleAppsSettings',
        props: {
            enableGmailButtons: '?boolean',
            enableGmailButtonsAndLinks: '?boolean',
            enableGmailLinks: '?boolean',
            enableGoogleDocs: '?boolean',
            enableGoogleDocsTab: '?boolean',
            enableGoogleTalk: '?boolean',
            googleAppsDomain: '?string',
            googleAppsDomainLinked: '?boolean',
            googleAppsDomainValidated: '?boolean'
        },
        extends: 'Metadata'
    },
    Group: {
        type: 'Group',
        props: {
            doesIncludeBosses: '?boolean',
            name: 'string'
        },
        extends: 'Metadata'
    },
    HighVelocitySalesSettings: {
        type: 'HighVelocitySalesSettings',
        props: {
            enableDispositionCategory: '?boolean',
            enableEngagementWaveAnalyticsPref: '?boolean',
            enableHighVelocitySales: '?boolean',
            enableHighVelocitySalesSetup: '?boolean'
        },
        extends: 'Metadata'
    },
    HomePageComponent: {
        type: 'HomePageComponent',
        props: {
            body: '?string',
            height: '?number',
            links: [
                'string'
            ],
            page: '?string',
            pageComponentType: 'string',
            showLabel: '?boolean',
            showScrollbars: '?boolean',
            width: '?string'
        },
        extends: 'Metadata'
    },
    HomePageLayout: {
        type: 'HomePageLayout',
        props: {
            narrowComponents: [
                'string'
            ],
            wideComponents: [
                'string'
            ]
        },
        extends: 'Metadata'
    },
    IdeasSettings: {
        type: 'IdeasSettings',
        props: {
            enableChatterProfile: '?boolean',
            enableHtmlIdea: '?boolean',
            enableIdeaMultipleCategory: '?boolean',
            enableIdeaThemes: '?boolean',
            enableIdeas: '?boolean',
            enableIdeasControllerExtensions: '?boolean',
            enableIdeasReputation: '?boolean',
            halfLife: '?number',
            ideasProfilePage: '?string'
        },
        extends: 'Metadata'
    },
    IndustriesManufacturingSettings: {
        type: 'IndustriesManufacturingSettings',
        props: {
            enableIndManufacturing: '?boolean',
            enableIndustriesMfgAccountForecast: '?boolean'
        },
        extends: 'Metadata'
    },
    IndustriesSettings: {
        type: 'IndustriesSettings',
        props: {
            allowMultipleProducersToWorkOnSamePolicy: '?boolean',
            enableAccessToMasterListOfCoverageTypes: '?boolean',
            enableBlockResourceAvailabilityOrgPref: '?boolean',
            enableEventManagementOrgPref: '?boolean',
            enableHCReferralScoring: '?boolean',
            enableManyToManyRelationships: '?boolean',
            enableMortgageRlaTotalsOrgPref: '?boolean',
            enableMultiResourceOrgPref: '?boolean',
            enableObjectDetection: '?boolean',
            enableOverbookingOrgPref: '?boolean',
            enableProviderSearchSyncOrgPref: '?boolean',
            enableReferralScoring: '?boolean',
            enableSentimentAnalysis: '?boolean'
        },
        extends: 'Metadata'
    },
    InstalledPackage: {
        type: 'InstalledPackage',
        props: {
            activateRSS: 'boolean',
            password: '?string',
            versionNumber: 'string'
        },
        extends: 'Metadata'
    },
    IntegrationHubSettings: {
        type: 'IntegrationHubSettings',
        props: {
            canonicalName: '?string',
            canonicalNameBindingChar: '?string',
            description: '?string',
            isEnabled: '?boolean',
            isProtected: '?boolean',
            masterLabel: 'string',
            setupData: '?string',
            setupDefinition: '?string',
            setupNamespace: '?string',
            setupSimpleName: 'string',
            uUID: '?string',
            version: '?string',
            versionBuild: '?number',
            versionMajor: '?number',
            versionMinor: '?number',
            versionSetUuid: '?string'
        },
        extends: 'Metadata'
    },
    IntegrationHubSettingsType: {
        type: 'IntegrationHubSettingsType',
        props: {
            canonicalName: '?string',
            canonicalNameBindingChar: '?string',
            description: '?string',
            isEnabled: '?boolean',
            isProtected: '?boolean',
            masterLabel: 'string',
            setupNamespace: '?string',
            setupSimpleName: 'string',
            uUID: '?string',
            version: '?string',
            versionBuild: '?number',
            versionMajor: '?number',
            versionMinor: '?number',
            versionSetUuid: '?string'
        },
        extends: 'Metadata'
    },
    InvocableActionSettings: {
        type: 'InvocableActionSettings',
        props: {
            isPartialSaveAllowed: '?boolean'
        },
        extends: 'Metadata'
    },
    IoTSettings: {
        type: 'IoTSettings',
        props: {
            enableIoT: '?boolean',
            enableIoTInsightsPilot: '?boolean',
            enableIoTUsageEmail: '?boolean'
        },
        extends: 'Metadata'
    },
    IsvHammerSettings: {
        type: 'IsvHammerSettings',
        props: {
            enableIsvHammerSubIsOptedOut: '?boolean'
        },
        extends: 'Metadata'
    },
    KeywordList: {
        type: 'KeywordList',
        props: {
            description: '?string',
            keywords: [
                'Keyword'
            ],
            masterLabel: 'string'
        },
        extends: 'Metadata'
    },
    Keyword: {
        type: 'Keyword',
        props: {
            keyword: 'string'
        }
    },
    KnowledgeSettings: {
        type: 'KnowledgeSettings',
        props: {
            answers: '?KnowledgeAnswerSettings',
            cases: '?KnowledgeCaseSettings',
            defaultLanguage: '?string',
            enableChatterQuestionKBDeflection: '?boolean',
            enableCreateEditOnArticlesTab: '?boolean',
            enableExternalMediaContent: '?boolean',
            enableKnowledge: '?boolean',
            enableKnowledgeArticleTextHighlights: '?boolean',
            enableKnowledgeKeywordAutoComplete: '?boolean',
            enableKnowledgeTitleAutoComplete: '?boolean',
            enableLightningKbAutoLoadRichTextField: '?boolean',
            enableLightningKnowledge: '?boolean',
            languages: '?KnowledgeLanguageSettings',
            showArticleSummariesCustomerPortal: '?boolean',
            showArticleSummariesInternalApp: '?boolean',
            showArticleSummariesPartnerPortal: '?boolean',
            showValidationStatusField: '?boolean',
            suggestedArticles: '?KnowledgeSuggestedArticlesSettings'
        },
        extends: 'Metadata'
    },
    KnowledgeAnswerSettings: {
        type: 'KnowledgeAnswerSettings',
        props: {
            assignTo: '?string',
            defaultArticleType: '?string',
            enableArticleCreation: '?boolean'
        }
    },
    KnowledgeCaseSettings: {
        type: 'KnowledgeCaseSettings',
        props: {
            articlePDFCreationProfile: '?string',
            articlePublicSharingCommunities: '?KnowledgeCommunitiesSettings',
            articlePublicSharingSites: '?KnowledgeSitesSettings',
            articlePublicSharingSitesChatterAnswers: '?KnowledgeSitesSettings',
            assignTo: '?string',
            customizationClass: '?string',
            defaultContributionArticleType: '?string',
            editor: '?string',
            enableArticleCreation: '?boolean',
            enableArticlePublicSharingSites: '?boolean',
            enableCaseDataCategoryMapping: '?boolean',
            useProfileForPDFCreation: '?boolean'
        }
    },
    KnowledgeCommunitiesSettings: {
        type: 'KnowledgeCommunitiesSettings',
        props: {
            community: [
                'string'
            ]
        }
    },
    KnowledgeSitesSettings: {
        type: 'KnowledgeSitesSettings',
        props: {
            site: [
                'string'
            ]
        }
    },
    KnowledgeLanguageSettings: {
        type: 'KnowledgeLanguageSettings',
        props: {
            language: [
                'KnowledgeLanguage'
            ]
        }
    },
    KnowledgeLanguage: {
        type: 'KnowledgeLanguage',
        props: {
            active: '?boolean',
            defaultAssignee: '?string',
            defaultAssigneeType: '?string',
            defaultReviewer: '?string',
            defaultReviewerType: '?string',
            name: 'string'
        }
    },
    KnowledgeSuggestedArticlesSettings: {
        type: 'KnowledgeSuggestedArticlesSettings',
        props: {
            caseFields: '?KnowledgeCaseFieldsSettings',
            useSuggestedArticlesForCase: '?boolean',
            workOrderFields: '?KnowledgeWorkOrderFieldsSettings',
            workOrderLineItemFields: '?KnowledgeWorkOrderLineItemFieldsSettings'
        }
    },
    KnowledgeCaseFieldsSettings: {
        type: 'KnowledgeCaseFieldsSettings',
        props: {
            field: [
                'KnowledgeCaseField'
            ]
        }
    },
    KnowledgeCaseField: {
        type: 'KnowledgeCaseField',
        props: {
            name: '?string'
        }
    },
    KnowledgeWorkOrderFieldsSettings: {
        type: 'KnowledgeWorkOrderFieldsSettings',
        props: {
            field: [
                'KnowledgeWorkOrderField'
            ]
        }
    },
    KnowledgeWorkOrderField: {
        type: 'KnowledgeWorkOrderField',
        props: {
            name: '?string'
        }
    },
    KnowledgeWorkOrderLineItemFieldsSettings: {
        type: 'KnowledgeWorkOrderLineItemFieldsSettings',
        props: {
            field: [
                'KnowledgeWorkOrderLineItemField'
            ]
        }
    },
    KnowledgeWorkOrderLineItemField: {
        type: 'KnowledgeWorkOrderLineItemField',
        props: {
            name: '?string'
        }
    },
    LanguageSettings: {
        type: 'LanguageSettings',
        props: {
            enableCanadaIcuFormat: '?boolean',
            enableEndUserLanguages: '?boolean',
            enableICULocaleDateFormat: '?boolean',
            enablePlatformLanguages: '?boolean',
            enableTranslationWorkbench: '?boolean',
            useLanguageFallback: '?boolean'
        },
        extends: 'Metadata'
    },
    Layout: {
        type: 'Layout',
        props: {
            customButtons: [
                'string'
            ],
            customConsoleComponents: '?CustomConsoleComponents',
            emailDefault: '?boolean',
            excludeButtons: [
                'string'
            ],
            feedLayout: '?FeedLayout',
            headers: [
                'string'
            ],
            layoutSections: [
                'LayoutSection'
            ],
            miniLayout: '?MiniLayout',
            multilineLayoutFields: [
                'string'
            ],
            platformActionList: '?PlatformActionList',
            quickActionList: '?QuickActionList',
            relatedContent: '?RelatedContent',
            relatedLists: [
                'RelatedListItem'
            ],
            relatedObjects: [
                'string'
            ],
            runAssignmentRulesDefault: '?boolean',
            showEmailCheckbox: '?boolean',
            showHighlightsPanel: '?boolean',
            showInteractionLogPanel: '?boolean',
            showKnowledgeComponent: '?boolean',
            showRunAssignmentRulesCheckbox: '?boolean',
            showSolutionSection: '?boolean',
            showSubmitAndAttachButton: '?boolean',
            summaryLayout: '?SummaryLayout'
        },
        extends: 'Metadata'
    },
    CustomConsoleComponents: {
        type: 'CustomConsoleComponents',
        props: {
            primaryTabComponents: '?PrimaryTabComponents',
            subtabComponents: '?SubtabComponents'
        }
    },
    PrimaryTabComponents: {
        type: 'PrimaryTabComponents',
        props: {
            containers: [
                'Container'
            ]
        }
    },
    Container: {
        type: 'Container',
        props: {
            height: '?number',
            isContainerAutoSizeEnabled: 'boolean',
            region: 'string',
            sidebarComponents: [
                'SidebarComponent'
            ],
            style: 'string',
            unit: 'string',
            width: '?number'
        }
    },
    SidebarComponent: {
        type: 'SidebarComponent',
        props: {
            componentType: 'string',
            createAction: '?string',
            enableLinking: '?boolean',
            height: '?number',
            label: '?string',
            lookup: '?string',
            page: '?string',
            relatedLists: [
                'RelatedList'
            ],
            unit: '?string',
            updateAction: '?string',
            width: '?number'
        }
    },
    RelatedList: {
        type: 'RelatedList',
        props: {
            hideOnDetail: 'boolean',
            name: 'string'
        }
    },
    SubtabComponents: {
        type: 'SubtabComponents',
        props: {
            containers: [
                'Container'
            ]
        }
    },
    FeedLayout: {
        type: 'FeedLayout',
        props: {
            autocollapsePublisher: '?boolean',
            compactFeed: '?boolean',
            feedFilterPosition: '?string',
            feedFilters: [
                'FeedLayoutFilter'
            ],
            fullWidthFeed: '?boolean',
            hideSidebar: '?boolean',
            highlightExternalFeedItems: '?boolean',
            leftComponents: [
                'FeedLayoutComponent'
            ],
            rightComponents: [
                'FeedLayoutComponent'
            ],
            useInlineFiltersInConsole: '?boolean'
        }
    },
    FeedLayoutFilter: {
        type: 'FeedLayoutFilter',
        props: {
            feedFilterName: '?string',
            feedFilterType: 'string',
            feedItemType: '?string'
        }
    },
    FeedLayoutComponent: {
        type: 'FeedLayoutComponent',
        props: {
            componentType: 'string',
            height: '?number',
            page: '?string'
        }
    },
    LayoutSection: {
        type: 'LayoutSection',
        props: {
            customLabel: '?boolean',
            detailHeading: '?boolean',
            editHeading: '?boolean',
            label: '?string',
            layoutColumns: [
                'LayoutColumn'
            ],
            style: 'string'
        }
    },
    LayoutColumn: {
        type: 'LayoutColumn',
        props: {
            layoutItems: [
                'LayoutItem'
            ],
            reserved: '?string'
        }
    },
    LayoutItem: {
        type: 'LayoutItem',
        props: {
            analyticsCloudComponent: '?AnalyticsCloudComponentLayoutItem',
            behavior: '?string',
            canvas: '?string',
            component: '?string',
            customLink: '?string',
            emptySpace: '?boolean',
            field: '?string',
            height: '?number',
            page: '?string',
            reportChartComponent: '?ReportChartComponentLayoutItem',
            scontrol: '?string',
            showLabel: '?boolean',
            showScrollbars: '?boolean',
            width: '?string'
        }
    },
    AnalyticsCloudComponentLayoutItem: {
        type: 'AnalyticsCloudComponentLayoutItem',
        props: {
            assetType: 'string',
            devName: 'string',
            error: '?string',
            filter: '?string',
            height: '?number',
            hideOnError: '?boolean',
            showHeader: '?boolean',
            showSharing: '?boolean',
            showTitle: '?boolean',
            width: '?string'
        }
    },
    ReportChartComponentLayoutItem: {
        type: 'ReportChartComponentLayoutItem',
        props: {
            cacheData: '?boolean',
            contextFilterableField: '?string',
            error: '?string',
            hideOnError: '?boolean',
            includeContext: '?boolean',
            reportName: 'string',
            showTitle: '?boolean',
            size: '?string'
        }
    },
    MiniLayout: {
        type: 'MiniLayout',
        props: {
            fields: [
                'string'
            ],
            relatedLists: [
                'RelatedListItem'
            ]
        }
    },
    RelatedListItem: {
        type: 'RelatedListItem',
        props: {
            customButtons: [
                'string'
            ],
            excludeButtons: [
                'string'
            ],
            fields: [
                'string'
            ],
            relatedList: 'string',
            sortField: '?string',
            sortOrder: '?string'
        }
    },
    RelatedContent: {
        type: 'RelatedContent',
        props: {
            relatedContentItems: [
                'RelatedContentItem'
            ]
        }
    },
    RelatedContentItem: {
        type: 'RelatedContentItem',
        props: {
            layoutItem: 'LayoutItem'
        }
    },
    SummaryLayout: {
        type: 'SummaryLayout',
        props: {
            masterLabel: 'string',
            sizeX: 'number',
            sizeY: '?number',
            sizeZ: '?number',
            summaryLayoutItems: [
                'SummaryLayoutItem'
            ],
            summaryLayoutStyle: 'string'
        }
    },
    SummaryLayoutItem: {
        type: 'SummaryLayoutItem',
        props: {
            customLink: '?string',
            field: '?string',
            posX: 'number',
            posY: '?number',
            posZ: '?number'
        }
    },
    LeadConfigSettings: {
        type: 'LeadConfigSettings',
        props: {
            doesEnableLeadConvertDefaultSubjectBlankTaskCreation: '?boolean',
            doesHideOpportunityInConvertLeadWindow: '?boolean',
            doesPreserveLeadStatus: '?boolean',
            doesSelectNoOpportunityOnConvertLead: '?boolean',
            doesTrackHistory: '?boolean',
            enableConversionsOnMobile: '?boolean',
            enableOrgWideMergeAndDelete: '?boolean',
            shouldLeadConvertRequireValidation: '?boolean'
        },
        extends: 'Metadata'
    },
    LeadConvertSettings: {
        type: 'LeadConvertSettings',
        props: {
            allowOwnerChange: '?boolean',
            objectMapping: [
                'ObjectMapping'
            ],
            opportunityCreationOptions: '?string'
        },
        extends: 'Metadata'
    },
    Letterhead: {
        type: 'Letterhead',
        props: {
            available: 'boolean',
            backgroundColor: 'string',
            bodyColor: 'string',
            bottomLine: 'LetterheadLine',
            description: '?string',
            footer: 'LetterheadHeaderFooter',
            header: 'LetterheadHeaderFooter',
            middleLine: 'LetterheadLine',
            name: 'string',
            topLine: 'LetterheadLine'
        },
        extends: 'Metadata'
    },
    LetterheadLine: {
        type: 'LetterheadLine',
        props: {
            color: 'string',
            height: 'number'
        }
    },
    LetterheadHeaderFooter: {
        type: 'LetterheadHeaderFooter',
        props: {
            backgroundColor: 'string',
            height: 'number',
            horizontalAlignment: '?string',
            logo: '?string',
            verticalAlignment: '?string'
        }
    },
    LicenseDefinition: {
        type: 'LicenseDefinition',
        props: {
            aggregationGroup: 'string',
            description: '?string',
            isPublished: 'boolean',
            label: 'string',
            licensedCustomPermissions: [
                'LicensedCustomPermissions'
            ],
            licensingAuthority: 'string',
            licensingAuthorityProvider: 'string',
            minPlatformVersion: 'number',
            origin: 'string',
            revision: 'number',
            trialLicenseDuration: 'number',
            trialLicenseQuantity: 'number'
        },
        extends: 'Metadata'
    },
    LicensedCustomPermissions: {
        type: 'LicensedCustomPermissions',
        props: {
            customPermission: 'string',
            licenseDefinition: 'string'
        }
    },
    LightningBolt: {
        type: 'LightningBolt',
        props: {
            category: 'string',
            lightningBoltFeatures: [
                'LightningBoltFeatures'
            ],
            lightningBoltImages: [
                'LightningBoltImages'
            ],
            lightningBoltItems: [
                'LightningBoltItems'
            ],
            masterLabel: 'string',
            publisher: 'string',
            summary: 'string'
        },
        extends: 'Metadata'
    },
    LightningBoltFeatures: {
        type: 'LightningBoltFeatures',
        props: {
            description: '?string',
            order: 'number',
            title: 'string'
        }
    },
    LightningBoltImages: {
        type: 'LightningBoltImages',
        props: {
            image: 'string',
            order: 'number'
        }
    },
    LightningBoltItems: {
        type: 'LightningBoltItems',
        props: {
            name: 'string',
            type: 'string'
        }
    },
    LightningComponentBundle: {
        type: 'LightningComponentBundle',
        props: {
            apiVersion: '?number',
            description: '?string',
            isExplicitImport: '?boolean',
            isExposed: '?boolean',
            lwcResources: '?LwcResources',
            masterLabel: '?string',
            runtimeNamespace: '?string',
            targetConfigs: '?string',
            targets: '?Targets'
        },
        extends: 'Metadata'
    },
    LwcResources: {
        type: 'LwcResources',
        props: {
            lwcResource: [
                'LwcResource'
            ]
        }
    },
    LwcResource: {
        type: 'LwcResource',
        props: {
            filePath: 'string',
            source: 'string'
        }
    },
    Targets: {
        type: 'Targets',
        props: {
            target: [
                'string'
            ]
        }
    },
    LightningExperienceSettings: {
        type: 'LightningExperienceSettings',
        props: {
            enableAccessCheckCrucPref: '?boolean',
            enableApiUserLtngOutAccessPref: '?boolean',
            enableAuraCDNPref: '?boolean',
            enableFeedbackInMobile: '?boolean',
            enableIE11DeprecationMsgHidden: '?boolean',
            enableIE11LEXCrucPref: '?boolean',
            enableInAppTooltips: '?boolean',
            enableLEXOnIpadEnabled: '?boolean',
            enableLexEndUsersNoSwitching: '?boolean',
            enableNavPersonalizationOptOut: '?boolean',
            enableRemoveThemeBrandBanner: '?boolean',
            enableS1BannerPref: '?boolean',
            enableS1BrowserEnabled: '?boolean',
            enableS1DesktopEnabled: '?boolean',
            enableS1UiLoggingEnabled: '?boolean',
            enableTryLightningOptOut: '?boolean',
            enableUseS1AlohaDesktop: '?boolean',
            enableUsersAreLightningOnly: '?boolean'
        },
        extends: 'Metadata'
    },
    LightningExperienceTheme: {
        type: 'LightningExperienceTheme',
        props: {
            defaultBrandingSet: 'string',
            description: '?string',
            masterLabel: 'string',
            shouldOverrideLoadingImage: '?boolean'
        },
        extends: 'Metadata'
    },
    LightningMessageChannel: {
        type: 'LightningMessageChannel',
        props: {
            description: '?string',
            isExposed: '?boolean',
            lightningMessageFields: [
                'LightningMessageField'
            ],
            masterLabel: 'string'
        },
        extends: 'Metadata'
    },
    LightningMessageField: {
        type: 'LightningMessageField',
        props: {
            description: '?string',
            fieldName: 'string'
        }
    },
    LightningOnboardingConfig: {
        type: 'LightningOnboardingConfig',
        props: {
            collaborationGroup: '?string',
            customQuestion: 'string',
            feedbackFormDaysFrequency: 'number',
            isCustom: 'boolean',
            masterLabel: 'string',
            sendFeedbackToSalesforce: 'boolean'
        },
        extends: 'Metadata'
    },
    LiveAgentSettings: {
        type: 'LiveAgentSettings',
        props: {
            enableLiveAgent: '?boolean',
            enableQuickTextEnabled: '?boolean'
        },
        extends: 'Metadata'
    },
    LiveChatAgentConfig: {
        type: 'LiveChatAgentConfig',
        props: {
            assignments: '?AgentConfigAssignments',
            autoGreeting: '?string',
            capacity: '?number',
            criticalWaitTime: '?number',
            customAgentName: '?string',
            enableAgentFileTransfer: '?boolean',
            enableAgentSneakPeek: '?boolean',
            enableAssistanceFlag: '?boolean',
            enableAutoAwayOnDecline: '?boolean',
            enableAutoAwayOnPushTimeout: '?boolean',
            enableChatConferencing: '?boolean',
            enableChatMonitoring: '?boolean',
            enableChatTransferToAgent: '?boolean',
            enableChatTransferToButton: '?boolean',
            enableChatTransferToSkill: '?boolean',
            enableLogoutSound: '?boolean',
            enableNotifications: '?boolean',
            enableRequestSound: '?boolean',
            enableSneakPeek: '?boolean',
            enableVisitorBlocking: '?boolean',
            enableWhisperMessage: '?boolean',
            label: 'string',
            supervisorDefaultAgentStatusFilter: '?string',
            supervisorDefaultButtonFilter: '?string',
            supervisorDefaultSkillFilter: '?string',
            supervisorSkills: '?SupervisorAgentConfigSkills',
            transferableButtons: '?AgentConfigButtons',
            transferableSkills: '?AgentConfigSkills'
        },
        extends: 'Metadata'
    },
    AgentConfigAssignments: {
        type: 'AgentConfigAssignments',
        props: {
            profiles: '?AgentConfigProfileAssignments',
            users: '?AgentConfigUserAssignments'
        }
    },
    AgentConfigProfileAssignments: {
        type: 'AgentConfigProfileAssignments',
        props: {
            profile: [
                'string'
            ]
        }
    },
    AgentConfigUserAssignments: {
        type: 'AgentConfigUserAssignments',
        props: {
            user: [
                'string'
            ]
        }
    },
    SupervisorAgentConfigSkills: {
        type: 'SupervisorAgentConfigSkills',
        props: {
            skill: [
                'string'
            ]
        }
    },
    AgentConfigButtons: {
        type: 'AgentConfigButtons',
        props: {
            button: [
                'string'
            ]
        }
    },
    AgentConfigSkills: {
        type: 'AgentConfigSkills',
        props: {
            skill: [
                'string'
            ]
        }
    },
    LiveChatButton: {
        type: 'LiveChatButton',
        props: {
            animation: '?string',
            autoGreeting: '?string',
            chasitorIdleTimeout: '?number',
            chasitorIdleTimeoutWarning: '?number',
            chatPage: '?string',
            customAgentName: '?string',
            deployments: '?LiveChatButtonDeployments',
            enableQueue: '?boolean',
            inviteEndPosition: '?string',
            inviteImage: '?string',
            inviteStartPosition: '?string',
            isActive: '?boolean',
            label: 'string',
            numberOfReroutingAttempts: '?number',
            offlineImage: '?string',
            onlineImage: '?string',
            optionsCustomRoutingIsEnabled: '?boolean',
            optionsHasChasitorIdleTimeout: 'boolean',
            optionsHasInviteAfterAccept: '?boolean',
            optionsHasInviteAfterReject: '?boolean',
            optionsHasRerouteDeclinedRequest: '?boolean',
            optionsIsAutoAccept: '?boolean',
            optionsIsInviteAutoRemove: '?boolean',
            overallQueueLength: '?number',
            perAgentQueueLength: '?number',
            postChatPage: '?string',
            postChatUrl: '?string',
            preChatFormPage: '?string',
            preChatFormUrl: '?string',
            pushTimeOut: '?number',
            routingType: 'string',
            site: '?string',
            skills: '?LiveChatButtonSkills',
            timeToRemoveInvite: '?number',
            type: 'string',
            windowLanguage: '?string'
        },
        extends: 'Metadata'
    },
    LiveChatButtonDeployments: {
        type: 'LiveChatButtonDeployments',
        props: {
            deployment: [
                'string'
            ]
        }
    },
    LiveChatButtonSkills: {
        type: 'LiveChatButtonSkills',
        props: {
            skill: [
                'string'
            ]
        }
    },
    LiveChatDeployment: {
        type: 'LiveChatDeployment',
        props: {
            brandingImage: '?string',
            connectionTimeoutDuration: '?number',
            connectionWarningDuration: '?number',
            displayQueuePosition: '?boolean',
            domainWhiteList: '?LiveChatDeploymentDomainWhitelist',
            enablePrechatApi: '?boolean',
            enableTranscriptSave: '?boolean',
            label: 'string',
            mobileBrandingImage: '?string',
            site: '?string',
            windowTitle: 'string'
        },
        extends: 'Metadata'
    },
    LiveChatDeploymentDomainWhitelist: {
        type: 'LiveChatDeploymentDomainWhitelist',
        props: {
            domain: [
                'string'
            ]
        }
    },
    LiveChatSensitiveDataRule: {
        type: 'LiveChatSensitiveDataRule',
        props: {
            actionType: 'string',
            description: '?string',
            enforceOn: 'number',
            isEnabled: 'boolean',
            pattern: 'string',
            priority: 'number',
            replacement: '?string'
        },
        extends: 'Metadata'
    },
    LiveMessageSettings: {
        type: 'LiveMessageSettings',
        props: {
            enableLiveMessage: '?boolean'
        },
        extends: 'Metadata'
    },
    MacroSettings: {
        type: 'MacroSettings',
        props: {
            enableAdvancedSearch: '?boolean',
            macrosInFolders: '?boolean'
        },
        extends: 'Metadata'
    },
    ManagedContentType: {
        type: 'ManagedContentType',
        props: {
            description: '?string',
            developerName: 'string',
            managedContentNodeTypes: [
                'ManagedContentNodeType'
            ],
            masterLabel: 'string'
        },
        extends: 'Metadata'
    },
    ManagedContentNodeType: {
        type: 'ManagedContentNodeType',
        props: {
            helpText: '?string',
            isLocalizable: '?boolean',
            isRequired: '?boolean',
            nodeLabel: 'string',
            nodeName: 'string',
            nodeType: 'string',
            placeholderText: '?string'
        }
    },
    ManagedTopic: {
        type: 'ManagedTopic',
        props: {
            managedTopicType: 'string',
            name: 'string',
            parentName: 'string',
            position: 'number',
            topicDescription: 'string'
        },
        extends: 'Metadata'
    },
    ManagedTopics: {
        type: 'ManagedTopics',
        props: {
            managedTopic: [
                'ManagedTopic'
            ]
        },
        extends: 'Metadata'
    },
    SourceTrackingSettings: {
        type: 'SourceTrackingSettings',
        props: {
            enableSourceTrackingSandboxes: '?boolean'
        },
        extends: 'Metadata'
    },
    MapsAndLocationSettings: {
        type: 'MapsAndLocationSettings',
        props: {
            enableAddressAutoComplete: '?boolean',
            enableMapsAndLocation: '?boolean'
        },
        extends: 'Metadata'
    },
    MatchingRule: {
        type: 'MatchingRule',
        props: {
            booleanFilter: '?string',
            description: '?string',
            label: 'string',
            matchingRuleItems: [
                'MatchingRuleItem'
            ],
            ruleStatus: 'string'
        },
        extends: 'Metadata'
    },
    MatchingRuleItem: {
        type: 'MatchingRuleItem',
        props: {
            blankValueBehavior: '?string',
            fieldName: 'string',
            matchingMethod: 'string'
        }
    },
    MatchingRules: {
        type: 'MatchingRules',
        props: {
            matchingRules: [
                'MatchingRule'
            ]
        },
        extends: 'Metadata'
    },
    MetadataWithContent: {
        type: 'MetadataWithContent',
        props: {
            content: '?string'
        },
        extends: 'Metadata'
    },
    AccessControlPolicy: {
        type: 'AccessControlPolicy',
        props: {
            active: 'boolean',
            deploymentStatus: 'string',
            description: '?string',
            masterLabel: 'string',
            targetEntity: 'string',
            version: 'number'
        },
        extends: 'MetadataWithContent'
    },
    ApexClass: {
        type: 'ApexClass',
        props: {
            apiVersion: 'number',
            packageVersions: [
                'PackageVersion'
            ],
            status: 'string'
        },
        extends: 'MetadataWithContent'
    },
    ApexComponent: {
        type: 'ApexComponent',
        props: {
            apiVersion: '?number',
            description: '?string',
            label: 'string',
            packageVersions: [
                'PackageVersion'
            ]
        },
        extends: 'MetadataWithContent'
    },
    ApexPage: {
        type: 'ApexPage',
        props: {
            apiVersion: 'number',
            availableInTouch: '?boolean',
            confirmationTokenRequired: '?boolean',
            description: '?string',
            label: 'string',
            packageVersions: [
                'PackageVersion'
            ]
        },
        extends: 'MetadataWithContent'
    },
    ApexTrigger: {
        type: 'ApexTrigger',
        props: {
            apiVersion: 'number',
            packageVersions: [
                'PackageVersion'
            ],
            status: 'string'
        },
        extends: 'MetadataWithContent'
    },
    Certificate: {
        type: 'Certificate',
        props: {
            caSigned: 'boolean',
            encryptedWithPlatformEncryption: '?boolean',
            expirationDate: '?string',
            keySize: '?number',
            masterLabel: 'string',
            privateKeyExportable: '?boolean'
        },
        extends: 'MetadataWithContent'
    },
    ContentAsset: {
        type: 'ContentAsset',
        props: {
            format: '?string',
            isVisibleByExternalUsers: '?boolean',
            language: 'string',
            masterLabel: 'string',
            originNetwork: '?string',
            relationships: '?ContentAssetRelationships',
            versions: 'ContentAssetVersions'
        },
        extends: 'MetadataWithContent'
    },
    ContentAssetRelationships: {
        type: 'ContentAssetRelationships',
        props: {
            insightsApplication: [
                'ContentAssetLink'
            ],
            network: [
                'ContentAssetLink'
            ],
            organization: '?ContentAssetLink',
            workspace: [
                'ContentAssetLink'
            ]
        }
    },
    ContentAssetLink: {
        type: 'ContentAssetLink',
        props: {
            access: 'string',
            isManagingWorkspace: '?boolean',
            name: '?string'
        }
    },
    ContentAssetVersions: {
        type: 'ContentAssetVersions',
        props: {
            version: [
                'ContentAssetVersion'
            ]
        }
    },
    ContentAssetVersion: {
        type: 'ContentAssetVersion',
        props: {
            number: 'string',
            pathOnClient: 'string',
            zipEntry: '?string'
        }
    },
    Document: {
        type: 'Document',
        props: {
            description: '?string',
            internalUseOnly: 'boolean',
            keywords: '?string',
            name: '?string',
            public: 'boolean'
        },
        extends: 'MetadataWithContent'
    },
    EclairGeoData: {
        type: 'EclairGeoData',
        props: {
            maps: [
                'EclairMap'
            ],
            masterLabel: 'string'
        },
        extends: 'MetadataWithContent'
    },
    EclairMap: {
        type: 'EclairMap',
        props: {
            boundingBoxBottom: '?number',
            boundingBoxLeft: '?number',
            boundingBoxRight: '?number',
            boundingBoxTop: '?number',
            mapLabel: '?string',
            mapName: 'string',
            projection: 'string'
        }
    },
    EmailTemplate: {
        type: 'EmailTemplate',
        props: {
            apiVersion: '?number',
            attachedDocuments: [
                'string'
            ],
            attachments: [
                'Attachment'
            ],
            available: 'boolean',
            description: '?string',
            encodingKey: 'string',
            letterhead: '?string',
            name: 'string',
            packageVersions: [
                'PackageVersion'
            ],
            relatedEntityType: '?string',
            style: 'string',
            subject: '?string',
            textOnly: '?string',
            type: 'string',
            uiType: '?string'
        },
        extends: 'MetadataWithContent'
    },
    Attachment: {
        type: 'Attachment',
        props: {
            content: 'string',
            name: 'string'
        }
    },
    NetworkBranding: {
        type: 'NetworkBranding',
        props: {
            loginBackgroundImageUrl: '?string',
            loginFooterText: '?string',
            loginLogo: '?string',
            loginLogoName: '?string',
            loginPrimaryColor: '?string',
            loginQuaternaryColor: '?string',
            loginRightFrameUrl: '?string',
            network: '?string',
            pageFooter: '?string',
            pageHeader: '?string',
            primaryColor: 'string',
            primaryComplementColor: 'string',
            quaternaryColor: 'string',
            quaternaryComplementColor: 'string',
            secondaryColor: 'string',
            staticLogoImageUrl: '?string',
            tertiaryColor: 'string',
            tertiaryComplementColor: 'string',
            zeronaryColor: 'string',
            zeronaryComplementColor: 'string'
        },
        extends: 'MetadataWithContent'
    },
    Orchestration: {
        type: 'Orchestration',
        props: {
            context: 'string',
            masterLabel: 'string'
        },
        extends: 'MetadataWithContent'
    },
    Scontrol: {
        type: 'Scontrol',
        props: {
            contentSource: 'string',
            description: '?string',
            encodingKey: 'string',
            fileContent: '?string',
            fileName: '?string',
            name: 'string',
            supportsCaching: 'boolean'
        },
        extends: 'MetadataWithContent'
    },
    SiteDotCom: {
        type: 'SiteDotCom',
        props: {
            label: 'string',
            siteType: 'string'
        },
        extends: 'MetadataWithContent'
    },
    StaticResource: {
        type: 'StaticResource',
        props: {
            cacheControl: 'string',
            contentType: 'string',
            description: '?string'
        },
        extends: 'MetadataWithContent'
    },
    UiPlugin: {
        type: 'UiPlugin',
        props: {
            description: '?string',
            extensionPointIdentifier: 'string',
            isEnabled: 'boolean',
            language: 'string',
            masterLabel: 'string'
        },
        extends: 'MetadataWithContent'
    },
    WaveDashboard: {
        type: 'WaveDashboard',
        props: {
            application: 'string',
            description: '?string',
            masterLabel: 'string',
            templateAssetSourceName: '?string'
        },
        extends: 'MetadataWithContent'
    },
    WaveDataflow: {
        type: 'WaveDataflow',
        props: {
            dataflowType: '?string',
            description: '?string',
            masterLabel: 'string'
        },
        extends: 'MetadataWithContent'
    },
    WaveLens: {
        type: 'WaveLens',
        props: {
            application: 'string',
            datasets: [
                'string'
            ],
            description: '?string',
            masterLabel: 'string',
            templateAssetSourceName: '?string',
            visualizationType: 'string'
        },
        extends: 'MetadataWithContent'
    },
    WaveRecipe: {
        type: 'WaveRecipe',
        props: {
            dataflow: 'string',
            masterLabel: 'string',
            securityPredicate: '?string',
            targetDatasetAlias: 'string'
        },
        extends: 'MetadataWithContent'
    },
    MilestoneType: {
        type: 'MilestoneType',
        props: {
            description: '?string',
            recurrenceType: '?string'
        },
        extends: 'Metadata'
    },
    MlDomain: {
        type: 'MlDomain',
        props: {
            description: '?string',
            label: 'string',
            mlIntents: [
                'MlIntent'
            ],
            mlSlotClasses: [
                'MlSlotClass'
            ]
        },
        extends: 'Metadata'
    },
    MobileApplicationDetail: {
        type: 'MobileApplicationDetail',
        props: {
            applicationBinaryFile: '?string',
            applicationBinaryFileName: '?string',
            applicationBundleIdentifier: '?string',
            applicationFileLength: '?number',
            applicationIconFile: '?string',
            applicationIconFileName: '?string',
            applicationInstallUrl: '?string',
            devicePlatform: 'string',
            deviceType: '?string',
            minimumOsVersion: '?string',
            privateApp: '?boolean',
            version: 'string'
        },
        extends: 'Metadata'
    },
    MobileSettings: {
        type: 'MobileSettings',
        props: {
            dashboardMobile: '?DashboardMobileSettings',
            enableImportContactFromDevice: '?boolean',
            enableLightningOnMobile: '?boolean',
            enableOfflineDraftsEnabled: '?boolean',
            enablePopulateNameManuallyInToday: '?boolean',
            enableS1EncryptedStoragePref2: '?boolean',
            enableS1OfflinePref: '?boolean'
        },
        extends: 'Metadata'
    },
    DashboardMobileSettings: {
        type: 'DashboardMobileSettings',
        props: {
            enableDashboardIPadApp: '?boolean'
        }
    },
    ModerationRule: {
        type: 'ModerationRule',
        props: {
            action: 'string',
            actionLimit: '?number',
            active: 'boolean',
            description: '?string',
            entitiesAndFields: [
                'ModeratedEntityField'
            ],
            masterLabel: 'string',
            notifyLimit: '?number',
            timePeriod: '?string',
            type: '?string',
            userCriteria: [
                'string'
            ],
            userMessage: '?string'
        },
        extends: 'Metadata'
    },
    ModeratedEntityField: {
        type: 'ModeratedEntityField',
        props: {
            entityName: 'string',
            fieldName: '?string',
            keywordList: '?string'
        }
    },
    MyDomainSettings: {
        type: 'MyDomainSettings',
        props: {
            canOnlyLoginWithMyDomainUrl: '?boolean',
            doesApiLoginRequireOrgDomain: '?boolean',
            enableNativeBrowserForAuthOnAndroid: '?boolean',
            enableNativeBrowserForAuthOnIos: '?boolean',
            useStabilizedMyDomainHostnames: '?boolean',
            useStabilizedSandboxMyDomainHostnames: '?boolean'
        },
        extends: 'Metadata'
    },
    NameSettings: {
        type: 'NameSettings',
        props: {
            enableMiddleName: '?boolean',
            enableNameSuffix: '?boolean'
        },
        extends: 'Metadata'
    },
    NamedCredential: {
        type: 'NamedCredential',
        props: {
            allowMergeFieldsInBody: '?boolean',
            allowMergeFieldsInHeader: '?boolean',
            authProvider: '?string',
            authTokenEndpointUrl: '?string',
            awsAccessKey: '?string',
            awsAccessSecret: '?string',
            awsRegion: '?string',
            awsService: '?string',
            certificate: '?string',
            endpoint: '?string',
            generateAuthorizationHeader: '?boolean',
            jwtAudience: '?string',
            jwtFormulaSubject: '?string',
            jwtIssuer: '?string',
            jwtSigningCertificate: '?string',
            jwtTextSubject: '?string',
            jwtValidityPeriodSeconds: '?number',
            label: 'string',
            oauthRefreshToken: '?string',
            oauthScope: '?string',
            oauthToken: '?string',
            password: '?string',
            principalType: 'string',
            privateConnection: '?string',
            protocol: 'string',
            username: '?string'
        },
        extends: 'Metadata'
    },
    NavigationMenu: {
        type: 'NavigationMenu',
        props: {
            container: 'string',
            containerType: 'string',
            label: 'string',
            navigationMenuItem: [
                'NavigationMenuItem'
            ]
        },
        extends: 'Metadata'
    },
    Network: {
        type: 'Network',
        props: {
            allowInternalUserLogin: '?boolean',
            allowMembersToFlag: '?boolean',
            allowedExtensions: '?string',
            caseCommentEmailTemplate: '?string',
            changePasswordTemplate: 'string',
            communityRoles: '?CommunityRoles',
            description: '?string',
            disableReputationRecordConversations: '?boolean',
            emailFooterLogo: '?string',
            emailFooterText: '?string',
            emailSenderAddress: 'string',
            emailSenderName: 'string',
            enableCustomVFErrorPageOverrides: '?boolean',
            enableDirectMessages: '?boolean',
            enableGuestChatter: '?boolean',
            enableGuestFileAccess: '?boolean',
            enableGuestMemberVisibility: '?boolean',
            enableInvitation: '?boolean',
            enableKnowledgeable: '?boolean',
            enableMemberVisibility: '?boolean',
            enableNicknameDisplay: '?boolean',
            enablePrivateMessages: '?boolean',
            enableReputation: '?boolean',
            enableShowAllNetworkSettings: '?boolean',
            enableSiteAsContainer: '?boolean',
            enableTalkingAboutStats: '?boolean',
            enableTopicAssignmentRules: '?boolean',
            enableTopicSuggestions: '?boolean',
            enableUpDownVote: '?boolean',
            feedChannel: '?string',
            forgotPasswordTemplate: 'string',
            gatherCustomerSentimentData: '?boolean',
            lockoutTemplate: '?string',
            logoutUrl: '?string',
            maxFileSizeKb: '?number',
            navigationLinkSet: '?NavigationLinkSet',
            networkMemberGroups: '?NetworkMemberGroup',
            networkPageOverrides: '?NetworkPageOverride',
            newSenderAddress: '?string',
            picassoSite: '?string',
            recommendationAudience: '?RecommendationAudience',
            recommendationDefinition: '?RecommendationDefinition',
            reputationLevels: '?ReputationLevelDefinitions',
            reputationPointsRules: '?ReputationPointsRules',
            selfRegProfile: '?string',
            selfRegistration: '?boolean',
            sendWelcomeEmail: '?boolean',
            site: 'string',
            status: 'string',
            tabs: 'NetworkTabSet',
            urlPathPrefix: '?string',
            verificationTemplate: '?string',
            welcomeTemplate: 'string'
        },
        extends: 'Metadata'
    },
    CommunityRoles: {
        type: 'CommunityRoles',
        props: {
            customerUserRole: '?string',
            employeeUserRole: '?string',
            partnerUserRole: '?string'
        }
    },
    NetworkMemberGroup: {
        type: 'NetworkMemberGroup',
        props: {
            permissionSet: [
                'string'
            ],
            profile: [
                'string'
            ]
        }
    },
    NetworkPageOverride: {
        type: 'NetworkPageOverride',
        props: {
            changePasswordPageOverrideSetting: '?string',
            forgotPasswordPageOverrideSetting: '?string',
            homePageOverrideSetting: '?string',
            loginPageOverrideSetting: '?string',
            selfRegProfilePageOverrideSetting: '?string'
        }
    },
    RecommendationAudience: {
        type: 'RecommendationAudience',
        props: {
            recommendationAudienceDetails: [
                'RecommendationAudienceDetail'
            ]
        }
    },
    RecommendationAudienceDetail: {
        type: 'RecommendationAudienceDetail',
        props: {
            audienceCriteriaType: '?string',
            audienceCriteriaValue: '?string',
            setupName: '?string'
        }
    },
    RecommendationDefinition: {
        type: 'RecommendationDefinition',
        props: {
            recommendationDefinitionDetails: [
                'RecommendationDefinitionDetail'
            ]
        }
    },
    RecommendationDefinitionDetail: {
        type: 'RecommendationDefinitionDetail',
        props: {
            actionUrl: '?string',
            description: '?string',
            linkText: '?string',
            scheduledRecommendations: '?ScheduledRecommendation',
            setupName: '?string',
            title: '?string'
        }
    },
    ScheduledRecommendation: {
        type: 'ScheduledRecommendation',
        props: {
            scheduledRecommendationDetails: [
                'ScheduledRecommendationDetail'
            ]
        }
    },
    ScheduledRecommendationDetail: {
        type: 'ScheduledRecommendationDetail',
        props: {
            channel: '?string',
            enabled: '?boolean',
            rank: '?number',
            recommendationAudience: '?string'
        }
    },
    ReputationLevelDefinitions: {
        type: 'ReputationLevelDefinitions',
        props: {
            level: [
                'ReputationLevel'
            ]
        }
    },
    ReputationLevel: {
        type: 'ReputationLevel',
        props: {
            branding: '?ReputationBranding',
            label: '?string',
            lowerThreshold: 'number'
        }
    },
    ReputationBranding: {
        type: 'ReputationBranding',
        props: {
            smallImage: '?string'
        }
    },
    ReputationPointsRules: {
        type: 'ReputationPointsRules',
        props: {
            pointsRule: [
                'ReputationPointsRule'
            ]
        }
    },
    ReputationPointsRule: {
        type: 'ReputationPointsRule',
        props: {
            eventType: 'string',
            points: 'number'
        }
    },
    NetworkTabSet: {
        type: 'NetworkTabSet',
        props: {
            customTab: [
                'string'
            ],
            defaultTab: 'string',
            standardTab: [
                'string'
            ]
        }
    },
    NotificationsSettings: {
        type: 'NotificationsSettings',
        props: {
            enableMobileAppPushNotifications: '?boolean',
            enableNotifications: '?boolean'
        },
        extends: 'Metadata'
    },
    OauthCustomScope: {
        type: 'OauthCustomScope',
        props: {
            description: 'string',
            developerName: 'string',
            isProtected: '?boolean',
            isPublic: '?boolean',
            masterLabel: 'string'
        },
        extends: 'Metadata'
    },
    ObjectLinkingSettings: {
        type: 'ObjectLinkingSettings',
        props: {
            enableObjectLinking: '?boolean'
        },
        extends: 'Metadata'
    },
    OmniChannelSettings: {
        type: 'OmniChannelSettings',
        props: {
            enableOmniAutoLoginPrompt: '?boolean',
            enableOmniChannel: '?boolean',
            enableOmniSecondaryRoutingPriority: '?boolean',
            enableOmniSkillsRouting: '?boolean'
        },
        extends: 'Metadata'
    },
    OpportunitySettings: {
        type: 'OpportunitySettings',
        props: {
            autoActivateNewReminders: '?boolean',
            customizableProductSchedulesEnabled: '?boolean',
            doesAutoAddSplitOwnerAsOpportunityTeamMember: '?boolean',
            doesEnforceStandardOpportunitySaveLogic: '?boolean',
            enableFindSimilarOpportunities: '?boolean',
            enableOpportunityFieldHistoryTracking: '?boolean',
            enableOpportunityInsightsInMobile: '?boolean',
            enableOpportunityTeam: '?boolean',
            enableUpdateReminders: '?boolean',
            findSimilarOppFilter: '?FindSimilarOppFilter',
            promptToAddProducts: '?boolean'
        },
        extends: 'Metadata'
    },
    FindSimilarOppFilter: {
        type: 'FindSimilarOppFilter',
        props: {
            similarOpportunitiesDisplayColumns: [
                'string'
            ],
            similarOpportunitiesMatchFields: [
                'string'
            ]
        }
    },
    OrchestrationContext: {
        type: 'OrchestrationContext',
        props: {
            datasets: [
                'OrchestrationContextDataset'
            ],
            description: '?string',
            events: [
                'OrchestrationContextEvent'
            ],
            imageFile: 'string',
            imageScale: 'number',
            masterLabel: 'string',
            runtimeType: 'string',
            salesforceObject: '?string',
            salesforceObjectPrimaryKey: '?string'
        },
        extends: 'Metadata'
    },
    OrchestrationContextDataset: {
        type: 'OrchestrationContextDataset',
        props: {
            datasetType: 'string',
            orchestrationDataset: 'string'
        }
    },
    OrchestrationContextEvent: {
        type: 'OrchestrationContextEvent',
        props: {
            eventType: 'string',
            orchestrationEvent: 'string',
            platformEvent: 'string',
            platformEventPrimaryKey: 'string'
        }
    },
    OrderManagementSettings: {
        type: 'OrderManagementSettings',
        props: {
            enableOrderManagement: '?boolean'
        },
        extends: 'Metadata'
    },
    OrderSettings: {
        type: 'OrderSettings',
        props: {
            enableNegativeQuantity: '?boolean',
            enableOrders: '?boolean',
            enableReductionOrders: '?boolean',
            enableZeroQuantity: '?boolean'
        },
        extends: 'Metadata'
    },
    OrgPreferenceSettings: {
        type: 'OrgPreferenceSettings',
        props: {
            preferences: [
                'OrganizationSettingsDetail'
            ]
        },
        extends: 'Metadata'
    },
    OrganizationSettingsDetail: {
        type: 'OrganizationSettingsDetail',
        props: {
            settingName: 'string',
            settingValue: 'boolean'
        }
    },
    OrgSettings: {
        type: 'OrgSettings',
        props: {
            enableCustomerSuccessPortal: '?boolean',
            enableExtendedMailMerge: '?boolean',
            enableIncludeContractStatus: '?boolean',
            enableMakeDeploymentsMandatory: '?boolean',
            enableManageSelfServiceUsers: '?boolean',
            enableOrgFeedSentimentAnalysis: '?boolean',
            enableRADeploymentAttributeOnly: '?boolean',
            enableResetDivisionOnLogin: '?boolean',
            saveMailMergeDocsAsSalesforceDocs: '?boolean'
        },
        extends: 'Metadata'
    },
    Package: {
        type: 'Package',
        props: {
            apiAccessLevel: '?string',
            description: '?string',
            namespacePrefix: '?string',
            objectPermissions: [
                'ProfileObjectPermissions'
            ],
            packageType: '?string',
            postInstallClass: '?string',
            setupWeblink: '?string',
            types: [
                'PackageTypeMembers'
            ],
            uninstallClass: '?string',
            version: 'string'
        },
        extends: 'Metadata'
    },
    ProfileObjectPermissions: {
        type: 'ProfileObjectPermissions',
        props: {
            allowCreate: '?boolean',
            allowDelete: '?boolean',
            allowEdit: '?boolean',
            allowRead: '?boolean',
            modifyAllRecords: '?boolean',
            object: 'string',
            viewAllRecords: '?boolean'
        }
    },
    PackageTypeMembers: {
        type: 'PackageTypeMembers',
        props: {
            members: [
                'string'
            ],
            name: 'string'
        }
    },
    PardotEinsteinSettings: {
        type: 'PardotEinsteinSettings',
        props: {
            enableCampaignInsight: '?boolean',
            enableEngagementScore: '?boolean'
        },
        extends: 'Metadata'
    },
    PardotSettings: {
        type: 'PardotSettings',
        props: {
            enableB2bmaAppEnabled: '?boolean',
            enableEngagementHistoryDashboards: '?boolean',
            enablePardotAppV1Enabled: '?boolean',
            enablePardotEnabled: '?boolean',
            enableProspectActivityDataset: '?boolean'
        },
        extends: 'Metadata'
    },
    PartyDataModelSettings: {
        type: 'PartyDataModelSettings',
        props: {
            enableAutoSelectIndividualOnMerge: '?boolean',
            enableConsentManagement: '?boolean'
        },
        extends: 'Metadata'
    },
    PathAssistant: {
        type: 'PathAssistant',
        props: {
            active: 'boolean',
            entityName: 'string',
            fieldName: 'string',
            masterLabel: 'string',
            pathAssistantSteps: [
                'PathAssistantStep'
            ],
            recordTypeName: 'string'
        },
        extends: 'Metadata'
    },
    PathAssistantStep: {
        type: 'PathAssistantStep',
        props: {
            fieldNames: [
                'string'
            ],
            info: '?string',
            picklistValueName: 'string'
        }
    },
    PathAssistantSettings: {
        type: 'PathAssistantSettings',
        props: {
            canOverrideAutoPathCollapseWithUserPref: '?boolean',
            pathAssistantEnabled: '?boolean'
        },
        extends: 'Metadata'
    },
    PermissionSet: {
        type: 'PermissionSet',
        props: {
            applicationVisibilities: [
                'PermissionSetApplicationVisibility'
            ],
            classAccesses: [
                'PermissionSetApexClassAccess'
            ],
            customMetadataTypeAccesses: [
                'PermissionSetCustomMetadataTypeAccess'
            ],
            customPermissions: [
                'PermissionSetCustomPermissions'
            ],
            description: '?string',
            externalDataSourceAccesses: [
                'PermissionSetExternalDataSourceAccess'
            ],
            fieldPermissions: [
                'PermissionSetFieldPermissions'
            ],
            flowAccesses: [
                'PermissionSetFlowAccess'
            ],
            hasActivationRequired: '?boolean',
            label: 'string',
            license: '?string',
            objectPermissions: [
                'PermissionSetObjectPermissions'
            ],
            pageAccesses: [
                'PermissionSetApexPageAccess'
            ],
            recordTypeVisibilities: [
                'PermissionSetRecordTypeVisibility'
            ],
            tabSettings: [
                'PermissionSetTabSetting'
            ],
            userPermissions: [
                'PermissionSetUserPermission'
            ]
        },
        extends: 'Metadata'
    },
    PermissionSetApplicationVisibility: {
        type: 'PermissionSetApplicationVisibility',
        props: {
            application: 'string',
            visible: 'boolean'
        }
    },
    PermissionSetApexClassAccess: {
        type: 'PermissionSetApexClassAccess',
        props: {
            apexClass: 'string',
            enabled: 'boolean'
        }
    },
    PermissionSetCustomMetadataTypeAccess: {
        type: 'PermissionSetCustomMetadataTypeAccess',
        props: {
            enabled: 'boolean',
            name: 'string'
        }
    },
    PermissionSetCustomPermissions: {
        type: 'PermissionSetCustomPermissions',
        props: {
            enabled: 'boolean',
            name: 'string'
        }
    },
    PermissionSetExternalDataSourceAccess: {
        type: 'PermissionSetExternalDataSourceAccess',
        props: {
            enabled: 'boolean',
            externalDataSource: 'string'
        }
    },
    PermissionSetFieldPermissions: {
        type: 'PermissionSetFieldPermissions',
        props: {
            editable: 'boolean',
            field: 'string',
            readable: '?boolean'
        }
    },
    PermissionSetFlowAccess: {
        type: 'PermissionSetFlowAccess',
        props: {
            enabled: 'boolean',
            flow: 'string'
        }
    },
    PermissionSetObjectPermissions: {
        type: 'PermissionSetObjectPermissions',
        props: {
            allowCreate: 'boolean',
            allowDelete: 'boolean',
            allowEdit: 'boolean',
            allowRead: 'boolean',
            modifyAllRecords: 'boolean',
            object: 'string',
            viewAllRecords: 'boolean'
        }
    },
    PermissionSetApexPageAccess: {
        type: 'PermissionSetApexPageAccess',
        props: {
            apexPage: 'string',
            enabled: 'boolean'
        }
    },
    PermissionSetRecordTypeVisibility: {
        type: 'PermissionSetRecordTypeVisibility',
        props: {
            recordType: 'string',
            visible: 'boolean'
        }
    },
    PermissionSetTabSetting: {
        type: 'PermissionSetTabSetting',
        props: {
            tab: 'string',
            visibility: 'string'
        }
    },
    PermissionSetUserPermission: {
        type: 'PermissionSetUserPermission',
        props: {
            enabled: 'boolean',
            name: 'string'
        }
    },
    MutingPermissionSet: {
        type: 'MutingPermissionSet',
        props: {
            label: 'string'
        },
        extends: 'PermissionSet'
    },
    PermissionSetGroup: {
        type: 'PermissionSetGroup',
        props: {
            description: '?string',
            label: 'string',
            mutingPermissionSets: [
                'string'
            ],
            permissionSets: [
                'string'
            ],
            status: '?string'
        },
        extends: 'Metadata'
    },
    PersonListSettings: {
        type: 'PersonListSettings',
        props: {
            enablePersonList: 'boolean'
        },
        extends: 'Metadata'
    },
    PicklistSettings: {
        type: 'PicklistSettings',
        props: {
            isPicklistApiNameEditDisabled: '?boolean'
        },
        extends: 'Metadata'
    },
    PlatformCachePartition: {
        type: 'PlatformCachePartition',
        props: {
            description: '?string',
            isDefaultPartition: 'boolean',
            masterLabel: 'string',
            platformCachePartitionTypes: [
                'PlatformCachePartitionType'
            ]
        },
        extends: 'Metadata'
    },
    PlatformCachePartitionType: {
        type: 'PlatformCachePartitionType',
        props: {
            allocatedCapacity: 'number',
            allocatedPurchasedCapacity: 'number',
            allocatedTrialCapacity: 'number',
            cacheType: 'string'
        }
    },
    PlatformEncryptionSettings: {
        type: 'PlatformEncryptionSettings',
        props: {
            canEncryptManagedPackageFields: '?boolean',
            enableDeterministicEncryption: '?boolean',
            enableEncryptFieldHistory: '?boolean',
            enableEventBusEncryption: '?boolean',
            isMEKForEncryptionRequired: '?boolean',
            isUseHighAssuranceKeysRequired: '?boolean'
        },
        extends: 'Metadata'
    },
    PlatformEventChannel: {
        type: 'PlatformEventChannel',
        props: {
            channelType: 'string',
            label: 'string'
        },
        extends: 'Metadata'
    },
    PlatformEventChannelMember: {
        type: 'PlatformEventChannelMember',
        props: {
            eventChannel: 'string',
            selectedEntity: 'string'
        },
        extends: 'Metadata'
    },
    Portal: {
        type: 'Portal',
        props: {
            active: 'boolean',
            admin: '?string',
            defaultLanguage: '?string',
            description: '?string',
            emailSenderAddress: 'string',
            emailSenderName: 'string',
            enableSelfCloseCase: '?boolean',
            footerDocument: '?string',
            forgotPassTemplate: '?string',
            headerDocument: '?string',
            isSelfRegistrationActivated: '?boolean',
            loginHeaderDocument: '?string',
            logoDocument: '?string',
            logoutUrl: '?string',
            newCommentTemplate: '?string',
            newPassTemplate: '?string',
            newUserTemplate: '?string',
            ownerNotifyTemplate: '?string',
            selfRegNewUserUrl: '?string',
            selfRegUserDefaultProfile: '?string',
            selfRegUserDefaultRole: '?string',
            selfRegUserTemplate: '?string',
            showActionConfirmation: '?boolean',
            stylesheetDocument: '?string',
            type: 'string'
        },
        extends: 'Metadata'
    },
    PostTemplate: {
        type: 'PostTemplate',
        props: {
            default: '?boolean',
            description: '?string',
            fields: [
                'string'
            ],
            label: 'string'
        },
        extends: 'Metadata'
    },
    PresenceDeclineReason: {
        type: 'PresenceDeclineReason',
        props: {
            label: 'string'
        },
        extends: 'Metadata'
    },
    PresenceUserConfig: {
        type: 'PresenceUserConfig',
        props: {
            assignments: '?PresenceConfigAssignments',
            capacity: 'number',
            declineReasons: [
                'string'
            ],
            enableAutoAccept: '?boolean',
            enableDecline: '?boolean',
            enableDeclineReason: '?boolean',
            enableDisconnectSound: '?boolean',
            enableRequestSound: '?boolean',
            label: 'string',
            presenceStatusOnDecline: '?string',
            presenceStatusOnPushTimeout: '?string'
        },
        extends: 'Metadata'
    },
    PresenceConfigAssignments: {
        type: 'PresenceConfigAssignments',
        props: {
            profiles: '?PresenceConfigProfileAssignments',
            users: '?PresenceConfigUserAssignments'
        }
    },
    PresenceConfigProfileAssignments: {
        type: 'PresenceConfigProfileAssignments',
        props: {
            profile: [
                'string'
            ]
        }
    },
    PresenceConfigUserAssignments: {
        type: 'PresenceConfigUserAssignments',
        props: {
            user: [
                'string'
            ]
        }
    },
    PrivacySettings: {
        type: 'PrivacySettings',
        props: {
            enableConsentAuditTrail: '?boolean',
            enableConsentEventStream: '?boolean',
            enableDefaultMetadataValues: '?boolean'
        },
        extends: 'Metadata'
    },
    PrivateConnection: {
        type: 'PrivateConnection',
        props: {
            description: '?string',
            direction: 'string',
            externalConnectionProperties: [
                'ExternalConnectionProperty'
            ],
            label: 'string',
            status: 'string',
            type: 'string'
        },
        extends: 'Metadata'
    },
    ExternalConnectionProperty: {
        type: 'ExternalConnectionProperty',
        props: {
            propertyName: 'string',
            propertyValue: 'string'
        }
    },
    ProductSettings: {
        type: 'ProductSettings',
        props: {
            enableCascadeActivateToRelatedPrices: '?boolean',
            enableMySettings: '?boolean',
            enableQuantitySchedule: '?boolean',
            enableRevenueSchedule: '?boolean'
        },
        extends: 'Metadata'
    },
    Profile: {
        type: 'Profile',
        props: {
            applicationVisibilities: [
                'ProfileApplicationVisibility'
            ],
            categoryGroupVisibilities: [
                'ProfileCategoryGroupVisibility'
            ],
            classAccesses: [
                'ProfileApexClassAccess'
            ],
            custom: '?boolean',
            customMetadataTypeAccesses: [
                'ProfileCustomMetadataTypeAccess'
            ],
            customPermissions: [
                'ProfileCustomPermissions'
            ],
            description: '?string',
            externalDataSourceAccesses: [
                'ProfileExternalDataSourceAccess'
            ],
            fieldPermissions: [
                'ProfileFieldLevelSecurity'
            ],
            flowAccesses: [
                'ProfileFlowAccess'
            ],
            layoutAssignments: [
                'ProfileLayoutAssignment'
            ],
            loginHours: '?ProfileLoginHours',
            loginIpRanges: [
                'ProfileLoginIpRange'
            ],
            objectPermissions: [
                'ProfileObjectPermissions'
            ],
            pageAccesses: [
                'ProfileApexPageAccess'
            ],
            profileActionOverrides: [
                'ProfileActionOverride'
            ],
            recordTypeVisibilities: [
                'ProfileRecordTypeVisibility'
            ],
            tabVisibilities: [
                'ProfileTabVisibility'
            ],
            userLicense: '?string',
            userPermissions: [
                'ProfileUserPermission'
            ]
        },
        extends: 'Metadata'
    },
    ProfileApplicationVisibility: {
        type: 'ProfileApplicationVisibility',
        props: {
            application: 'string',
            default: 'boolean',
            visible: 'boolean'
        }
    },
    ProfileCategoryGroupVisibility: {
        type: 'ProfileCategoryGroupVisibility',
        props: {
            dataCategories: [
                'string'
            ],
            dataCategoryGroup: 'string',
            visibility: 'string'
        }
    },
    ProfileApexClassAccess: {
        type: 'ProfileApexClassAccess',
        props: {
            apexClass: 'string',
            enabled: 'boolean'
        }
    },
    ProfileCustomMetadataTypeAccess: {
        type: 'ProfileCustomMetadataTypeAccess',
        props: {
            enabled: 'boolean',
            name: 'string'
        }
    },
    ProfileCustomPermissions: {
        type: 'ProfileCustomPermissions',
        props: {
            enabled: 'boolean',
            name: 'string'
        }
    },
    ProfileExternalDataSourceAccess: {
        type: 'ProfileExternalDataSourceAccess',
        props: {
            enabled: 'boolean',
            externalDataSource: 'string'
        }
    },
    ProfileFieldLevelSecurity: {
        type: 'ProfileFieldLevelSecurity',
        props: {
            editable: 'boolean',
            field: 'string',
            readable: '?boolean'
        }
    },
    ProfileFlowAccess: {
        type: 'ProfileFlowAccess',
        props: {
            enabled: 'boolean',
            flow: 'string'
        }
    },
    ProfileLayoutAssignment: {
        type: 'ProfileLayoutAssignment',
        props: {
            layout: 'string',
            recordType: '?string'
        }
    },
    ProfileLoginHours: {
        type: 'ProfileLoginHours',
        props: {
            fridayEnd: '?string',
            fridayStart: '?string',
            mondayEnd: '?string',
            mondayStart: '?string',
            saturdayEnd: '?string',
            saturdayStart: '?string',
            sundayEnd: '?string',
            sundayStart: '?string',
            thursdayEnd: '?string',
            thursdayStart: '?string',
            tuesdayEnd: '?string',
            tuesdayStart: '?string',
            wednesdayEnd: '?string',
            wednesdayStart: '?string'
        }
    },
    ProfileLoginIpRange: {
        type: 'ProfileLoginIpRange',
        props: {
            description: '?string',
            endAddress: 'string',
            startAddress: 'string'
        }
    },
    ProfileApexPageAccess: {
        type: 'ProfileApexPageAccess',
        props: {
            apexPage: 'string',
            enabled: 'boolean'
        }
    },
    ProfileRecordTypeVisibility: {
        type: 'ProfileRecordTypeVisibility',
        props: {
            default: 'boolean',
            personAccountDefault: '?boolean',
            recordType: 'string',
            visible: 'boolean'
        }
    },
    ProfileTabVisibility: {
        type: 'ProfileTabVisibility',
        props: {
            tab: 'string',
            visibility: 'string'
        }
    },
    ProfileUserPermission: {
        type: 'ProfileUserPermission',
        props: {
            enabled: 'boolean',
            name: 'string'
        }
    },
    ProfilePasswordPolicy: {
        type: 'ProfilePasswordPolicy',
        props: {
            forgotPasswordRedirect: '?boolean',
            lockoutInterval: 'number',
            maxLoginAttempts: 'number',
            minimumPasswordLength: 'number',
            minimumPasswordLifetime: '?boolean',
            obscure: '?boolean',
            passwordComplexity: 'number',
            passwordExpiration: 'number',
            passwordHistory: 'number',
            passwordQuestion: 'number',
            profile: 'string'
        },
        extends: 'Metadata'
    },
    ProfileSessionSetting: {
        type: 'ProfileSessionSetting',
        props: {
            externalCommunityUserIdentityVerif: 'boolean',
            forceLogout: 'boolean',
            profile: 'string',
            requiredSessionLevel: '?string',
            sessionPersistence: 'boolean',
            sessionTimeout: 'number',
            sessionTimeoutWarning: 'boolean'
        },
        extends: 'Metadata'
    },
    Prompt: {
        type: 'Prompt',
        props: {
            masterLabel: 'string',
            promptVersions: [
                'PromptVersion'
            ]
        },
        extends: 'Metadata'
    },
    PromptVersion: {
        type: 'PromptVersion',
        props: {
            actionButtonLabel: '?string',
            actionButtonLink: '?string',
            body: 'string',
            customApplication: '?string',
            delayDays: 'number',
            description: '?string',
            dismissButtonLabel: '?string',
            displayPosition: '?string',
            displayType: 'string',
            endDate: '?string',
            header: '?string',
            indexWithIsPublished: '?string',
            indexWithoutIsPublished: '?string',
            isPublished: '?boolean',
            masterLabel: 'string',
            publishedByUser: '?string',
            publishedDate: '?string',
            shouldDisplayActionButton: 'boolean',
            startDate: 'string',
            targetAppDeveloperName: 'string',
            targetAppNamespacePrefix: '?string',
            targetPageKey1: 'string',
            targetPageKey2: '?string',
            targetPageType: 'string',
            timesToDisplay: 'number',
            title: 'string',
            uiFormulaRule: '?UiFormulaRule',
            userAccess: 'string',
            versionNumber: 'number'
        }
    },
    Queue: {
        type: 'Queue',
        props: {
            doesSendEmailToMembers: '?boolean',
            email: '?string',
            name: 'string',
            queueMembers: '?QueueMembers',
            queueRoutingConfig: '?string',
            queueSobject: [
                'QueueSobject'
            ]
        },
        extends: 'Metadata'
    },
    QueueMembers: {
        type: 'QueueMembers',
        props: {
            publicGroups: '?PublicGroups',
            roleAndSubordinates: '?RoleAndSubordinates',
            roleAndSubordinatesInternal: '?RoleAndSubordinatesInternal',
            roles: '?Roles',
            users: '?Users'
        }
    },
    PublicGroups: {
        type: 'PublicGroups',
        props: {
            publicGroup: [
                'string'
            ]
        }
    },
    RoleAndSubordinates: {
        type: 'RoleAndSubordinates',
        props: {
            roleAndSubordinate: [
                'string'
            ]
        }
    },
    RoleAndSubordinatesInternal: {
        type: 'RoleAndSubordinatesInternal',
        props: {
            roleAndSubordinateInternal: [
                'string'
            ]
        }
    },
    Roles: {
        type: 'Roles',
        props: {
            role: [
                'string'
            ]
        }
    },
    Users: {
        type: 'Users',
        props: {
            user: [
                'string'
            ]
        }
    },
    QueueSobject: {
        type: 'QueueSobject',
        props: {
            sobjectType: 'string'
        }
    },
    QueueRoutingConfig: {
        type: 'QueueRoutingConfig',
        props: {
            capacityPercentage: '?number',
            capacityWeight: '?number',
            dropAdditionalSkillsTimeout: '?number',
            isAttributeBased: '?boolean',
            label: 'string',
            pushTimeout: '?number',
            queueOverflowAssignee: '?string',
            routingModel: 'string',
            routingPriority: 'number',
            userOverflowAssignee: '?string'
        },
        extends: 'Metadata'
    },
    QuickAction: {
        type: 'QuickAction',
        props: {
            canvas: '?string',
            description: '?string',
            fieldOverrides: [
                'FieldOverride'
            ],
            flowDefinition: '?string',
            height: '?number',
            icon: '?string',
            isProtected: '?boolean',
            label: '?string',
            lightningComponent: '?string',
            mobExtDisplayMode: '?string',
            optionsCreateFeedItem: 'boolean',
            page: '?string',
            quickActionLayout: '?QuickActionLayout',
            quickActionSendEmailOptions: '?QuickActionSendEmailOptions',
            standardLabel: '?string',
            successMessage: '?string',
            targetObject: '?string',
            targetParentField: '?string',
            targetRecordType: '?string',
            type: 'string',
            width: '?number'
        },
        extends: 'Metadata'
    },
    FieldOverride: {
        type: 'FieldOverride',
        props: {
            field: 'string',
            formula: '?string',
            literalValue: '?string'
        }
    },
    QuickActionLayout: {
        type: 'QuickActionLayout',
        props: {
            layoutSectionStyle: 'string',
            quickActionLayoutColumns: [
                'QuickActionLayoutColumn'
            ]
        }
    },
    QuickActionLayoutColumn: {
        type: 'QuickActionLayoutColumn',
        props: {
            quickActionLayoutItems: [
                'QuickActionLayoutItem'
            ]
        }
    },
    QuickActionLayoutItem: {
        type: 'QuickActionLayoutItem',
        props: {
            emptySpace: '?boolean',
            field: '?string',
            uiBehavior: '?string'
        }
    },
    QuickActionSendEmailOptions: {
        type: 'QuickActionSendEmailOptions',
        props: {
            defaultEmailTemplateName: '?string',
            ignoreDefaultEmailTemplateSubject: 'boolean'
        }
    },
    QuoteSettings: {
        type: 'QuoteSettings',
        props: {
            enableQuote: 'boolean',
            enableQuotesWithoutOppEnabled: '?boolean'
        },
        extends: 'Metadata'
    },
    RecommendationStrategy: {
        type: 'RecommendationStrategy',
        props: {
            actionContext: [
                'StrategyAction'
            ],
            contextRecordType: '?string',
            description: '?string',
            filter: [
                'StrategyNodeFilter'
            ],
            if: [
                'StrategyNodeIf'
            ],
            invocableAction: [
                'StrategyNodeInvocableAction'
            ],
            isTemplate: '?boolean',
            label: 'string',
            map: [
                'StrategyNodeMap'
            ],
            mutuallyExclusive: [
                'StrategyNodeExclusive'
            ],
            onBehalfOfExpression: '?string',
            recommendationLimit: [
                'StrategyNodeRecommendationLimit'
            ],
            recommendationLoad: [
                'StrategyNodeRecommendationLoad'
            ],
            sort: [
                'StrategyNodeSort'
            ],
            union: [
                'StrategyNodeUnion'
            ]
        },
        extends: 'Metadata'
    },
    StrategyAction: {
        type: 'StrategyAction',
        props: {
            action: 'string',
            argument: [
                'StrategyActionArg'
            ],
            description: '?string',
            label: '?string',
            name: 'string',
            type: 'string'
        }
    },
    StrategyActionArg: {
        type: 'StrategyActionArg',
        props: {
            name: 'string',
            value: 'string'
        }
    },
    StrategyNodeFilter: {
        type: 'StrategyNodeFilter',
        props: {
            expression: 'string'
        },
        extends: 'StrategyNodeUnionBase'
    },
    StrategyNodeUnionBase: {
        type: 'StrategyNodeUnionBase',
        props: {
            limit: '?number'
        },
        extends: 'StrategyNodeBase'
    },
    StrategyNodeBase: {
        type: 'StrategyNodeBase',
        props: {
            childNode: [
                'string'
            ],
            description: '?string',
            label: '?string',
            name: 'string'
        }
    },
    StrategyNodeExclusive: {
        type: 'StrategyNodeExclusive',
        props: {},
        extends: 'StrategyNodeUnionBase'
    },
    StrategyNodeIf: {
        type: 'StrategyNodeIf',
        props: {
            childNodeExpression: [
                'IfExpression'
            ],
            onlyFirstMatch: '?boolean'
        },
        extends: 'StrategyNodeUnionBase'
    },
    IfExpression: {
        type: 'IfExpression',
        props: {
            childName: 'string',
            expression: 'string'
        }
    },
    StrategyNodeInvocableAction: {
        type: 'StrategyNodeInvocableAction',
        props: {
            action: 'string',
            argument: [
                'StrategyNodeInvocableActionArg'
            ],
            isGenerator: 'boolean',
            type: 'string'
        },
        extends: 'StrategyNodeUnionBase'
    },
    StrategyNodeInvocableActionArg: {
        type: 'StrategyNodeInvocableActionArg',
        props: {
            name: 'string',
            value: 'string'
        }
    },
    StrategyNodeMap: {
        type: 'StrategyNodeMap',
        props: {
            mapExpression: [
                'MapExpression'
            ]
        },
        extends: 'StrategyNodeUnionBase'
    },
    MapExpression: {
        type: 'MapExpression',
        props: {
            expression: 'string',
            name: 'string',
            type: 'string'
        }
    },
    StrategyNodeRecommendationLimit: {
        type: 'StrategyNodeRecommendationLimit',
        props: {
            filterMode: [
                'string'
            ],
            lookbackDuration: '?number',
            maxRecommendationCount: '?number'
        },
        extends: 'StrategyNodeUnionBase'
    },
    StrategyNodeRecommendationLoad: {
        type: 'StrategyNodeRecommendationLoad',
        props: {
            condition: [
                'RecommendationLoadCondition'
            ],
            conditionLogic: '?string'
        },
        extends: 'StrategyNodeUnionBase'
    },
    RecommendationLoadCondition: {
        type: 'RecommendationLoadCondition',
        props: {
            field: 'string',
            operator: 'string',
            value: 'RecommendationConditionValue'
        }
    },
    RecommendationConditionValue: {
        type: 'RecommendationConditionValue',
        props: {
            type: 'string',
            value: '?string'
        }
    },
    StrategyNodeSort: {
        type: 'StrategyNodeSort',
        props: {
            field: [
                'StrategyNodeSortField'
            ]
        },
        extends: 'StrategyNodeUnionBase'
    },
    StrategyNodeSortField: {
        type: 'StrategyNodeSortField',
        props: {
            name: 'string',
            nullsFirst: '?boolean',
            order: '?string'
        }
    },
    StrategyNodeUnion: {
        type: 'StrategyNodeUnion',
        props: {},
        extends: 'StrategyNodeUnionBase'
    },
    RecordActionDeployment: {
        type: 'RecordActionDeployment',
        props: {
            channelConfigurations: [
                'RecordActionDeploymentChannel'
            ],
            deploymentContexts: [
                'RecordActionDeploymentContext'
            ],
            hasGuidedActions: '?boolean',
            hasRecommendations: '?boolean',
            masterLabel: 'string',
            recommendation: '?RecordActionRecommendation',
            selectableItems: [
                'RecordActionSelectableItem'
            ]
        },
        extends: 'Metadata'
    },
    RecordActionDeploymentChannel: {
        type: 'RecordActionDeploymentChannel',
        props: {
            channel: 'string',
            channelItems: [
                'RecordActionDefaultItem'
            ],
            isAutopopEnabled: '?boolean'
        }
    },
    RecordActionDefaultItem: {
        type: 'RecordActionDefaultItem',
        props: {
            action: 'string',
            isMandatory: '?boolean',
            isUiRemoveHidden: '?boolean',
            pinned: 'string',
            position: 'number',
            type: 'string'
        }
    },
    RecordActionDeploymentContext: {
        type: 'RecordActionDeploymentContext',
        props: {
            entityName: 'string',
            recommendationStrategy: '?string'
        }
    },
    RecordActionRecommendation: {
        type: 'RecordActionRecommendation',
        props: {
            defaultStrategy: '?string',
            hasDescription: 'boolean',
            hasImage: 'boolean',
            hasRejectAction: 'boolean',
            hasTitle: 'boolean',
            maxDisplayRecommendations: 'number'
        }
    },
    RecordActionSelectableItem: {
        type: 'RecordActionSelectableItem',
        props: {
            action: 'string',
            type: 'string'
        }
    },
    RecordPageSettings: {
        type: 'RecordPageSettings',
        props: {
            enableActivityRelatedList: '?boolean',
            enableFullRecordView: '?boolean'
        },
        extends: 'Metadata'
    },
    RemoteSiteSetting: {
        type: 'RemoteSiteSetting',
        props: {
            description: '?string',
            disableProtocolSecurity: 'boolean',
            isActive: 'boolean',
            url: 'string'
        },
        extends: 'Metadata'
    },
    Report: {
        type: 'Report',
        props: {
            aggregates: [
                'ReportAggregate'
            ],
            block: [
                'Report'
            ],
            blockInfo: '?ReportBlockInfo',
            buckets: [
                'ReportBucketField'
            ],
            chart: '?ReportChart',
            colorRanges: [
                'ReportColorRange'
            ],
            columns: [
                'ReportColumn'
            ],
            crossFilters: [
                'ReportCrossFilter'
            ],
            currency: '?string',
            customDetailFormulas: [
                'ReportCustomDetailFormula'
            ],
            dataCategoryFilters: [
                'ReportDataCategoryFilter'
            ],
            description: '?string',
            division: '?string',
            filter: '?ReportFilter',
            folderName: '?string',
            format: 'string',
            formattingRules: [
                'ReportFormattingRule'
            ],
            groupingsAcross: [
                'ReportGrouping'
            ],
            groupingsDown: [
                'ReportGrouping'
            ],
            historicalSelector: '?ReportHistoricalSelector',
            name: 'string',
            numSubscriptions: '?number',
            params: [
                'ReportParam'
            ],
            reportType: 'string',
            roleHierarchyFilter: '?string',
            rowLimit: '?number',
            scope: '?string',
            showCurrentDate: '?boolean',
            showDetails: '?boolean',
            showGrandTotal: '?boolean',
            showSubTotals: '?boolean',
            sortColumn: '?string',
            sortOrder: '?string',
            territoryHierarchyFilter: '?string',
            timeFrameFilter: '?ReportTimeFrameFilter',
            userFilter: '?string'
        },
        extends: 'Metadata'
    },
    ReportAggregate: {
        type: 'ReportAggregate',
        props: {
            acrossGroupingContext: '?string',
            calculatedFormula: 'string',
            datatype: 'string',
            description: '?string',
            developerName: 'string',
            downGroupingContext: '?string',
            isActive: 'boolean',
            isCrossBlock: '?boolean',
            masterLabel: 'string',
            reportType: '?string',
            scale: '?number'
        }
    },
    ReportBlockInfo: {
        type: 'ReportBlockInfo',
        props: {
            aggregateReferences: [
                'ReportAggregateReference'
            ],
            blockId: 'string',
            joinTable: 'string'
        }
    },
    ReportAggregateReference: {
        type: 'ReportAggregateReference',
        props: {
            aggregate: 'string'
        }
    },
    ReportBucketField: {
        type: 'ReportBucketField',
        props: {
            bucketType: 'string',
            developerName: 'string',
            masterLabel: 'string',
            nullTreatment: '?string',
            otherBucketLabel: '?string',
            sourceColumnName: 'string',
            useOther: '?boolean',
            values: [
                'ReportBucketFieldValue'
            ]
        }
    },
    ReportBucketFieldValue: {
        type: 'ReportBucketFieldValue',
        props: {
            sourceValues: [
                'ReportBucketFieldSourceValue'
            ],
            value: 'string'
        }
    },
    ReportBucketFieldSourceValue: {
        type: 'ReportBucketFieldSourceValue',
        props: {
            from: '?string',
            sourceValue: '?string',
            to: '?string'
        }
    },
    ReportChart: {
        type: 'ReportChart',
        props: {
            backgroundColor1: '?string',
            backgroundColor2: '?string',
            backgroundFadeDir: '?string',
            chartSummaries: [
                'ChartSummary'
            ],
            chartType: 'string',
            enableHoverLabels: '?boolean',
            expandOthers: '?boolean',
            groupingColumn: '?string',
            legendPosition: '?string',
            location: '?string',
            secondaryGroupingColumn: '?string',
            showAxisLabels: '?boolean',
            showPercentage: '?boolean',
            showTotal: '?boolean',
            showValues: '?boolean',
            size: '?string',
            summaryAxisManualRangeEnd: '?number',
            summaryAxisManualRangeStart: '?number',
            summaryAxisRange: '?string',
            textColor: '?string',
            textSize: '?number',
            title: '?string',
            titleColor: '?string',
            titleSize: '?number'
        }
    },
    ReportColorRange: {
        type: 'ReportColorRange',
        props: {
            aggregate: '?string',
            columnName: 'string',
            highBreakpoint: '?number',
            highColor: 'string',
            lowBreakpoint: '?number',
            lowColor: 'string',
            midColor: 'string'
        }
    },
    ReportColumn: {
        type: 'ReportColumn',
        props: {
            aggregateTypes: [
                'string'
            ],
            field: 'string',
            reverseColors: '?boolean',
            showChanges: '?boolean'
        }
    },
    ReportCrossFilter: {
        type: 'ReportCrossFilter',
        props: {
            criteriaItems: [
                'ReportFilterItem'
            ],
            operation: 'string',
            primaryTableColumn: 'string',
            relatedTable: 'string',
            relatedTableJoinColumn: 'string'
        }
    },
    ReportFilterItem: {
        type: 'ReportFilterItem',
        props: {
            column: 'string',
            columnToColumn: '?boolean',
            isUnlocked: '?boolean',
            operator: 'string',
            snapshot: '?string',
            value: '?string'
        }
    },
    ReportCustomDetailFormula: {
        type: 'ReportCustomDetailFormula',
        props: {
            calculatedFormula: 'string',
            dataType: 'string',
            description: '?string',
            developerName: 'string',
            label: 'string',
            scale: 'number'
        }
    },
    ReportDataCategoryFilter: {
        type: 'ReportDataCategoryFilter',
        props: {
            dataCategory: 'string',
            dataCategoryGroup: 'string',
            operator: 'string'
        }
    },
    ReportFilter: {
        type: 'ReportFilter',
        props: {
            booleanFilter: '?string',
            criteriaItems: [
                'ReportFilterItem'
            ],
            language: '?string'
        }
    },
    ReportFormattingRule: {
        type: 'ReportFormattingRule',
        props: {
            aggregate: '?string',
            columnName: 'string',
            values: [
                'ReportFormattingRuleValue'
            ]
        }
    },
    ReportFormattingRuleValue: {
        type: 'ReportFormattingRuleValue',
        props: {
            backgroundColor: '?string',
            rangeUpperBound: '?number'
        }
    },
    ReportGrouping: {
        type: 'ReportGrouping',
        props: {
            aggregateType: '?string',
            dateGranularity: '?string',
            field: 'string',
            sortByName: '?string',
            sortOrder: 'string',
            sortType: '?string'
        }
    },
    ReportHistoricalSelector: {
        type: 'ReportHistoricalSelector',
        props: {
            snapshot: [
                'string'
            ]
        }
    },
    ReportParam: {
        type: 'ReportParam',
        props: {
            name: 'string',
            value: 'string'
        }
    },
    ReportTimeFrameFilter: {
        type: 'ReportTimeFrameFilter',
        props: {
            dateColumn: 'string',
            endDate: '?string',
            interval: 'string',
            startDate: '?string'
        }
    },
    ReportType: {
        type: 'ReportType',
        props: {
            autogenerated: '?boolean',
            baseObject: 'string',
            category: 'string',
            deployed: 'boolean',
            description: '?string',
            join: '?ObjectRelationship',
            label: 'string',
            sections: [
                'ReportLayoutSection'
            ]
        },
        extends: 'Metadata'
    },
    ObjectRelationship: {
        type: 'ObjectRelationship',
        props: {
            join: '?ObjectRelationship',
            outerJoin: 'boolean',
            relationship: 'string'
        }
    },
    ReportLayoutSection: {
        type: 'ReportLayoutSection',
        props: {
            columns: [
                'ReportTypeColumn'
            ],
            masterLabel: 'string'
        }
    },
    ReportTypeColumn: {
        type: 'ReportTypeColumn',
        props: {
            checkedByDefault: 'boolean',
            displayNameOverride: '?string',
            field: 'string',
            table: 'string'
        }
    },
    RestrictionRule: {
        type: 'RestrictionRule',
        props: {
            active: 'boolean',
            description: 'string',
            enforcementType: 'string',
            masterLabel: 'string',
            recordFilter: 'string',
            targetEntity: 'string',
            userCriteria: 'string',
            version: 'number'
        },
        extends: 'Metadata'
    },
    RetailExecutionSettings: {
        type: 'RetailExecutionSettings',
        props: {
            enableRetailExecution: '?boolean'
        },
        extends: 'Metadata'
    },
    RoleOrTerritory: {
        type: 'RoleOrTerritory',
        props: {
            caseAccessLevel: '?string',
            contactAccessLevel: '?string',
            description: '?string',
            mayForecastManagerShare: '?boolean',
            name: 'string',
            opportunityAccessLevel: '?string'
        },
        extends: 'Metadata'
    },
    Role: {
        type: 'Role',
        props: {
            parentRole: '?string'
        },
        extends: 'RoleOrTerritory'
    },
    Territory: {
        type: 'Territory',
        props: {
            accountAccessLevel: '?string',
            parentTerritory: '?string'
        },
        extends: 'RoleOrTerritory'
    },
    SamlSsoConfig: {
        type: 'SamlSsoConfig',
        props: {
            attributeName: '?string',
            attributeNameIdFormat: '?string',
            decryptionCertificate: '?string',
            errorUrl: '?string',
            executionUserId: '?string',
            identityLocation: 'string',
            identityMapping: 'string',
            issuer: 'string',
            loginUrl: '?string',
            logoutUrl: '?string',
            name: 'string',
            oauthTokenEndpoint: '?string',
            redirectBinding: '?boolean',
            requestSignatureMethod: '?string',
            requestSigningCertId: '?string',
            salesforceLoginUrl: '?string',
            samlEntityId: 'string',
            samlJitHandlerId: '?string',
            samlVersion: 'string',
            singleLogoutBinding: '?string',
            singleLogoutUrl: '?string',
            userProvisioning: '?boolean',
            validationCert: 'string'
        },
        extends: 'Metadata'
    },
    SchemaSettings: {
        type: 'SchemaSettings',
        props: {
            enableAdvancedCMTSecurity: '?boolean',
            enableAdvancedCSSecurity: '?boolean',
            enableListCustomSettingCreation: '?boolean',
            enableSOSLOnCustomSettings: '?boolean'
        },
        extends: 'Metadata'
    },
    SearchSettings: {
        type: 'SearchSettings',
        props: {
            documentContentSearchEnabled: 'boolean',
            enableAdvancedSearchInAlohaSidebar: '?boolean',
            enableEinsteinSearchPersonalization: '?boolean',
            enableQuerySuggestionPigOn: '?boolean',
            enableSalesforceGeneratedSynonyms: '?boolean',
            enableSetupSearch: '?boolean',
            optimizeSearchForCJKEnabled: 'boolean',
            recentlyViewedUsersForBlankLookupEnabled: 'boolean',
            searchSettingsByObject: 'SearchSettingsByObject',
            sidebarAutoCompleteEnabled: 'boolean',
            sidebarDropDownListEnabled: 'boolean',
            sidebarLimitToItemsIOwnCheckboxEnabled: 'boolean',
            singleSearchResultShortcutEnabled: 'boolean',
            spellCorrectKnowledgeSearchEnabled: 'boolean'
        },
        extends: 'Metadata'
    },
    SearchSettingsByObject: {
        type: 'SearchSettingsByObject',
        props: {
            searchSettingsByObject: [
                'ObjectSearchSetting'
            ]
        }
    },
    ObjectSearchSetting: {
        type: 'ObjectSearchSetting',
        props: {
            enhancedLookupEnabled: 'boolean',
            lookupAutoCompleteEnabled: 'boolean',
            name: 'string',
            resultsPerPageCount: 'number'
        }
    },
    SecuritySettings: {
        type: 'SecuritySettings',
        props: {
            canUsersGrantLoginAccess: '?boolean',
            enableAdminLoginAsAnyUser: '?boolean',
            enableAuditFieldsInactiveOwner: '?boolean',
            enableAuraSecureEvalPref: '?boolean',
            enableRequireHttpsConnection: '?boolean',
            isTLSv12Required: '?boolean',
            isTLSv12RequiredCommunities: '?boolean',
            networkAccess: '?NetworkAccess',
            passwordPolicies: '?PasswordPolicies',
            sessionSettings: '?SessionSettings',
            singleSignOnSettings: '?SingleSignOnSettings'
        },
        extends: 'Metadata'
    },
    NetworkAccess: {
        type: 'NetworkAccess',
        props: {
            ipRanges: [
                'IpRange'
            ]
        }
    },
    IpRange: {
        type: 'IpRange',
        props: {
            description: '?string',
            end: '?string',
            start: '?string'
        }
    },
    PasswordPolicies: {
        type: 'PasswordPolicies',
        props: {
            apiOnlyUserHomePageURL: '?string',
            complexity: '?string',
            enableSetPasswordInApi: '?boolean',
            expiration: '?string',
            historyRestriction: '?string',
            lockoutInterval: '?string',
            maxLoginAttempts: '?string',
            minimumPasswordLength: '?string',
            minimumPasswordLifetime: '?boolean',
            obscureSecretAnswer: '?boolean',
            passwordAssistanceMessage: '?string',
            passwordAssistanceURL: '?string',
            questionRestriction: '?string'
        }
    },
    SessionSettings: {
        type: 'SessionSettings',
        props: {
            allowUserAuthenticationByCertificate: '?boolean',
            canConfirmEmailChangeInLightningCommunities: '?boolean',
            disableTimeoutWarning: '?boolean',
            enableCSPOnEmail: '?boolean',
            enableCSRFOnGet: '?boolean',
            enableCSRFOnPost: '?boolean',
            enableCacheAndAutocomplete: '?boolean',
            enableClickjackNonsetupSFDC: '?boolean',
            enableClickjackNonsetupUser: '?boolean',
            enableClickjackNonsetupUserHeaderless: '?boolean',
            enableClickjackSetup: '?boolean',
            enableContentSniffingProtection: '?boolean',
            enableLightningLogin: '?boolean',
            enableLightningLoginOnlyWithUserPerm: '?boolean',
            enablePostForSessions: '?boolean',
            enableSMSIdentity: '?boolean',
            enableU2F: '?boolean',
            enableUpgradeInsecureRequests: '?boolean',
            enableXssProtection: '?boolean',
            enforceIpRangesEveryRequest: '?boolean',
            forceLogoutOnSessionTimeout: '?boolean',
            forceRelogin: '?boolean',
            hasRetainedLoginHints: '?boolean',
            hasUserSwitching: '?boolean',
            hstsOnForcecomSites: '?boolean',
            identityConfirmationOnEmailChange: '?boolean',
            identityConfirmationOnTwoFactorRegistrationEnabled: '?boolean',
            lockSessionsToDomain: '?boolean',
            lockSessionsToIp: '?boolean',
            lockerServiceAPIVersion: '?string',
            lockerServiceCSP: '?boolean',
            lockerServiceFrozenRealm: '?boolean',
            logoutURL: '?string',
            redirectionWarning: '?boolean',
            referrerPolicy: '?boolean',
            requireHttpOnly: '?boolean',
            requireHttps: '?boolean',
            securityCentralKillSession: '?boolean',
            sessionTimeout: '?string'
        }
    },
    SingleSignOnSettings: {
        type: 'SingleSignOnSettings',
        props: {
            enableForceDelegatedCallout: '?boolean',
            enableMultipleSamlConfigs: '?boolean',
            enableSamlJitProvisioning: '?boolean',
            enableSamlLogin: '?boolean'
        }
    },
    ServiceChannel: {
        type: 'ServiceChannel',
        props: {
            interactionComponent: '?string',
            label: 'string',
            relatedEntityType: 'string',
            secondaryRoutingPriorityField: '?string',
            serviceChannelFieldPriorities: [
                'ServiceChannelFieldPriority'
            ]
        },
        extends: 'Metadata'
    },
    ServiceChannelFieldPriority: {
        type: 'ServiceChannelFieldPriority',
        props: {
            priority: 'number',
            value: 'string'
        }
    },
    ServicePresenceStatus: {
        type: 'ServicePresenceStatus',
        props: {
            channels: '?ServiceChannelStatus',
            label: 'string'
        },
        extends: 'Metadata'
    },
    ServiceChannelStatus: {
        type: 'ServiceChannelStatus',
        props: {
            channel: [
                'string'
            ]
        }
    },
    SharingBaseRule: {
        type: 'SharingBaseRule',
        props: {
            accessLevel: 'string',
            accountSettings: '?AccountSharingRuleSettings',
            description: '?string',
            label: 'string',
            sharedTo: 'SharedTo'
        },
        extends: 'Metadata'
    },
    AccountSharingRuleSettings: {
        type: 'AccountSharingRuleSettings',
        props: {
            caseAccessLevel: 'string',
            contactAccessLevel: 'string',
            opportunityAccessLevel: 'string'
        }
    },
    SharingCriteriaRule: {
        type: 'SharingCriteriaRule',
        props: {
            booleanFilter: '?string',
            criteriaItems: [
                'FilterItem'
            ]
        },
        extends: 'SharingBaseRule'
    },
    SharingGuestRule: {
        type: 'SharingGuestRule',
        props: {
            booleanFilter: '?string',
            criteriaItems: [
                'FilterItem'
            ]
        },
        extends: 'SharingBaseRule'
    },
    SharingOwnerRule: {
        type: 'SharingOwnerRule',
        props: {
            sharedFrom: 'SharedTo'
        },
        extends: 'SharingBaseRule'
    },
    SharingTerritoryRule: {
        type: 'SharingTerritoryRule',
        props: {},
        extends: 'SharingOwnerRule'
    },
    SharingRules: {
        type: 'SharingRules',
        props: {
            sharingCriteriaRules: [
                'SharingCriteriaRule'
            ],
            sharingGuestRules: [
                'SharingGuestRule'
            ],
            sharingOwnerRules: [
                'SharingOwnerRule'
            ],
            sharingTerritoryRules: [
                'SharingTerritoryRule'
            ]
        },
        extends: 'Metadata'
    },
    SharingSet: {
        type: 'SharingSet',
        props: {
            accessMappings: [
                'AccessMapping'
            ],
            description: '?string',
            name: 'string',
            profiles: [
                'string'
            ]
        },
        extends: 'Metadata'
    },
    AccessMapping: {
        type: 'AccessMapping',
        props: {
            accessLevel: 'string',
            object: 'string',
            objectField: 'string',
            userField: 'string'
        }
    },
    SharingSettings: {
        type: 'SharingSettings',
        props: {
            enableAccountRoleOptimization: '?boolean',
            enableAssetSharing: '?boolean',
            enableCommunityUserVisibility: '?boolean',
            enableExternalSharingModel: '?boolean',
            enableManagerGroups: '?boolean',
            enableManualUserRecordSharing: '?boolean',
            enablePartnerSuperUserAccess: '?boolean',
            enablePortalUserCaseSharing: '?boolean',
            enablePortalUserVisibility: '?boolean',
            enableRemoveTMGroupMembership: '?boolean',
            enableSecureGuestAccess: '?boolean',
            enableStandardReportVisibility: '?boolean',
            enableTerritoryForecastManager: '?boolean'
        },
        extends: 'Metadata'
    },
    SiteSettings: {
        type: 'SiteSettings',
        props: {
            enableProxyLoginICHeader: '?boolean',
            enableTopicsInSites: '?boolean',
            enableVisualforceApiAccessAllowed: '?boolean'
        },
        extends: 'Metadata'
    },
    Skill: {
        type: 'Skill',
        props: {
            assignments: '?SkillAssignments',
            description: '?string',
            label: 'string'
        },
        extends: 'Metadata'
    },
    SkillAssignments: {
        type: 'SkillAssignments',
        props: {
            profiles: '?SkillProfileAssignments',
            users: '?SkillUserAssignments'
        }
    },
    SkillProfileAssignments: {
        type: 'SkillProfileAssignments',
        props: {
            profile: [
                'string'
            ]
        }
    },
    SkillUserAssignments: {
        type: 'SkillUserAssignments',
        props: {
            user: [
                'string'
            ]
        }
    },
    SocialCustomerServiceSettings: {
        type: 'SocialCustomerServiceSettings',
        props: {
            caseSubjectOption: 'string',
            enableSocialApprovals: '?boolean',
            enableSocialCaseAssignmentRules: '?boolean',
            enableSocialCustomerService: '?boolean',
            enableSocialPersonaHistoryTracking: '?boolean',
            enableSocialPostHistoryTracking: '?boolean',
            enableSocialReceiveParentPost: '?boolean'
        },
        extends: 'Metadata'
    },
    SocialProfileSettings: {
        type: 'SocialProfileSettings',
        props: {
            enableSocialProfiles: '?boolean',
            isFacebookSocialProfilesDisabled: '?boolean',
            isLinkedInSocialProfilesDisabled: '?boolean',
            isTwitterSocialProfilesDisabled: '?boolean',
            isYouTubeSocialProfilesDisabled: '?boolean'
        },
        extends: 'Metadata'
    },
    StandardValueSet: {
        type: 'StandardValueSet',
        props: {
            groupingStringEnum: '?string',
            sorted: 'boolean',
            standardValue: [
                'StandardValue'
            ]
        },
        extends: 'Metadata'
    },
    StandardValueSetTranslation: {
        type: 'StandardValueSetTranslation',
        props: {
            valueTranslation: [
                'ValueTranslation'
            ]
        },
        extends: 'Metadata'
    },
    SurveySettings: {
        type: 'SurveySettings',
        props: {
            enableSurvey: '?boolean',
            enableSurveyOwnerCanManageResponse: '?boolean'
        },
        extends: 'Metadata'
    },
    SynonymDictionary: {
        type: 'SynonymDictionary',
        props: {
            groups: [
                'SynonymGroup'
            ],
            isProtected: '?boolean',
            label: 'string'
        },
        extends: 'Metadata'
    },
    SystemNotificationSettings: {
        type: 'SystemNotificationSettings',
        props: {
            disableDowntimeNotifications: '?boolean',
            disableMaintenanceNotifications: '?boolean'
        },
        extends: 'Metadata'
    },
    Territory2: {
        type: 'Territory2',
        props: {
            accountAccessLevel: '?string',
            caseAccessLevel: '?string',
            contactAccessLevel: '?string',
            customFields: [
                'FieldValue'
            ],
            description: '?string',
            name: 'string',
            opportunityAccessLevel: '?string',
            parentTerritory: '?string',
            ruleAssociations: [
                'Territory2RuleAssociation'
            ],
            territory2Type: 'string'
        },
        extends: 'Metadata'
    },
    FieldValue: {
        type: 'FieldValue',
        props: {
            name: 'string',
            value: '?any'
        }
    },
    Territory2RuleAssociation: {
        type: 'Territory2RuleAssociation',
        props: {
            inherited: 'boolean',
            ruleName: 'string'
        }
    },
    Territory2Model: {
        type: 'Territory2Model',
        props: {
            customFields: [
                'FieldValue'
            ],
            description: '?string',
            name: 'string'
        },
        extends: 'Metadata'
    },
    Territory2Rule: {
        type: 'Territory2Rule',
        props: {
            active: 'boolean',
            booleanFilter: '?string',
            name: 'string',
            objectType: 'string',
            ruleItems: [
                'Territory2RuleItem'
            ]
        },
        extends: 'Metadata'
    },
    Territory2RuleItem: {
        type: 'Territory2RuleItem',
        props: {
            field: 'string',
            operation: 'string',
            value: '?string'
        }
    },
    Territory2Settings: {
        type: 'Territory2Settings',
        props: {
            defaultAccountAccessLevel: '?string',
            defaultCaseAccessLevel: '?string',
            defaultContactAccessLevel: '?string',
            defaultOpportunityAccessLevel: '?string',
            enableTerritoryManagement2: '?boolean',
            opportunityFilterSettings: '?Territory2SettingsOpportunityFilter'
        },
        extends: 'Metadata'
    },
    Territory2SettingsOpportunityFilter: {
        type: 'Territory2SettingsOpportunityFilter',
        props: {
            apexClassName: '?string',
            enableFilter: 'boolean',
            runOnCreate: 'boolean'
        }
    },
    Territory2Type: {
        type: 'Territory2Type',
        props: {
            description: '?string',
            name: 'string',
            priority: 'number'
        },
        extends: 'Metadata'
    },
    TimeSheetTemplate: {
        type: 'TimeSheetTemplate',
        props: {
            active: 'boolean',
            description: '?string',
            frequency: 'string',
            masterLabel: 'string',
            startDate: 'string',
            timeSheetTemplateAssignments: [
                'TimeSheetTemplateAssignment'
            ],
            workWeekEndDay: 'string',
            workWeekStartDay: 'string'
        },
        extends: 'Metadata'
    },
    TimeSheetTemplateAssignment: {
        type: 'TimeSheetTemplateAssignment',
        props: {
            assignedTo: '?string'
        }
    },
    TopicsForObjects: {
        type: 'TopicsForObjects',
        props: {
            enableTopics: 'boolean',
            entityApiName: 'string'
        },
        extends: 'Metadata'
    },
    TrailheadSettings: {
        type: 'TrailheadSettings',
        props: {
            enableMyTrailheadPref: '?boolean'
        },
        extends: 'Metadata'
    },
    TransactionSecurityPolicy: {
        type: 'TransactionSecurityPolicy',
        props: {
            action: 'TransactionSecurityAction',
            active: 'boolean',
            apexClass: '?string',
            description: '?string',
            developerName: '?string',
            eventName: '?string',
            eventType: '?string',
            executionUser: '?string',
            flow: '?string',
            masterLabel: '?string',
            resourceName: '?string',
            type: '?string'
        },
        extends: 'Metadata'
    },
    TransactionSecurityAction: {
        type: 'TransactionSecurityAction',
        props: {
            block: 'boolean',
            endSession: 'boolean',
            freezeUser: 'boolean',
            notifications: [
                'TransactionSecurityNotification'
            ],
            twoFactorAuthentication: 'boolean'
        }
    },
    TransactionSecurityNotification: {
        type: 'TransactionSecurityNotification',
        props: {
            inApp: 'boolean',
            sendEmail: 'boolean',
            user: 'string'
        }
    },
    Translations: {
        type: 'Translations',
        props: {
            customApplications: [
                'CustomApplicationTranslation'
            ],
            customDataTypeTranslations: [
                'CustomDataTypeTranslation'
            ],
            customLabels: [
                'CustomLabelTranslation'
            ],
            customPageWebLinks: [
                'CustomPageWebLinkTranslation'
            ],
            customTabs: [
                'CustomTabTranslation'
            ],
            flowDefinitions: [
                'FlowDefinitionTranslation'
            ],
            quickActions: [
                'GlobalQuickActionTranslation'
            ],
            reportTypes: [
                'ReportTypeTranslation'
            ],
            scontrols: [
                'ScontrolTranslation'
            ]
        },
        extends: 'Metadata'
    },
    CustomApplicationTranslation: {
        type: 'CustomApplicationTranslation',
        props: {
            label: 'string',
            name: 'string'
        }
    },
    CustomDataTypeTranslation: {
        type: 'CustomDataTypeTranslation',
        props: {
            components: [
                'CustomDataTypeComponentTranslation'
            ],
            customDataTypeName: 'string',
            description: '?string',
            label: '?string'
        }
    },
    CustomDataTypeComponentTranslation: {
        type: 'CustomDataTypeComponentTranslation',
        props: {
            developerSuffix: 'string',
            label: '?string'
        }
    },
    CustomLabelTranslation: {
        type: 'CustomLabelTranslation',
        props: {
            label: 'string',
            name: 'string'
        }
    },
    CustomPageWebLinkTranslation: {
        type: 'CustomPageWebLinkTranslation',
        props: {
            label: 'string',
            name: 'string'
        }
    },
    CustomTabTranslation: {
        type: 'CustomTabTranslation',
        props: {
            label: 'string',
            name: 'string'
        }
    },
    FlowDefinitionTranslation: {
        type: 'FlowDefinitionTranslation',
        props: {
            flows: [
                'FlowTranslation'
            ],
            fullName: 'string',
            label: '?string'
        }
    },
    FlowTranslation: {
        type: 'FlowTranslation',
        props: {
            choices: [
                'FlowChoiceTranslation'
            ],
            fullName: 'string',
            label: '?string',
            screens: [
                'FlowScreenTranslation'
            ],
            stages: [
                'FlowStageTranslation'
            ],
            textTemplates: [
                'FlowTextTemplateTranslation'
            ]
        }
    },
    FlowChoiceTranslation: {
        type: 'FlowChoiceTranslation',
        props: {
            choiceText: '?string',
            name: 'string',
            userInput: '?FlowChoiceUserInputTranslation'
        }
    },
    FlowChoiceUserInputTranslation: {
        type: 'FlowChoiceUserInputTranslation',
        props: {
            promptText: '?string',
            validationRule: '?FlowInputValidationRuleTranslation'
        }
    },
    FlowInputValidationRuleTranslation: {
        type: 'FlowInputValidationRuleTranslation',
        props: {
            errorMessage: '?string'
        }
    },
    FlowScreenTranslation: {
        type: 'FlowScreenTranslation',
        props: {
            fields: [
                'FlowScreenFieldTranslation'
            ],
            helpText: '?string',
            name: 'string',
            pausedText: '?string'
        }
    },
    FlowScreenFieldTranslation: {
        type: 'FlowScreenFieldTranslation',
        props: {
            fieldText: '?string',
            helpText: '?string',
            name: 'string',
            validationRule: '?FlowInputValidationRuleTranslation'
        }
    },
    FlowStageTranslation: {
        type: 'FlowStageTranslation',
        props: {
            label: '?string',
            name: 'string'
        }
    },
    FlowTextTemplateTranslation: {
        type: 'FlowTextTemplateTranslation',
        props: {
            name: 'string',
            text: '?string'
        }
    },
    GlobalQuickActionTranslation: {
        type: 'GlobalQuickActionTranslation',
        props: {
            label: 'string',
            name: 'string'
        }
    },
    ReportTypeTranslation: {
        type: 'ReportTypeTranslation',
        props: {
            description: '?string',
            label: '?string',
            name: 'string',
            sections: [
                'ReportTypeSectionTranslation'
            ]
        }
    },
    ReportTypeSectionTranslation: {
        type: 'ReportTypeSectionTranslation',
        props: {
            columns: [
                'ReportTypeColumnTranslation'
            ],
            label: '?string',
            name: 'string'
        }
    },
    ReportTypeColumnTranslation: {
        type: 'ReportTypeColumnTranslation',
        props: {
            label: 'string',
            name: 'string'
        }
    },
    ScontrolTranslation: {
        type: 'ScontrolTranslation',
        props: {
            label: 'string',
            name: 'string'
        }
    },
    UIObjectRelationConfig: {
        type: 'UIObjectRelationConfig',
        props: {
            UIObjectRelationFieldConfigs: [
                'UIObjectRelationFieldConfig'
            ],
            contextObject: 'string',
            contextObjectRecordType: '?string',
            directRelationshipField: '?string',
            indirectObjectContextField: '?string',
            indirectObjectRelatedField: '?string',
            indirectRelationshipObject: '?string',
            isActive: 'boolean',
            masterLabel: 'string',
            relatedObject: 'string',
            relatedObjectRecordType: '?string',
            relationshipType: 'string'
        },
        extends: 'Metadata'
    },
    UIObjectRelationFieldConfig: {
        type: 'UIObjectRelationFieldConfig',
        props: {
            displayLabel: 'string',
            queryText: 'string',
            rowOrder: 'number'
        }
    },
    UserCriteria: {
        type: 'UserCriteria',
        props: {
            creationAgeInSeconds: '?number',
            description: '?string',
            lastChatterActivityAgeInSeconds: '?number',
            masterLabel: 'string',
            profiles: [
                'string'
            ],
            userTypes: [
                'string'
            ]
        },
        extends: 'Metadata'
    },
    UserEngagementSettings: {
        type: 'UserEngagementSettings',
        props: {
            canGovCloudUseAdoptionApps: '?boolean',
            doesScheduledSwitcherRunDaily: '?boolean',
            enableCustomHelpGlobalSection: '?boolean',
            enableHelpMenuShowFeedback: '?boolean',
            enableHelpMenuShowHelp: '?boolean',
            enableHelpMenuShowNewUser: '?boolean',
            enableHelpMenuShowSearch: '?boolean',
            enableHelpMenuShowSfdcContent: '?boolean',
            enableHelpMenuShowShortcut: '?boolean',
            enableHelpMenuShowSupport: '?boolean',
            enableHelpMenuShowTrailhead: '?boolean',
            enableIBILOptOutDashboards: '?boolean',
            enableIBILOptOutEvents: '?boolean',
            enableIBILOptOutReports: '?boolean',
            enableIBILOptOutTasks: '?boolean',
            enableLexToClassicFeedbackEnable: '?boolean',
            enableOrchestrationInSandbox: '?boolean',
            enableOrgUserAssistEnabled: '?boolean',
            enableScheduledSwitcher: '?boolean',
            enableSfdcProductFeedbackSurvey: '?boolean',
            enableShowSalesforceUserAssist: '?boolean',
            isAutoTransitionDelayed: '?boolean',
            isCrucNotificationDisabled: '?boolean',
            isCustomProfileAutoTransitionDelayed: '?boolean',
            isLEXWelcomeMatDisabled: '?boolean',
            isMeetTheAssistantDisabledInClassic: '?boolean',
            isMeetTheAssistantDisabledInLightning: '?boolean',
            optimizerAppEnabled: '?boolean'
        },
        extends: 'Metadata'
    },
    UserInterfaceSettings: {
        type: 'UserInterfaceSettings',
        props: {
            alternateAlohaListView: '?boolean',
            enableAsyncRelatedLists: '?boolean',
            enableClickjackUserPageHeaderless: '?boolean',
            enableCollapsibleSections: '?boolean',
            enableCollapsibleSideBar: '?boolean',
            enableCustomObjectTruncate: '?boolean',
            enableCustomeSideBarOnAllPages: '?boolean',
            enableDeleteFieldHistory: '?boolean',
            enableHoverDetails: '?boolean',
            enableInlineEdit: '?boolean',
            enableNewPageLayoutEditor: '?boolean',
            enablePersonalCanvas: '?boolean',
            enablePrintableListViews: '?boolean',
            enableProfileCustomTabsets: '?boolean',
            enableQuickCreate: '?boolean',
            enableTabOrganizer: '?boolean'
        },
        extends: 'Metadata'
    },
    UserManagementSettings: {
        type: 'UserManagementSettings',
        props: {
            enableCanAnswerContainUsername: '?boolean',
            enableCanSaveUserPerm: '?boolean',
            enableConcealPersonalInfo: '?boolean',
            enableContactlessExternalIdentityUsers: '?boolean',
            enableEnhancedPermsetMgmt: '?boolean',
            enableEnhancedProfileMgmt: '?boolean',
            enableNewProfileUI: '?boolean',
            enableScrambleUserData: '?boolean',
            enableUserSelfDeactivate: '?boolean'
        },
        extends: 'Metadata'
    },
    VoiceSettings: {
        type: 'VoiceSettings',
        props: {
            enableCallDisposition: '?boolean',
            enableVoiceCallList: '?boolean',
            enableVoiceCallRecording: '?boolean',
            enableVoiceCoaching: '?boolean',
            enableVoiceConferencing: '?boolean',
            enableVoiceLocalPresence: '?boolean',
            enableVoiceMail: '?boolean',
            enableVoiceMailDrop: '?boolean'
        },
        extends: 'Metadata'
    },
    WaveApplication: {
        type: 'WaveApplication',
        props: {
            assetIcon: '?string',
            description: '?string',
            folder: 'string',
            masterLabel: 'string',
            shares: [
                'FolderShare'
            ],
            templateOrigin: '?string',
            templateVersion: '?string'
        },
        extends: 'Metadata'
    },
    WaveDataset: {
        type: 'WaveDataset',
        props: {
            application: 'string',
            description: '?string',
            masterLabel: 'string',
            templateAssetSourceName: '?string'
        },
        extends: 'Metadata'
    },
    WaveTemplateBundle: {
        type: 'WaveTemplateBundle',
        props: {
            assetIcon: '?string',
            assetVersion: '?number',
            description: '?string',
            label: 'string',
            templateType: 'string'
        },
        extends: 'Metadata'
    },
    WaveXmd: {
        type: 'WaveXmd',
        props: {
            application: '?string',
            dataset: 'string',
            datasetConnector: '?string',
            datasetFullyQualifiedName: '?string',
            dates: [
                'WaveXmdDate'
            ],
            dimensions: [
                'WaveXmdDimension'
            ],
            measures: [
                'WaveXmdMeasure'
            ],
            organizations: [
                'WaveXmdOrganization'
            ],
            origin: '?string',
            type: '?string',
            waveVisualization: '?string'
        },
        extends: 'Metadata'
    },
    WaveXmdDate: {
        type: 'WaveXmdDate',
        props: {
            alias: 'string',
            compact: '?boolean',
            dateFieldDay: '?string',
            dateFieldEpochDay: '?string',
            dateFieldEpochSecond: '?string',
            dateFieldFiscalMonth: '?string',
            dateFieldFiscalQuarter: '?string',
            dateFieldFiscalWeek: '?string',
            dateFieldFiscalYear: '?string',
            dateFieldFullYear: '?string',
            dateFieldHour: '?string',
            dateFieldMinute: '?string',
            dateFieldMonth: '?string',
            dateFieldQuarter: '?string',
            dateFieldSecond: '?string',
            dateFieldWeek: '?string',
            dateFieldYear: '?string',
            description: '?string',
            firstDayOfWeek: 'number',
            fiscalMonthOffset: 'number',
            isYearEndFiscalYear: '?boolean',
            label: '?string',
            showInExplorer: '?boolean',
            sortIndex: 'number',
            type: 'string'
        }
    },
    WaveXmdDimension: {
        type: 'WaveXmdDimension',
        props: {
            conditionalFormatting: [
                'WaveXmdFormattingProperty'
            ],
            customActions: [
                'WaveXmdDimensionCustomAction'
            ],
            customActionsEnabled: '?boolean',
            dateFormat: '?string',
            description: '?string',
            field: 'string',
            fullyQualifiedName: '?string',
            imageTemplate: '?string',
            isDerived: 'boolean',
            isMultiValue: '?boolean',
            label: '?string',
            linkTemplate: '?string',
            linkTemplateEnabled: '?boolean',
            linkTooltip: '?string',
            members: [
                'WaveXmdDimensionMember'
            ],
            origin: '?string',
            recordDisplayFields: [
                'WaveXmdRecordDisplayLookup'
            ],
            recordIdField: '?string',
            recordOrganizationIdField: '?string',
            salesforceActions: [
                'WaveXmdDimensionSalesforceAction'
            ],
            salesforceActionsEnabled: '?boolean',
            showDetailsDefaultFieldIndex: '?number',
            showInExplorer: '?boolean',
            sortIndex: 'number'
        }
    },
    WaveXmdFormattingProperty: {
        type: 'WaveXmdFormattingProperty',
        props: {
            formattingBins: [
                'WaveXmdFormattingBin'
            ],
            formattingPredicates: [
                'WaveXmdFormattingPredicate'
            ],
            property: 'string',
            referenceField: 'string',
            sortIndex: 'number',
            type: 'string'
        }
    },
    WaveXmdFormattingBin: {
        type: 'WaveXmdFormattingBin',
        props: {
            bin: 'string',
            formatValue: 'string',
            label: 'string',
            sortIndex: 'number'
        }
    },
    WaveXmdFormattingPredicate: {
        type: 'WaveXmdFormattingPredicate',
        props: {
            formatValue: 'string',
            operator: 'string',
            sortIndex: 'number',
            value: 'string'
        }
    },
    WaveXmdDimensionCustomAction: {
        type: 'WaveXmdDimensionCustomAction',
        props: {
            customActionName: 'string',
            enabled: 'boolean',
            icon: '?string',
            method: '?string',
            sortIndex: 'number',
            target: '?string',
            tooltip: '?string',
            url: '?string'
        }
    },
    WaveXmdDimensionMember: {
        type: 'WaveXmdDimensionMember',
        props: {
            color: '?string',
            label: '?string',
            member: 'string',
            sortIndex: 'number'
        }
    },
    WaveXmdRecordDisplayLookup: {
        type: 'WaveXmdRecordDisplayLookup',
        props: {
            recordDisplayField: 'string'
        }
    },
    WaveXmdDimensionSalesforceAction: {
        type: 'WaveXmdDimensionSalesforceAction',
        props: {
            enabled: 'boolean',
            salesforceActionName: 'string',
            sortIndex: 'number'
        }
    },
    WaveXmdMeasure: {
        type: 'WaveXmdMeasure',
        props: {
            conditionalFormatting: [
                'WaveXmdFormattingProperty'
            ],
            dateFormat: '?string',
            description: '?string',
            field: 'string',
            formatCustomFormat: '?string',
            formatDecimalDigits: '?number',
            formatIsNegativeParens: '?boolean',
            formatPrefix: '?string',
            formatSuffix: '?string',
            formatUnit: '?string',
            formatUnitMultiplier: '?number',
            fullyQualifiedName: '?string',
            isDerived: 'boolean',
            label: '?string',
            origin: '?string',
            showDetailsDefaultFieldIndex: '?number',
            showInExplorer: '?boolean',
            sortIndex: 'number'
        }
    },
    WaveXmdOrganization: {
        type: 'WaveXmdOrganization',
        props: {
            instanceUrl: 'string',
            label: 'string',
            organizationIdentifier: 'string',
            sortIndex: 'number'
        }
    },
    WorkDotComSettings: {
        type: 'WorkDotComSettings',
        props: {
            enableCoachingManagerGroupAccess: '?boolean',
            enableGoalManagerGroupAccess: '?boolean',
            enableProfileSkills: '?boolean',
            enableProfileSkillsAddFeedPost: '?boolean',
            enableProfileSkillsAutoSuggest: '?boolean',
            enableProfileSkillsUsePlatform: '?boolean',
            enableWorkBadgeDefRestrictPref: '?boolean',
            enableWorkCalibration: '?boolean',
            enableWorkCanvasPref: '?boolean',
            enableWorkCertification: '?boolean',
            enableWorkCertificationNotification: '?boolean',
            enableWorkRewardsPref: '?boolean',
            enableWorkThanksPref: '?boolean',
            enableWorkUseObjectivesForGoals: '?boolean'
        },
        extends: 'Metadata'
    },
    Workflow: {
        type: 'Workflow',
        props: {
            alerts: [
                'WorkflowAlert'
            ],
            fieldUpdates: [
                'WorkflowFieldUpdate'
            ],
            flowActions: [
                'WorkflowFlowAction'
            ],
            knowledgePublishes: [
                'WorkflowKnowledgePublish'
            ],
            outboundMessages: [
                'WorkflowOutboundMessage'
            ],
            rules: [
                'WorkflowRule'
            ],
            send: [
                'WorkflowSend'
            ],
            tasks: [
                'WorkflowTask'
            ]
        },
        extends: 'Metadata'
    },
    WorkflowAlert: {
        type: 'WorkflowAlert',
        props: {
            ccEmails: [
                'string'
            ],
            description: 'string',
            protected: 'boolean',
            recipients: [
                'WorkflowEmailRecipient'
            ],
            senderAddress: '?string',
            senderType: '?string',
            template: 'string'
        },
        extends: 'WorkflowAction'
    },
    WorkflowAction: {
        type: 'WorkflowAction',
        props: {},
        extends: 'Metadata'
    },
    WorkflowFieldUpdate: {
        type: 'WorkflowFieldUpdate',
        props: {
            description: '?string',
            field: 'string',
            formula: '?string',
            literalValue: '?string',
            lookupValue: '?string',
            lookupValueType: '?string',
            name: 'string',
            notifyAssignee: 'boolean',
            operation: 'string',
            protected: 'boolean',
            reevaluateOnChange: '?boolean',
            targetObject: '?string'
        },
        extends: 'WorkflowAction'
    },
    WorkflowFlowAction: {
        type: 'WorkflowFlowAction',
        props: {
            description: '?string',
            flow: 'string',
            flowInputs: [
                'WorkflowFlowActionParameter'
            ],
            label: 'string',
            language: '?string',
            protected: 'boolean'
        },
        extends: 'WorkflowAction'
    },
    WorkflowFlowActionParameter: {
        type: 'WorkflowFlowActionParameter',
        props: {
            name: 'string',
            value: '?string'
        }
    },
    WorkflowKnowledgePublish: {
        type: 'WorkflowKnowledgePublish',
        props: {
            action: 'string',
            description: '?string',
            label: 'string',
            language: '?string',
            protected: 'boolean'
        },
        extends: 'WorkflowAction'
    },
    WorkflowOutboundMessage: {
        type: 'WorkflowOutboundMessage',
        props: {
            apiVersion: 'number',
            description: '?string',
            endpointUrl: 'string',
            fields: [
                'string'
            ],
            includeSessionId: 'boolean',
            integrationUser: 'string',
            name: 'string',
            protected: 'boolean',
            useDeadLetterQueue: '?boolean'
        },
        extends: 'WorkflowAction'
    },
    WorkflowSend: {
        type: 'WorkflowSend',
        props: {
            action: 'string',
            description: '?string',
            label: 'string',
            language: '?string',
            protected: 'boolean'
        },
        extends: 'WorkflowAction'
    },
    WorkflowTask: {
        type: 'WorkflowTask',
        props: {
            assignedTo: '?string',
            assignedToType: 'string',
            description: '?string',
            dueDateOffset: 'number',
            notifyAssignee: 'boolean',
            offsetFromField: '?string',
            priority: 'string',
            protected: 'boolean',
            status: 'string',
            subject: 'string'
        },
        extends: 'WorkflowAction'
    },
    WorkflowEmailRecipient: {
        type: 'WorkflowEmailRecipient',
        props: {
            field: '?string',
            recipient: '?string',
            type: 'string'
        }
    },
    WorkflowRule: {
        type: 'WorkflowRule',
        props: {
            actions: [
                'WorkflowActionReference'
            ],
            active: 'boolean',
            booleanFilter: '?string',
            criteriaItems: [
                'FilterItem'
            ],
            description: '?string',
            formula: '?string',
            triggerType: 'string',
            workflowTimeTriggers: [
                'WorkflowTimeTrigger'
            ]
        },
        extends: 'Metadata'
    },
    WorkflowTimeTrigger: {
        type: 'WorkflowTimeTrigger',
        props: {
            actions: [
                'WorkflowActionReference'
            ],
            offsetFromField: '?string',
            timeLength: '?string',
            workflowTimeTriggerUnit: 'string'
        }
    },
    SaveResult: {
        type: 'SaveResult',
        props: {
            errors: [
                'Error'
            ],
            fullName: 'string',
            success: 'boolean'
        }
    },
    Error: {
        type: 'Error',
        props: {
            extendedErrorDetails: [
                'ExtendedErrorDetails'
            ],
            fields: [
                'string'
            ],
            message: 'string',
            statusCode: 'string'
        }
    },
    ExtendedErrorDetails: {
        type: 'ExtendedErrorDetails',
        props: {
            extendedErrorCode: 'string'
        }
    },
    DeleteResult: {
        type: 'DeleteResult',
        props: {
            errors: [
                'Error'
            ],
            fullName: 'string',
            success: 'boolean'
        }
    },
    DeployOptions: {
        type: 'DeployOptions',
        props: {
            allowMissingFiles: 'boolean',
            autoUpdatePackage: 'boolean',
            checkOnly: 'boolean',
            ignoreWarnings: 'boolean',
            performRetrieve: 'boolean',
            purgeOnDelete: 'boolean',
            rollbackOnError: 'boolean',
            runTests: [
                'string'
            ],
            singlePackage: 'boolean',
            testLevel: 'string'
        }
    },
    AsyncResult: {
        type: 'AsyncResult',
        props: {
            done: 'boolean',
            id: 'string',
            message: '?string',
            state: 'string',
            statusCode: '?string'
        }
    },
    DescribeMetadataResult: {
        type: 'DescribeMetadataResult',
        props: {
            metadataObjects: [
                'DescribeMetadataObject'
            ],
            organizationNamespace: 'string',
            partialSaveAllowed: 'boolean',
            testRequired: 'boolean'
        }
    },
    DescribeMetadataObject: {
        type: 'DescribeMetadataObject',
        props: {
            childXmlNames: [
                'string'
            ],
            directoryName: 'string',
            inFolder: 'boolean',
            metaFile: 'boolean',
            suffix: '?string',
            xmlName: 'string'
        }
    },
    DescribeValueTypeResult: {
        type: 'DescribeValueTypeResult',
        props: {
            apiCreatable: 'boolean',
            apiDeletable: 'boolean',
            apiReadable: 'boolean',
            apiUpdatable: 'boolean',
            parentField: '?ValueTypeField',
            valueTypeFields: [
                'ValueTypeField'
            ]
        }
    },
    ValueTypeField: {
        type: 'ValueTypeField',
        props: {
            fields: [
                'ValueTypeField'
            ],
            foreignKeyDomain: [
                'string'
            ],
            isForeignKey: 'boolean',
            isNameField: 'boolean',
            minOccurs: 'number',
            name: 'string',
            picklistValues: [
                'PicklistEntry'
            ],
            soapType: 'string',
            valueRequired: 'boolean'
        }
    },
    PicklistEntry: {
        type: 'PicklistEntry',
        props: {
            active: 'boolean',
            defaultValue: 'boolean',
            label: 'string',
            validFor: '?string',
            value: 'string'
        }
    },
    ListMetadataQuery: {
        type: 'ListMetadataQuery',
        props: {
            folder: '?string',
            type: 'string'
        }
    },
    ReadResult: {
        type: 'ReadResult',
        props: {
            records: [
                'Metadata'
            ]
        }
    },
    RetrieveRequest: {
        type: 'RetrieveRequest',
        props: {
            apiVersion: 'number',
            packageNames: [
                'string'
            ],
            singlePackage: 'boolean',
            specificFiles: [
                'string'
            ],
            unpackaged: '?Package'
        }
    },
    UpsertResult: {
        type: 'UpsertResult',
        props: {
            created: 'boolean',
            errors: [
                'Error'
            ],
            fullName: 'string',
            success: 'boolean'
        }
    },
    LogInfo: {
        type: 'LogInfo',
        props: {
            category: 'string',
            level: 'string'
        }
    }
};
}),
"[project]/node_modules/jsforce/lib/api/metadata.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DeployResultLocator = exports.RetrieveResultLocator = exports.AsyncResultLocator = exports.MetadataApi = void 0;
/**
 * @file Manages Salesforce Metadata API
 * @author Shinichi Tomita <shinichi.tomita@gmail.com>
 */ const events_1 = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
const stream_1 = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const form_data_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/form-data/lib/form_data.js [app-route] (ecmascript)"));
const jsforce_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/jsforce.js [app-route] (ecmascript)");
const soap_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/soap.js [app-route] (ecmascript)"));
const function_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/util/function.js [app-route] (ecmascript)");
const schema_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/api/metadata/schema.js [app-route] (ecmascript)");
__exportStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/api/metadata/schema.js [app-route] (ecmascript)"), exports);
/**
 *
 */ function deallocateTypeWithMetadata(metadata) {
    const { $, ...md } = metadata;
    return md;
}
function assignTypeWithMetadata(metadata, type) {
    const convert = (md)=>({
            ['@xsi:type']: type,
            ...md
        });
    return Array.isArray(metadata) ? metadata.map(convert) : convert(metadata);
}
/**
 * Class for Salesforce Metadata API
 */ class MetadataApi {
    _conn;
    /**
     * Polling interval in milliseconds
     */ pollInterval = 1000;
    /**
     * Polling timeout in milliseconds
     */ pollTimeout = 10000;
    /**
     *
     */ constructor(conn){
        this._conn = conn;
    }
    /**
     * Call Metadata API SOAP endpoint
     *
     * @private
     */ async _invoke(method, message, schema) {
        const soapEndpoint = new soap_1.default(this._conn, {
            xmlns: 'http://soap.sforce.com/2006/04/metadata',
            endpointUrl: `${this._conn.instanceUrl}/services/Soap/m/${this._conn.version}`
        });
        const res = await soapEndpoint.invoke(method, message, schema ? {
            result: schema
        } : undefined, schema_1.ApiSchemas);
        return res.result;
    }
    create(type, metadata) {
        const isArray = Array.isArray(metadata);
        metadata = assignTypeWithMetadata(metadata, type);
        const schema = isArray ? [
            schema_1.ApiSchemas.SaveResult
        ] : schema_1.ApiSchemas.SaveResult;
        return this._invoke('createMetadata', {
            metadata
        }, schema);
    }
    async read(type, fullNames) {
        const ReadResultSchema = type in schema_1.ApiSchemas ? {
            type: schema_1.ApiSchemas.ReadResult.type,
            props: {
                records: [
                    type
                ]
            }
        } : schema_1.ApiSchemas.ReadResult;
        const res = await this._invoke('readMetadata', {
            type,
            fullNames
        }, ReadResultSchema);
        return Array.isArray(fullNames) ? res.records.map(deallocateTypeWithMetadata) : deallocateTypeWithMetadata(res.records[0]);
    }
    update(type, metadata) {
        const isArray = Array.isArray(metadata);
        metadata = assignTypeWithMetadata(metadata, type);
        const schema = isArray ? [
            schema_1.ApiSchemas.SaveResult
        ] : schema_1.ApiSchemas.SaveResult;
        return this._invoke('updateMetadata', {
            metadata
        }, schema);
    }
    upsert(type, metadata) {
        const isArray = Array.isArray(metadata);
        metadata = assignTypeWithMetadata(metadata, type);
        const schema = isArray ? [
            schema_1.ApiSchemas.UpsertResult
        ] : schema_1.ApiSchemas.UpsertResult;
        return this._invoke('upsertMetadata', {
            metadata
        }, schema);
    }
    delete(type, fullNames) {
        const schema = Array.isArray(fullNames) ? [
            schema_1.ApiSchemas.SaveResult
        ] : schema_1.ApiSchemas.SaveResult;
        return this._invoke('deleteMetadata', {
            type,
            fullNames
        }, schema);
    }
    /**
     * Rename fullname of a metadata component in the organization
     */ rename(type, oldFullName, newFullName) {
        return this._invoke('renameMetadata', {
            type,
            oldFullName,
            newFullName
        }, schema_1.ApiSchemas.SaveResult);
    }
    /**
     * Retrieves the metadata which describes your organization, including Apex classes and triggers,
     * custom objects, custom fields on standard objects, tab sets that define an app,
     * and many other components.
     */ describe(asOfVersion) {
        if (!asOfVersion) {
            asOfVersion = this._conn.version;
        }
        return this._invoke('describeMetadata', {
            asOfVersion
        }, schema_1.ApiSchemas.DescribeMetadataResult);
    }
    /**
     * Retrieves property information about metadata components in your organization
     */ list(queries, asOfVersion) {
        if (!asOfVersion) {
            asOfVersion = this._conn.version;
        }
        return this._invoke('listMetadata', {
            queries,
            asOfVersion
        }, [
            schema_1.ApiSchemas.FileProperties
        ]);
    }
    /**
     * Checks the status of asynchronous metadata calls
     */ checkStatus(asyncProcessId) {
        const res = this._invoke('checkStatus', {
            asyncProcessId
        }, schema_1.ApiSchemas.AsyncResult);
        return new AsyncResultLocator(this, res);
    }
    /**
     * Retrieves XML file representations of components in an organization
     */ retrieve(request) {
        const res = this._invoke('retrieve', {
            request
        }, schema_1.ApiSchemas.RetrieveResult);
        return new RetrieveResultLocator(this, res);
    }
    /**
     * Checks the status of declarative metadata call retrieve() and returns the zip file contents
     */ checkRetrieveStatus(asyncProcessId) {
        return this._invoke('checkRetrieveStatus', {
            asyncProcessId
        }, schema_1.ApiSchemas.RetrieveResult);
    }
    /**
     * Will deploy a recently validated deploy request
     *
     * @param options.id = the deploy ID that's been validated already from a previous checkOnly deploy request
     * @param options.rest = a boolean whether or not to use the REST API
     * @returns the deploy ID of the recent validation request
     */ async deployRecentValidation(options) {
        const { id, rest } = options;
        let response;
        if (rest) {
            const messageBody = JSON.stringify({
                validatedDeployRequestId: id
            });
            const requestInfo = {
                method: 'POST',
                url: `${this._conn._baseUrl()}/metadata/deployRequest`,
                body: messageBody,
                headers: {
                    'content-type': 'application/json'
                }
            };
            const requestOptions = {
                headers: 'json'
            };
            // This is the deploy ID of the deployRecentValidation response, not
            // the already validated deploy ID (i.e., validateddeployrequestid).
            // REST returns an object with an id property, SOAP returns the id as a string directly.
            response = (await this._conn.request(requestInfo, requestOptions)).id;
        } else {
            response = await this._invoke('deployRecentValidation', {
                validationId: id
            });
        }
        return response;
    }
    /**
     * Deploy components into an organization using zipped file representations
     * using the REST Metadata API instead of SOAP
     */ deployRest(zipInput, options = {}) {
        const form = new form_data_1.default();
        form.append('file', zipInput, {
            contentType: 'application/zip',
            filename: 'package.xml'
        });
        // Add the deploy options
        form.append('entity_content', JSON.stringify({
            deployOptions: options
        }), {
            contentType: 'application/json'
        });
        const request = {
            url: '/metadata/deployRequest',
            method: 'POST',
            headers: {
                ...form.getHeaders()
            },
            body: form.getBuffer()
        };
        const res = this._conn.request(request);
        return new DeployResultLocator(this, res);
    }
    /**
     * Deploy components into an organization using zipped file representations
     */ deploy(zipInput, options = {}) {
        const res = (async ()=>{
            const zipContentB64 = await new Promise((resolve, reject)=>{
                if ((0, function_1.isObject)(zipInput) && 'pipe' in zipInput && typeof zipInput.pipe === 'function') {
                    const bufs = [];
                    zipInput.on('data', (d)=>bufs.push(d));
                    zipInput.on('error', reject);
                    zipInput.on('end', ()=>{
                        resolve(Buffer.concat(bufs).toString('base64'));
                    });
                // zipInput.resume();
                } else if (zipInput instanceof Buffer) {
                    resolve(zipInput.toString('base64'));
                } else if (zipInput instanceof String || typeof zipInput === 'string') {
                    resolve(zipInput);
                } else {
                    throw 'Unexpected zipInput type';
                }
            });
            return this._invoke('deploy', {
                ZipFile: zipContentB64,
                DeployOptions: options
            }, schema_1.ApiSchemas.DeployResult);
        })();
        return new DeployResultLocator(this, res);
    }
    /**
     * Checks the status of declarative metadata call deploy(), using either
     * SOAP or REST APIs. SOAP is the default.
     */ async checkDeployStatus(asyncProcessId, includeDetails = false, rest = false) {
        if (rest) {
            const url = `/metadata/deployRequest/${asyncProcessId}${includeDetails ? '?includeDetails=true' : ''}`;
            return (await this._conn.requestGet(url)).deployResult;
        } else {
            return this._invoke('checkDeployStatus', {
                asyncProcessId,
                includeDetails
            }, schema_1.ApiSchemas.DeployResult);
        }
    }
    async cancelDeploy(id) {
        return this._invoke('cancelDeploy', {
            id
        });
    }
}
exports.MetadataApi = MetadataApi;
/*--------------------------------------------*/ /**
 * The locator class for Metadata API asynchronous call result
 */ class AsyncResultLocator extends events_1.EventEmitter {
    _meta;
    _promise;
    _id;
    /**
     *
     */ constructor(meta, promise){
        super();
        this._meta = meta;
        this._promise = promise;
    }
    /**
     * Promise/A+ interface
     * http://promises-aplus.github.io/promises-spec/
     *
     * @method Metadata~AsyncResultLocator#then
     */ then(onResolve, onReject) {
        return this._promise.then(onResolve, onReject);
    }
    /**
     * Check the status of async request
     */ async check() {
        const result = await this._promise;
        this._id = result.id;
        return this._meta.checkStatus(result.id);
    }
    /**
     * Polling until async call status becomes complete or error
     */ poll(interval, timeout) {
        const startTime = new Date().getTime();
        const poll = async ()=>{
            try {
                const now = new Date().getTime();
                if (startTime + timeout < now) {
                    let errMsg = 'Polling time out.';
                    if (this._id) {
                        errMsg += ' Process Id = ' + this._id;
                    }
                    this.emit('error', new Error(errMsg));
                    return;
                }
                const result = await this.check();
                if (result.done) {
                    this.emit('complete', result);
                } else {
                    this.emit('progress', result);
                    setTimeout(poll, interval);
                }
            } catch (err) {
                this.emit('error', err);
            }
        };
        setTimeout(poll, interval);
    }
    /**
     * Check and wait until the async requests become in completed status
     */ complete() {
        return new Promise((resolve, reject)=>{
            this.on('complete', resolve);
            this.on('error', reject);
            this.poll(this._meta.pollInterval, this._meta.pollTimeout);
        });
    }
}
exports.AsyncResultLocator = AsyncResultLocator;
/*--------------------------------------------*/ /**
 * The locator class to track retreive() Metadata API call result
 */ class RetrieveResultLocator extends AsyncResultLocator {
    /**
     * Check and wait until the async request becomes in completed status,
     * and retrieve the result data.
     */ async complete() {
        const result = await super.complete();
        return this._meta.checkRetrieveStatus(result.id);
    }
    /**
     * Change the retrieved result to Node.js readable stream
     */ stream() {
        const resultStream = new stream_1.Readable();
        let reading = false;
        resultStream._read = async ()=>{
            if (reading) {
                return;
            }
            reading = true;
            try {
                const result = await this.complete();
                resultStream.push(Buffer.from(result.zipFile, 'base64'));
                resultStream.push(null);
            } catch (e) {
                resultStream.emit('error', e);
            }
        };
        return resultStream;
    }
}
exports.RetrieveResultLocator = RetrieveResultLocator;
/*--------------------------------------------*/ /**
 * The locator class to track deploy() Metadata API call result
 *
 * @protected
 * @class Metadata~DeployResultLocator
 * @extends Metadata~AsyncResultLocator
 * @param {Metadata} meta - Metadata API object
 * @param {Promise.<Metadata~AsyncResult>} result - Promise object for async result of deploy() call
 */ class DeployResultLocator extends AsyncResultLocator {
    /**
     * Check and wait until the async request becomes in completed status,
     * and retrieve the result data.
     */ async complete(includeDetails) {
        const result = await super.complete();
        return this._meta.checkDeployStatus(result.id, includeDetails);
    }
}
exports.DeployResultLocator = DeployResultLocator;
/*--------------------------------------------*/ /*
 * Register hook in connection instantiation for dynamically adding this API module features
 */ (0, jsforce_1.registerModule)('metadata', (conn)=>new MetadataApi(conn));
exports.default = MetadataApi;
}),
"[project]/node_modules/jsforce/lib/api/soap/schema.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * This file is generated from WSDL file by wsdl2schema.ts.
 * Do not modify directly.
 * To generate the file, run "ts-node path/to/wsdl2schema.ts path/to/wsdl.xml path/to/schema.ts"
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ApiSchemas = void 0;
exports.ApiSchemas = {
    sObject: {
        type: 'sObject',
        props: {
            type: 'string',
            fieldsToNull: [
                '?',
                'string'
            ],
            Id: '?string'
        }
    },
    address: {
        type: 'address',
        props: {
            city: '?string',
            country: '?string',
            countryCode: '?string',
            geocodeAccuracy: '?string',
            postalCode: '?string',
            state: '?string',
            stateCode: '?string',
            street: '?string'
        },
        extends: 'location'
    },
    location: {
        type: 'location',
        props: {
            latitude: '?number',
            longitude: '?number'
        }
    },
    QueryResult: {
        type: 'QueryResult',
        props: {
            done: 'boolean',
            queryLocator: '?string',
            records: [
                '?',
                'sObject'
            ],
            size: 'number'
        }
    },
    SearchResult: {
        type: 'SearchResult',
        props: {
            queryId: 'string',
            searchRecords: [
                'SearchRecord'
            ],
            searchResultsMetadata: '?SearchResultsMetadata'
        }
    },
    SearchRecord: {
        type: 'SearchRecord',
        props: {
            record: 'sObject',
            searchRecordMetadata: '?SearchRecordMetadata',
            snippet: '?SearchSnippet'
        }
    },
    SearchRecordMetadata: {
        type: 'SearchRecordMetadata',
        props: {
            searchPromoted: 'boolean',
            spellCorrected: 'boolean'
        }
    },
    SearchSnippet: {
        type: 'SearchSnippet',
        props: {
            text: '?string',
            wholeFields: [
                'NameValuePair'
            ]
        }
    },
    SearchResultsMetadata: {
        type: 'SearchResultsMetadata',
        props: {
            entityLabelMetadata: [
                'LabelsSearchMetadata'
            ],
            entityMetadata: [
                'EntitySearchMetadata'
            ]
        }
    },
    LabelsSearchMetadata: {
        type: 'LabelsSearchMetadata',
        props: {
            entityFieldLabels: [
                'NameValuePair'
            ],
            entityName: 'string'
        }
    },
    EntitySearchMetadata: {
        type: 'EntitySearchMetadata',
        props: {
            entityName: 'string',
            errorMetadata: '?EntityErrorMetadata',
            fieldMetadata: [
                'FieldLevelSearchMetadata'
            ],
            intentQueryMetadata: '?EntityIntentQueryMetadata',
            searchPromotionMetadata: '?EntitySearchPromotionMetadata',
            spellCorrectionMetadata: '?EntitySpellCorrectionMetadata'
        }
    },
    FieldLevelSearchMetadata: {
        type: 'FieldLevelSearchMetadata',
        props: {
            label: '?string',
            name: 'string',
            type: '?string'
        }
    },
    EntitySpellCorrectionMetadata: {
        type: 'EntitySpellCorrectionMetadata',
        props: {
            correctedQuery: 'string',
            hasNonCorrectedResults: 'boolean'
        }
    },
    EntitySearchPromotionMetadata: {
        type: 'EntitySearchPromotionMetadata',
        props: {
            promotedResultCount: 'number'
        }
    },
    EntityIntentQueryMetadata: {
        type: 'EntityIntentQueryMetadata',
        props: {
            intentQuery: 'boolean',
            message: '?string'
        }
    },
    EntityErrorMetadata: {
        type: 'EntityErrorMetadata',
        props: {
            errorCode: '?string',
            message: '?string'
        }
    },
    RelationshipReferenceTo: {
        type: 'RelationshipReferenceTo',
        props: {
            referenceTo: [
                'string'
            ]
        }
    },
    RecordTypesSupported: {
        type: 'RecordTypesSupported',
        props: {
            recordTypeInfos: [
                'RecordTypeInfo'
            ]
        }
    },
    JunctionIdListNames: {
        type: 'JunctionIdListNames',
        props: {
            names: [
                'string'
            ]
        }
    },
    SearchLayoutButtonsDisplayed: {
        type: 'SearchLayoutButtonsDisplayed',
        props: {
            applicable: 'boolean',
            buttons: [
                'SearchLayoutButton'
            ]
        }
    },
    SearchLayoutButton: {
        type: 'SearchLayoutButton',
        props: {
            apiName: 'string',
            label: 'string'
        }
    },
    SearchLayoutFieldsDisplayed: {
        type: 'SearchLayoutFieldsDisplayed',
        props: {
            applicable: 'boolean',
            fields: [
                'SearchLayoutField'
            ]
        }
    },
    SearchLayoutField: {
        type: 'SearchLayoutField',
        props: {
            apiName: 'string',
            label: 'string',
            sortable: 'boolean'
        }
    },
    NameValuePair: {
        type: 'NameValuePair',
        props: {
            name: 'string',
            value: 'string'
        }
    },
    NameObjectValuePair: {
        type: 'NameObjectValuePair',
        props: {
            isVisible: '?boolean',
            name: 'string',
            value: [
                'any'
            ]
        }
    },
    GetUpdatedResult: {
        type: 'GetUpdatedResult',
        props: {
            ids: [
                'string'
            ],
            latestDateCovered: 'string'
        }
    },
    GetDeletedResult: {
        type: 'GetDeletedResult',
        props: {
            deletedRecords: [
                'DeletedRecord'
            ],
            earliestDateAvailable: 'string',
            latestDateCovered: 'string'
        }
    },
    DeletedRecord: {
        type: 'DeletedRecord',
        props: {
            deletedDate: 'string',
            id: 'string'
        }
    },
    GetServerTimestampResult: {
        type: 'GetServerTimestampResult',
        props: {
            timestamp: 'string'
        }
    },
    InvalidateSessionsResult: {
        type: 'InvalidateSessionsResult',
        props: {
            errors: [
                'Error'
            ],
            success: 'boolean'
        }
    },
    SetPasswordResult: {
        type: 'SetPasswordResult',
        props: {}
    },
    ChangeOwnPasswordResult: {
        type: 'ChangeOwnPasswordResult',
        props: {}
    },
    ResetPasswordResult: {
        type: 'ResetPasswordResult',
        props: {
            password: 'string'
        }
    },
    GetUserInfoResult: {
        type: 'GetUserInfoResult',
        props: {
            accessibilityMode: 'boolean',
            chatterExternal: 'boolean',
            currencySymbol: '?string',
            orgAttachmentFileSizeLimit: 'number',
            orgDefaultCurrencyIsoCode: '?string',
            orgDefaultCurrencyLocale: '?string',
            orgDisallowHtmlAttachments: 'boolean',
            orgHasPersonAccounts: 'boolean',
            organizationId: 'string',
            organizationMultiCurrency: 'boolean',
            organizationName: 'string',
            profileId: 'string',
            roleId: '?string',
            sessionSecondsValid: 'number',
            userDefaultCurrencyIsoCode: '?string',
            userEmail: 'string',
            userFullName: 'string',
            userId: 'string',
            userLanguage: 'string',
            userLocale: 'string',
            userName: 'string',
            userTimeZone: 'string',
            userType: 'string',
            userUiSkin: 'string'
        }
    },
    LoginResult: {
        type: 'LoginResult',
        props: {
            metadataServerUrl: '?string',
            passwordExpired: 'boolean',
            sandbox: 'boolean',
            serverUrl: '?string',
            sessionId: '?string',
            userId: '?string',
            userInfo: '?GetUserInfoResult'
        }
    },
    ExtendedErrorDetails: {
        type: 'ExtendedErrorDetails',
        props: {
            extendedErrorCode: 'string'
        }
    },
    Error: {
        type: 'Error',
        props: {
            extendedErrorDetails: [
                '?',
                'ExtendedErrorDetails'
            ],
            fields: [
                '?',
                'string'
            ],
            message: 'string',
            statusCode: 'string'
        }
    },
    SendEmailError: {
        type: 'SendEmailError',
        props: {
            fields: [
                '?',
                'string'
            ],
            message: 'string',
            statusCode: 'string',
            targetObjectId: '?string'
        }
    },
    SaveResult: {
        type: 'SaveResult',
        props: {
            errors: [
                'Error'
            ],
            id: '?string',
            success: 'boolean'
        }
    },
    RenderEmailTemplateError: {
        type: 'RenderEmailTemplateError',
        props: {
            fieldName: 'string',
            message: 'string',
            offset: 'number',
            statusCode: 'string'
        }
    },
    UpsertResult: {
        type: 'UpsertResult',
        props: {
            created: 'boolean',
            errors: [
                'Error'
            ],
            id: '?string',
            success: 'boolean'
        }
    },
    PerformQuickActionResult: {
        type: 'PerformQuickActionResult',
        props: {
            contextId: '?string',
            created: 'boolean',
            errors: [
                'Error'
            ],
            feedItemIds: [
                '?',
                'string'
            ],
            ids: [
                '?',
                'string'
            ],
            success: 'boolean',
            successMessage: '?string'
        }
    },
    QuickActionTemplateResult: {
        type: 'QuickActionTemplateResult',
        props: {
            contextId: '?string',
            defaultValueFormulas: '?sObject',
            defaultValues: '?sObject',
            errors: [
                'Error'
            ],
            success: 'boolean'
        }
    },
    MergeRequest: {
        type: 'MergeRequest',
        props: {
            additionalInformationMap: [
                'AdditionalInformationMap'
            ],
            masterRecord: 'sObject',
            recordToMergeIds: [
                'string'
            ]
        }
    },
    MergeResult: {
        type: 'MergeResult',
        props: {
            errors: [
                'Error'
            ],
            id: '?string',
            mergedRecordIds: [
                'string'
            ],
            success: 'boolean',
            updatedRelatedIds: [
                'string'
            ]
        }
    },
    ProcessRequest: {
        type: 'ProcessRequest',
        props: {
            comments: '?string',
            nextApproverIds: [
                '?',
                'string'
            ]
        }
    },
    ProcessSubmitRequest: {
        type: 'ProcessSubmitRequest',
        props: {
            objectId: 'string',
            submitterId: '?string',
            processDefinitionNameOrId: '?string',
            skipEntryCriteria: '?boolean'
        },
        extends: 'ProcessRequest'
    },
    ProcessWorkitemRequest: {
        type: 'ProcessWorkitemRequest',
        props: {
            action: 'string',
            workitemId: 'string'
        },
        extends: 'ProcessRequest'
    },
    PerformQuickActionRequest: {
        type: 'PerformQuickActionRequest',
        props: {
            contextId: '?string',
            quickActionName: 'string',
            records: [
                '?',
                'sObject'
            ]
        }
    },
    DescribeAvailableQuickActionResult: {
        type: 'DescribeAvailableQuickActionResult',
        props: {
            actionEnumOrId: 'string',
            label: 'string',
            name: 'string',
            type: 'string'
        }
    },
    DescribeQuickActionResult: {
        type: 'DescribeQuickActionResult',
        props: {
            accessLevelRequired: '?string',
            actionEnumOrId: 'string',
            canvasApplicationId: '?string',
            canvasApplicationName: '?string',
            colors: [
                'DescribeColor'
            ],
            contextSobjectType: '?string',
            defaultValues: [
                '?',
                'DescribeQuickActionDefaultValue'
            ],
            flowDevName: '?string',
            flowRecordIdVar: '?string',
            height: '?number',
            iconName: '?string',
            iconUrl: '?string',
            icons: [
                'DescribeIcon'
            ],
            label: 'string',
            layout: '?DescribeLayoutSection',
            lightningComponentBundleId: '?string',
            lightningComponentBundleName: '?string',
            lightningComponentQualifiedName: '?string',
            miniIconUrl: '?string',
            mobileExtensionDisplayMode: '?string',
            mobileExtensionId: '?string',
            name: 'string',
            showQuickActionLcHeader: 'boolean',
            showQuickActionVfHeader: 'boolean',
            targetParentField: '?string',
            targetRecordTypeId: '?string',
            targetSobjectType: '?string',
            type: 'string',
            visualforcePageName: '?string',
            visualforcePageUrl: '?string',
            width: '?number'
        }
    },
    DescribeQuickActionDefaultValue: {
        type: 'DescribeQuickActionDefaultValue',
        props: {
            defaultValue: '?string',
            field: 'string'
        }
    },
    DescribeVisualForceResult: {
        type: 'DescribeVisualForceResult',
        props: {
            domain: 'string'
        }
    },
    ProcessResult: {
        type: 'ProcessResult',
        props: {
            actorIds: [
                'string'
            ],
            entityId: '?string',
            errors: [
                'Error'
            ],
            instanceId: '?string',
            instanceStatus: '?string',
            newWorkitemIds: [
                '?',
                'string'
            ],
            success: 'boolean'
        }
    },
    DeleteResult: {
        type: 'DeleteResult',
        props: {
            errors: [
                '?',
                'Error'
            ],
            id: '?string',
            success: 'boolean'
        }
    },
    UndeleteResult: {
        type: 'UndeleteResult',
        props: {
            errors: [
                'Error'
            ],
            id: '?string',
            success: 'boolean'
        }
    },
    DeleteByExampleResult: {
        type: 'DeleteByExampleResult',
        props: {
            entity: '?sObject',
            errors: [
                '?',
                'Error'
            ],
            rowCount: 'number',
            success: 'boolean'
        }
    },
    EmptyRecycleBinResult: {
        type: 'EmptyRecycleBinResult',
        props: {
            errors: [
                'Error'
            ],
            id: '?string',
            success: 'boolean'
        }
    },
    LeadConvert: {
        type: 'LeadConvert',
        props: {
            accountId: '?string',
            accountRecord: '?sObject',
            bypassAccountDedupeCheck: '?boolean',
            bypassContactDedupeCheck: '?boolean',
            contactId: '?string',
            contactRecord: '?sObject',
            convertedStatus: 'string',
            doNotCreateOpportunity: 'boolean',
            leadId: 'string',
            opportunityId: '?string',
            opportunityName: '?string',
            opportunityRecord: '?sObject',
            overwriteLeadSource: 'boolean',
            ownerId: '?string',
            sendNotificationEmail: 'boolean'
        }
    },
    LeadConvertResult: {
        type: 'LeadConvertResult',
        props: {
            accountId: '?string',
            contactId: '?string',
            errors: [
                'Error'
            ],
            leadId: '?string',
            opportunityId: '?string',
            success: 'boolean'
        }
    },
    DescribeSObjectResult: {
        type: 'DescribeSObjectResult',
        props: {
            actionOverrides: [
                '?',
                'ActionOverride'
            ],
            activateable: 'boolean',
            childRelationships: [
                'ChildRelationship'
            ],
            compactLayoutable: 'boolean',
            createable: 'boolean',
            custom: 'boolean',
            customSetting: 'boolean',
            dataTranslationEnabled: '?boolean',
            deepCloneable: 'boolean',
            defaultImplementation: '?string',
            deletable: 'boolean',
            deprecatedAndHidden: 'boolean',
            feedEnabled: 'boolean',
            fields: [
                '?',
                'Field'
            ],
            hasSubtypes: 'boolean',
            idEnabled: 'boolean',
            implementedBy: '?string',
            implementsInterfaces: '?string',
            isInterface: 'boolean',
            isSubtype: 'boolean',
            keyPrefix: '?string',
            label: 'string',
            labelPlural: 'string',
            layoutable: 'boolean',
            mergeable: 'boolean',
            mruEnabled: 'boolean',
            name: 'string',
            namedLayoutInfos: [
                'NamedLayoutInfo'
            ],
            networkScopeFieldName: '?string',
            queryable: 'boolean',
            recordTypeInfos: [
                'RecordTypeInfo'
            ],
            replicateable: 'boolean',
            retrieveable: 'boolean',
            searchLayoutable: '?boolean',
            searchable: 'boolean',
            supportedScopes: [
                '?',
                'ScopeInfo'
            ],
            triggerable: '?boolean',
            undeletable: 'boolean',
            updateable: 'boolean',
            urlDetail: '?string',
            urlEdit: '?string',
            urlNew: '?string'
        }
    },
    DescribeGlobalSObjectResult: {
        type: 'DescribeGlobalSObjectResult',
        props: {
            activateable: 'boolean',
            createable: 'boolean',
            custom: 'boolean',
            customSetting: 'boolean',
            dataTranslationEnabled: '?boolean',
            deepCloneable: 'boolean',
            deletable: 'boolean',
            deprecatedAndHidden: 'boolean',
            feedEnabled: 'boolean',
            hasSubtypes: 'boolean',
            idEnabled: 'boolean',
            isInterface: 'boolean',
            isSubtype: 'boolean',
            keyPrefix: '?string',
            label: 'string',
            labelPlural: 'string',
            layoutable: 'boolean',
            mergeable: 'boolean',
            mruEnabled: 'boolean',
            name: 'string',
            queryable: 'boolean',
            replicateable: 'boolean',
            retrieveable: 'boolean',
            searchable: 'boolean',
            triggerable: 'boolean',
            undeletable: 'boolean',
            updateable: 'boolean'
        }
    },
    ChildRelationship: {
        type: 'ChildRelationship',
        props: {
            cascadeDelete: 'boolean',
            childSObject: 'string',
            deprecatedAndHidden: 'boolean',
            field: 'string',
            junctionIdListNames: [
                '?',
                'string'
            ],
            junctionReferenceTo: [
                '?',
                'string'
            ],
            relationshipName: '?string',
            restrictedDelete: '?boolean'
        }
    },
    DescribeGlobalResult: {
        type: 'DescribeGlobalResult',
        props: {
            encoding: '?string',
            maxBatchSize: 'number',
            sobjects: [
                'DescribeGlobalSObjectResult'
            ]
        }
    },
    DescribeGlobalTheme: {
        type: 'DescribeGlobalTheme',
        props: {
            global: 'DescribeGlobalResult',
            theme: 'DescribeThemeResult'
        }
    },
    ScopeInfo: {
        type: 'ScopeInfo',
        props: {
            label: 'string',
            name: 'string'
        }
    },
    StringList: {
        type: 'StringList',
        props: {
            values: [
                'string'
            ]
        }
    },
    ChangeEventHeader: {
        type: 'ChangeEventHeader',
        props: {
            entityName: 'string',
            recordIds: [
                'string'
            ],
            commitTimestamp: 'number',
            commitNumber: 'number',
            commitUser: 'string',
            diffFields: [
                'string'
            ],
            changeType: 'string',
            changeOrigin: 'string',
            transactionKey: 'string',
            sequenceNumber: 'number',
            nulledFields: [
                'string'
            ],
            changedFields: [
                'string'
            ]
        }
    },
    FilteredLookupInfo: {
        type: 'FilteredLookupInfo',
        props: {
            controllingFields: [
                'string'
            ],
            dependent: 'boolean',
            optionalFilter: 'boolean'
        }
    },
    Field: {
        type: 'Field',
        props: {
            aggregatable: 'boolean',
            aiPredictionField: 'boolean',
            autoNumber: 'boolean',
            byteLength: 'number',
            calculated: 'boolean',
            calculatedFormula: '?string',
            cascadeDelete: '?boolean',
            caseSensitive: 'boolean',
            compoundFieldName: '?string',
            controllerName: '?string',
            createable: 'boolean',
            custom: 'boolean',
            dataTranslationEnabled: '?boolean',
            defaultValue: '?any',
            defaultValueFormula: '?string',
            defaultedOnCreate: 'boolean',
            dependentPicklist: '?boolean',
            deprecatedAndHidden: 'boolean',
            digits: 'number',
            displayLocationInDecimal: '?boolean',
            encrypted: '?boolean',
            externalId: '?boolean',
            extraTypeInfo: '?string',
            filterable: 'boolean',
            filteredLookupInfo: '?FilteredLookupInfo',
            formulaTreatNullNumberAsZero: '?boolean',
            groupable: 'boolean',
            highScaleNumber: '?boolean',
            htmlFormatted: '?boolean',
            idLookup: 'boolean',
            inlineHelpText: '?string',
            label: 'string',
            length: 'number',
            mask: '?string',
            maskType: '?string',
            name: 'string',
            nameField: 'boolean',
            namePointing: '?boolean',
            nillable: 'boolean',
            permissionable: 'boolean',
            picklistValues: [
                '?',
                'PicklistEntry'
            ],
            polymorphicForeignKey: 'boolean',
            precision: 'number',
            queryByDistance: 'boolean',
            referenceTargetField: '?string',
            referenceTo: [
                '?',
                'string'
            ],
            relationshipName: '?string',
            relationshipOrder: '?number',
            restrictedDelete: '?boolean',
            restrictedPicklist: 'boolean',
            scale: 'number',
            searchPrefilterable: 'boolean',
            soapType: 'string',
            sortable: '?boolean',
            type: 'string',
            unique: 'boolean',
            updateable: 'boolean',
            writeRequiresMasterRead: '?boolean'
        }
    },
    PicklistEntry: {
        type: 'PicklistEntry',
        props: {
            active: 'boolean',
            defaultValue: 'boolean',
            label: '?string',
            validFor: '?string',
            value: 'string'
        }
    },
    DescribeDataCategoryGroupResult: {
        type: 'DescribeDataCategoryGroupResult',
        props: {
            categoryCount: 'number',
            description: 'string',
            label: 'string',
            name: 'string',
            sobject: 'string'
        }
    },
    DescribeDataCategoryGroupStructureResult: {
        type: 'DescribeDataCategoryGroupStructureResult',
        props: {
            description: 'string',
            label: 'string',
            name: 'string',
            sobject: 'string',
            topCategories: [
                'DataCategory'
            ]
        }
    },
    DataCategoryGroupSobjectTypePair: {
        type: 'DataCategoryGroupSobjectTypePair',
        props: {
            dataCategoryGroupName: 'string',
            sobject: 'string'
        }
    },
    DataCategory: {
        type: 'DataCategory',
        props: {
            childCategories: [
                'DataCategory'
            ],
            label: 'string',
            name: 'string'
        }
    },
    DescribeDataCategoryMappingResult: {
        type: 'DescribeDataCategoryMappingResult',
        props: {
            dataCategoryGroupId: 'string',
            dataCategoryGroupLabel: 'string',
            dataCategoryGroupName: 'string',
            dataCategoryId: 'string',
            dataCategoryLabel: 'string',
            dataCategoryName: 'string',
            id: 'string',
            mappedEntity: 'string',
            mappedField: 'string'
        }
    },
    KnowledgeSettings: {
        type: 'KnowledgeSettings',
        props: {
            defaultLanguage: '?string',
            knowledgeEnabled: 'boolean',
            languages: [
                'KnowledgeLanguageItem'
            ]
        }
    },
    KnowledgeLanguageItem: {
        type: 'KnowledgeLanguageItem',
        props: {
            active: 'boolean',
            assigneeId: '?string',
            name: 'string'
        }
    },
    FieldDiff: {
        type: 'FieldDiff',
        props: {
            difference: 'string',
            name: 'string'
        }
    },
    AdditionalInformationMap: {
        type: 'AdditionalInformationMap',
        props: {
            name: 'string',
            value: 'string'
        }
    },
    MatchRecord: {
        type: 'MatchRecord',
        props: {
            additionalInformation: [
                'AdditionalInformationMap'
            ],
            fieldDiffs: [
                'FieldDiff'
            ],
            matchConfidence: 'number',
            record: 'sObject'
        }
    },
    MatchResult: {
        type: 'MatchResult',
        props: {
            entityType: 'string',
            errors: [
                'Error'
            ],
            matchEngine: 'string',
            matchRecords: [
                'MatchRecord'
            ],
            rule: 'string',
            size: 'number',
            success: 'boolean'
        }
    },
    DuplicateResult: {
        type: 'DuplicateResult',
        props: {
            allowSave: 'boolean',
            duplicateRule: 'string',
            duplicateRuleEntityType: 'string',
            errorMessage: '?string',
            matchResults: [
                'MatchResult'
            ]
        }
    },
    DuplicateError: {
        type: 'DuplicateError',
        props: {
            duplicateResult: 'DuplicateResult'
        },
        extends: 'Error'
    },
    DescribeNounResult: {
        type: 'DescribeNounResult',
        props: {
            caseValues: [
                'NameCaseValue'
            ],
            developerName: 'string',
            gender: '?string',
            name: 'string',
            pluralAlias: '?string',
            startsWith: '?string'
        }
    },
    NameCaseValue: {
        type: 'NameCaseValue',
        props: {
            article: '?string',
            caseType: '?string',
            number: '?string',
            possessive: '?string',
            value: '?string'
        }
    },
    FindDuplicatesResult: {
        type: 'FindDuplicatesResult',
        props: {
            duplicateResults: [
                'DuplicateResult'
            ],
            errors: [
                'Error'
            ],
            success: 'boolean'
        }
    },
    DescribeAppMenuResult: {
        type: 'DescribeAppMenuResult',
        props: {
            appMenuItems: [
                'DescribeAppMenuItem'
            ]
        }
    },
    DescribeAppMenuItem: {
        type: 'DescribeAppMenuItem',
        props: {
            colors: [
                'DescribeColor'
            ],
            content: 'string',
            icons: [
                'DescribeIcon'
            ],
            label: 'string',
            name: 'string',
            type: 'string',
            url: 'string'
        }
    },
    DescribeThemeResult: {
        type: 'DescribeThemeResult',
        props: {
            themeItems: [
                'DescribeThemeItem'
            ]
        }
    },
    DescribeThemeItem: {
        type: 'DescribeThemeItem',
        props: {
            colors: [
                'DescribeColor'
            ],
            icons: [
                'DescribeIcon'
            ],
            name: 'string'
        }
    },
    DescribeSoftphoneLayoutResult: {
        type: 'DescribeSoftphoneLayoutResult',
        props: {
            callTypes: [
                'DescribeSoftphoneLayoutCallType'
            ],
            id: 'string',
            name: 'string'
        }
    },
    DescribeSoftphoneLayoutCallType: {
        type: 'DescribeSoftphoneLayoutCallType',
        props: {
            infoFields: [
                'DescribeSoftphoneLayoutInfoField'
            ],
            name: 'string',
            screenPopOptions: [
                'DescribeSoftphoneScreenPopOption'
            ],
            screenPopsOpenWithin: '?string',
            sections: [
                'DescribeSoftphoneLayoutSection'
            ]
        }
    },
    DescribeSoftphoneScreenPopOption: {
        type: 'DescribeSoftphoneScreenPopOption',
        props: {
            matchType: 'string',
            screenPopData: 'string',
            screenPopType: 'string'
        }
    },
    DescribeSoftphoneLayoutInfoField: {
        type: 'DescribeSoftphoneLayoutInfoField',
        props: {
            name: 'string'
        }
    },
    DescribeSoftphoneLayoutSection: {
        type: 'DescribeSoftphoneLayoutSection',
        props: {
            entityApiName: 'string',
            items: [
                'DescribeSoftphoneLayoutItem'
            ]
        }
    },
    DescribeSoftphoneLayoutItem: {
        type: 'DescribeSoftphoneLayoutItem',
        props: {
            itemApiName: 'string'
        }
    },
    DescribeCompactLayoutsResult: {
        type: 'DescribeCompactLayoutsResult',
        props: {
            compactLayouts: [
                'DescribeCompactLayout'
            ],
            defaultCompactLayoutId: 'string',
            recordTypeCompactLayoutMappings: [
                'RecordTypeCompactLayoutMapping'
            ]
        }
    },
    DescribeCompactLayout: {
        type: 'DescribeCompactLayout',
        props: {
            actions: [
                'DescribeLayoutButton'
            ],
            fieldItems: [
                'DescribeLayoutItem'
            ],
            id: 'string',
            imageItems: [
                'DescribeLayoutItem'
            ],
            label: 'string',
            name: 'string',
            objectType: 'string'
        }
    },
    RecordTypeCompactLayoutMapping: {
        type: 'RecordTypeCompactLayoutMapping',
        props: {
            available: 'boolean',
            compactLayoutId: '?string',
            compactLayoutName: 'string',
            recordTypeId: 'string',
            recordTypeName: 'string'
        }
    },
    DescribePathAssistantsResult: {
        type: 'DescribePathAssistantsResult',
        props: {
            pathAssistants: [
                'DescribePathAssistant'
            ]
        }
    },
    DescribePathAssistant: {
        type: 'DescribePathAssistant',
        props: {
            active: 'boolean',
            animationRule: [
                '?',
                'DescribeAnimationRule'
            ],
            apiName: 'string',
            label: 'string',
            pathPicklistField: 'string',
            picklistsForRecordType: [
                '?',
                'PicklistForRecordType'
            ],
            recordTypeId: '?string',
            steps: [
                'DescribePathAssistantStep'
            ]
        }
    },
    DescribePathAssistantStep: {
        type: 'DescribePathAssistantStep',
        props: {
            closed: 'boolean',
            converted: 'boolean',
            fields: [
                'DescribePathAssistantField'
            ],
            info: '?string',
            layoutSection: '?DescribeLayoutSection',
            picklistLabel: 'string',
            picklistValue: 'string',
            won: 'boolean'
        }
    },
    DescribePathAssistantField: {
        type: 'DescribePathAssistantField',
        props: {
            apiName: 'string',
            label: 'string',
            readOnly: 'boolean',
            required: 'boolean'
        }
    },
    DescribeAnimationRule: {
        type: 'DescribeAnimationRule',
        props: {
            animationFrequency: 'string',
            isActive: 'boolean',
            recordTypeContext: 'string',
            recordTypeId: '?string',
            targetField: 'string',
            targetFieldChangeToValues: 'string'
        }
    },
    DescribeApprovalLayoutResult: {
        type: 'DescribeApprovalLayoutResult',
        props: {
            approvalLayouts: [
                'DescribeApprovalLayout'
            ]
        }
    },
    DescribeApprovalLayout: {
        type: 'DescribeApprovalLayout',
        props: {
            id: 'string',
            label: 'string',
            layoutItems: [
                'DescribeLayoutItem'
            ],
            name: 'string'
        }
    },
    DescribeLayoutResult: {
        type: 'DescribeLayoutResult',
        props: {
            layouts: [
                'DescribeLayout'
            ],
            recordTypeMappings: [
                'RecordTypeMapping'
            ],
            recordTypeSelectorRequired: 'boolean'
        }
    },
    DescribeLayout: {
        type: 'DescribeLayout',
        props: {
            buttonLayoutSection: '?DescribeLayoutButtonSection',
            detailLayoutSections: [
                'DescribeLayoutSection'
            ],
            editLayoutSections: [
                'DescribeLayoutSection'
            ],
            feedView: '?DescribeLayoutFeedView',
            highlightsPanelLayoutSection: '?DescribeLayoutSection',
            id: '?string',
            quickActionList: '?DescribeQuickActionListResult',
            relatedContent: '?RelatedContent',
            relatedLists: [
                'RelatedList'
            ],
            saveOptions: [
                'DescribeLayoutSaveOption'
            ]
        }
    },
    DescribeQuickActionListResult: {
        type: 'DescribeQuickActionListResult',
        props: {
            quickActionListItems: [
                'DescribeQuickActionListItemResult'
            ]
        }
    },
    DescribeQuickActionListItemResult: {
        type: 'DescribeQuickActionListItemResult',
        props: {
            accessLevelRequired: '?string',
            colors: [
                'DescribeColor'
            ],
            iconUrl: '?string',
            icons: [
                'DescribeIcon'
            ],
            label: 'string',
            miniIconUrl: 'string',
            quickActionName: 'string',
            targetSobjectType: '?string',
            type: 'string'
        }
    },
    DescribeLayoutFeedView: {
        type: 'DescribeLayoutFeedView',
        props: {
            feedFilters: [
                'DescribeLayoutFeedFilter'
            ]
        }
    },
    DescribeLayoutFeedFilter: {
        type: 'DescribeLayoutFeedFilter',
        props: {
            label: 'string',
            name: 'string',
            type: 'string'
        }
    },
    DescribeLayoutSaveOption: {
        type: 'DescribeLayoutSaveOption',
        props: {
            defaultValue: 'boolean',
            isDisplayed: 'boolean',
            label: 'string',
            name: 'string',
            restHeaderName: 'string',
            soapHeaderName: 'string'
        }
    },
    DescribeLayoutSection: {
        type: 'DescribeLayoutSection',
        props: {
            collapsed: 'boolean',
            columns: 'number',
            heading: '?string',
            layoutRows: [
                'DescribeLayoutRow'
            ],
            layoutSectionId: '?string',
            parentLayoutId: 'string',
            rows: 'number',
            tabOrder: 'string',
            useCollapsibleSection: 'boolean',
            useHeading: 'boolean'
        }
    },
    DescribeLayoutButtonSection: {
        type: 'DescribeLayoutButtonSection',
        props: {
            detailButtons: [
                'DescribeLayoutButton'
            ]
        }
    },
    DescribeLayoutRow: {
        type: 'DescribeLayoutRow',
        props: {
            layoutItems: [
                'DescribeLayoutItem'
            ],
            numItems: 'number'
        }
    },
    DescribeLayoutItem: {
        type: 'DescribeLayoutItem',
        props: {
            editableForNew: 'boolean',
            editableForUpdate: 'boolean',
            label: '?string',
            layoutComponents: [
                'DescribeLayoutComponent'
            ],
            placeholder: 'boolean',
            required: 'boolean'
        }
    },
    DescribeLayoutButton: {
        type: 'DescribeLayoutButton',
        props: {
            behavior: '?string',
            colors: [
                'DescribeColor'
            ],
            content: '?string',
            contentSource: '?string',
            custom: 'boolean',
            encoding: '?string',
            height: '?number',
            icons: [
                'DescribeIcon'
            ],
            label: '?string',
            menubar: '?boolean',
            name: '?string',
            overridden: 'boolean',
            resizeable: '?boolean',
            scrollbars: '?boolean',
            showsLocation: '?boolean',
            showsStatus: '?boolean',
            toolbar: '?boolean',
            url: '?string',
            width: '?number',
            windowPosition: '?string'
        }
    },
    DescribeLayoutComponent: {
        type: 'DescribeLayoutComponent',
        props: {
            displayLines: 'number',
            tabOrder: 'number',
            type: 'string',
            value: '?string'
        }
    },
    FieldComponent: {
        type: 'FieldComponent',
        props: {
            field: 'Field'
        },
        extends: 'DescribeLayoutComponent'
    },
    FieldLayoutComponent: {
        type: 'FieldLayoutComponent',
        props: {
            components: [
                'DescribeLayoutComponent'
            ],
            fieldType: 'string'
        },
        extends: 'DescribeLayoutComponent'
    },
    VisualforcePage: {
        type: 'VisualforcePage',
        props: {
            showLabel: 'boolean',
            showScrollbars: 'boolean',
            suggestedHeight: 'string',
            suggestedWidth: 'string',
            url: 'string'
        },
        extends: 'DescribeLayoutComponent'
    },
    Canvas: {
        type: 'Canvas',
        props: {
            displayLocation: 'string',
            referenceId: 'string',
            showLabel: 'boolean',
            showScrollbars: 'boolean',
            suggestedHeight: 'string',
            suggestedWidth: 'string'
        },
        extends: 'DescribeLayoutComponent'
    },
    ReportChartComponent: {
        type: 'ReportChartComponent',
        props: {
            cacheData: 'boolean',
            contextFilterableField: 'string',
            error: 'string',
            hideOnError: 'boolean',
            includeContext: 'boolean',
            showTitle: 'boolean',
            size: 'string'
        },
        extends: 'DescribeLayoutComponent'
    },
    AnalyticsCloudComponent: {
        type: 'AnalyticsCloudComponent',
        props: {
            error: 'string',
            filter: 'string',
            height: 'string',
            hideOnError: 'boolean',
            showSharing: 'boolean',
            showTitle: 'boolean',
            width: 'string'
        },
        extends: 'DescribeLayoutComponent'
    },
    CustomLinkComponent: {
        type: 'CustomLinkComponent',
        props: {
            customLink: 'DescribeLayoutButton'
        },
        extends: 'DescribeLayoutComponent'
    },
    NamedLayoutInfo: {
        type: 'NamedLayoutInfo',
        props: {
            name: 'string'
        }
    },
    RecordTypeInfo: {
        type: 'RecordTypeInfo',
        props: {
            active: 'boolean',
            available: 'boolean',
            defaultRecordTypeMapping: 'boolean',
            developerName: 'string',
            master: 'boolean',
            name: 'string',
            recordTypeId: '?string'
        }
    },
    RecordTypeMapping: {
        type: 'RecordTypeMapping',
        props: {
            active: 'boolean',
            available: 'boolean',
            defaultRecordTypeMapping: 'boolean',
            developerName: 'string',
            layoutId: 'string',
            master: 'boolean',
            name: 'string',
            picklistsForRecordType: [
                '?',
                'PicklistForRecordType'
            ],
            recordTypeId: '?string'
        }
    },
    PicklistForRecordType: {
        type: 'PicklistForRecordType',
        props: {
            picklistName: 'string',
            picklistValues: [
                '?',
                'PicklistEntry'
            ]
        }
    },
    RelatedContent: {
        type: 'RelatedContent',
        props: {
            relatedContentItems: [
                'DescribeRelatedContentItem'
            ]
        }
    },
    DescribeRelatedContentItem: {
        type: 'DescribeRelatedContentItem',
        props: {
            describeLayoutItem: 'DescribeLayoutItem'
        }
    },
    RelatedList: {
        type: 'RelatedList',
        props: {
            accessLevelRequiredForCreate: '?string',
            buttons: [
                '?',
                'DescribeLayoutButton'
            ],
            columns: [
                'RelatedListColumn'
            ],
            custom: 'boolean',
            field: '?string',
            label: 'string',
            limitRows: 'number',
            name: 'string',
            sobject: '?string',
            sort: [
                'RelatedListSort'
            ]
        }
    },
    RelatedListColumn: {
        type: 'RelatedListColumn',
        props: {
            field: '?string',
            fieldApiName: 'string',
            format: '?string',
            label: 'string',
            lookupId: '?string',
            name: 'string',
            sortable: 'boolean'
        }
    },
    RelatedListSort: {
        type: 'RelatedListSort',
        props: {
            ascending: 'boolean',
            column: 'string'
        }
    },
    EmailFileAttachment: {
        type: 'EmailFileAttachment',
        props: {
            body: '?string',
            contentType: '?string',
            fileName: 'string',
            id: '?string',
            inline: '?boolean'
        }
    },
    Email: {
        type: 'Email',
        props: {
            bccSender: '?boolean',
            emailPriority: '?string',
            replyTo: '?string',
            saveAsActivity: '?boolean',
            senderDisplayName: '?string',
            subject: '?string',
            useSignature: '?boolean'
        }
    },
    MassEmailMessage: {
        type: 'MassEmailMessage',
        props: {
            description: '?string',
            targetObjectIds: '?string',
            templateId: 'string',
            whatIds: '?string'
        },
        extends: 'Email'
    },
    SingleEmailMessage: {
        type: 'SingleEmailMessage',
        props: {
            bccAddresses: '?string',
            ccAddresses: '?string',
            charset: '?string',
            documentAttachments: [
                'string'
            ],
            entityAttachments: [
                'string'
            ],
            fileAttachments: [
                'EmailFileAttachment'
            ],
            htmlBody: '?string',
            inReplyTo: '?string',
            optOutPolicy: '?string',
            orgWideEmailAddressId: '?string',
            plainTextBody: '?string',
            references: '?string',
            targetObjectId: '?string',
            templateId: '?string',
            templateName: '?string',
            toAddresses: '?string',
            treatBodiesAsTemplate: '?boolean',
            treatTargetObjectAsRecipient: '?boolean',
            whatId: '?string'
        },
        extends: 'Email'
    },
    SendEmailResult: {
        type: 'SendEmailResult',
        props: {
            errors: [
                'SendEmailError'
            ],
            success: 'boolean'
        }
    },
    ListViewColumn: {
        type: 'ListViewColumn',
        props: {
            ascendingLabel: '?string',
            descendingLabel: '?string',
            fieldNameOrPath: 'string',
            hidden: 'boolean',
            label: 'string',
            searchable: 'boolean',
            selectListItem: 'string',
            sortDirection: '?string',
            sortIndex: '?number',
            sortable: 'boolean',
            type: 'string'
        }
    },
    ListViewOrderBy: {
        type: 'ListViewOrderBy',
        props: {
            fieldNameOrPath: 'string',
            nullsPosition: '?string',
            sortDirection: '?string'
        }
    },
    DescribeSoqlListView: {
        type: 'DescribeSoqlListView',
        props: {
            columns: [
                'ListViewColumn'
            ],
            id: 'string',
            orderBy: [
                'ListViewOrderBy'
            ],
            query: 'string',
            relatedEntityId: '?string',
            scope: '?string',
            scopeEntityId: '?string',
            sobjectType: 'string',
            whereCondition: '?SoqlWhereCondition'
        }
    },
    DescribeSoqlListViewsRequest: {
        type: 'DescribeSoqlListViewsRequest',
        props: {
            listViewParams: [
                'DescribeSoqlListViewParams'
            ]
        }
    },
    DescribeSoqlListViewParams: {
        type: 'DescribeSoqlListViewParams',
        props: {
            developerNameOrId: 'string',
            sobjectType: '?string'
        }
    },
    DescribeSoqlListViewResult: {
        type: 'DescribeSoqlListViewResult',
        props: {
            describeSoqlListViews: [
                'DescribeSoqlListView'
            ]
        }
    },
    ExecuteListViewRequest: {
        type: 'ExecuteListViewRequest',
        props: {
            developerNameOrId: 'string',
            limit: '?number',
            offset: '?number',
            orderBy: [
                'ListViewOrderBy'
            ],
            sobjectType: 'string'
        }
    },
    ExecuteListViewResult: {
        type: 'ExecuteListViewResult',
        props: {
            columns: [
                'ListViewColumn'
            ],
            developerName: 'string',
            done: 'boolean',
            id: 'string',
            label: 'string',
            records: [
                'ListViewRecord'
            ],
            size: 'number'
        }
    },
    ListViewRecord: {
        type: 'ListViewRecord',
        props: {
            columns: [
                'ListViewRecordColumn'
            ]
        }
    },
    ListViewRecordColumn: {
        type: 'ListViewRecordColumn',
        props: {
            fieldNameOrPath: 'string',
            value: '?string'
        }
    },
    SoqlWhereCondition: {
        type: 'SoqlWhereCondition',
        props: {}
    },
    SoqlCondition: {
        type: 'SoqlCondition',
        props: {
            field: 'string',
            operator: 'string',
            values: [
                'string'
            ]
        },
        extends: 'SoqlWhereCondition'
    },
    SoqlNotCondition: {
        type: 'SoqlNotCondition',
        props: {
            condition: 'SoqlWhereCondition'
        },
        extends: 'SoqlWhereCondition'
    },
    SoqlConditionGroup: {
        type: 'SoqlConditionGroup',
        props: {
            conditions: [
                'SoqlWhereCondition'
            ],
            conjunction: 'string'
        },
        extends: 'SoqlWhereCondition'
    },
    SoqlSubQueryCondition: {
        type: 'SoqlSubQueryCondition',
        props: {
            field: 'string',
            operator: 'string',
            subQuery: 'string'
        },
        extends: 'SoqlWhereCondition'
    },
    DescribeSearchLayoutResult: {
        type: 'DescribeSearchLayoutResult',
        props: {
            errorMsg: '?string',
            label: '?string',
            limitRows: '?number',
            objectType: 'string',
            searchColumns: [
                '?',
                'DescribeColumn'
            ]
        }
    },
    DescribeColumn: {
        type: 'DescribeColumn',
        props: {
            field: 'string',
            format: '?string',
            label: 'string',
            name: 'string'
        }
    },
    DescribeSearchScopeOrderResult: {
        type: 'DescribeSearchScopeOrderResult',
        props: {
            keyPrefix: 'string',
            name: 'string'
        }
    },
    DescribeSearchableEntityResult: {
        type: 'DescribeSearchableEntityResult',
        props: {
            label: 'string',
            name: 'string',
            pluralLabel: 'string'
        }
    },
    DescribeTabSetResult: {
        type: 'DescribeTabSetResult',
        props: {
            description: 'string',
            label: 'string',
            logoUrl: 'string',
            namespace: '?string',
            selected: 'boolean',
            tabSetId: 'string',
            tabs: [
                'DescribeTab'
            ]
        }
    },
    DescribeTab: {
        type: 'DescribeTab',
        props: {
            colors: [
                'DescribeColor'
            ],
            custom: 'boolean',
            iconUrl: 'string',
            icons: [
                'DescribeIcon'
            ],
            label: 'string',
            miniIconUrl: 'string',
            name: 'string',
            sobjectName: '?string',
            url: 'string'
        }
    },
    DescribeColor: {
        type: 'DescribeColor',
        props: {
            color: 'string',
            context: 'string',
            theme: 'string'
        }
    },
    DescribeIcon: {
        type: 'DescribeIcon',
        props: {
            contentType: 'string',
            height: '?number',
            theme: 'string',
            url: 'string',
            width: '?number'
        }
    },
    ActionOverride: {
        type: 'ActionOverride',
        props: {
            formFactor: 'string',
            isAvailableInTouch: 'boolean',
            name: 'string',
            pageId: 'string',
            url: '?string'
        }
    },
    RenderEmailTemplateRequest: {
        type: 'RenderEmailTemplateRequest',
        props: {
            escapeHtmlInMergeFields: '?boolean',
            templateBodies: 'string',
            whatId: '?string',
            whoId: '?string'
        }
    },
    RenderEmailTemplateBodyResult: {
        type: 'RenderEmailTemplateBodyResult',
        props: {
            errors: [
                'RenderEmailTemplateError'
            ],
            mergedBody: '?string',
            success: 'boolean'
        }
    },
    RenderEmailTemplateResult: {
        type: 'RenderEmailTemplateResult',
        props: {
            bodyResults: '?RenderEmailTemplateBodyResult',
            errors: [
                'Error'
            ],
            success: 'boolean'
        }
    },
    RenderStoredEmailTemplateRequest: {
        type: 'RenderStoredEmailTemplateRequest',
        props: {
            attachmentRetrievalOption: '?string',
            templateId: 'string',
            updateTemplateUsage: '?boolean',
            whatId: '?string',
            whoId: '?string'
        }
    },
    RenderStoredEmailTemplateResult: {
        type: 'RenderStoredEmailTemplateResult',
        props: {
            errors: [
                'Error'
            ],
            renderedEmail: '?SingleEmailMessage',
            success: 'boolean'
        }
    },
    LimitInfo: {
        type: 'LimitInfo',
        props: {
            current: 'number',
            limit: 'number',
            type: 'string'
        }
    },
    OwnerChangeOption: {
        type: 'OwnerChangeOption',
        props: {
            type: 'string',
            execute: 'boolean'
        }
    },
    ApiFault: {
        type: 'ApiFault',
        props: {
            exceptionCode: 'string',
            exceptionMessage: 'string',
            extendedErrorDetails: [
                '?',
                'ExtendedErrorDetails'
            ]
        }
    },
    ApiQueryFault: {
        type: 'ApiQueryFault',
        props: {
            row: 'number',
            column: 'number'
        },
        extends: 'ApiFault'
    },
    LoginFault: {
        type: 'LoginFault',
        props: {},
        extends: 'ApiFault'
    },
    InvalidQueryLocatorFault: {
        type: 'InvalidQueryLocatorFault',
        props: {},
        extends: 'ApiFault'
    },
    InvalidNewPasswordFault: {
        type: 'InvalidNewPasswordFault',
        props: {},
        extends: 'ApiFault'
    },
    InvalidOldPasswordFault: {
        type: 'InvalidOldPasswordFault',
        props: {},
        extends: 'ApiFault'
    },
    InvalidIdFault: {
        type: 'InvalidIdFault',
        props: {},
        extends: 'ApiFault'
    },
    UnexpectedErrorFault: {
        type: 'UnexpectedErrorFault',
        props: {},
        extends: 'ApiFault'
    },
    InvalidFieldFault: {
        type: 'InvalidFieldFault',
        props: {},
        extends: 'ApiQueryFault'
    },
    InvalidSObjectFault: {
        type: 'InvalidSObjectFault',
        props: {},
        extends: 'ApiQueryFault'
    },
    MalformedQueryFault: {
        type: 'MalformedQueryFault',
        props: {},
        extends: 'ApiQueryFault'
    },
    MalformedSearchFault: {
        type: 'MalformedSearchFault',
        props: {},
        extends: 'ApiQueryFault'
    }
};
}),
"[project]/node_modules/jsforce/lib/api/soap.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SoapApi = void 0;
/**
 * @file Salesforce SOAP API
 * @author Shinichi Tomita <shinichi.tomita@gmail.com>
 */ const jsforce_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/jsforce.js [app-route] (ecmascript)");
const soap_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/soap.js [app-route] (ecmascript)"));
const schema_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/api/soap/schema.js [app-route] (ecmascript)");
/**
 *
 */ function toSoapRecord(records) {
    return (Array.isArray(records) ? records : [
        records
    ]).map((record)=>{
        const { type, attributes, ...rec } = record;
        const t = type || attributes?.type;
        if (!t) {
            throw new Error('Given record is not including sObject type information');
        }
        const fieldsToNull = Object.keys(rec).filter((field)=>record[field] === null);
        for (const field of fieldsToNull){
            delete rec[field];
        }
        return fieldsToNull.length > 0 ? {
            type: t,
            fieldsToNull,
            ...rec
        } : {
            type: t,
            ...rec
        };
    });
}
/**
 * API class for Partner SOAP call
 */ class SoapApi {
    _conn;
    constructor(conn){
        this._conn = conn;
    }
    /**
     * Call SOAP Api (Partner) endpoint
     * @private
     */ async _invoke(method, message, schema) {
        const soapEndpoint = new soap_1.default(this._conn, {
            xmlns: 'urn:partner.soap.sforce.com',
            endpointUrl: `${this._conn.instanceUrl}/services/Soap/u/${this._conn.version}`
        });
        const res = await soapEndpoint.invoke(method, message, schema ? {
            result: schema
        } : undefined, schema_1.ApiSchemas);
        return res.result;
    }
    async convertLead(leadConverts) {
        const schema = Array.isArray(leadConverts) ? [
            schema_1.ApiSchemas.LeadConvertResult
        ] : schema_1.ApiSchemas.LeadConvertResult;
        return this._invoke('convertLead', {
            leadConverts
        }, schema);
    }
    async merge(mergeRequests) {
        const schema = Array.isArray(mergeRequests) ? [
            schema_1.ApiSchemas.MergeResult
        ] : schema_1.ApiSchemas.MergeResult;
        return this._invoke('merge', {
            mergeRequests
        }, schema);
    }
    /**
     * Delete records from the recycle bin immediately
     */ async emptyRecycleBin(ids) {
        return this._invoke('emptyRecycleBin', {
            ids
        }, [
            schema_1.ApiSchemas.EmptyRecycleBinResult
        ]);
    }
    /**
     * Returns information about the standard and custom apps available to the logged-in user
     */ async describeTabs() {
        return this._invoke('describeTabs', {}, [
            schema_1.ApiSchemas.DescribeTabSetResult
        ]);
    }
    /**
     * Retrieves the current system timestamp (Coordinated Universal Time (UTC) time zone) from the API
     */ async getServerTimestamp() {
        return this._invoke('getServerTimestamp', {}, schema_1.ApiSchemas.GetServerTimestampResult);
    }
    /**
     * Retrieves personal information for the user associated with the current session
     */ async getUserInfo() {
        return this._invoke('getUserInfo', {}, schema_1.ApiSchemas.GetUserInfoResult);
    }
    /**
     * Sets the specified users password to the specified value
     */ setPassword(userId, password) {
        return this._invoke('setPassword', {
            userId,
            password
        }, 'string');
    }
    /**
     * Resets the specified users password
     */ resetPassword(userId) {
        return this._invoke('resetPassword', {
            userId
        }, schema_1.ApiSchemas.ResetPasswordResult);
    }
    create(sObjects) {
        const schema = Array.isArray(sObjects) ? [
            schema_1.ApiSchemas.SaveResult
        ] : schema_1.ApiSchemas.SaveResult;
        const args = {
            '@xmlns': 'urn:partner.soap.sforce.com',
            '@xmlns:ns1': 'sobject.partner.soap.sforce.com',
            'ns1:sObjects': toSoapRecord(sObjects)
        };
        return this._invoke('create', args, schema);
    }
    update(sObjects) {
        const schema = Array.isArray(sObjects) ? [
            schema_1.ApiSchemas.SaveResult
        ] : schema_1.ApiSchemas.SaveResult;
        const args = {
            '@xmlns': 'urn:partner.soap.sforce.com',
            '@xmlns:ns1': 'sobject.partner.soap.sforce.com',
            'ns1:sObjects': toSoapRecord(sObjects)
        };
        return this._invoke('update', args, schema);
    }
    upsert(externalIdFieldName, sObjects) {
        const schema = Array.isArray(sObjects) ? [
            schema_1.ApiSchemas.UpsertResult
        ] : schema_1.ApiSchemas.UpsertResult;
        const args = {
            '@xmlns': 'urn:partner.soap.sforce.com',
            '@xmlns:ns1': 'sobject.partner.soap.sforce.com',
            'ns1:externalIDFieldName': externalIdFieldName,
            'ns1:sObjects': toSoapRecord(sObjects)
        };
        return this._invoke('upsert', args, schema);
    }
    delete(ids) {
        const schema = Array.isArray(ids) ? [
            schema_1.ApiSchemas.DeleteResult
        ] : schema_1.ApiSchemas.DeleteResult;
        const args = {
            '@xmlns': 'urn:partner.soap.sforce.com',
            '@xmlns:ns1': 'sobject.partner.soap.sforce.com',
            'ns1:ids': ids
        };
        return this._invoke('delete', args, schema);
    }
    /**
     * Undelete records from the recycle bin immediately
     */ undelete(ids) {
        const schema = [
            schema_1.ApiSchemas.UndeleteResult
        ];
        const args = {
            '@xmlns': 'urn:partner.soap.sforce.com',
            '@xmlns:ns1': 'sobject.partner.soap.sforce.com',
            'ns1:ids': ids
        };
        return this._invoke('undelete', args, schema);
    }
}
exports.SoapApi = SoapApi;
/*--------------------------------------------*/ /*
 * Register hook in connection instantiation for dynamically adding this API module features
 */ (0, jsforce_1.registerModule)('soap', (conn)=>new SoapApi(conn));
exports.default = SoapApi;
}),
"[project]/node_modules/jsforce/lib/api/streaming/extension.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Faye Client extensions: https://faye.jcoglan.com/browser/extensions.html
 *
 * For use with Streaming.prototype.createClient()
 **/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Replay = exports.AuthFailure = void 0;
/*-------------------------------------------*/ /**
 * Constructor for an auth failure detector extension
 *
 * Based on new feature released with Salesforce Spring '18:
 * https://releasenotes.docs.salesforce.com/en-us/spring18/release-notes/rn_messaging_cometd_auth_validation.htm?edition=&impact=
 *
 * Example triggering error message:
 *
 * ```
 * {
 *   "ext":{
 *     "sfdc":{"failureReason":"401::Authentication invalid"},
 *     "replay":true},
 *   "advice":{"reconnect":"none"},
 *   "channel":"/meta/handshake",
 *   "error":"403::Handshake denied",
 *   "successful":false
 * }
 * ```
 *
 * Example usage:
 *
 * ```javascript
 * const jsforce = require('jsforce');
 * const { StreamingExtension } = require('jsforce/api/streaming');
 *
 * const conn = new jsforce.Connection({  });
 *
 * const channel = "/event/My_Event__e";
 *
 * // Exit the Node process when auth fails
 * const exitCallback = () => process.exit(1);
 * const authFailureExt = new StreamingExtension.AuthFailure(exitCallback);
 *
 * const fayeClient = conn.streaming.createClient([ authFailureExt ]);
 *
 * const subscription = fayeClient.subscribe(channel, data => {
 *   console.log('topic received data', data);
 * });
 *
 * subscription.cancel();
 * ```
 *
 * @param {Function} failureCallback - Invoked when authentication becomes invalid
 */ class AuthFailure {
    _failureCallback;
    constructor(failureCallback){
        this._failureCallback = failureCallback;
    }
    incoming(message, callback) {
        if ((message.channel === '/meta/connect' || message.channel === '/meta/handshake') && message.advice && message.advice.reconnect == 'none') {
            this._failureCallback(message);
        } else {
            callback(message);
        }
    }
}
exports.AuthFailure = AuthFailure;
/*-------------------------------------------*/ const REPLAY_FROM_KEY = 'replay';
/**
 * Constructor for a durable streaming replay extension
 *
 * Modified from original Salesforce demo source code:
 * https://github.com/developerforce/SalesforceDurableStreamingDemo/blob/3d4a56eac956f744ad6c22e6a8141b6feb57abb9/staticresources/cometdReplayExtension.resource
 *
 * Example usage:
 *
 * ```javascript
 * const jsforce = require('jsforce');
 * const { StreamingExtension } = require('jsforce/api/streaming');
 
 * const conn = new jsforce.Connection({  });
 *
 * const channel = "/event/My_Event__e";
 * const replayId = -2; // -2 is all retained events
 *
 * const replayExt = new StreamingExtension.Replay(channel, replayId);
 *
 * const fayeClient = conn.streaming.createClient([ replayExt ]);
 *
 * const subscription = fayeClient.subscribe(channel, data => {
 *   console.log('topic received data', data);
 * });
 *
 * subscription.cancel();
 * ```
 */ class Replay {
    _extensionEnabled;
    _replay;
    _channel;
    constructor(channel, replayId){
        this._extensionEnabled = replayId != null;
        this._channel = channel;
        this._replay = replayId;
    }
    setExtensionEnabled(extensionEnabled) {
        this._extensionEnabled = extensionEnabled;
    }
    setReplay(replay) {
        this._replay = parseInt(replay, 10);
    }
    setChannel(channel) {
        this._channel = channel;
    }
    incoming(message, callback) {
        if (message.channel === '/meta/handshake') {
            if (message.ext && message.ext[REPLAY_FROM_KEY] == true) {
                this._extensionEnabled = true;
            }
        } else if (message.channel === this._channel && message.data?.event?.replayId) {
            this._replay = message.data.event.replayId;
        }
        callback(message);
    }
    outgoing(message, callback) {
        if (message.channel === '/meta/subscribe') {
            if (this._extensionEnabled) {
                if (!message.ext) {
                    message.ext = {};
                }
                const replayFromMap = {
                    [this._channel]: this._replay
                };
                // add "ext : { "replay" : { CHANNEL : REPLAY_VALUE }}" to subscribe message
                message.ext[REPLAY_FROM_KEY] = replayFromMap;
            }
        }
        callback(message);
    }
}
exports.Replay = Replay;
}),
"[project]/node_modules/jsforce/lib/api/streaming.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StreamingExtension = exports.Streaming = exports.Subscription = exports.Client = void 0;
/**
 * @file Manages Streaming APIs
 * @author Shinichi Tomita <shinichi.tomita@gmail.com>
 */ const events_1 = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
const faye_1 = __turbopack_context__.r("[project]/node_modules/faye/src/faye_node.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Client", {
    enumerable: true,
    get: function() {
        return faye_1.Client;
    }
});
Object.defineProperty(exports, "Subscription", {
    enumerable: true,
    get: function() {
        return faye_1.Subscription;
    }
});
const jsforce_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/jsforce.js [app-route] (ecmascript)");
const StreamingExtension = __importStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/api/streaming/extension.js [app-route] (ecmascript)"));
exports.StreamingExtension = StreamingExtension;
/*--------------------------------------------*/ /**
 * Streaming API topic class
 */ class Topic {
    _streaming;
    name;
    constructor(streaming, name){
        this._streaming = streaming;
        this.name = name;
    }
    /**
     * Subscribe listener to topic
     */ subscribe(listener) {
        return this._streaming.subscribe(this.name, listener);
    }
    /**
     * Unsubscribe listener from topic
     */ unsubscribe(subscr) {
        this._streaming.unsubscribe(this.name, subscr);
        return this;
    }
}
/*--------------------------------------------*/ /**
 * Streaming API Generic Streaming Channel
 */ class Channel {
    _streaming;
    _id;
    name;
    constructor(streaming, name){
        this._streaming = streaming;
        this.name = name;
    }
    /**
     * Subscribe to channel
     */ subscribe(listener) {
        return this._streaming.subscribe(this.name, listener);
    }
    unsubscribe(subscr) {
        this._streaming.unsubscribe(this.name, subscr);
        return this;
    }
    async push(events) {
        const isArray = Array.isArray(events);
        const pushEvents = Array.isArray(events) ? events : [
            events
        ];
        const conn = this._streaming._conn;
        if (!this._id) {
            this._id = conn.sobject('StreamingChannel').findOne({
                Name: this.name
            }, [
                'Id'
            ]).then((rec)=>rec?.Id);
        }
        const id = await this._id;
        if (!id) {
            throw new Error(`No streaming channel available for name: ${this.name}`);
        }
        const channelUrl = `/sobjects/StreamingChannel/${id}/push`;
        const rets = await conn.requestPost(channelUrl, {
            pushEvents
        });
        return isArray ? rets : rets[0];
    }
}
/*--------------------------------------------*/ /**
 * Streaming API class
 */ class Streaming extends events_1.EventEmitter {
    _conn;
    _topics = {};
    _fayeClients = {};
    /**
     *
     */ constructor(conn){
        super();
        this._conn = conn;
    }
    /* @private */ _createClient(forChannelName, extensions) {
        // forChannelName is advisory, for an API workaround. It does not restrict or select the channel.
        const needsReplayFix = typeof forChannelName === 'string' && forChannelName.startsWith('/u/');
        const endpointUrl = [
            this._conn.instanceUrl,
            // special endpoint "/cometd/replay/xx.x" is only available in 36.0.
            // See https://releasenotes.docs.salesforce.com/en-us/summer16/release-notes/rn_api_streaming_classic_replay.htm
            'cometd' + (needsReplayFix && this._conn.version === '36.0' ? '/replay' : ''),
            this._conn.version
        ].join('/');
        const fayeClient = new faye_1.Client(endpointUrl, {});
        fayeClient.setHeader('Authorization', 'OAuth ' + this._conn.accessToken);
        if (Array.isArray(extensions)) {
            for (const extension of extensions){
                fayeClient.addExtension(extension);
            }
        }
        // prevent streaming API server error
        const dispatcher = fayeClient._dispatcher;
        if (dispatcher.getConnectionTypes().indexOf('callback-polling') === -1) {
            dispatcher.selectTransport('long-polling');
            dispatcher._transport.batching = false;
        }
        return fayeClient;
    }
    /** @private **/ _getFayeClient(channelName) {
        const isGeneric = channelName.startsWith('/u/');
        const clientType = isGeneric ? 'generic' : 'pushTopic';
        if (!this._fayeClients[clientType]) {
            this._fayeClients[clientType] = this._createClient(channelName);
        }
        return this._fayeClients[clientType];
    }
    /**
     * Get named topic
     */ topic(name) {
        this._topics = this._topics || {};
        const topic = this._topics[name] = this._topics[name] || new Topic(this, name);
        return topic;
    }
    /**
     * Get channel for channel name
     */ channel(name) {
        return new Channel(this, name);
    }
    /**
     * Subscribe topic/channel
     */ subscribe(name, listener) {
        const channelName = name.startsWith('/') ? name : '/topic/' + name;
        const fayeClient = this._getFayeClient(channelName);
        return fayeClient.subscribe(channelName, listener);
    }
    /**
     * Unsubscribe topic
     */ unsubscribe(name, subscription) {
        const channelName = name.startsWith('/') ? name : '/topic/' + name;
        const fayeClient = this._getFayeClient(channelName);
        fayeClient.unsubscribe(channelName, subscription);
        return this;
    }
    /**
     * Create a Streaming client, optionally with extensions
     *
     * See Faye docs for implementation details: https://faye.jcoglan.com/browser/extensions.html
     *
     * Example usage:
     *
     * ```javascript
     * const jsforce = require('jsforce');
     *
     * // Establish a Salesforce connection. (Details elided)
     * const conn = new jsforce.Connection({  });
     *
     * const fayeClient = conn.streaming.createClient();
     *
     * const subscription = fayeClient.subscribe(channel, data => {
     *   console.log('topic received data', data);
     * });
     *
     * subscription.cancel();
     * ```
     *
     * Example with extensions, using Replay & Auth Failure extensions in a server-side Node.js app:
     *
     * ```javascript
     * const jsforce = require('jsforce');
     * const { StreamingExtension } = require('jsforce/api/streaming');
     *
     * // Establish a Salesforce connection. (Details elided)
     * const conn = new jsforce.Connection({  });
     *
     * const channel = "/event/My_Event__e";
     * const replayId = -2; // -2 is all retained events
     *
     * const exitCallback = () => process.exit(1);
     * const authFailureExt = new StreamingExtension.AuthFailure(exitCallback);
     *
     * const replayExt = new StreamingExtension.Replay(channel, replayId);
     *
     * const fayeClient = conn.streaming.createClient([
     *   authFailureExt,
     *   replayExt
     * ]);
     *
     * const subscription = fayeClient.subscribe(channel, data => {
     *   console.log('topic received data', data);
     * });
     *
     * subscription.cancel();
     * ```
     */ createClient(extensions) {
        return this._createClient(null, extensions);
    }
}
exports.Streaming = Streaming;
/*--------------------------------------------*/ /*
 * Register hook in connection instantiation for dynamically adding this API module features
 */ (0, jsforce_1.registerModule)('streaming', (conn)=>new Streaming(conn));
exports.default = Streaming;
}),
"[project]/node_modules/jsforce/lib/api/tooling.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tooling = void 0;
/**
 * @file Manages Tooling APIs
 * @author Shinichi Tomita <shinichi.tomita@gmail.com>
 */ const jsforce_1 = __turbopack_context__.r("[project]/node_modules/jsforce/lib/jsforce.js [app-route] (ecmascript)");
const connection_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/connection.js [app-route] (ecmascript)"));
const cache_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/cache.js [app-route] (ecmascript)"));
/**
 *
 */ const { query, queryMore, _ensureVersion, create, _createSingle, _createMany, _createParallel, retrieve, _retrieveSingle, _retrieveParallel, _retrieveMany, update, _updateSingle, _updateParallel, _updateMany, upsert, destroy, _destroySingle, _destroyParallel, _destroyMany, describe, describeGlobal, sobject } = connection_1.default.prototype;
const describeCacheKey = (type)=>type ? `describe.${type}` : 'describe';
/**
 * API class for Tooling API call
 */ class Tooling {
    _conn;
    get version() {
        return this._conn.version;
    }
    /**
     * Execute query by using SOQL
     */ query = query;
    /**
     * Query next record set by using query locator
     */ queryMore = queryMore;
    _ensureVersion = _ensureVersion;
    /**
     * Create records
     */ create = create;
    _createSingle = _createSingle;
    _createParallel = _createParallel;
    _createMany = _createMany;
    /**
     * Synonym of Tooling#create()
     */ insert = create;
    /**
     * Retrieve specified records
     */ retrieve = retrieve;
    _retrieveSingle = _retrieveSingle;
    _retrieveParallel = _retrieveParallel;
    _retrieveMany = _retrieveMany;
    /**
     * Update records
     */ update = update;
    _updateSingle = _updateSingle;
    _updateParallel = _updateParallel;
    _updateMany = _updateMany;
    /**
     * Upsert records
     */ upsert = upsert;
    /**
     * Delete records
     */ destroy = destroy;
    _destroySingle = _destroySingle;
    _destroyParallel = _destroyParallel;
    _destroyMany = _destroyMany;
    /**
     * Synonym of Tooling#destroy()
     */ delete = destroy;
    /**
     * Synonym of Tooling#destroy()
     */ del = destroy;
    cache = new cache_1.default();
    /**
     * Describe SObject metadata
     */ describe = this.cache.createCachedFunction(describe, this, {
        key: describeCacheKey,
        strategy: 'NOCACHE'
    });
    describe$ = this.cache.createCachedFunction(describe, this, {
        key: describeCacheKey,
        strategy: 'HIT'
    });
    describe$$ = this.cache.createCachedFunction(describe, this, {
        key: describeCacheKey,
        strategy: 'IMMEDIATE'
    });
    /**
     * Synonym of Tooling#describe()
     */ describeSObject = this.describe;
    describeSObject$ = this.describe$;
    describeSObject$$ = this.describe$$;
    /**
     * Describe global SObjects
     */ describeGlobal = this.cache.createCachedFunction(describeGlobal, this, {
        key: 'describeGlobal',
        strategy: 'NOCACHE'
    });
    describeGlobal$ = this.cache.createCachedFunction(describeGlobal, this, {
        key: 'describeGlobal',
        strategy: 'HIT'
    });
    describeGlobal$$ = this.cache.createCachedFunction(describeGlobal, this, {
        key: 'describeGlobal',
        strategy: 'IMMEDIATE'
    });
    /**
     * Get SObject instance
     */ sobject = sobject;
    sobjects = {};
    /**
     *
     */ constructor(conn){
        this._conn = conn;
    }
    /**
     * @private
     */ _establish() {
        this.sobjects = {};
        this.cache.clear();
        this.cache.get('describeGlobal').removeAllListeners('value');
        this.cache.get('describeGlobal').on('value', (res)=>{
            if (res.result) {
                for (const { name: type } of res.result.sobjects){
                    this.sobject(type);
                }
            }
        });
    }
    /**
     * @private
     */ _baseUrl() {
        return this._conn._baseUrl() + '/tooling';
    }
    /**
     * @private
     */ _supports(feature) {
        return this._conn._supports(feature);
    }
    /**
     *
     */ request(request, options) {
        return this._conn.request(request, options);
    }
    /**
     * Executes Apex code anonymously
     */ executeAnonymous(body) {
        const url = this._baseUrl() + '/executeAnonymous?anonymousBody=' + encodeURIComponent(body);
        return this.request(url);
    }
    /**
     * Executes Apex tests asynchronously
     */ runTestsAsynchronous(req) {
        const url = this._baseUrl() + '/runTestsAsynchronous/';
        return this._conn.requestPost(url, req);
    }
    /**
     * Executes Apex tests synchronously
     */ runTestsSynchronous(req) {
        const url = this._baseUrl() + '/runTestsSynchronous/';
        return this._conn.requestPost(url, req);
    }
    /**
     * Retrieves available code completions of the referenced type
     */ completions(type = 'apex') {
        const url = this._baseUrl() + '/completions?type=' + encodeURIComponent(type);
        return this.request({
            method: 'GET',
            url,
            headers: {
                Accept: 'application/json'
            }
        });
    }
}
exports.Tooling = Tooling;
/*--------------------------------------------*/ /*
 * Register hook in connection instantiation for dynamically adding this API module features
 */ (0, jsforce_1.registerModule)('tooling', (conn)=>new Tooling(conn));
exports.default = Tooling;
}),
"[project]/node_modules/jsforce/lib/types/common.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/jsforce/lib/types/schema.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/jsforce/lib/types/projection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/jsforce/lib/types/record.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/jsforce/lib/types/util.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/jsforce/lib/types/soap.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/jsforce/lib/types/standard-schema.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/jsforce/lib/types/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/types/common.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/types/schema.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/types/projection.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/types/record.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/types/util.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/types/soap.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/types/standard-schema.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/util/promise.js [app-route] (ecmascript)"), exports);
}),
"[project]/node_modules/jsforce/lib/core.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.browser = exports.registry = exports.RecordStream = exports.RecordReference = exports.BrowserClient = exports.SfDate = exports.Date = exports.VERSION = void 0;
const jsforce_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/jsforce.js [app-route] (ecmascript)"));
const date_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/date.js [app-route] (ecmascript)"));
exports.Date = date_1.default;
exports.SfDate = date_1.default;
const registry_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/registry/index.js [app-route] (ecmascript)"));
exports.registry = registry_1.default;
const client_1 = __importStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/browser/client.js [app-route] (ecmascript)"));
exports.browser = client_1.default;
Object.defineProperty(exports, "BrowserClient", {
    enumerable: true,
    get: function() {
        return client_1.BrowserClient;
    }
});
const VERSION_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/VERSION.js [app-route] (ecmascript)"));
exports.VERSION = VERSION_1.default;
const record_reference_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/record-reference.js [app-route] (ecmascript)"));
exports.RecordReference = record_reference_1.default;
const record_stream_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/record-stream.js [app-route] (ecmascript)"));
exports.RecordStream = record_stream_1.default;
__exportStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/oauth2.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/connection.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/query.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/quick-action.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/sobject.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/types/index.js [app-route] (ecmascript)"), exports);
exports.default = jsforce_1.default;
}),
"[project]/node_modules/jsforce/lib/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const jsforce_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/jsforce/lib/jsforce.js [app-route] (ecmascript)"));
__turbopack_context__.r("[project]/node_modules/jsforce/lib/api/analytics.js [app-route] (ecmascript)");
__turbopack_context__.r("[project]/node_modules/jsforce/lib/api/apex.js [app-route] (ecmascript)");
__turbopack_context__.r("[project]/node_modules/jsforce/lib/api/bulk.js [app-route] (ecmascript)");
__turbopack_context__.r("[project]/node_modules/jsforce/lib/api/bulk2.js [app-route] (ecmascript)");
__turbopack_context__.r("[project]/node_modules/jsforce/lib/api/chatter.js [app-route] (ecmascript)");
__turbopack_context__.r("[project]/node_modules/jsforce/lib/api/metadata.js [app-route] (ecmascript)");
__turbopack_context__.r("[project]/node_modules/jsforce/lib/api/soap.js [app-route] (ecmascript)");
__turbopack_context__.r("[project]/node_modules/jsforce/lib/api/streaming.js [app-route] (ecmascript)");
__turbopack_context__.r("[project]/node_modules/jsforce/lib/api/tooling.js [app-route] (ecmascript)");
__exportStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/types/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/core.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/jsforce/lib/util/promise.js [app-route] (ecmascript)"), exports);
exports.default = jsforce_1.default;
}),
"[project]/node_modules/jsforce/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = __turbopack_context__.r("[project]/node_modules/jsforce/lib/index.js [app-route] (ecmascript)").default;
}),
];

//# sourceMappingURL=node_modules_jsforce_e4470580._.js.map