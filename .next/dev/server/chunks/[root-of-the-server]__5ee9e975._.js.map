{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/ron.feathers/GitHub/LUCI/src/lib/supabase-server.js"],"sourcesContent":["/**\n * Server-side Supabase Client for Next.js\n * Uses the same logic as lib/supabase-client.js but as ES module\n */\n\nexport function getSupabaseClient() {\n  try {\n    const { createClient } = require('@supabase/supabase-js');\n    const supabaseUrl = process.env.SUPABASE_URL;\n    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n    \n    if (!supabaseUrl || !supabaseServiceKey) {\n      const missing = [];\n      if (!supabaseUrl) missing.push('SUPABASE_URL');\n      if (!supabaseServiceKey) missing.push('SUPABASE_SERVICE_ROLE_KEY');\n      console.error(`[Supabase] Missing environment variables: ${missing.join(', ')}`);\n      return null;\n    }\n    \n    return createClient(supabaseUrl, supabaseServiceKey, {\n      auth: {\n        autoRefreshToken: false,\n        persistSession: false\n      }\n    });\n  } catch (error) {\n    console.error('[Supabase] Error creating client:', error.message);\n    if (error.stack) {\n      console.error('[Supabase] Stack:', error.stack);\n    }\n    return null;\n  }\n}\n\nexport function validateSupabase(supabase) {\n  if (!supabase) {\n    return {\n      valid: false,\n      error: { status: 503, message: 'Database not configured' }\n    };\n  }\n  return { valid: true };\n}\n\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;AAEM,SAAS;IACd,IAAI;QACF,MAAM,EAAE,YAAY,EAAE;QACtB,MAAM,cAAc,QAAQ,GAAG,CAAC,YAAY;QAC5C,MAAM,qBAAqB,QAAQ,GAAG,CAAC,yBAAyB;QAEhE,IAAI,CAAC,eAAe,CAAC,oBAAoB;YACvC,MAAM,UAAU,EAAE;YAClB,IAAI,CAAC,aAAa,QAAQ,IAAI,CAAC;YAC/B,IAAI,CAAC,oBAAoB,QAAQ,IAAI,CAAC;YACtC,QAAQ,KAAK,CAAC,CAAC,0CAA0C,EAAE,QAAQ,IAAI,CAAC,OAAO;YAC/E,OAAO;QACT;QAEA,OAAO,aAAa,aAAa,oBAAoB;YACnD,MAAM;gBACJ,kBAAkB;gBAClB,gBAAgB;YAClB;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,qCAAqC,MAAM,OAAO;QAChE,IAAI,MAAM,KAAK,EAAE;YACf,QAAQ,KAAK,CAAC,qBAAqB,MAAM,KAAK;QAChD;QACA,OAAO;IACT;AACF;AAEO,SAAS,iBAAiB,QAAQ;IACvC,IAAI,CAAC,UAAU;QACb,OAAO;YACL,OAAO;YACP,OAAO;gBAAE,QAAQ;gBAAK,SAAS;YAA0B;QAC3D;IACF;IACA,OAAO;QAAE,OAAO;IAAK;AACvB"}},
    {"offset": {"line": 98, "column": 0}, "map": {"version":3,"sources":["file:///Users/ron.feathers/GitHub/LUCI/lib/constants.js"],"sourcesContent":["/**\n * Shared Constants\n * \n * Centralized constants used across the application\n */\n\n// Request limits\nconst MAX_REQUEST_SIZE = {\n  DEFAULT: 1024 * 1024, // 1MB\n  LARGE: 10 * 1024 * 1024, // 10MB (for sentiment analysis)\n};\n\n// Timeouts\nconst REQUEST_TIMEOUT = 30000; // 30 seconds\n\n// Rate limiting\nconst RATE_LIMIT = {\n  WINDOW: 60 * 1000, // 1 minute\n  MAX_REQUESTS: 10, // 10 requests per minute per IP\n};\n\n// Cache TTL (in hours, except CALENDAR_EVENTS which is in minutes)\nconst CACHE_TTL = {\n  ACCOUNTS: 1, // 1 hour\n  CASES: 1, // 1 hour\n  CONTACTS: 24, // 24 hours\n  TRANSCRIPTIONS: 24, // 24 hours\n  LINKEDIN_PROFILES: 24, // 24 hours\n  CALENDAR_EVENTS: 15, // 15 minutes (calendar events change frequently)\n};\n\n// API Limits\nconst API_LIMITS = {\n  CASES_PER_ACCOUNT: 25,\n  CONTACTS_PER_ACCOUNT: 100,\n  ACCOUNTS_PER_USER: 1000,\n};\n\nmodule.exports = {\n  MAX_REQUEST_SIZE,\n  REQUEST_TIMEOUT,\n  RATE_LIMIT,\n  CACHE_TTL,\n  API_LIMITS,\n};\n\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED,iBAAiB;AACjB,MAAM,mBAAmB;IACvB,SAAS,OAAO;IAChB,OAAO,KAAK,OAAO;AACrB;AAEA,WAAW;AACX,MAAM,kBAAkB,OAAO,aAAa;AAE5C,gBAAgB;AAChB,MAAM,aAAa;IACjB,QAAQ,KAAK;IACb,cAAc;AAChB;AAEA,mEAAmE;AACnE,MAAM,YAAY;IAChB,UAAU;IACV,OAAO;IACP,UAAU;IACV,gBAAgB;IAChB,mBAAmB;IACnB,iBAAiB;AACnB;AAEA,aAAa;AACb,MAAM,aAAa;IACjB,mBAAmB;IACnB,sBAAsB;IACtB,mBAAmB;AACrB;AAEA,OAAO,OAAO,GAAG;IACf;IACA;IACA;IACA;IACA;AACF"}},
    {"offset": {"line": 139, "column": 0}, "map": {"version":3,"sources":["file:///Users/ron.feathers/GitHub/LUCI/lib/api-helpers.js"],"sourcesContent":["/**\n * Shared API Helper Functions\n * \n * Common utilities for Vercel serverless functions\n */\n\nconst { MAX_REQUEST_SIZE, REQUEST_TIMEOUT } = require('./constants');\n\n/**\n * Set standard CORS headers\n */\nfunction setCORSHeaders(res, methods = ['GET', 'POST', 'OPTIONS']) {\n  res.setHeader('Access-Control-Allow-Origin', '*');\n  res.setHeader('Access-Control-Allow-Methods', methods.join(', '));\n  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n}\n\n/**\n * Handle preflight OPTIONS requests\n */\nfunction handlePreflight(req, res) {\n  if (req.method === 'OPTIONS') {\n    setCORSHeaders(res);\n    return res.status(200).end();\n  }\n  return false;\n}\n\n/**\n * Validate request size\n */\nfunction validateRequestSize(req, maxSize = MAX_REQUEST_SIZE.DEFAULT) {\n  const contentLength = req.headers['content-length'];\n  if (contentLength && parseInt(contentLength) > maxSize) {\n    return {\n      valid: false,\n      error: {\n        status: 413,\n        message: 'Request too large',\n      },\n    };\n  }\n  return { valid: true };\n}\n\n/**\n * Sanitize error message for production\n */\nfunction sanitizeError(error, isProduction = false) {\n  if (isProduction) {\n    // In production, don't expose internal error details\n    return {\n      error: 'An error occurred',\n      message: 'Please try again later or contact support if the problem persists.',\n    };\n  }\n  \n  // In development, return full error details\n  return {\n    error: error.message || 'An error occurred',\n    message: error.message,\n    stack: error.stack,\n  };\n}\n\n/**\n * Standard error response\n */\nfunction sendErrorResponse(res, error, statusCode = 500, isProduction = false) {\n  setCORSHeaders(res);\n  const sanitized = sanitizeError(error, isProduction);\n  return res.status(statusCode).json(sanitized);\n}\n\n/**\n * Standard success response\n */\nfunction sendSuccessResponse(res, data, statusCode = 200) {\n  setCORSHeaders(res);\n  return res.status(statusCode).json(data);\n}\n\n/**\n * Get client IP address from request\n */\nfunction getClientIP(req) {\n  return req.headers['x-forwarded-for']?.split(',')[0] || \n         req.headers['x-real-ip'] || \n         req.connection?.remoteAddress || \n         'unknown';\n}\n\n/**\n * Validate Supabase client and return error response if invalid\n * \n * @param {Object|null} supabase - Supabase client instance\n * @param {Object} res - Express response object\n * @returns {boolean} True if valid, false if invalid (response already sent)\n */\nfunction validateSupabase(supabase, res) {\n  if (!supabase) {\n    sendErrorResponse(res, new Error('Database not configured'), 503, isProduction());\n    return false;\n  }\n  return true;\n}\n\n/**\n * Check if environment is production\n */\nfunction isProduction() {\n  return process.env.NODE_ENV === 'production';\n}\n\n/**\n * Structured logging with levels\n */\nfunction formatLog(level, message) {\n  const timestamp = new Date().toISOString();\n  return `[${timestamp}] [${level.toUpperCase()}] ${message}`;\n}\n\n/**\n * Info log (only in non-production)\n */\nfunction log(message, data = null) {\n  if (!isProduction()) {\n    if (data) {\n      console.log(formatLog('info', message), data);\n    } else {\n      console.log(formatLog('info', message));\n    }\n  }\n}\n\n/**\n * Error log (always logs, even in production)\n */\nfunction logError(message, error = null) {\n  if (error) {\n    console.error(formatLog('error', message), error);\n  } else {\n    console.error(formatLog('error', message));\n  }\n}\n\n/**\n * Warning log (only in non-production)\n */\nfunction logWarn(message, data = null) {\n  if (!isProduction()) {\n    if (data) {\n      console.warn(formatLog('warn', message), data);\n    } else {\n      console.warn(formatLog('warn', message));\n    }\n  }\n}\n\n/**\n * Debug log (only in non-production, for verbose debugging)\n */\nfunction logDebug(message, data = null) {\n  if (!isProduction() && process.env.DEBUG === 'true') {\n    if (data) {\n      console.log(formatLog('debug', message), data);\n    } else {\n      console.log(formatLog('debug', message));\n    }\n  }\n}\n\n/**\n * Simple in-memory rate limiter\n * For production, use Redis or similar distributed store\n */\nconst rateLimitStore = new Map();\n\nfunction checkRateLimit(ip, windowMs, maxRequests) {\n  const now = Date.now();\n  const key = ip;\n  \n  if (!rateLimitStore.has(key)) {\n    rateLimitStore.set(key, { count: 1, resetTime: now + windowMs });\n    return true;\n  }\n  \n  const record = rateLimitStore.get(key);\n  \n  // Reset if window expired\n  if (now > record.resetTime) {\n    record.count = 1;\n    record.resetTime = now + windowMs;\n    return true;\n  }\n  \n  // Check if limit exceeded\n  if (record.count >= maxRequests) {\n    return false;\n  }\n  \n  record.count++;\n  return true;\n}\n\n// Clean up old entries periodically\nconst { RATE_LIMIT } = require('./constants');\nsetInterval(() => {\n  const now = Date.now();\n  for (const [key, record] of rateLimitStore.entries()) {\n    if (now > record.resetTime) {\n      rateLimitStore.delete(key);\n    }\n  }\n}, RATE_LIMIT.WINDOW);\n\nmodule.exports = {\n  setCORSHeaders,\n  handlePreflight,\n  validateRequestSize,\n  sanitizeError,\n  sendErrorResponse,\n  sendSuccessResponse,\n  getClientIP,\n  validateSupabase,\n  checkRateLimit,\n  isProduction,\n  log,\n  logError,\n  logWarn,\n  logDebug,\n};\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 340, "column": 0}, "map": {"version":3,"sources":["file:///Users/ron.feathers/GitHub/LUCI/src/lib/next-api-helpers.js"],"sourcesContent":["/**\n * Next.js API Route Helper Functions\n * \n * Adapters for existing lib/api-helpers.js to work with Next.js\n * Can use require() for existing helpers\n */\n\nimport { NextResponse } from 'next/server';\n\n// Import existing helpers (they work in Next.js via require)\n// From src/lib/next-api-helpers.js -> up to src/ -> up to root/ -> lib/\nconst apiHelpers = require('../../lib/api-helpers');\nconst { MAX_REQUEST_SIZE, REQUEST_TIMEOUT, RATE_LIMIT } = require('../../lib/constants');\n\n/**\n * Set CORS headers for Next.js Response\n */\nexport function setCORSHeaders(response, methods = ['GET', 'POST', 'OPTIONS']) {\n  response.headers.set('Access-Control-Allow-Origin', '*');\n  response.headers.set('Access-Control-Allow-Methods', methods.join(', '));\n  response.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n  return response;\n}\n\n/**\n * Handle preflight OPTIONS requests for Next.js\n */\nexport async function handlePreflight(request) {\n  if (request.method === 'OPTIONS') {\n    const response = new NextResponse(null, { status: 200 });\n    return setCORSHeaders(response);\n  }\n  return null;\n}\n\n/**\n * Validate request size for Next.js\n */\nexport function validateRequestSize(request, maxSize = MAX_REQUEST_SIZE.DEFAULT) {\n  const contentLength = request.headers.get('content-length');\n  if (contentLength && parseInt(contentLength) > maxSize) {\n    return {\n      valid: false,\n      error: {\n        status: 413,\n        message: 'Request too large',\n      },\n    };\n  }\n  return { valid: true };\n}\n\n/**\n * Send error response for Next.js\n */\nexport function sendErrorResponse(error, statusCode = 500) {\n  const isProd = apiHelpers.isProduction();\n  const sanitized = {\n    error: isProd ? 'An error occurred' : (error?.message || 'An error occurred'),\n    message: isProd ? 'Please try again later or contact support if the problem persists.' : (error?.message || 'An error occurred'),\n  };\n  \n  if (!isProd && error?.stack) {\n    sanitized.stack = error.stack;\n  }\n  \n  const response = NextResponse.json(sanitized, { status: statusCode });\n  return setCORSHeaders(response);\n}\n\n/**\n * Send success response for Next.js\n */\nexport function sendSuccessResponse(data, statusCode = 200) {\n  const response = NextResponse.json(data, { status: statusCode });\n  return setCORSHeaders(response);\n}\n\n/**\n * Get client IP from Next.js Request\n */\nexport function getClientIP(request) {\n  const forwarded = request.headers.get('x-forwarded-for');\n  if (forwarded) {\n    return forwarded.split(',')[0].trim();\n  }\n  return request.headers.get('x-real-ip') || 'unknown';\n}\n\n/**\n * Validate Supabase client for Next.js\n */\nexport function validateSupabase(supabase) {\n  if (!supabase) {\n    return {\n      valid: false,\n      error: { status: 503, message: 'Database not configured' }\n    };\n  }\n  return { valid: true };\n}\n\n/**\n * Check rate limit\n */\nexport function checkRateLimit(ip, windowMs, maxRequests) {\n  return apiHelpers.checkRateLimit(ip, windowMs, maxRequests);\n}\n\n// Re-export other helpers\nexport const log = apiHelpers.log;\nexport const logError = apiHelpers.logError;\nexport const logWarn = apiHelpers.logWarn;\nexport const logDebug = apiHelpers.logDebug;\nexport const isProduction = apiHelpers.isProduction;\n\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAED;;AAEA,6DAA6D;AAC7D,wEAAwE;AACxE,MAAM;AACN,MAAM,EAAE,gBAAgB,EAAE,eAAe,EAAE,UAAU,EAAE;AAKhD,SAAS,eAAe,QAAQ,EAAE,UAAU;IAAC;IAAO;IAAQ;CAAU;IAC3E,SAAS,OAAO,CAAC,GAAG,CAAC,+BAA+B;IACpD,SAAS,OAAO,CAAC,GAAG,CAAC,gCAAgC,QAAQ,IAAI,CAAC;IAClE,SAAS,OAAO,CAAC,GAAG,CAAC,gCAAgC;IACrD,OAAO;AACT;AAKO,eAAe,gBAAgB,OAAO;IAC3C,IAAI,QAAQ,MAAM,KAAK,WAAW;QAChC,MAAM,WAAW,IAAI,gJAAY,CAAC,MAAM;YAAE,QAAQ;QAAI;QACtD,OAAO,eAAe;IACxB;IACA,OAAO;AACT;AAKO,SAAS,oBAAoB,OAAO,EAAE,UAAU,iBAAiB,OAAO;IAC7E,MAAM,gBAAgB,QAAQ,OAAO,CAAC,GAAG,CAAC;IAC1C,IAAI,iBAAiB,SAAS,iBAAiB,SAAS;QACtD,OAAO;YACL,OAAO;YACP,OAAO;gBACL,QAAQ;gBACR,SAAS;YACX;QACF;IACF;IACA,OAAO;QAAE,OAAO;IAAK;AACvB;AAKO,SAAS,kBAAkB,KAAK,EAAE,aAAa,GAAG;IACvD,MAAM,SAAS,WAAW,YAAY;IACtC,MAAM,YAAY;QAChB,OAAO,SAAS,sBAAuB,OAAO,WAAW;QACzD,SAAS,SAAS,uEAAwE,OAAO,WAAW;IAC9G;IAEA,IAAI,CAAC,UAAU,OAAO,OAAO;QAC3B,UAAU,KAAK,GAAG,MAAM,KAAK;IAC/B;IAEA,MAAM,WAAW,gJAAY,CAAC,IAAI,CAAC,WAAW;QAAE,QAAQ;IAAW;IACnE,OAAO,eAAe;AACxB;AAKO,SAAS,oBAAoB,IAAI,EAAE,aAAa,GAAG;IACxD,MAAM,WAAW,gJAAY,CAAC,IAAI,CAAC,MAAM;QAAE,QAAQ;IAAW;IAC9D,OAAO,eAAe;AACxB;AAKO,SAAS,YAAY,OAAO;IACjC,MAAM,YAAY,QAAQ,OAAO,CAAC,GAAG,CAAC;IACtC,IAAI,WAAW;QACb,OAAO,UAAU,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI;IACrC;IACA,OAAO,QAAQ,OAAO,CAAC,GAAG,CAAC,gBAAgB;AAC7C;AAKO,SAAS,iBAAiB,QAAQ;IACvC,IAAI,CAAC,UAAU;QACb,OAAO;YACL,OAAO;YACP,OAAO;gBAAE,QAAQ;gBAAK,SAAS;YAA0B;QAC3D;IACF;IACA,OAAO;QAAE,OAAO;IAAK;AACvB;AAKO,SAAS,eAAe,EAAE,EAAE,QAAQ,EAAE,WAAW;IACtD,OAAO,WAAW,cAAc,CAAC,IAAI,UAAU;AACjD;AAGO,MAAM,MAAM,WAAW,GAAG;AAC1B,MAAM,WAAW,WAAW,QAAQ;AACpC,MAAM,UAAU,WAAW,OAAO;AAClC,MAAM,WAAW,WAAW,QAAQ;AACpC,MAAM,eAAe,WAAW,YAAY"}},
    {"offset": {"line": 609, "column": 0}, "map": {"version":3,"sources":["file:///Users/ron.feathers/GitHub/LUCI/lib/google-calendar-client.js"],"sourcesContent":["/**\n * Google Calendar API Client Library\n * \n * Handles Google Calendar API authentication and data fetching\n * Uses per-user OAuth tokens stored in database\n */\n\nconst { google } = require('googleapis');\n\n/**\n * Get Google Calendar OAuth configuration from environment\n * Uses existing GOOGLE_CLIENT_ID if GOOGLE_CALENDAR_CLIENT_ID is not set\n */\nfunction getGoogleCalendarConfig() {\n  // Try GOOGLE_CALENDAR_CLIENT_ID first, fallback to GOOGLE_CLIENT_ID (for reusing existing OAuth client)\n  // Trim whitespace to prevent issues with environment variable formatting\n  const clientId = (process.env.GOOGLE_CALENDAR_CLIENT_ID || process.env.GOOGLE_CLIENT_ID || '').trim();\n  // Try GOOGLE_CALENDAR_CLIENT_SECRET first, fallback to GOOGLE_CLIENT_SECRET\n  const clientSecret = (process.env.GOOGLE_CALENDAR_CLIENT_SECRET || process.env.GOOGLE_CLIENT_SECRET || '').trim();\n  const redirectUri = process.env.GOOGLE_CALENDAR_REDIRECT_URI ? process.env.GOOGLE_CALENDAR_REDIRECT_URI.trim() : undefined;\n\n  if (!clientId || !clientSecret) {\n    throw new Error('Google Calendar OAuth credentials not configured. Please set GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET (or GOOGLE_CALENDAR_CLIENT_ID and GOOGLE_CALENDAR_CLIENT_SECRET) environment variables.');\n  }\n\n  // Validate that clientId is an OAuth Client ID, not an API key\n  // OAuth Client IDs end with .apps.googleusercontent.com\n  // API keys start with AIza\n  if (clientId.startsWith('AIza')) {\n    throw new Error(`Invalid OAuth Client ID format. The value \"${clientId.substring(0, 20)}...\" appears to be an API key, not an OAuth Client ID. OAuth Client IDs should end with \".apps.googleusercontent.com\". Please check your GOOGLE_CLIENT_ID or GOOGLE_CALENDAR_CLIENT_ID environment variable.`);\n  }\n\n  if (!clientId.includes('.apps.googleusercontent.com')) {\n    throw new Error(`Invalid OAuth Client ID format. The Client ID should end with \".apps.googleusercontent.com\". Got: \"${clientId.substring(0, 30)}...\". Please check your GOOGLE_CLIENT_ID or GOOGLE_CALENDAR_CLIENT_ID environment variable.`);\n  }\n\n  return {\n    clientId,\n    clientSecret,\n    redirectUri: redirectUri || 'http://localhost:3000/api/google-calendar', // Default for local dev\n  };\n}\n\n/**\n * Create OAuth2 client for Google Calendar\n */\nfunction createOAuth2Client(config = null) {\n  const cfg = config || getGoogleCalendarConfig();\n  \n  // Ensure redirectUri is set\n  const redirectUri = cfg.redirectUri || 'http://localhost:3000/api/google-calendar';\n  \n  const oauth2Client = new google.auth.OAuth2(\n    cfg.clientId,\n    cfg.clientSecret,\n    redirectUri\n  );\n  \n  return oauth2Client;\n}\n\n/**\n * Get user's Google Calendar token from database\n */\nasync function getUserCalendarToken(supabase, userId) {\n  const { data: tokenData, error } = await supabase\n    .from('google_calendar_tokens')\n    .select('*')\n    .eq('user_id', userId)\n    .eq('is_active', true)\n    .single();\n\n  if (error || !tokenData) {\n    return null;\n  }\n\n  return tokenData;\n}\n\n/**\n * Get or refresh Google Calendar access token for a user\n */\nasync function getAccessToken(supabase, userId) {\n  const tokenData = await getUserCalendarToken(supabase, userId);\n  \n  if (!tokenData) {\n    throw new Error('Google Calendar not authorized. Please authorize via /api/google-calendar');\n  }\n\n  // Check if token is expired or expiring soon (within 5 minutes)\n  if (tokenData.token_expires_at) {\n    const expiresAt = new Date(tokenData.token_expires_at);\n    const now = new Date();\n    const fiveMinutesFromNow = new Date(now.getTime() + 5 * 60 * 1000);\n\n    if (expiresAt <= fiveMinutesFromNow) {\n      // Token expired or expiring soon - try to refresh\n      if (tokenData.refresh_token) {\n        try {\n          const refreshedToken = await refreshAccessToken(supabase, userId, tokenData);\n          return refreshedToken;\n        } catch (error) {\n          const { logError } = require('./api-helpers');\n          logError('Error refreshing Google Calendar token', error);\n          throw new Error('Google Calendar access token expired and refresh failed. Please re-authorize.');\n        }\n      } else {\n        throw new Error('Google Calendar access token expired and no refresh token available. Please re-authorize.');\n      }\n    }\n  }\n\n  return tokenData.access_token;\n}\n\n/**\n * Refresh Google Calendar access token using refresh token\n */\nasync function refreshAccessToken(supabase, userId, tokenData) {\n  const config = getGoogleCalendarConfig();\n  const oauth2Client = createOAuth2Client(config);\n  \n  oauth2Client.setCredentials({\n    refresh_token: tokenData.refresh_token,\n  });\n\n  try {\n    const { credentials } = await oauth2Client.refreshAccessToken();\n    \n    // Calculate token expiration\n    const expiresAt = new Date();\n    expiresAt.setSeconds(expiresAt.getSeconds() + (credentials.expiry_date ? \n      Math.floor((credentials.expiry_date - Date.now()) / 1000) : 3600));\n\n    // Update token in database\n    const { error: updateError } = await supabase\n      .from('google_calendar_tokens')\n      .update({\n        access_token: credentials.access_token,\n        refresh_token: credentials.refresh_token || tokenData.refresh_token, // Keep existing if not provided\n        token_expires_at: expiresAt.toISOString(),\n        last_tested: new Date().toISOString(),\n      })\n      .eq('user_id', userId);\n\n    if (updateError) {\n      throw new Error(`Failed to update token: ${updateError.message}`);\n    }\n\n    return credentials.access_token;\n  } catch (error) {\n    const { logError } = require('./api-helpers');\n    logError('Error refreshing Google Calendar token', error);\n    throw error;\n  }\n}\n\n/**\n * Get authenticated Google Calendar API client for a user\n */\nasync function getCalendarClient(supabase, userId) {\n  const accessToken = await getAccessToken(supabase, userId);\n  const oauth2Client = createOAuth2Client();\n  \n  oauth2Client.setCredentials({\n    access_token: accessToken,\n  });\n\n  return google.calendar({ version: 'v3', auth: oauth2Client });\n}\n\n/**\n * Fetch upcoming calendar events for a user\n */\nasync function fetchUpcomingEvents(supabase, userId, options = {}) {\n  const {\n    maxResults = 50,\n    timeMin = new Date().toISOString(), // Default to now\n    timeMax = null, // Default to 7 days from now if not specified\n    calendarId = 'primary',\n  } = options;\n\n  // Default to 7 days from now if timeMax not specified\n  const maxDate = timeMax || new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString();\n\n  try {\n    const calendar = await getCalendarClient(supabase, userId);\n    \n    const response = await calendar.events.list({\n      calendarId: calendarId,\n      timeMin: timeMin,\n      timeMax: maxDate,\n      maxResults: maxResults,\n      singleEvents: true,\n      orderBy: 'startTime',\n    });\n\n    return response.data.items || [];\n  } catch (error) {\n    const { logError } = require('./api-helpers');\n    logError('Error fetching Google Calendar events', error);\n    throw error;\n  }\n}\n\n/**\n * Store calendar events in database\n */\nasync function storeCalendarEvents(supabase, userId, events) {\n  const eventsToStore = events.map(event => ({\n    user_id: userId,\n    event_id: event.id,\n    summary: event.summary || null,\n    description: event.description || null,\n    start_time: event.start?.dateTime || event.start?.date || null,\n    end_time: event.end?.dateTime || event.end?.date || null,\n    location: event.location || null,\n    attendees: event.attendees || null,\n    organizer_email: event.organizer?.email || null,\n    organizer_name: event.organizer?.displayName || null,\n    conference_data: event.conferenceData || null,\n    html_link: event.htmlLink || null,\n  }));\n\n  // Upsert events (update if exists, insert if not)\n  const { error } = await supabase\n    .from('google_calendar_events')\n    .upsert(eventsToStore, {\n      onConflict: 'user_id,event_id',\n      ignoreDuplicates: false,\n    });\n\n  if (error) {\n    const { logError } = require('./api-helpers');\n    logError('Error storing calendar events', error);\n    throw error;\n  }\n\n  return eventsToStore;\n}\n\nmodule.exports = {\n  getGoogleCalendarConfig,\n  createOAuth2Client,\n  getUserCalendarToken,\n  getAccessToken,\n  refreshAccessToken,\n  getCalendarClient,\n  fetchUpcomingEvents,\n  storeCalendarEvents,\n};\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 799, "column": 0}, "map": {"version":3,"sources":["file:///Users/ron.feathers/GitHub/LUCI/lib/calendar-account-matcher.js"],"sourcesContent":["/**\n * Calendar Event to Account Matcher\n * \n * Matches Google Calendar events to Salesforce accounts based on:\n * - Account names in event title/summary\n * - Attendee email addresses matching contact emails\n * - Account names in event description\n */\n\nconst { log, logError } = require('./api-helpers');\n\n/**\n * Match calendar events to Salesforce accounts\n * \n * @param {Object} supabase - Supabase client\n * @param {string} userId - User ID\n * @param {Array} events - Array of Google Calendar events\n * @returns {Promise<Array>} Array of events with matched accounts\n */\nasync function matchEventsToAccounts(supabase, userId, events) {\n  // Get user's accounts\n  const { data: userAccounts, error: accountsError } = await supabase\n    .from('user_accounts')\n    .select(`\n      account_id,\n      accounts:account_id (\n        id,\n        salesforce_id,\n        name\n      )\n    `)\n    .eq('user_id', userId);\n\n  if (accountsError) {\n    logError('Error fetching user accounts:', accountsError);\n    return events.map(event => ({ event, matchedAccounts: [] }));\n  }\n\n  if (!userAccounts || userAccounts.length === 0) {\n    return events.map(event => ({ event, matchedAccounts: [] }));\n  }\n\n  // Get account names for matching\n  const accountMap = new Map();\n  userAccounts.forEach(ua => {\n    if (ua.accounts) {\n      accountMap.set(ua.accounts.name.toLowerCase(), {\n        id: ua.accounts.id,\n        salesforce_id: ua.accounts.salesforce_id,\n        name: ua.accounts.name,\n      });\n    }\n  });\n\n  // Get contacts for email matching\n  // Try both account_id (UUID) and salesforce_account_id (Salesforce ID) matching\n  const accountIds = userAccounts.map(ua => ua.account_id).filter(Boolean);\n  const salesforceAccountIds = userAccounts.map(ua => ua.accounts?.salesforce_id).filter(Boolean);\n  \n  log(`User has ${userAccounts.length} accounts for calendar matching`);\n  const hasManaManage = userAccounts.some(ua => ua.accounts?.name?.toLowerCase().includes('manamanage'));\n  if (hasManaManage) {\n    log(`ManaManage account found in user accounts`);\n  }\n  \n  let contacts = [];\n  if (accountIds.length > 0 || salesforceAccountIds.length > 0) {\n    // Build query to match by either account_id (UUID) or salesforce_account_id\n    let contactsQuery = supabase\n      .from('contacts')\n      .select('id, email, first_name, last_name, account_id, salesforce_account_id, account_name')\n      .not('email', 'is', null);\n    \n    // Match by account_id (UUID) if available\n    if (accountIds.length > 0) {\n      contactsQuery = contactsQuery.in('account_id', accountIds);\n    }\n    \n    // Also match by salesforce_account_id if we have those\n    // Note: Supabase doesn't support OR in a single query easily, so we'll do two queries and merge\n    const contactsPromises = [];\n    \n    if (accountIds.length > 0) {\n      contactsPromises.push(\n        supabase\n          .from('contacts')\n          .select('id, email, first_name, last_name, account_id, salesforce_account_id, account_name')\n          .in('account_id', accountIds)\n          .not('email', 'is', null)\n      );\n    }\n    \n    if (salesforceAccountIds.length > 0) {\n      contactsPromises.push(\n        supabase\n          .from('contacts')\n          .select('id, email, first_name, last_name, account_id, salesforce_account_id, account_name')\n          .in('salesforce_account_id', salesforceAccountIds)\n          .not('email', 'is', null)\n      );\n    }\n    \n    const contactsResults = await Promise.all(contactsPromises);\n    \n    // Merge results and deduplicate by contact id\n    const contactsMap = new Map();\n    contactsResults.forEach(({ data: contactsData, error: contactsError }) => {\n      if (contactsError) {\n        logError('Error fetching contacts for calendar matching:', contactsError);\n      } else if (contactsData) {\n        contactsData.forEach(contact => {\n          if (!contactsMap.has(contact.id)) {\n            contactsMap.set(contact.id, contact);\n          }\n        });\n      }\n    });\n    \n    const allContacts = Array.from(contactsMap.values());\n    \n    if (allContacts.length > 0) {\n      // Map contacts to include account info from userAccounts\n      // Try matching by account_id first, then by salesforce_account_id (case-insensitive)\n      contacts = allContacts.map(contact => {\n        let userAccount = null;\n        \n        // First try UUID match\n        if (contact.account_id) {\n          userAccount = userAccounts.find(ua => ua.account_id === contact.account_id);\n        }\n        \n        // If no UUID match, try Salesforce ID match (case-insensitive)\n        if (!userAccount && contact.salesforce_account_id) {\n          const contactSalesforceId = contact.salesforce_account_id.toLowerCase().trim();\n          userAccount = userAccounts.find(ua => {\n            const accountSalesforceId = ua.accounts?.salesforce_id?.toLowerCase().trim();\n            return accountSalesforceId === contactSalesforceId;\n          });\n        }\n        \n        return {\n          ...contact,\n          accounts: userAccount?.accounts || null,\n        };\n      });\n      \n      // Log contacts that didn't match for debugging\n      const unmatchedContacts = contacts.filter(contact => contact.accounts === null);\n      if (unmatchedContacts.length > 0) {\n        log(`Warning: ${unmatchedContacts.length} contacts found but not matched to user accounts:`);\n        unmatchedContacts.slice(0, 5).forEach(contact => {\n          log(`  - ${contact.email} (account_id: ${contact.account_id || 'null'}, salesforce_account_id: ${contact.salesforce_account_id})`);\n        });\n      }\n      \n      // Only include contacts that matched to an account\n      contacts = contacts.filter(contact => contact.accounts !== null);\n      \n      log(`Found ${contacts.length} contacts for calendar matching (from ${allContacts.length} total contacts across ${accountIds.length} UUID accounts and ${salesforceAccountIds.length} Salesforce accounts)`);\n      \n      // Log sample of contact emails for debugging\n      if (contacts.length > 0 && contacts.length <= 20) {\n        const sampleEmails = contacts.map(c => c.email).filter(Boolean).slice(0, 10);\n        log(`  Sample contact emails: ${sampleEmails.join(', ')}`);\n      }\n    } else {\n      log(`No contacts found for calendar matching (accountIds: ${accountIds.length}, salesforceAccountIds: ${salesforceAccountIds.length})`);\n      \n      // If no contacts found by account, try to find contacts by email for debugging\n      // This is a fallback to help identify if contacts exist but aren't linked properly\n      if (salesforceAccountIds.length > 0) {\n        log(`  Attempting fallback: checking for contacts with salesforce_account_id in [${salesforceAccountIds.slice(0, 3).join(', ')}...]`);\n      }\n    }\n  } else {\n    log('No account IDs found for calendar matching');\n  }\n\n  // Create email to account map (exact matches)\n  const emailToAccountMap = new Map();\n  // Create domain to account map (domain-based matches)\n  const domainToAccountMap = new Map();\n  \n      log(`Building email maps from ${contacts.length} contacts`);\n  contacts.forEach(contact => {\n    if (contact.email && contact.accounts) {\n      const email = contact.email.toLowerCase().trim();\n      \n      // Exact email matching\n      if (!emailToAccountMap.has(email)) {\n        emailToAccountMap.set(email, []);\n      }\n      emailToAccountMap.get(email).push({\n        id: contact.accounts.id,\n        salesforce_id: contact.accounts.salesforce_id,\n        name: contact.accounts.name,\n      });\n      \n      // Domain-based matching - extract domain from email\n      try {\n        const domain = email.split('@')[1];\n        if (domain) {\n          if (!domainToAccountMap.has(domain)) {\n            domainToAccountMap.set(domain, []);\n          }\n          // Only add if not already in the array for this domain\n          const existingAccounts = domainToAccountMap.get(domain);\n          const alreadyExists = existingAccounts.some(acc => acc.id === contact.accounts.id);\n          if (!alreadyExists) {\n            domainToAccountMap.get(domain).push({\n              id: contact.accounts.id,\n              salesforce_id: contact.accounts.salesforce_id,\n              name: contact.accounts.name,\n            });\n          }\n        }\n      } catch (e) {\n        // Skip if email format is invalid\n        logError('Invalid email format for domain extraction:', contact.email);\n      }\n    }\n  });\n\n  // Match events to accounts\n  const eventsWithAccounts = events.map(event => {\n    const matchedAccounts = new Set();\n    const matchReasons = [];\n\n    const eventText = [\n      event.summary || '',\n      event.description || '',\n      event.location || '',\n    ].join(' ').toLowerCase();\n\n    // Match by account name in event text\n    accountMap.forEach((account, accountNameLower) => {\n      // Check if account name appears in event text\n      // Use word boundaries to avoid partial matches\n      const regex = new RegExp(`\\\\b${accountNameLower.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'i');\n      if (regex.test(eventText)) {\n        matchedAccounts.add(account.id);\n        matchReasons.push({\n          accountId: account.id,\n          accountName: account.name,\n          reason: `Account name \"${account.name}\" found in event`,\n          confidence: 'high',\n        });\n      }\n    });\n\n    // Match by attendee email addresses\n    if (event.attendees && Array.isArray(event.attendees)) {\n      event.attendees.forEach((attendee) => {\n        if (attendee.email) {\n          const email = attendee.email.toLowerCase().trim();\n          \n          // First try exact email match (higher confidence)\n          const matchedAccountsForEmail = emailToAccountMap.get(email);\n          if (matchedAccountsForEmail && matchedAccountsForEmail.length > 0) {\n            matchedAccountsForEmail.forEach(account => {\n              if (!matchedAccounts.has(account.id)) {\n                matchedAccounts.add(account.id);\n                matchReasons.push({\n                  accountId: account.id,\n                  accountName: account.name,\n                  reason: `Attendee email ${attendee.email} matches contact`,\n                  confidence: 'high',\n                });\n              }\n            });\n          } else {\n            // If no exact match, try domain-based matching (lower confidence)\n            try {\n              const attendeeDomain = email.split('@')[1];\n              if (attendeeDomain) {\n                const matchedAccountsForDomain = domainToAccountMap.get(attendeeDomain);\n                if (matchedAccountsForDomain && matchedAccountsForDomain.length > 0) {\n                  matchedAccountsForDomain.forEach(account => {\n                    if (!matchedAccounts.has(account.id)) {\n                      matchedAccounts.add(account.id);\n                      matchReasons.push({\n                        accountId: account.id,\n                        accountName: account.name,\n                        reason: `Attendee email domain ${attendeeDomain} matches contacts from ${account.name}`,\n                        confidence: 'medium',\n                      });\n                    }\n                  });\n                }\n              }\n            } catch (e) {\n              // Skip if email format is invalid\n              logError('Invalid attendee email format for domain extraction:', attendee.email);\n            }\n          }\n        }\n      });\n    }\n\n    // Convert Set to Array and get full account details\n    const matchedAccountIds = Array.from(matchedAccounts);\n    const matchedAccountsFull = matchedAccountIds.map(accountId => {\n      const userAccount = userAccounts.find(ua => ua.account_id === accountId);\n      if (userAccount && userAccount.accounts) {\n        const matchReason = matchReasons.find(mr => mr.accountId === accountId);\n        return {\n          id: userAccount.accounts.id,\n          salesforce_id: userAccount.accounts.salesforce_id,\n          name: userAccount.accounts.name,\n          matchReason: matchReason?.reason || 'Matched',\n          confidence: matchReason?.confidence || 'medium',\n        };\n      }\n      return null;\n    }).filter(Boolean);\n\n    return {\n      event,\n      matchedAccounts: matchedAccountsFull,\n    };\n  });\n\n  // Store matches in database\n  try {\n    await storeEventAccountMatches(supabase, eventsWithAccounts);\n  } catch (error) {\n    logError('Error storing event-account matches:', error);\n    // Continue even if storage fails\n  }\n\n  return eventsWithAccounts;\n}\n\n/**\n * Store event-account matches in database\n */\nasync function storeEventAccountMatches(supabase, eventsWithAccounts) {\n  const matchesToStore = [];\n\n  for (const { event, matchedAccounts } of eventsWithAccounts) {\n    if (matchedAccounts.length === 0) continue;\n\n    // Get the stored event ID from database\n    const { data: storedEvent, error: eventError } = await supabase\n      .from('google_calendar_events')\n      .select('id')\n      .eq('event_id', event.id)\n      .single();\n\n    if (eventError || !storedEvent) {\n      continue; // Skip if event not found in database\n    }\n\n    // Create matches for each account\n    matchedAccounts.forEach(account => {\n      matchesToStore.push({\n        event_id: storedEvent.id,\n        account_id: account.id,\n        salesforce_account_id: account.salesforce_id,\n        match_confidence: account.confidence,\n        match_reason: account.matchReason,\n      });\n    });\n  }\n\n  if (matchesToStore.length > 0) {\n    // Upsert matches (update if exists, insert if not)\n    const { error: upsertError } = await supabase\n      .from('calendar_event_account_matches')\n      .upsert(matchesToStore, {\n        onConflict: 'event_id,account_id',\n        ignoreDuplicates: false,\n      });\n\n    if (upsertError) {\n      logError('Error storing event-account matches:', upsertError);\n      throw upsertError;\n    }\n  }\n}\n\nmodule.exports = {\n  matchEventsToAccounts,\n  storeEventAccountMatches,\n};\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1122, "column": 0}, "map": {"version":3,"sources":["file:///Users/ron.feathers/GitHub/LUCI/src/app/api/google-calendar/route.js"],"sourcesContent":["/**\n * Next.js App Router API Route for Google Calendar\n * \n * Combined endpoint handling:\n * - OAuth authorization flow (GET with code/userId/action)\n * - Event fetching (GET with action=events)\n * - Status checks (GET with action=status)\n * - Disconnection (DELETE)\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { getSupabaseClient } from '../../../lib/supabase-server';\nimport { handlePreflight, sendErrorResponse, sendSuccessResponse, validateSupabase, log, logError, isProduction } from '../../../lib/next-api-helpers';\n\n// Can use require for lib files in Next.js API routes\nconst { getGoogleCalendarConfig, createOAuth2Client } = require('../../../../lib/google-calendar-client');\nconst { fetchUpcomingEvents, storeCalendarEvents } = require('../../../../lib/google-calendar-client');\nconst { matchEventsToAccounts } = require('../../../../lib/calendar-account-matcher');\nconst { CACHE_TTL } = require('../../../../lib/constants');\n\n// Handle OPTIONS preflight\nexport async function OPTIONS() {\n  return handlePreflight(new NextRequest('http://localhost', { method: 'OPTIONS' }));\n}\n\n// DELETE /api/google-calendar - Disconnect Google Calendar\nexport async function DELETE(request) {\n  const preflight = await handlePreflight(request);\n  if (preflight) return preflight;\n\n  try {\n    const supabase = getSupabaseClient();\n    const validation = validateSupabase(supabase);\n    \n    if (!validation.valid) {\n      return sendErrorResponse(new Error(validation.error.message), validation.error.status);\n    }\n\n    const { searchParams } = new URL(request.url);\n    let deleteUserId = searchParams.get('userId');\n    \n    // Try body if not in query params\n    if (!deleteUserId) {\n      try {\n        const body = await request.json().catch(() => ({}));\n        deleteUserId = body.userId;\n      } catch (e) {\n        // Body not available or not JSON\n      }\n    }\n\n    if (!deleteUserId) {\n      return sendErrorResponse(new Error('Missing required parameter: userId'), 400);\n    }\n\n    // Verify user exists\n    const { data: user, error: userError } = await supabase\n      .from('users')\n      .select('id')\n      .eq('id', deleteUserId)\n      .single();\n\n    if (userError || !user) {\n      return sendErrorResponse(new Error('User not found'), 404);\n    }\n\n    // Deactivate token (soft delete)\n    const { error: updateError } = await supabase\n      .from('google_calendar_tokens')\n      .update({\n        is_active: false,\n        updated_at: new Date().toISOString(),\n      })\n      .eq('user_id', deleteUserId);\n\n    if (updateError) {\n      logError('Error disconnecting Google Calendar', updateError);\n      return sendErrorResponse(new Error('Failed to disconnect Google Calendar'), 500);\n    }\n\n    return sendSuccessResponse({ message: 'Google Calendar disconnected successfully' });\n  } catch (error) {\n    logError('Error in google-calendar DELETE:', error);\n    return sendErrorResponse(error, 500);\n  }\n}\n\n// GET /api/google-calendar - Handle OAuth flow, status checks, and event fetching\nexport async function GET(request) {\n  const preflight = await handlePreflight(request);\n  if (preflight) return preflight;\n\n  try {\n    const supabase = getSupabaseClient();\n    const validation = validateSupabase(supabase);\n    \n    if (!validation.valid) {\n      return sendErrorResponse(new Error(validation.error.message), validation.error.status);\n    }\n\n    // Get Google Calendar config (needed for most operations)\n    let config;\n    try {\n      config = getGoogleCalendarConfig();\n    } catch (error) {\n      // Only throw error for operations that require config (not status checks)\n      const { searchParams } = new URL(request.url);\n      const action = searchParams.get('action');\n      if (action !== 'status') {\n        return sendErrorResponse(new Error('Google Calendar not configured. Please set GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET (or GOOGLE_CALENDAR_CLIENT_ID and GOOGLE_CALENDAR_CLIENT_SECRET) environment variables.'), 400);\n      }\n    }\n\n    const { searchParams } = new URL(request.url);\n    const code = searchParams.get('code');\n    const state = searchParams.get('state');\n    const oauthError = searchParams.get('error');\n    const userId = searchParams.get('userId');\n    const action = searchParams.get('action');\n    const days = searchParams.get('days');\n    const forceRefresh = searchParams.get('forceRefresh');\n\n    // Action: events - Fetch calendar events\n    if (action === 'events') {\n      if (!userId) {\n        return sendErrorResponse(new Error('Missing required parameter: userId'), 400);\n      }\n\n      // Verify user exists\n      const { data: user, error: userError } = await supabase\n        .from('users')\n        .select('id, email')\n        .eq('id', userId)\n        .single();\n\n      if (userError || !user) {\n        return sendErrorResponse(new Error('User not found'), 404);\n      }\n\n      const daysNum = parseInt(days, 10) || 7;\n      const timeMin = new Date().toISOString();\n      const timeMax = new Date(Date.now() + daysNum * 24 * 60 * 60 * 1000).toISOString();\n      const shouldForceRefresh = forceRefresh === 'true' || forceRefresh === '1';\n\n      // CACHE-FIRST: Check for cached events before fetching from Google Calendar\n      let events = [];\n      let useCached = false;\n      let needsRefresh = true;\n\n      if (!shouldForceRefresh) {\n        try {\n          // Get cached events from database\n          const { data: cachedEvents, error: cacheError } = await supabase\n            .from('google_calendar_events')\n            .select('*')\n            .eq('user_id', userId)\n            .gte('start_time', timeMin)\n            .lte('start_time', timeMax)\n            .order('start_time', { ascending: true });\n\n          if (!cacheError && cachedEvents && cachedEvents.length > 0) {\n            // Check if cache is fresh (within TTL)\n            const now = new Date();\n            const cacheExpiry = (CACHE_TTL.CALENDAR_EVENTS || 15) * 60 * 1000; // 15 minutes in milliseconds\n            \n            // Use the most recent updated_at as the cache timestamp\n            const mostRecentUpdate = cachedEvents.reduce((latest, event) => {\n              if (!event.updated_at) return latest;\n              const updated = new Date(event.updated_at);\n              return updated > latest ? updated : latest;\n            }, new Date(0));\n            \n            const allFresh = (now - mostRecentUpdate) < cacheExpiry;\n\n            if (allFresh) {\n              // Convert cached events to Google Calendar API format\n              events = cachedEvents.map(event => {\n                let attendees = event.attendees;\n                if (attendees && typeof attendees === 'string') {\n                  try {\n                    attendees = JSON.parse(attendees);\n                  } catch (e) {\n                    logError('Error parsing attendees JSON:', e);\n                    attendees = null;\n                  }\n                }\n                \n                return {\n                  id: event.event_id,\n                  summary: event.summary,\n                  description: event.description,\n                  start: {\n                    dateTime: event.start_time,\n                    date: event.start_time,\n                  },\n                  end: {\n                    dateTime: event.end_time,\n                    date: event.end_time,\n                  },\n                  location: event.location,\n                  attendees: Array.isArray(attendees) ? attendees : (attendees ? [attendees] : null),\n                  organizer: event.organizer_email ? {\n                    email: event.organizer_email,\n                    displayName: event.organizer_name,\n                  } : null,\n                  conferenceData: event.conference_data,\n                  htmlLink: event.html_link,\n                };\n              });\n              useCached = true;\n              needsRefresh = false;\n              log(`Returning ${events.length} cached calendar events`);\n            } else {\n              needsRefresh = true;\n            }\n          }\n        } catch (cacheError) {\n          logError('Error getting cached calendar events', cacheError);\n          needsRefresh = true;\n        }\n      }\n\n      // Fetch from Google Calendar if cache is stale/missing or force refresh requested\n      if (needsRefresh || shouldForceRefresh) {\n        try {\n          const fetchedEvents = await fetchUpcomingEvents(supabase, userId, {\n            timeMin,\n            timeMax,\n            maxResults: 50,\n          });\n          \n          events = fetchedEvents;\n          \n          // Store events in database\n          if (events.length > 0) {\n            try {\n              await storeCalendarEvents(supabase, userId, events);\n              log(`Fetched and cached ${events.length} calendar events`);\n            } catch (error) {\n              logError('Error storing calendar events', error);\n            }\n          }\n        } catch (error) {\n          if (error.message && error.message.includes('not authorized')) {\n            return sendErrorResponse(new Error('Google Calendar not authorized. Please connect your calendar first.'), 401);\n          }\n          logError('Error fetching calendar events', error);\n          \n          // If we have cached events (even if stale), use them as fallback\n          if (useCached && events.length > 0) {\n            log('Using stale cache as fallback');\n          } else {\n            throw error;\n          }\n        }\n      }\n\n      // Match events to Salesforce accounts\n      let eventsWithAccounts = [];\n      if (events.length > 0) {\n        try {\n          eventsWithAccounts = await matchEventsToAccounts(supabase, userId, events);\n        } catch (error) {\n          logError('Error matching events to accounts', error);\n          // Return events without matches if matching fails\n          eventsWithAccounts = events.map(event => ({\n            event,\n            matchedAccounts: [],\n          }));\n        }\n      }\n\n      return sendSuccessResponse({\n        events: eventsWithAccounts,\n        totalEvents: events.length,\n        matchedEvents: eventsWithAccounts.filter(e => e.matchedAccounts.length > 0).length,\n        cached: useCached,\n        forceRefresh: shouldForceRefresh,\n      });\n    }\n\n    // Action: status - Check connection status\n    if (action === 'status' || (!code && !userId && !oauthError && !action)) {\n      // Check if Google Calendar is configured\n      try {\n        getGoogleCalendarConfig();\n      } catch (configError) {\n        const hasClientId = !!(process.env.GOOGLE_CALENDAR_CLIENT_ID || process.env.GOOGLE_CLIENT_ID);\n        const hasClientSecret = !!(process.env.GOOGLE_CALENDAR_CLIENT_SECRET || process.env.GOOGLE_CLIENT_SECRET);\n        const clientIdValue = process.env.GOOGLE_CALENDAR_CLIENT_ID || process.env.GOOGLE_CLIENT_ID;\n        const isApiKey = clientIdValue && clientIdValue.startsWith('AIza');\n        \n        let errorMessage = 'Google Calendar integration is not configured.';\n        if (isApiKey) {\n          errorMessage = 'Google Calendar integration is misconfigured. An API key is being used instead of an OAuth Client ID. Please update GOOGLE_CLIENT_ID or GOOGLE_CALENDAR_CLIENT_ID to use an OAuth Client ID (ending with .apps.googleusercontent.com) instead of an API key.';\n        } else if (!hasClientId || !hasClientSecret) {\n          errorMessage = 'Google Calendar integration is not configured. Please set GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET (or GOOGLE_CALENDAR_CLIENT_ID and GOOGLE_CALENDAR_CLIENT_SECRET) environment variables.';\n        } else {\n          errorMessage = configError.message || errorMessage;\n        }\n        \n        return sendSuccessResponse({\n          connected: false,\n          configured: false,\n          message: errorMessage,\n          error: configError.message,\n        });\n      }\n\n      const statusUserId = userId || searchParams.get('userId');\n      if (!statusUserId) {\n        return sendErrorResponse(new Error('Missing required parameter: userId'), 400);\n      }\n\n      // Check if user has an active Google Calendar token\n      const { data: tokenData, error } = await supabase\n        .from('google_calendar_tokens')\n        .select('id, token_expires_at, is_active')\n        .eq('user_id', statusUserId)\n        .eq('is_active', true)\n        .single();\n\n      if (error && error.code !== 'PGRST116') {\n        logError('Error checking calendar status', error);\n        throw error;\n      }\n\n      const connected = !!(tokenData && tokenData.is_active);\n\n      return sendSuccessResponse({\n        connected,\n        configured: true,\n        tokenExpiresAt: tokenData?.token_expires_at || null,\n      });\n    }\n\n    // OAuth Flow: Initiate OAuth (redirect to Google)\n    if (!code && !oauthError) {\n      if (!userId) {\n        return sendErrorResponse(new Error('Missing required parameter: userId'), 400);\n      }\n\n      // Verify user exists\n      const { data: user, error: userError } = await supabase\n        .from('users')\n        .select('id, email')\n        .eq('id', userId)\n        .single();\n\n      if (userError || !user) {\n        return sendErrorResponse(new Error('User not found'), 404);\n      }\n\n      // Determine redirect URI\n      const host = request.headers.get('host') || 'unknown';\n      const isLocalhost = host.includes('localhost') || host.includes('127.0.0.1');\n      const protocol = isLocalhost ? 'http' : (request.headers.get('x-forwarded-proto') || 'https');\n      \n      let redirectUri;\n      if (isLocalhost) {\n        redirectUri = 'http://localhost:3000/api/google-calendar';\n      } else {\n        redirectUri = config.redirectUri || `${protocol}://${host}/api/google-calendar`;\n      }\n      \n      log(`Initiating Google Calendar OAuth for user ${userId}`);\n      \n      // Generate state for CSRF protection\n      const stateValue = Buffer.from(JSON.stringify({ userId, timestamp: Date.now() })).toString('base64');\n      \n      // Create OAuth2 client\n      const oauth2ClientConfig = {\n        clientId: config.clientId,\n        clientSecret: config.clientSecret,\n        redirectUri: redirectUri,\n      };\n      \n      const oauth2Client = createOAuth2Client(oauth2ClientConfig);\n      \n      // Generate auth URL\n      const authUrl = oauth2Client.generateAuthUrl({\n        access_type: 'offline',\n        scope: [\n          'https://www.googleapis.com/auth/calendar.readonly',\n          'https://www.googleapis.com/auth/calendar.events.readonly',\n        ],\n        state: stateValue,\n        prompt: 'consent',\n      });\n\n      return NextResponse.redirect(authUrl);\n    }\n\n    // Handle OAuth error\n    if (oauthError) {\n      return sendErrorResponse(new Error(`Google Calendar OAuth error: ${oauthError}. User denied authorization or an error occurred.`), 400);\n    }\n\n    // Exchange authorization code for access token\n    if (code) {\n      // Parse state to get userId\n      let userIdFromState = null;\n      try {\n        const stateData = JSON.parse(Buffer.from(state, 'base64').toString());\n        userIdFromState = stateData.userId;\n      } catch (error) {\n        logError('Error parsing state:', error);\n      }\n\n      const userId = userIdFromState || searchParams.get('userId');\n\n      if (!userId) {\n        return sendErrorResponse(new Error('Missing userId. Please include userId in the authorization request.'), 400);\n      }\n\n      // Verify user exists\n      const { data: user, error: userError } = await supabase\n        .from('users')\n        .select('id, email')\n        .eq('id', userId)\n        .single();\n\n      if (userError || !user) {\n        return sendErrorResponse(new Error('User not found'), 404);\n      }\n\n      // Determine redirect URI (must match auth URL)\n      const host = request.headers.get('host') || 'unknown';\n      const isLocalhost = host.includes('localhost') || host.includes('127.0.0.1');\n      const protocol = isLocalhost ? 'http' : (request.headers.get('x-forwarded-proto') || 'https');\n      \n      let redirectUri;\n      if (isLocalhost) {\n        redirectUri = 'http://localhost:3000/api/google-calendar';\n      } else {\n        redirectUri = config.redirectUri || `${protocol}://${host}/api/google-calendar`;\n      }\n\n      log(`Exchanging OAuth code for token for user ${userId}`);\n\n      // Create OAuth2 client\n      const oauth2ClientConfig = {\n        clientId: config.clientId,\n        clientSecret: config.clientSecret,\n        redirectUri: redirectUri,\n      };\n      \n      const oauth2Client = createOAuth2Client(oauth2ClientConfig);\n      \n      try {\n        const { tokens } = await oauth2Client.getToken(code);\n        \n        if (!tokens.access_token) {\n          return sendErrorResponse(new Error('Invalid token response. Google did not return an access token.'), 400);\n        }\n\n        // Calculate token expiration\n        const expiresAt = new Date();\n        expiresAt.setSeconds(expiresAt.getSeconds() + (tokens.expiry_date ? \n          Math.floor((tokens.expiry_date - Date.now()) / 1000) : 3600));\n\n        // Store or update tokens in database\n        const { error: upsertError } = await supabase\n          .from('google_calendar_tokens')\n          .upsert({\n            user_id: userId,\n            access_token: tokens.access_token,\n            refresh_token: tokens.refresh_token || null,\n            token_expires_at: expiresAt.toISOString(),\n            scope: tokens.scope || null,\n            is_active: true,\n            last_tested: new Date().toISOString(),\n          }, {\n            onConflict: 'user_id',\n            ignoreDuplicates: false,\n          });\n\n        if (upsertError) {\n          logError('Error storing Google Calendar token', upsertError);\n          return sendErrorResponse(new Error('Failed to store access token. Could not save access token to database.'), 500);\n        }\n\n        // Return success page with auto-redirect\n        const htmlContent = `\n          <!DOCTYPE html>\n          <html>\n          <head>\n            <title>Google Calendar OAuth Success</title>\n            <meta http-equiv=\"refresh\" content=\"2;url=/calendar\">\n            <style>\n              body {\n                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;\n                display: flex;\n                justify-content: center;\n                align-items: center;\n                min-height: 100vh;\n                margin: 0;\n                background: linear-gradient(135deg, #4285f4 0%, #34a853 100%);\n              }\n              .container {\n                background: white;\n                padding: 2rem;\n                border-radius: 8px;\n                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n                text-align: center;\n                max-width: 500px;\n              }\n              h1 {\n                color: #4285f4;\n                margin-bottom: 1rem;\n              }\n              .success {\n                color: #34a853;\n                font-size: 3rem;\n                margin-bottom: 1rem;\n              }\n              p {\n                color: #6b7280;\n                line-height: 1.6;\n              }\n              .token-info {\n                background: #f3f4f6;\n                padding: 1rem;\n                border-radius: 4px;\n                margin-top: 1rem;\n                font-size: 0.875rem;\n                color: #374151;\n              }\n              .redirect-message {\n                margin-top: 1.5rem;\n                font-size: 0.875rem;\n                color: #6b7280;\n              }\n              .redirect-link {\n                display: inline-block;\n                margin-top: 1rem;\n                padding: 0.75rem 1.5rem;\n                background: #4285f4;\n                color: white;\n                text-decoration: none;\n                border-radius: 0.375rem;\n                font-weight: 600;\n                transition: background 0.2s;\n              }\n              .redirect-link:hover {\n                background: #3367d6;\n              }\n            </style>\n          </head>\n          <body>\n            <div class=\"container\">\n              <div class=\"success\"></div>\n              <h1>Google Calendar Connected!</h1>\n              <p>Your Google Calendar has been successfully connected and is ready to use.</p>\n              <div class=\"token-info\">\n                <strong>Token expires:</strong> ${new Date(expiresAt).toLocaleString()}\n              </div>\n              <div class=\"redirect-message\">\n                <p>Redirecting you back to the calendar page...</p>\n                <a href=\"/calendar\" class=\"redirect-link\">Go to Calendar Page</a>\n              </div>\n            </div>\n            <script>\n              setTimeout(function() {\n                window.location.href = '/calendar';\n              }, 2000);\n            </script>\n          </body>\n          </html>\n        `;\n\n        return new NextResponse(htmlContent, {\n          status: 200,\n          headers: {\n            'Content-Type': 'text/html',\n          },\n        });\n      } catch (tokenError) {\n        logError('Error exchanging authorization code', tokenError);\n        if (tokenError.message && tokenError.message.includes('invalid_client')) {\n          return sendErrorResponse(new Error(`Invalid OAuth client credentials. Please verify that GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET in .env.local match the OAuth client in Google Cloud Console. Error: ${tokenError.message}`), 400);\n        }\n        return sendErrorResponse(new Error(`Failed to exchange authorization code: ${tokenError.message}`), 400);\n      }\n    }\n\n    return sendErrorResponse(new Error('Invalid request'), 400);\n\n  } catch (error) {\n    logError('Error in google-calendar', error);\n    return sendErrorResponse(error, 500);\n  }\n}\n\n"],"names":[],"mappings":"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"}}]
}