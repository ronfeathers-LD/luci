module.exports = [
"[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ __turbopack_context__.s([
    "__addDisposableResource",
    ()=>__addDisposableResource,
    "__assign",
    ()=>__assign,
    "__asyncDelegator",
    ()=>__asyncDelegator,
    "__asyncGenerator",
    ()=>__asyncGenerator,
    "__asyncValues",
    ()=>__asyncValues,
    "__await",
    ()=>__await,
    "__awaiter",
    ()=>__awaiter,
    "__classPrivateFieldGet",
    ()=>__classPrivateFieldGet,
    "__classPrivateFieldIn",
    ()=>__classPrivateFieldIn,
    "__classPrivateFieldSet",
    ()=>__classPrivateFieldSet,
    "__createBinding",
    ()=>__createBinding,
    "__decorate",
    ()=>__decorate,
    "__disposeResources",
    ()=>__disposeResources,
    "__esDecorate",
    ()=>__esDecorate,
    "__exportStar",
    ()=>__exportStar,
    "__extends",
    ()=>__extends,
    "__generator",
    ()=>__generator,
    "__importDefault",
    ()=>__importDefault,
    "__importStar",
    ()=>__importStar,
    "__makeTemplateObject",
    ()=>__makeTemplateObject,
    "__metadata",
    ()=>__metadata,
    "__param",
    ()=>__param,
    "__propKey",
    ()=>__propKey,
    "__read",
    ()=>__read,
    "__rest",
    ()=>__rest,
    "__rewriteRelativeImportExtension",
    ()=>__rewriteRelativeImportExtension,
    "__runInitializers",
    ()=>__runInitializers,
    "__setFunctionName",
    ()=>__setFunctionName,
    "__spread",
    ()=>__spread,
    "__spreadArray",
    ()=>__spreadArray,
    "__spreadArrays",
    ()=>__spreadArrays,
    "__values",
    ()=>__values,
    "default",
    ()=>__TURBOPACK__default__export__
]);
var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(d, b) {
        d.__proto__ = b;
    } || function(d, b) {
        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return extendStatics(d, b);
};
function __extends(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function __rest(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
}
function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
        if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
        return f;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for(var i = decorators.length - 1; i >= 0; i--){
        var context = {};
        for(var p in contextIn)context[p] = p === "access" ? {} : contextIn[p];
        for(var p in contextIn.access)context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
            if (done) throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? {
            get: descriptor.get,
            set: descriptor.set
        } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        } else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
}
;
function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for(var i = 0; i < initializers.length; i++){
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
}
;
function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
}
;
function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", {
        configurable: true,
        value: prefix ? "".concat(prefix, " ", name) : name
    });
}
;
function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    //TURBOPACK unreachable
    ;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var __createBinding = Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
};
function __exportStar(m, o) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
}
function __spread() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
}
function __spreadArrays() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
}
function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    //TURBOPACK unreachable
    ;
    function awaitReturn(f) {
        return function(v) {
            return Promise.resolve(v).then(f, reject);
        };
    }
    function verb(n, f) {
        if (g[n]) {
            i[n] = function(v) {
                return new Promise(function(a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
            if (f) i[n] = f(i[n]);
        }
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
}
function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
        return this;
    }, i;
    //TURBOPACK unreachable
    ;
    function verb(n, f) {
        i[n] = o[n] ? function(v) {
            return (p = !p) ? {
                value: __await(o[n](v)),
                done: false
            } : f ? f(v) : v;
        } : f;
    }
}
function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    //TURBOPACK unreachable
    ;
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
}
function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", {
            value: raw
        });
    } else {
        cooked.raw = raw;
    }
    return cooked;
}
;
var __setModuleDefault = Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
};
var ownKeys = function(o) {
    ownKeys = Object.getOwnPropertyNames || function(o) {
        var ar = [];
        for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
    };
    return ownKeys(o);
};
function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
    }
    __setModuleDefault(result, mod);
    return result;
}
function __importDefault(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() {
            try {
                inner.call(this);
            } catch (e) {
                return Promise.reject(e);
            }
        };
        env.stack.push({
            value: value,
            dispose: dispose,
            async: async
        });
    } else if (async) {
        env.stack.push({
            async: true
        });
    }
    return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
    function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
    }
    var r, s = 0;
    function next() {
        while(r = env.stack.pop()){
            try {
                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                if (r.dispose) {
                    var result = r.dispose.call(r.value);
                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                        fail(e);
                        return next();
                    });
                } else s |= 1;
            } catch (e) {
                fail(e);
            }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
    }
    return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
    if (typeof path === "string" && /^\.\.?\//.test(path)) {
        return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
            return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
        });
    }
    return path;
}
const __TURBOPACK__default__export__ = {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __esDecorate,
    __runInitializers,
    __propKey,
    __setFunctionName,
    __metadata,
    __awaiter,
    __generator,
    __createBinding,
    __exportStar,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn,
    __addDisposableResource,
    __disposeResources,
    __rewriteRelativeImportExtension
};
}),
"[project]/node_modules/@supabase/functions-js/dist/module/helper.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "resolveFetch",
    ()=>resolveFetch
]);
const resolveFetch = (customFetch)=>{
    if (customFetch) {
        return (...args)=>customFetch(...args);
    }
    return (...args)=>fetch(...args);
}; //# sourceMappingURL=helper.js.map
}),
"[project]/node_modules/@supabase/functions-js/dist/module/types.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Base error for Supabase Edge Function invocations.
 *
 * @example
 * ```ts
 * import { FunctionsError } from '@supabase/functions-js'
 *
 * throw new FunctionsError('Unexpected error invoking function', 'FunctionsError', {
 *   requestId: 'abc123',
 * })
 * ```
 */ __turbopack_context__.s([
    "FunctionRegion",
    ()=>FunctionRegion,
    "FunctionsError",
    ()=>FunctionsError,
    "FunctionsFetchError",
    ()=>FunctionsFetchError,
    "FunctionsHttpError",
    ()=>FunctionsHttpError,
    "FunctionsRelayError",
    ()=>FunctionsRelayError
]);
class FunctionsError extends Error {
    constructor(message, name = 'FunctionsError', context){
        super(message);
        this.name = name;
        this.context = context;
    }
}
class FunctionsFetchError extends FunctionsError {
    constructor(context){
        super('Failed to send a request to the Edge Function', 'FunctionsFetchError', context);
    }
}
class FunctionsRelayError extends FunctionsError {
    constructor(context){
        super('Relay Error invoking the Edge Function', 'FunctionsRelayError', context);
    }
}
class FunctionsHttpError extends FunctionsError {
    constructor(context){
        super('Edge Function returned a non-2xx status code', 'FunctionsHttpError', context);
    }
}
var FunctionRegion;
(function(FunctionRegion) {
    FunctionRegion["Any"] = "any";
    FunctionRegion["ApNortheast1"] = "ap-northeast-1";
    FunctionRegion["ApNortheast2"] = "ap-northeast-2";
    FunctionRegion["ApSouth1"] = "ap-south-1";
    FunctionRegion["ApSoutheast1"] = "ap-southeast-1";
    FunctionRegion["ApSoutheast2"] = "ap-southeast-2";
    FunctionRegion["CaCentral1"] = "ca-central-1";
    FunctionRegion["EuCentral1"] = "eu-central-1";
    FunctionRegion["EuWest1"] = "eu-west-1";
    FunctionRegion["EuWest2"] = "eu-west-2";
    FunctionRegion["EuWest3"] = "eu-west-3";
    FunctionRegion["SaEast1"] = "sa-east-1";
    FunctionRegion["UsEast1"] = "us-east-1";
    FunctionRegion["UsWest1"] = "us-west-1";
    FunctionRegion["UsWest2"] = "us-west-2";
})(FunctionRegion || (FunctionRegion = {})); //# sourceMappingURL=types.js.map
}),
"[project]/node_modules/@supabase/functions-js/dist/module/FunctionsClient.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FunctionsClient",
    ()=>FunctionsClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$functions$2d$js$2f$dist$2f$module$2f$helper$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/functions-js/dist/module/helper.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$functions$2d$js$2f$dist$2f$module$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/functions-js/dist/module/types.js [app-route] (ecmascript)");
;
;
;
class FunctionsClient {
    /**
     * Creates a new Functions client bound to an Edge Functions URL.
     *
     * @example
     * ```ts
     * import { FunctionsClient, FunctionRegion } from '@supabase/functions-js'
     *
     * const functions = new FunctionsClient('https://xyzcompany.supabase.co/functions/v1', {
     *   headers: { apikey: 'public-anon-key' },
     *   region: FunctionRegion.UsEast1,
     * })
     * ```
     */ constructor(url, { headers = {}, customFetch, region = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$functions$2d$js$2f$dist$2f$module$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FunctionRegion"].Any } = {}){
        this.url = url;
        this.headers = headers;
        this.region = region;
        this.fetch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$functions$2d$js$2f$dist$2f$module$2f$helper$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["resolveFetch"])(customFetch);
    }
    /**
     * Updates the authorization header
     * @param token - the new jwt token sent in the authorisation header
     * @example
     * ```ts
     * functions.setAuth(session.access_token)
     * ```
     */ setAuth(token) {
        this.headers.Authorization = `Bearer ${token}`;
    }
    /**
     * Invokes a function
     * @param functionName - The name of the Function to invoke.
     * @param options - Options for invoking the Function.
     * @example
     * ```ts
     * const { data, error } = await functions.invoke('hello-world', {
     *   body: { name: 'Ada' },
     * })
     * ```
     */ invoke(functionName_1) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__awaiter"])(this, arguments, void 0, function*(functionName, options = {}) {
            var _a;
            let timeoutId;
            let timeoutController;
            try {
                const { headers, method, body: functionArgs, signal, timeout } = options;
                let _headers = {};
                let { region } = options;
                if (!region) {
                    region = this.region;
                }
                // Add region as query parameter using URL API
                const url = new URL(`${this.url}/${functionName}`);
                if (region && region !== 'any') {
                    _headers['x-region'] = region;
                    url.searchParams.set('forceFunctionRegion', region);
                }
                let body;
                if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, 'Content-Type') || !headers)) {
                    if (typeof Blob !== 'undefined' && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {
                        // will work for File as File inherits Blob
                        // also works for ArrayBuffer as it is the same underlying structure as a Blob
                        _headers['Content-Type'] = 'application/octet-stream';
                        body = functionArgs;
                    } else if (typeof functionArgs === 'string') {
                        // plain string
                        _headers['Content-Type'] = 'text/plain';
                        body = functionArgs;
                    } else if (typeof FormData !== 'undefined' && functionArgs instanceof FormData) {
                        // don't set content-type headers
                        // Request will automatically add the right boundary value
                        body = functionArgs;
                    } else {
                        // default, assume this is JSON
                        _headers['Content-Type'] = 'application/json';
                        body = JSON.stringify(functionArgs);
                    }
                } else {
                    // if the Content-Type was supplied, simply set the body
                    body = functionArgs;
                }
                // Handle timeout by creating an AbortController
                let effectiveSignal = signal;
                if (timeout) {
                    timeoutController = new AbortController();
                    timeoutId = setTimeout(()=>timeoutController.abort(), timeout);
                    // If user provided their own signal, we need to respect both
                    if (signal) {
                        effectiveSignal = timeoutController.signal;
                        // If the user's signal is aborted, abort our timeout controller too
                        signal.addEventListener('abort', ()=>timeoutController.abort());
                    } else {
                        effectiveSignal = timeoutController.signal;
                    }
                }
                const response = yield this.fetch(url.toString(), {
                    method: method || 'POST',
                    // headers priority is (high to low):
                    // 1. invoke-level headers
                    // 2. client-level headers
                    // 3. default Content-Type header
                    headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),
                    body,
                    signal: effectiveSignal
                }).catch((fetchError)=>{
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$functions$2d$js$2f$dist$2f$module$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FunctionsFetchError"](fetchError);
                });
                const isRelayError = response.headers.get('x-relay-error');
                if (isRelayError && isRelayError === 'true') {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$functions$2d$js$2f$dist$2f$module$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FunctionsRelayError"](response);
                }
                if (!response.ok) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$functions$2d$js$2f$dist$2f$module$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FunctionsHttpError"](response);
                }
                let responseType = ((_a = response.headers.get('Content-Type')) !== null && _a !== void 0 ? _a : 'text/plain').split(';')[0].trim();
                let data;
                if (responseType === 'application/json') {
                    data = yield response.json();
                } else if (responseType === 'application/octet-stream' || responseType === 'application/pdf') {
                    data = yield response.blob();
                } else if (responseType === 'text/event-stream') {
                    data = response;
                } else if (responseType === 'multipart/form-data') {
                    data = yield response.formData();
                } else {
                    // default to text
                    data = yield response.text();
                }
                return {
                    data,
                    error: null,
                    response
                };
            } catch (error) {
                return {
                    data: null,
                    error,
                    response: error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$functions$2d$js$2f$dist$2f$module$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FunctionsHttpError"] || error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$functions$2d$js$2f$dist$2f$module$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FunctionsRelayError"] ? error.context : undefined
                };
            } finally{
                // Clear the timeout if it was set
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
            }
        });
    }
} //# sourceMappingURL=FunctionsClient.js.map
}),
"[project]/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * Error format
 *
 * {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}
 */ class PostgrestError extends Error {
    /**
     * @example
     * ```ts
     * import PostgrestError from '@supabase/postgrest-js'
     *
     * throw new PostgrestError({
     *   message: 'Row level security prevented the request',
     *   details: 'RLS denied the insert',
     *   hint: 'Check your policies',
     *   code: 'PGRST301',
     * })
     * ```
     */ constructor(context){
        super(context.message);
        this.name = 'PostgrestError';
        this.details = context.details;
        this.hint = context.hint;
        this.code = context.code;
    }
}
exports.default = PostgrestError; //# sourceMappingURL=PostgrestError.js.map
}),
"[project]/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const PostgrestError_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js [app-route] (ecmascript)"));
class PostgrestBuilder {
    /**
     * Creates a builder configured for a specific PostgREST request.
     *
     * @example
     * ```ts
     * import PostgrestQueryBuilder from '@supabase/postgrest-js'
     *
     * const builder = new PostgrestQueryBuilder(
     *   new URL('https://xyzcompany.supabase.co/rest/v1/users'),
     *   { headers: new Headers({ apikey: 'public-anon-key' }) }
     * )
     * ```
     */ constructor(builder){
        var _a, _b;
        this.shouldThrowOnError = false;
        this.method = builder.method;
        this.url = builder.url;
        this.headers = new Headers(builder.headers);
        this.schema = builder.schema;
        this.body = builder.body;
        this.shouldThrowOnError = (_a = builder.shouldThrowOnError) !== null && _a !== void 0 ? _a : false;
        this.signal = builder.signal;
        this.isMaybeSingle = (_b = builder.isMaybeSingle) !== null && _b !== void 0 ? _b : false;
        if (builder.fetch) {
            this.fetch = builder.fetch;
        } else {
            this.fetch = fetch;
        }
    }
    /**
     * If there's an error with the query, throwOnError will reject the promise by
     * throwing the error instead of returning it as part of a successful response.
     *
     * {@link https://github.com/supabase/supabase-js/issues/92}
     */ throwOnError() {
        this.shouldThrowOnError = true;
        return this;
    }
    /**
     * Set an HTTP header for the request.
     */ setHeader(name, value) {
        this.headers = new Headers(this.headers);
        this.headers.set(name, value);
        return this;
    }
    then(onfulfilled, onrejected) {
        // https://postgrest.org/en/stable/api.html#switching-schemas
        if (this.schema === undefined) {
        // skip
        } else if ([
            'GET',
            'HEAD'
        ].includes(this.method)) {
            this.headers.set('Accept-Profile', this.schema);
        } else {
            this.headers.set('Content-Profile', this.schema);
        }
        if (this.method !== 'GET' && this.method !== 'HEAD') {
            this.headers.set('Content-Type', 'application/json');
        }
        // NOTE: Invoke w/o `this` to avoid illegal invocation error.
        // https://github.com/supabase/postgrest-js/pull/247
        const _fetch = this.fetch;
        let res = _fetch(this.url.toString(), {
            method: this.method,
            headers: this.headers,
            body: JSON.stringify(this.body),
            signal: this.signal
        }).then(async (res)=>{
            var _a, _b, _c, _d;
            let error = null;
            let data = null;
            let count = null;
            let status = res.status;
            let statusText = res.statusText;
            if (res.ok) {
                if (this.method !== 'HEAD') {
                    const body = await res.text();
                    if (body === '') {
                    // Prefer: return=minimal
                    } else if (this.headers.get('Accept') === 'text/csv') {
                        data = body;
                    } else if (this.headers.get('Accept') && ((_a = this.headers.get('Accept')) === null || _a === void 0 ? void 0 : _a.includes('application/vnd.pgrst.plan+text'))) {
                        data = body;
                    } else {
                        data = JSON.parse(body);
                    }
                }
                const countHeader = (_b = this.headers.get('Prefer')) === null || _b === void 0 ? void 0 : _b.match(/count=(exact|planned|estimated)/);
                const contentRange = (_c = res.headers.get('content-range')) === null || _c === void 0 ? void 0 : _c.split('/');
                if (countHeader && contentRange && contentRange.length > 1) {
                    count = parseInt(contentRange[1]);
                }
                // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361
                // Issue persists e.g. for `.insert([...]).select().maybeSingle()`
                if (this.isMaybeSingle && this.method === 'GET' && Array.isArray(data)) {
                    if (data.length > 1) {
                        error = {
                            // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553
                            code: 'PGRST116',
                            details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                            hint: null,
                            message: 'JSON object requested, multiple (or no) rows returned'
                        };
                        data = null;
                        count = null;
                        status = 406;
                        statusText = 'Not Acceptable';
                    } else if (data.length === 1) {
                        data = data[0];
                    } else {
                        data = null;
                    }
                }
            } else {
                const body = await res.text();
                try {
                    error = JSON.parse(body);
                    // Workaround for https://github.com/supabase/postgrest-js/issues/295
                    if (Array.isArray(error) && res.status === 404) {
                        data = [];
                        error = null;
                        status = 200;
                        statusText = 'OK';
                    }
                } catch (_e) {
                    // Workaround for https://github.com/supabase/postgrest-js/issues/295
                    if (res.status === 404 && body === '') {
                        status = 204;
                        statusText = 'No Content';
                    } else {
                        error = {
                            message: body
                        };
                    }
                }
                if (error && this.isMaybeSingle && ((_d = error === null || error === void 0 ? void 0 : error.details) === null || _d === void 0 ? void 0 : _d.includes('0 rows'))) {
                    error = null;
                    status = 200;
                    statusText = 'OK';
                }
                if (error && this.shouldThrowOnError) {
                    throw new PostgrestError_1.default(error);
                }
            }
            const postgrestResponse = {
                error,
                data,
                count,
                status,
                statusText
            };
            return postgrestResponse;
        });
        if (!this.shouldThrowOnError) {
            res = res.catch((fetchError)=>{
                var _a, _b, _c, _d, _e, _f;
                // Build detailed error information including cause if available
                // Note: We don't populate code/hint for client-side network errors since those
                // fields are meant for upstream service errors (PostgREST/PostgreSQL)
                let errorDetails = '';
                // Add cause information if available (e.g., DNS errors, network failures)
                const cause = fetchError === null || fetchError === void 0 ? void 0 : fetchError.cause;
                if (cause) {
                    const causeMessage = (_a = cause === null || cause === void 0 ? void 0 : cause.message) !== null && _a !== void 0 ? _a : '';
                    const causeCode = (_b = cause === null || cause === void 0 ? void 0 : cause.code) !== null && _b !== void 0 ? _b : '';
                    errorDetails = `${(_c = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _c !== void 0 ? _c : 'FetchError'}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`;
                    errorDetails += `\n\nCaused by: ${(_d = cause === null || cause === void 0 ? void 0 : cause.name) !== null && _d !== void 0 ? _d : 'Error'}: ${causeMessage}`;
                    if (causeCode) {
                        errorDetails += ` (${causeCode})`;
                    }
                    if (cause === null || cause === void 0 ? void 0 : cause.stack) {
                        errorDetails += `\n${cause.stack}`;
                    }
                } else {
                    // No cause available, just include the error stack
                    errorDetails = (_e = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _e !== void 0 ? _e : '';
                }
                return {
                    error: {
                        message: `${(_f = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _f !== void 0 ? _f : 'FetchError'}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,
                        details: errorDetails,
                        hint: '',
                        code: ''
                    },
                    data: null,
                    count: null,
                    status: 0,
                    statusText: ''
                };
            });
        }
        return res.then(onfulfilled, onrejected);
    }
    /**
     * Override the type of the returned `data`.
     *
     * @typeParam NewResult - The new result type to override with
     * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead
     */ returns() {
        /* istanbul ignore next */ return this;
    }
    /**
     * Override the type of the returned `data` field in the response.
     *
     * @typeParam NewResult - The new type to cast the response data to
     * @typeParam Options - Optional type configuration (defaults to { merge: true })
     * @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)
     * @example
     * ```typescript
     * // Merge with existing types (default behavior)
     * const query = supabase
     *   .from('users')
     *   .select()
     *   .overrideTypes<{ custom_field: string }>()
     *
     * // Replace existing types completely
     * const replaceQuery = supabase
     *   .from('users')
     *   .select()
     *   .overrideTypes<{ id: number; name: string }, { merge: false }>()
     * ```
     * @returns A PostgrestBuilder instance with the new type
     */ overrideTypes() {
        return this;
    }
}
exports.default = PostgrestBuilder; //# sourceMappingURL=PostgrestBuilder.js.map
}),
"[project]/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const PostgrestBuilder_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js [app-route] (ecmascript)"));
class PostgrestTransformBuilder extends PostgrestBuilder_1.default {
    /**
     * Perform a SELECT on the query result.
     *
     * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not
     * return modified rows. By calling this method, modified rows are returned in
     * `data`.
     *
     * @param columns - The columns to retrieve, separated by commas
     */ select(columns) {
        // Remove whitespaces except when quoted
        let quoted = false;
        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*').split('').map((c)=>{
            if (/\s/.test(c) && !quoted) {
                return '';
            }
            if (c === '"') {
                quoted = !quoted;
            }
            return c;
        }).join('');
        this.url.searchParams.set('select', cleanedColumns);
        this.headers.append('Prefer', 'return=representation');
        return this;
    }
    /**
     * Order the query result by `column`.
     *
     * You can call this method multiple times to order by multiple columns.
     *
     * You can order referenced tables, but it only affects the ordering of the
     * parent table if you use `!inner` in the query.
     *
     * @param column - The column to order by
     * @param options - Named parameters
     * @param options.ascending - If `true`, the result will be in ascending order
     * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,
     * `null`s appear last.
     * @param options.referencedTable - Set this to order a referenced table by
     * its columns
     * @param options.foreignTable - Deprecated, use `options.referencedTable`
     * instead
     */ order(column, { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable } = {}) {
        const key = referencedTable ? `${referencedTable}.order` : 'order';
        const existingOrder = this.url.searchParams.get(key);
        this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}${nullsFirst === undefined ? '' : nullsFirst ? '.nullsfirst' : '.nullslast'}`);
        return this;
    }
    /**
     * Limit the query result by `count`.
     *
     * @param count - The maximum number of rows to return
     * @param options - Named parameters
     * @param options.referencedTable - Set this to limit rows of referenced
     * tables instead of the parent table
     * @param options.foreignTable - Deprecated, use `options.referencedTable`
     * instead
     */ limit(count, { foreignTable, referencedTable = foreignTable } = {}) {
        const key = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`;
        this.url.searchParams.set(key, `${count}`);
        return this;
    }
    /**
     * Limit the query result by starting at an offset `from` and ending at the offset `to`.
     * Only records within this range are returned.
     * This respects the query order and if there is no order clause the range could behave unexpectedly.
     * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third
     * and fourth rows of the query.
     *
     * @param from - The starting index from which to limit the result
     * @param to - The last index to which to limit the result
     * @param options - Named parameters
     * @param options.referencedTable - Set this to limit rows of referenced
     * tables instead of the parent table
     * @param options.foreignTable - Deprecated, use `options.referencedTable`
     * instead
     */ range(from, to, { foreignTable, referencedTable = foreignTable } = {}) {
        const keyOffset = typeof referencedTable === 'undefined' ? 'offset' : `${referencedTable}.offset`;
        const keyLimit = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`;
        this.url.searchParams.set(keyOffset, `${from}`);
        // Range is inclusive, so add 1
        this.url.searchParams.set(keyLimit, `${to - from + 1}`);
        return this;
    }
    /**
     * Set the AbortSignal for the fetch request.
     *
     * @param signal - The AbortSignal to use for the fetch request
     */ abortSignal(signal) {
        this.signal = signal;
        return this;
    }
    /**
     * Return `data` as a single object instead of an array of objects.
     *
     * Query result must be one row (e.g. using `.limit(1)`), otherwise this
     * returns an error.
     */ single() {
        this.headers.set('Accept', 'application/vnd.pgrst.object+json');
        return this;
    }
    /**
     * Return `data` as a single object instead of an array of objects.
     *
     * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise
     * this returns an error.
     */ maybeSingle() {
        // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361
        // Issue persists e.g. for `.insert([...]).select().maybeSingle()`
        if (this.method === 'GET') {
            this.headers.set('Accept', 'application/json');
        } else {
            this.headers.set('Accept', 'application/vnd.pgrst.object+json');
        }
        this.isMaybeSingle = true;
        return this;
    }
    /**
     * Return `data` as a string in CSV format.
     */ csv() {
        this.headers.set('Accept', 'text/csv');
        return this;
    }
    /**
     * Return `data` as an object in [GeoJSON](https://geojson.org) format.
     */ geojson() {
        this.headers.set('Accept', 'application/geo+json');
        return this;
    }
    /**
     * Return `data` as the EXPLAIN plan for the query.
     *
     * You need to enable the
     * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)
     * setting before using this method.
     *
     * @param options - Named parameters
     *
     * @param options.analyze - If `true`, the query will be executed and the
     * actual run time will be returned
     *
     * @param options.verbose - If `true`, the query identifier will be returned
     * and `data` will include the output columns of the query
     *
     * @param options.settings - If `true`, include information on configuration
     * parameters that affect query planning
     *
     * @param options.buffers - If `true`, include information on buffer usage
     *
     * @param options.wal - If `true`, include information on WAL record generation
     *
     * @param options.format - The format of the output, can be `"text"` (default)
     * or `"json"`
     */ explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = 'text' } = {}) {
        var _a;
        const options = [
            analyze ? 'analyze' : null,
            verbose ? 'verbose' : null,
            settings ? 'settings' : null,
            buffers ? 'buffers' : null,
            wal ? 'wal' : null
        ].filter(Boolean).join('|');
        // An Accept header can carry multiple media types but postgrest-js always sends one
        const forMediatype = (_a = this.headers.get('Accept')) !== null && _a !== void 0 ? _a : 'application/json';
        this.headers.set('Accept', `application/vnd.pgrst.plan+${format}; for="${forMediatype}"; options=${options};`);
        if (format === 'json') {
            return this;
        } else {
            return this;
        }
    }
    /**
     * Rollback the query.
     *
     * `data` will still be returned, but the query is not committed.
     */ rollback() {
        this.headers.append('Prefer', 'tx=rollback');
        return this;
    }
    /**
     * Override the type of the returned `data`.
     *
     * @typeParam NewResult - The new result type to override with
     * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead
     */ returns() {
        return this;
    }
    /**
     * Set the maximum number of rows that can be affected by the query.
     * Only available in PostgREST v13+ and only works with PATCH and DELETE methods.
     *
     * @param value - The maximum number of rows that can be affected
     */ maxAffected(value) {
        this.headers.append('Prefer', 'handling=strict');
        this.headers.append('Prefer', `max-affected=${value}`);
        return this;
    }
}
exports.default = PostgrestTransformBuilder; //# sourceMappingURL=PostgrestTransformBuilder.js.map
}),
"[project]/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const PostgrestTransformBuilder_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js [app-route] (ecmascript)"));
const PostgrestReservedCharsRegexp = new RegExp('[,()]');
class PostgrestFilterBuilder extends PostgrestTransformBuilder_1.default {
    /**
     * Match only rows where `column` is equal to `value`.
     *
     * To check if the value of `column` is NULL, you should use `.is()` instead.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */ eq(column, value) {
        this.url.searchParams.append(column, `eq.${value}`);
        return this;
    }
    /**
     * Match only rows where `column` is not equal to `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */ neq(column, value) {
        this.url.searchParams.append(column, `neq.${value}`);
        return this;
    }
    /**
     * Match only rows where `column` is greater than `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */ gt(column, value) {
        this.url.searchParams.append(column, `gt.${value}`);
        return this;
    }
    /**
     * Match only rows where `column` is greater than or equal to `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */ gte(column, value) {
        this.url.searchParams.append(column, `gte.${value}`);
        return this;
    }
    /**
     * Match only rows where `column` is less than `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */ lt(column, value) {
        this.url.searchParams.append(column, `lt.${value}`);
        return this;
    }
    /**
     * Match only rows where `column` is less than or equal to `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */ lte(column, value) {
        this.url.searchParams.append(column, `lte.${value}`);
        return this;
    }
    /**
     * Match only rows where `column` matches `pattern` case-sensitively.
     *
     * @param column - The column to filter on
     * @param pattern - The pattern to match with
     */ like(column, pattern) {
        this.url.searchParams.append(column, `like.${pattern}`);
        return this;
    }
    /**
     * Match only rows where `column` matches all of `patterns` case-sensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */ likeAllOf(column, patterns) {
        this.url.searchParams.append(column, `like(all).{${patterns.join(',')}}`);
        return this;
    }
    /**
     * Match only rows where `column` matches any of `patterns` case-sensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */ likeAnyOf(column, patterns) {
        this.url.searchParams.append(column, `like(any).{${patterns.join(',')}}`);
        return this;
    }
    /**
     * Match only rows where `column` matches `pattern` case-insensitively.
     *
     * @param column - The column to filter on
     * @param pattern - The pattern to match with
     */ ilike(column, pattern) {
        this.url.searchParams.append(column, `ilike.${pattern}`);
        return this;
    }
    /**
     * Match only rows where `column` matches all of `patterns` case-insensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */ ilikeAllOf(column, patterns) {
        this.url.searchParams.append(column, `ilike(all).{${patterns.join(',')}}`);
        return this;
    }
    /**
     * Match only rows where `column` matches any of `patterns` case-insensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */ ilikeAnyOf(column, patterns) {
        this.url.searchParams.append(column, `ilike(any).{${patterns.join(',')}}`);
        return this;
    }
    /**
     * Match only rows where `column` matches the PostgreSQL regex `pattern`
     * case-sensitively (using the `~` operator).
     *
     * @param column - The column to filter on
     * @param pattern - The PostgreSQL regular expression pattern to match with
     */ regexMatch(column, pattern) {
        this.url.searchParams.append(column, `match.${pattern}`);
        return this;
    }
    /**
     * Match only rows where `column` matches the PostgreSQL regex `pattern`
     * case-insensitively (using the `~*` operator).
     *
     * @param column - The column to filter on
     * @param pattern - The PostgreSQL regular expression pattern to match with
     */ regexIMatch(column, pattern) {
        this.url.searchParams.append(column, `imatch.${pattern}`);
        return this;
    }
    /**
     * Match only rows where `column` IS `value`.
     *
     * For non-boolean columns, this is only relevant for checking if the value of
     * `column` is NULL by setting `value` to `null`.
     *
     * For boolean columns, you can also set `value` to `true` or `false` and it
     * will behave the same way as `.eq()`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */ is(column, value) {
        this.url.searchParams.append(column, `is.${value}`);
        return this;
    }
    /**
     * Match only rows where `column` IS DISTINCT FROM `value`.
     *
     * Unlike `.neq()`, this treats `NULL` as a comparable value. Two `NULL` values
     * are considered equal (not distinct), and comparing `NULL` with any non-NULL
     * value returns true (distinct).
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */ isDistinct(column, value) {
        this.url.searchParams.append(column, `isdistinct.${value}`);
        return this;
    }
    /**
     * Match only rows where `column` is included in the `values` array.
     *
     * @param column - The column to filter on
     * @param values - The values array to filter with
     */ in(column, values) {
        const cleanedValues = Array.from(new Set(values)).map((s)=>{
            // handle postgrest reserved characters
            // https://postgrest.org/en/v7.0.0/api.html#reserved-characters
            if (typeof s === 'string' && PostgrestReservedCharsRegexp.test(s)) return `"${s}"`;
            else return `${s}`;
        }).join(',');
        this.url.searchParams.append(column, `in.(${cleanedValues})`);
        return this;
    }
    /**
     * Only relevant for jsonb, array, and range columns. Match only rows where
     * `column` contains every element appearing in `value`.
     *
     * @param column - The jsonb, array, or range column to filter on
     * @param value - The jsonb, array, or range value to filter with
     */ contains(column, value) {
        if (typeof value === 'string') {
            // range types can be inclusive '[', ']' or exclusive '(', ')' so just
            // keep it simple and accept a string
            this.url.searchParams.append(column, `cs.${value}`);
        } else if (Array.isArray(value)) {
            // array
            this.url.searchParams.append(column, `cs.{${value.join(',')}}`);
        } else {
            // json
            this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);
        }
        return this;
    }
    /**
     * Only relevant for jsonb, array, and range columns. Match only rows where
     * every element appearing in `column` is contained by `value`.
     *
     * @param column - The jsonb, array, or range column to filter on
     * @param value - The jsonb, array, or range value to filter with
     */ containedBy(column, value) {
        if (typeof value === 'string') {
            // range
            this.url.searchParams.append(column, `cd.${value}`);
        } else if (Array.isArray(value)) {
            // array
            this.url.searchParams.append(column, `cd.{${value.join(',')}}`);
        } else {
            // json
            this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);
        }
        return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is greater than any element in `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */ rangeGt(column, range) {
        this.url.searchParams.append(column, `sr.${range}`);
        return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is either contained in `range` or greater than any element in
     * `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */ rangeGte(column, range) {
        this.url.searchParams.append(column, `nxl.${range}`);
        return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is less than any element in `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */ rangeLt(column, range) {
        this.url.searchParams.append(column, `sl.${range}`);
        return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is either contained in `range` or less than any element in
     * `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */ rangeLte(column, range) {
        this.url.searchParams.append(column, `nxr.${range}`);
        return this;
    }
    /**
     * Only relevant for range columns. Match only rows where `column` is
     * mutually exclusive to `range` and there can be no element between the two
     * ranges.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */ rangeAdjacent(column, range) {
        this.url.searchParams.append(column, `adj.${range}`);
        return this;
    }
    /**
     * Only relevant for array and range columns. Match only rows where
     * `column` and `value` have an element in common.
     *
     * @param column - The array or range column to filter on
     * @param value - The array or range value to filter with
     */ overlaps(column, value) {
        if (typeof value === 'string') {
            // range
            this.url.searchParams.append(column, `ov.${value}`);
        } else {
            // array
            this.url.searchParams.append(column, `ov.{${value.join(',')}}`);
        }
        return this;
    }
    /**
     * Only relevant for text and tsvector columns. Match only rows where
     * `column` matches the query string in `query`.
     *
     * @param column - The text or tsvector column to filter on
     * @param query - The query text to match with
     * @param options - Named parameters
     * @param options.config - The text search configuration to use
     * @param options.type - Change how the `query` text is interpreted
     */ textSearch(column, query, { config, type } = {}) {
        let typePart = '';
        if (type === 'plain') {
            typePart = 'pl';
        } else if (type === 'phrase') {
            typePart = 'ph';
        } else if (type === 'websearch') {
            typePart = 'w';
        }
        const configPart = config === undefined ? '' : `(${config})`;
        this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);
        return this;
    }
    /**
     * Match only rows where each column in `query` keys is equal to its
     * associated value. Shorthand for multiple `.eq()`s.
     *
     * @param query - The object to filter with, with column names as keys mapped
     * to their filter values
     */ match(query) {
        Object.entries(query).forEach(([column, value])=>{
            this.url.searchParams.append(column, `eq.${value}`);
        });
        return this;
    }
    /**
     * Match only rows which doesn't satisfy the filter.
     *
     * Unlike most filters, `opearator` and `value` are used as-is and need to
     * follow [PostgREST
     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
     * to make sure they are properly sanitized.
     *
     * @param column - The column to filter on
     * @param operator - The operator to be negated to filter with, following
     * PostgREST syntax
     * @param value - The value to filter with, following PostgREST syntax
     */ not(column, operator, value) {
        this.url.searchParams.append(column, `not.${operator}.${value}`);
        return this;
    }
    /**
     * Match only rows which satisfy at least one of the filters.
     *
     * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST
     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
     * to make sure it's properly sanitized.
     *
     * It's currently not possible to do an `.or()` filter across multiple tables.
     *
     * @param filters - The filters to use, following PostgREST syntax
     * @param options - Named parameters
     * @param options.referencedTable - Set this to filter on referenced tables
     * instead of the parent table
     * @param options.foreignTable - Deprecated, use `referencedTable` instead
     */ or(filters, { foreignTable, referencedTable = foreignTable } = {}) {
        const key = referencedTable ? `${referencedTable}.or` : 'or';
        this.url.searchParams.append(key, `(${filters})`);
        return this;
    }
    /**
     * Match only rows which satisfy the filter. This is an escape hatch - you
     * should use the specific filter methods wherever possible.
     *
     * Unlike most filters, `opearator` and `value` are used as-is and need to
     * follow [PostgREST
     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
     * to make sure they are properly sanitized.
     *
     * @param column - The column to filter on
     * @param operator - The operator to filter with, following PostgREST syntax
     * @param value - The value to filter with, following PostgREST syntax
     */ filter(column, operator, value) {
        this.url.searchParams.append(column, `${operator}.${value}`);
        return this;
    }
}
exports.default = PostgrestFilterBuilder; //# sourceMappingURL=PostgrestFilterBuilder.js.map
}),
"[project]/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const PostgrestFilterBuilder_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js [app-route] (ecmascript)"));
class PostgrestQueryBuilder {
    /**
     * Creates a query builder scoped to a Postgres table or view.
     *
     * @example
     * ```ts
     * import PostgrestQueryBuilder from '@supabase/postgrest-js'
     *
     * const query = new PostgrestQueryBuilder(
     *   new URL('https://xyzcompany.supabase.co/rest/v1/users'),
     *   { headers: { apikey: 'public-anon-key' } }
     * )
     * ```
     */ constructor(url, { headers = {}, schema, fetch: fetch1 }){
        this.url = url;
        this.headers = new Headers(headers);
        this.schema = schema;
        this.fetch = fetch1;
    }
    /**
     * Perform a SELECT query on the table or view.
     *
     * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`
     *
     * @param options - Named parameters
     *
     * @param options.head - When set to `true`, `data` will not be returned.
     * Useful if you only need the count.
     *
     * @param options.count - Count algorithm to use to count rows in the table or view.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */ select(columns, options) {
        const { head = false, count } = options !== null && options !== void 0 ? options : {};
        const method = head ? 'HEAD' : 'GET';
        // Remove whitespaces except when quoted
        let quoted = false;
        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*').split('').map((c)=>{
            if (/\s/.test(c) && !quoted) {
                return '';
            }
            if (c === '"') {
                quoted = !quoted;
            }
            return c;
        }).join('');
        this.url.searchParams.set('select', cleanedColumns);
        if (count) {
            this.headers.append('Prefer', `count=${count}`);
        }
        return new PostgrestFilterBuilder_1.default({
            method,
            url: this.url,
            headers: this.headers,
            schema: this.schema,
            fetch: this.fetch
        });
    }
    /**
     * Perform an INSERT into the table or view.
     *
     * By default, inserted rows are not returned. To return it, chain the call
     * with `.select()`.
     *
     * @param values - The values to insert. Pass an object to insert a single row
     * or an array to insert multiple rows.
     *
     * @param options - Named parameters
     *
     * @param options.count - Count algorithm to use to count inserted rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     *
     * @param options.defaultToNull - Make missing fields default to `null`.
     * Otherwise, use the default value for the column. Only applies for bulk
     * inserts.
     */ insert(values, { count, defaultToNull = true } = {}) {
        var _a;
        const method = 'POST';
        if (count) {
            this.headers.append('Prefer', `count=${count}`);
        }
        if (!defaultToNull) {
            this.headers.append('Prefer', `missing=default`);
        }
        if (Array.isArray(values)) {
            const columns = values.reduce((acc, x)=>acc.concat(Object.keys(x)), []);
            if (columns.length > 0) {
                const uniqueColumns = [
                    ...new Set(columns)
                ].map((column)=>`"${column}"`);
                this.url.searchParams.set('columns', uniqueColumns.join(','));
            }
        }
        return new PostgrestFilterBuilder_1.default({
            method,
            url: this.url,
            headers: this.headers,
            schema: this.schema,
            body: values,
            fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch
        });
    }
    /**
     * Perform an UPSERT on the table or view. Depending on the column(s) passed
     * to `onConflict`, `.upsert()` allows you to perform the equivalent of
     * `.insert()` if a row with the corresponding `onConflict` columns doesn't
     * exist, or if it does exist, perform an alternative action depending on
     * `ignoreDuplicates`.
     *
     * By default, upserted rows are not returned. To return it, chain the call
     * with `.select()`.
     *
     * @param values - The values to upsert with. Pass an object to upsert a
     * single row or an array to upsert multiple rows.
     *
     * @param options - Named parameters
     *
     * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how
     * duplicate rows are determined. Two rows are duplicates if all the
     * `onConflict` columns are equal.
     *
     * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If
     * `false`, duplicate rows are merged with existing rows.
     *
     * @param options.count - Count algorithm to use to count upserted rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     *
     * @param options.defaultToNull - Make missing fields default to `null`.
     * Otherwise, use the default value for the column. This only applies when
     * inserting new rows, not when merging with existing rows under
     * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.
     */ upsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true } = {}) {
        var _a;
        const method = 'POST';
        this.headers.append('Prefer', `resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`);
        if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict);
        if (count) {
            this.headers.append('Prefer', `count=${count}`);
        }
        if (!defaultToNull) {
            this.headers.append('Prefer', 'missing=default');
        }
        if (Array.isArray(values)) {
            const columns = values.reduce((acc, x)=>acc.concat(Object.keys(x)), []);
            if (columns.length > 0) {
                const uniqueColumns = [
                    ...new Set(columns)
                ].map((column)=>`"${column}"`);
                this.url.searchParams.set('columns', uniqueColumns.join(','));
            }
        }
        return new PostgrestFilterBuilder_1.default({
            method,
            url: this.url,
            headers: this.headers,
            schema: this.schema,
            body: values,
            fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch
        });
    }
    /**
     * Perform an UPDATE on the table or view.
     *
     * By default, updated rows are not returned. To return it, chain the call
     * with `.select()` after filters.
     *
     * @param values - The values to update with
     *
     * @param options - Named parameters
     *
     * @param options.count - Count algorithm to use to count updated rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */ update(values, { count } = {}) {
        var _a;
        const method = 'PATCH';
        if (count) {
            this.headers.append('Prefer', `count=${count}`);
        }
        return new PostgrestFilterBuilder_1.default({
            method,
            url: this.url,
            headers: this.headers,
            schema: this.schema,
            body: values,
            fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch
        });
    }
    /**
     * Perform a DELETE on the table or view.
     *
     * By default, deleted rows are not returned. To return it, chain the call
     * with `.select()` after filters.
     *
     * @param options - Named parameters
     *
     * @param options.count - Count algorithm to use to count deleted rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */ delete({ count } = {}) {
        var _a;
        const method = 'DELETE';
        if (count) {
            this.headers.append('Prefer', `count=${count}`);
        }
        return new PostgrestFilterBuilder_1.default({
            method,
            url: this.url,
            headers: this.headers,
            schema: this.schema,
            fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch
        });
    }
}
exports.default = PostgrestQueryBuilder; //# sourceMappingURL=PostgrestQueryBuilder.js.map
}),
"[project]/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const PostgrestQueryBuilder_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js [app-route] (ecmascript)"));
const PostgrestFilterBuilder_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js [app-route] (ecmascript)"));
/**
 * PostgREST client.
 *
 * @typeParam Database - Types for the schema from the [type
 * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)
 *
 * @typeParam SchemaName - Postgres schema to switch to. Must be a string
 * literal, the same one passed to the constructor. If the schema is not
 * `"public"`, this must be supplied manually.
 */ class PostgrestClient {
    // TODO: Add back shouldThrowOnError once we figure out the typings
    /**
     * Creates a PostgREST client.
     *
     * @param url - URL of the PostgREST endpoint
     * @param options - Named parameters
     * @param options.headers - Custom headers
     * @param options.schema - Postgres schema to switch to
     * @param options.fetch - Custom fetch
     * @example
     * ```ts
     * import PostgrestClient from '@supabase/postgrest-js'
     *
     * const postgrest = new PostgrestClient('https://xyzcompany.supabase.co/rest/v1', {
     *   headers: { apikey: 'public-anon-key' },
     *   schema: 'public',
     * })
     * ```
     */ constructor(url, { headers = {}, schema, fetch: fetch1 } = {}){
        this.url = url;
        this.headers = new Headers(headers);
        this.schemaName = schema;
        this.fetch = fetch1;
    }
    /**
     * Perform a query on a table or a view.
     *
     * @param relation - The table or view name to query
     */ from(relation) {
        if (!relation || typeof relation !== 'string' || relation.trim() === '') {
            throw new Error('Invalid relation name: relation must be a non-empty string.');
        }
        const url = new URL(`${this.url}/${relation}`);
        return new PostgrestQueryBuilder_1.default(url, {
            headers: new Headers(this.headers),
            schema: this.schemaName,
            fetch: this.fetch
        });
    }
    /**
     * Select a schema to query or perform an function (rpc) call.
     *
     * The schema needs to be on the list of exposed schemas inside Supabase.
     *
     * @param schema - The schema to query
     */ schema(schema) {
        return new PostgrestClient(this.url, {
            headers: this.headers,
            schema,
            fetch: this.fetch
        });
    }
    /**
     * Perform a function call.
     *
     * @param fn - The function name to call
     * @param args - The arguments to pass to the function call
     * @param options - Named parameters
     * @param options.head - When set to `true`, `data` will not be returned.
     * Useful if you only need the count.
     * @param options.get - When set to `true`, the function will be called with
     * read-only access mode.
     * @param options.count - Count algorithm to use to count rows returned by the
     * function. Only applicable for [set-returning
     * functions](https://www.postgresql.org/docs/current/functions-srf.html).
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */ rpc(fn, args = {}, { head = false, get = false, count } = {}) {
        var _a;
        let method;
        const url = new URL(`${this.url}/rpc/${fn}`);
        let body;
        if (head || get) {
            method = head ? 'HEAD' : 'GET';
            Object.entries(args)// params with undefined value needs to be filtered out, otherwise it'll
            // show up as `?param=undefined`
            .filter(([_, value])=>value !== undefined)// array values need special syntax
            .map(([name, value])=>[
                    name,
                    Array.isArray(value) ? `{${value.join(',')}}` : `${value}`
                ]).forEach(([name, value])=>{
                url.searchParams.append(name, value);
            });
        } else {
            method = 'POST';
            body = args;
        }
        const headers = new Headers(this.headers);
        if (count) {
            headers.set('Prefer', `count=${count}`);
        }
        return new PostgrestFilterBuilder_1.default({
            method,
            url,
            headers,
            schema: this.schemaName,
            body,
            fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch
        });
    }
}
exports.default = PostgrestClient; //# sourceMappingURL=PostgrestClient.js.map
}),
"[project]/node_modules/@supabase/postgrest-js/dist/cjs/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PostgrestError = exports.PostgrestBuilder = exports.PostgrestTransformBuilder = exports.PostgrestFilterBuilder = exports.PostgrestQueryBuilder = exports.PostgrestClient = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
// Always update wrapper.mjs when updating this file.
const PostgrestClient_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js [app-route] (ecmascript)"));
exports.PostgrestClient = PostgrestClient_1.default;
const PostgrestQueryBuilder_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js [app-route] (ecmascript)"));
exports.PostgrestQueryBuilder = PostgrestQueryBuilder_1.default;
const PostgrestFilterBuilder_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js [app-route] (ecmascript)"));
exports.PostgrestFilterBuilder = PostgrestFilterBuilder_1.default;
const PostgrestTransformBuilder_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js [app-route] (ecmascript)"));
exports.PostgrestTransformBuilder = PostgrestTransformBuilder_1.default;
const PostgrestBuilder_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js [app-route] (ecmascript)"));
exports.PostgrestBuilder = PostgrestBuilder_1.default;
const PostgrestError_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js [app-route] (ecmascript)"));
exports.PostgrestError = PostgrestError_1.default;
exports.default = {
    PostgrestClient: PostgrestClient_1.default,
    PostgrestQueryBuilder: PostgrestQueryBuilder_1.default,
    PostgrestFilterBuilder: PostgrestFilterBuilder_1.default,
    PostgrestTransformBuilder: PostgrestTransformBuilder_1.default,
    PostgrestBuilder: PostgrestBuilder_1.default,
    PostgrestError: PostgrestError_1.default
}; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PostgrestBuilder",
    ()=>PostgrestBuilder,
    "PostgrestClient",
    ()=>PostgrestClient,
    "PostgrestError",
    ()=>PostgrestError,
    "PostgrestFilterBuilder",
    ()=>PostgrestFilterBuilder,
    "PostgrestQueryBuilder",
    ()=>PostgrestQueryBuilder,
    "PostgrestTransformBuilder",
    ()=>PostgrestTransformBuilder,
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$postgrest$2d$js$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/postgrest-js/dist/cjs/index.js [app-route] (ecmascript)");
;
const { PostgrestClient, PostgrestQueryBuilder, PostgrestFilterBuilder, PostgrestTransformBuilder, PostgrestBuilder, PostgrestError } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$postgrest$2d$js$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__.default || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$postgrest$2d$js$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__;
;
const __TURBOPACK__default__export__ = {
    PostgrestClient,
    PostgrestQueryBuilder,
    PostgrestFilterBuilder,
    PostgrestTransformBuilder,
    PostgrestBuilder,
    PostgrestError
};
}),
"[project]/node_modules/@supabase/supabase-js/dist/module/lib/version.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Generated automatically during releases by scripts/update-version-files.ts
// This file provides runtime access to the package version for:
// - HTTP request headers (e.g., X-Client-Info header for API requests)
// - Debugging and support (identifying which version is running)
// - Telemetry and logging (version reporting in errors/analytics)
// - Ensuring build artifacts match the published package version
__turbopack_context__.s([
    "version",
    ()=>version
]);
const version = '2.84.0'; //# sourceMappingURL=version.js.map
}),
"[project]/node_modules/@supabase/supabase-js/dist/module/lib/constants.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DEFAULT_AUTH_OPTIONS",
    ()=>DEFAULT_AUTH_OPTIONS,
    "DEFAULT_DB_OPTIONS",
    ()=>DEFAULT_DB_OPTIONS,
    "DEFAULT_GLOBAL_OPTIONS",
    ()=>DEFAULT_GLOBAL_OPTIONS,
    "DEFAULT_HEADERS",
    ()=>DEFAULT_HEADERS,
    "DEFAULT_REALTIME_OPTIONS",
    ()=>DEFAULT_REALTIME_OPTIONS
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$lib$2f$version$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/supabase-js/dist/module/lib/version.js [app-route] (ecmascript)");
;
let JS_ENV = '';
// @ts-ignore
if (typeof Deno !== 'undefined') {
    JS_ENV = 'deno';
} else if (typeof document !== 'undefined') {
    JS_ENV = 'web';
} else if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    JS_ENV = 'react-native';
} else {
    JS_ENV = 'node';
}
const DEFAULT_HEADERS = {
    'X-Client-Info': `supabase-js-${JS_ENV}/${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$lib$2f$version$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["version"]}`
};
const DEFAULT_GLOBAL_OPTIONS = {
    headers: DEFAULT_HEADERS
};
const DEFAULT_DB_OPTIONS = {
    schema: 'public'
};
const DEFAULT_AUTH_OPTIONS = {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
    flowType: 'implicit'
};
const DEFAULT_REALTIME_OPTIONS = {}; //# sourceMappingURL=constants.js.map
}),
"[project]/node_modules/@supabase/supabase-js/dist/module/lib/fetch.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fetchWithAuth",
    ()=>fetchWithAuth,
    "resolveFetch",
    ()=>resolveFetch,
    "resolveHeadersConstructor",
    ()=>resolveHeadersConstructor
]);
const resolveFetch = (customFetch)=>{
    if (customFetch) {
        return (...args)=>customFetch(...args);
    }
    return (...args)=>fetch(...args);
};
const resolveHeadersConstructor = ()=>{
    return Headers;
};
const fetchWithAuth = (supabaseKey, getAccessToken, customFetch)=>{
    const fetch1 = resolveFetch(customFetch);
    const HeadersConstructor = resolveHeadersConstructor();
    return async (input, init)=>{
        var _a;
        const accessToken = (_a = await getAccessToken()) !== null && _a !== void 0 ? _a : supabaseKey;
        let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);
        if (!headers.has('apikey')) {
            headers.set('apikey', supabaseKey);
        }
        if (!headers.has('Authorization')) {
            headers.set('Authorization', `Bearer ${accessToken}`);
        }
        return fetch1(input, Object.assign(Object.assign({}, init), {
            headers
        }));
    };
}; //# sourceMappingURL=fetch.js.map
}),
"[project]/node_modules/@supabase/supabase-js/dist/module/lib/helpers.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "applySettingDefaults",
    ()=>applySettingDefaults,
    "ensureTrailingSlash",
    ()=>ensureTrailingSlash,
    "isBrowser",
    ()=>isBrowser,
    "uuid",
    ()=>uuid,
    "validateSupabaseUrl",
    ()=>validateSupabaseUrl
]);
function uuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0, v = c == 'x' ? r : r & 0x3 | 0x8;
        return v.toString(16);
    });
}
function ensureTrailingSlash(url) {
    return url.endsWith('/') ? url : url + '/';
}
const isBrowser = ()=>("TURBOPACK compile-time value", "undefined") !== 'undefined';
function applySettingDefaults(options, defaults) {
    var _a, _b;
    const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;
    const { db: DEFAULT_DB_OPTIONS, auth: DEFAULT_AUTH_OPTIONS, realtime: DEFAULT_REALTIME_OPTIONS, global: DEFAULT_GLOBAL_OPTIONS } = defaults;
    const result = {
        db: Object.assign(Object.assign({}, DEFAULT_DB_OPTIONS), dbOptions),
        auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), authOptions),
        realtime: Object.assign(Object.assign({}, DEFAULT_REALTIME_OPTIONS), realtimeOptions),
        storage: {},
        global: Object.assign(Object.assign(Object.assign({}, DEFAULT_GLOBAL_OPTIONS), globalOptions), {
            headers: Object.assign(Object.assign({}, (_a = DEFAULT_GLOBAL_OPTIONS === null || DEFAULT_GLOBAL_OPTIONS === void 0 ? void 0 : DEFAULT_GLOBAL_OPTIONS.headers) !== null && _a !== void 0 ? _a : {}), (_b = globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.headers) !== null && _b !== void 0 ? _b : {})
        }),
        accessToken: async ()=>''
    };
    if (options.accessToken) {
        result.accessToken = options.accessToken;
    } else {
        // hack around Required<>
        delete result.accessToken;
    }
    return result;
}
function validateSupabaseUrl(supabaseUrl) {
    const trimmedUrl = supabaseUrl === null || supabaseUrl === void 0 ? void 0 : supabaseUrl.trim();
    if (!trimmedUrl) {
        throw new Error('supabaseUrl is required.');
    }
    if (!trimmedUrl.match(/^https?:\/\//i)) {
        throw new Error('Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.');
    }
    try {
        return new URL(ensureTrailingSlash(trimmedUrl));
    } catch (_a) {
        throw Error('Invalid supabaseUrl: Provided URL is malformed.');
    }
} //# sourceMappingURL=helpers.js.map
}),
"[project]/node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SupabaseAuthClient",
    ()=>SupabaseAuthClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/auth-js/dist/module/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$AuthClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__AuthClient$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/auth-js/dist/module/AuthClient.js [app-route] (ecmascript) <export default as AuthClient>");
;
class SupabaseAuthClient extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$AuthClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__AuthClient$3e$__["AuthClient"] {
    constructor(options){
        super(options);
    }
} //# sourceMappingURL=SupabaseAuthClient.js.map
}),
"[project]/node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>SupabaseClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$functions$2d$js$2f$dist$2f$module$2f$FunctionsClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/functions-js/dist/module/FunctionsClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$postgrest$2d$js$2f$dist$2f$esm$2f$wrapper$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$RealtimeClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__RealtimeClient$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js [app-route] (ecmascript) <export default as RealtimeClient>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$storage$2d$js$2f$dist$2f$module$2f$StorageClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/storage-js/dist/module/StorageClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/supabase-js/dist/module/lib/constants.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$lib$2f$fetch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/supabase-js/dist/module/lib/fetch.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$lib$2f$helpers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/supabase-js/dist/module/lib/helpers.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$lib$2f$SupabaseAuthClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
class SupabaseClient {
    /**
     * Create a new client for use in the browser.
     * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.
     * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.
     * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.
     * @param options.auth.autoRefreshToken Set to "true" if you want to automatically refresh the token before expiring.
     * @param options.auth.persistSession Set to "true" if you want to automatically save the user session into local storage.
     * @param options.auth.detectSessionInUrl Set to "true" if you want to automatically detects OAuth grants in the URL and signs in the user.
     * @param options.realtime Options passed along to realtime-js constructor.
     * @param options.storage Options passed along to the storage-js constructor.
     * @param options.global.fetch A custom fetch implementation.
     * @param options.global.headers Any additional headers to send with each network request.
     * @example
     * ```ts
     * import { createClient } from '@supabase/supabase-js'
     *
     * const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')
     * const { data } = await supabase.from('profiles').select('*')
     * ```
     */ constructor(supabaseUrl, supabaseKey, options){
        var _a, _b, _c;
        this.supabaseUrl = supabaseUrl;
        this.supabaseKey = supabaseKey;
        const baseUrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$lib$2f$helpers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validateSupabaseUrl"])(supabaseUrl);
        if (!supabaseKey) throw new Error('supabaseKey is required.');
        this.realtimeUrl = new URL('realtime/v1', baseUrl);
        this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace('http', 'ws');
        this.authUrl = new URL('auth/v1', baseUrl);
        this.storageUrl = new URL('storage/v1', baseUrl);
        this.functionsUrl = new URL('functions/v1', baseUrl);
        // default storage key uses the supabase project ref as a namespace
        const defaultStorageKey = `sb-${baseUrl.hostname.split('.')[0]}-auth-token`;
        const DEFAULTS = {
            db: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DEFAULT_DB_OPTIONS"],
            realtime: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DEFAULT_REALTIME_OPTIONS"],
            auth: Object.assign(Object.assign({}, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DEFAULT_AUTH_OPTIONS"]), {
                storageKey: defaultStorageKey
            }),
            global: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DEFAULT_GLOBAL_OPTIONS"]
        };
        const settings = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$lib$2f$helpers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["applySettingDefaults"])(options !== null && options !== void 0 ? options : {}, DEFAULTS);
        this.storageKey = (_a = settings.auth.storageKey) !== null && _a !== void 0 ? _a : '';
        this.headers = (_b = settings.global.headers) !== null && _b !== void 0 ? _b : {};
        if (!settings.accessToken) {
            this.auth = this._initSupabaseAuthClient((_c = settings.auth) !== null && _c !== void 0 ? _c : {}, this.headers, settings.global.fetch);
        } else {
            this.accessToken = settings.accessToken;
            this.auth = new Proxy({}, {
                get: (_, prop)=>{
                    throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);
                }
            });
        }
        this.fetch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$lib$2f$fetch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fetchWithAuth"])(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);
        this.realtime = this._initRealtimeClient(Object.assign({
            headers: this.headers,
            accessToken: this._getAccessToken.bind(this)
        }, settings.realtime));
        if (this.accessToken) {
            // Start auth immediately to avoid race condition with channel subscriptions
            this.accessToken().then((token)=>this.realtime.setAuth(token)).catch((e)=>console.warn('Failed to set initial Realtime auth token:', e));
        }
        this.rest = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$postgrest$2d$js$2f$dist$2f$esm$2f$wrapper$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PostgrestClient"](new URL('rest/v1', baseUrl).href, {
            headers: this.headers,
            schema: settings.db.schema,
            fetch: this.fetch
        });
        this.storage = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$storage$2d$js$2f$dist$2f$module$2f$StorageClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StorageClient"](this.storageUrl.href, this.headers, this.fetch, options === null || options === void 0 ? void 0 : options.storage);
        if (!settings.accessToken) {
            this._listenForAuthEvents();
        }
    }
    /**
     * Supabase Functions allows you to deploy and invoke edge functions.
     */ get functions() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$functions$2d$js$2f$dist$2f$module$2f$FunctionsClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FunctionsClient"](this.functionsUrl.href, {
            headers: this.headers,
            customFetch: this.fetch
        });
    }
    /**
     * Perform a query on a table or a view.
     *
     * @param relation - The table or view name to query
     */ from(relation) {
        return this.rest.from(relation);
    }
    // NOTE: signatures must be kept in sync with PostgrestClient.schema
    /**
     * Select a schema to query or perform an function (rpc) call.
     *
     * The schema needs to be on the list of exposed schemas inside Supabase.
     *
     * @param schema - The schema to query
     */ schema(schema) {
        return this.rest.schema(schema);
    }
    // NOTE: signatures must be kept in sync with PostgrestClient.rpc
    /**
     * Perform a function call.
     *
     * @param fn - The function name to call
     * @param args - The arguments to pass to the function call
     * @param options - Named parameters
     * @param options.head - When set to `true`, `data` will not be returned.
     * Useful if you only need the count.
     * @param options.get - When set to `true`, the function will be called with
     * read-only access mode.
     * @param options.count - Count algorithm to use to count rows returned by the
     * function. Only applicable for [set-returning
     * functions](https://www.postgresql.org/docs/current/functions-srf.html).
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */ rpc(fn, args = {}, options = {
        head: false,
        get: false,
        count: undefined
    }) {
        return this.rest.rpc(fn, args, options);
    }
    /**
     * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.
     *
     * @param {string} name - The name of the Realtime channel.
     * @param {Object} opts - The options to pass to the Realtime channel.
     *
     */ channel(name, opts = {
        config: {}
    }) {
        return this.realtime.channel(name, opts);
    }
    /**
     * Returns all Realtime channels.
     */ getChannels() {
        return this.realtime.getChannels();
    }
    /**
     * Unsubscribes and removes Realtime channel from Realtime client.
     *
     * @param {RealtimeChannel} channel - The name of the Realtime channel.
     *
     */ removeChannel(channel) {
        return this.realtime.removeChannel(channel);
    }
    /**
     * Unsubscribes and removes all Realtime channels from Realtime client.
     */ removeAllChannels() {
        return this.realtime.removeAllChannels();
    }
    async _getAccessToken() {
        var _a, _b;
        if (this.accessToken) {
            return await this.accessToken();
        }
        const { data } = await this.auth.getSession();
        return (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : this.supabaseKey;
    }
    _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, userStorage, storageKey, flowType, lock, debug, throwOnError }, headers, fetch) {
        const authHeaders = {
            Authorization: `Bearer ${this.supabaseKey}`,
            apikey: `${this.supabaseKey}`
        };
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$lib$2f$SupabaseAuthClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SupabaseAuthClient"]({
            url: this.authUrl.href,
            headers: Object.assign(Object.assign({}, authHeaders), headers),
            storageKey: storageKey,
            autoRefreshToken,
            persistSession,
            detectSessionInUrl,
            storage,
            userStorage,
            flowType,
            lock,
            debug,
            throwOnError,
            fetch,
            // auth checks if there is a custom authorizaiton header using this flag
            // so it knows whether to return an error when getUser is called with no session
            hasCustomAuthorizationHeader: Object.keys(this.headers).some((key)=>key.toLowerCase() === 'authorization')
        });
    }
    _initRealtimeClient(options) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$RealtimeClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__RealtimeClient$3e$__["RealtimeClient"](this.realtimeUrl.href, Object.assign(Object.assign({}, options), {
            params: Object.assign({
                apikey: this.supabaseKey
            }, options === null || options === void 0 ? void 0 : options.params)
        }));
    }
    _listenForAuthEvents() {
        const data = this.auth.onAuthStateChange((event, session)=>{
            this._handleTokenChanged(event, 'CLIENT', session === null || session === void 0 ? void 0 : session.access_token);
        });
        return data;
    }
    _handleTokenChanged(event, source, token) {
        if ((event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') && this.changedAccessToken !== token) {
            this.changedAccessToken = token;
            this.realtime.setAuth(token);
        } else if (event === 'SIGNED_OUT') {
            this.realtime.setAuth();
            if (source == 'STORAGE') this.auth.signOut();
            this.changedAccessToken = undefined;
        }
    }
} //# sourceMappingURL=SupabaseClient.js.map
}),
"[project]/node_modules/@supabase/supabase-js/dist/module/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createClient",
    ()=>createClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$SupabaseClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/auth-js/dist/module/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$postgrest$2d$js$2f$dist$2f$esm$2f$wrapper$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/index.js [app-route] (ecmascript) <locals>");
;
;
;
;
;
;
const createClient = (supabaseUrl, supabaseKey, options)=>{
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$SupabaseClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](supabaseUrl, supabaseKey, options);
};
// Check for Node.js <= 18 deprecation
function shouldShowDeprecationWarning() {
    // Skip in browser environments
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    // Skip if process is not available (e.g., Edge Runtime)
    if (typeof process === 'undefined') {
        return false;
    }
    // Use dynamic property access to avoid Next.js Edge Runtime static analysis warnings
    const processVersion = process['version'];
    if (processVersion === undefined || processVersion === null) {
        return false;
    }
    const versionMatch = processVersion.match(/^v(\d+)\./);
    if (!versionMatch) {
        return false;
    }
    const majorVersion = parseInt(versionMatch[1], 10);
    return majorVersion <= 18;
}
if (shouldShowDeprecationWarning()) {
    console.warn(`  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. ` + `Please upgrade to Node.js 20 or later. ` + `For more information, visit: https://github.com/orgs/supabase/discussions/37217`);
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@supabase/supabase-js/dist/module/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AuthAdminApi",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AuthAdminApi"],
    "AuthApiError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AuthApiError"],
    "AuthClient",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AuthClient"],
    "AuthError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AuthError"],
    "AuthImplicitGrantRedirectError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AuthImplicitGrantRedirectError"],
    "AuthInvalidCredentialsError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AuthInvalidCredentialsError"],
    "AuthInvalidJwtError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AuthInvalidJwtError"],
    "AuthInvalidTokenResponseError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AuthInvalidTokenResponseError"],
    "AuthPKCEGrantCodeExchangeError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AuthPKCEGrantCodeExchangeError"],
    "AuthRetryableFetchError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AuthRetryableFetchError"],
    "AuthSessionMissingError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AuthSessionMissingError"],
    "AuthUnknownError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AuthUnknownError"],
    "AuthWeakPasswordError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AuthWeakPasswordError"],
    "CustomAuthError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CustomAuthError"],
    "FunctionRegion",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$functions$2d$js$2f$dist$2f$module$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FunctionRegion"],
    "FunctionsError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$functions$2d$js$2f$dist$2f$module$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FunctionsError"],
    "FunctionsFetchError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$functions$2d$js$2f$dist$2f$module$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FunctionsFetchError"],
    "FunctionsHttpError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$functions$2d$js$2f$dist$2f$module$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FunctionsHttpError"],
    "FunctionsRelayError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$functions$2d$js$2f$dist$2f$module$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FunctionsRelayError"],
    "GoTrueAdminApi",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GoTrueAdminApi"],
    "GoTrueClient",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GoTrueClient"],
    "NavigatorLockAcquireTimeoutError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NavigatorLockAcquireTimeoutError"],
    "PostgrestError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$postgrest$2d$js$2f$dist$2f$esm$2f$wrapper$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PostgrestError"],
    "REALTIME_CHANNEL_STATES",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["REALTIME_CHANNEL_STATES"],
    "REALTIME_LISTEN_TYPES",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["REALTIME_LISTEN_TYPES"],
    "REALTIME_POSTGRES_CHANGES_LISTEN_EVENT",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["REALTIME_POSTGRES_CHANGES_LISTEN_EVENT"],
    "REALTIME_PRESENCE_LISTEN_EVENTS",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["REALTIME_PRESENCE_LISTEN_EVENTS"],
    "REALTIME_SUBSCRIBE_STATES",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["REALTIME_SUBSCRIBE_STATES"],
    "RealtimeChannel",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RealtimeChannel"],
    "RealtimeClient",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RealtimeClient"],
    "RealtimePresence",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RealtimePresence"],
    "SIGN_OUT_SCOPES",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SIGN_OUT_SCOPES"],
    "SupabaseClient",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$SupabaseClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"],
    "WebSocketFactory",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WebSocketFactory"],
    "createClient",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createClient"],
    "isAuthApiError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isAuthApiError"],
    "isAuthError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isAuthError"],
    "isAuthImplicitGrantRedirectError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isAuthImplicitGrantRedirectError"],
    "isAuthRetryableFetchError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isAuthRetryableFetchError"],
    "isAuthSessionMissingError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isAuthSessionMissingError"],
    "isAuthWeakPasswordError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isAuthWeakPasswordError"],
    "lockInternals",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["lockInternals"],
    "navigatorLock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["navigatorLock"],
    "processLock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["processLock"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/supabase-js/dist/module/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/auth-js/dist/module/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$postgrest$2d$js$2f$dist$2f$esm$2f$wrapper$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$functions$2d$js$2f$dist$2f$module$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/functions-js/dist/module/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$SupabaseClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js [app-route] (ecmascript)");
}),
"[project]/node_modules/webidl-conversions/lib/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var conversions = {};
module.exports = conversions;
function sign(x) {
    return x < 0 ? -1 : 1;
}
function evenRound(x) {
    // Round x to the nearest integer, choosing the even integer if it lies halfway between two.
    if (x % 1 === 0.5 && (x & 1) === 0) {
        return Math.floor(x);
    } else {
        return Math.round(x);
    }
}
function createNumberConversion(bitLength, typeOpts) {
    if (!typeOpts.unsigned) {
        --bitLength;
    }
    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
    const upperBound = Math.pow(2, bitLength) - 1;
    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
    return function(V, opts) {
        if (!opts) opts = {};
        let x = +V;
        if (opts.enforceRange) {
            if (!Number.isFinite(x)) {
                throw new TypeError("Argument is not a finite number");
            }
            x = sign(x) * Math.floor(Math.abs(x));
            if (x < lowerBound || x > upperBound) {
                throw new TypeError("Argument is not in byte range");
            }
            return x;
        }
        if (!isNaN(x) && opts.clamp) {
            x = evenRound(x);
            if (x < lowerBound) x = lowerBound;
            if (x > upperBound) x = upperBound;
            return x;
        }
        if (!Number.isFinite(x) || x === 0) {
            return 0;
        }
        x = sign(x) * Math.floor(Math.abs(x));
        x = x % moduloVal;
        if (!typeOpts.unsigned && x >= moduloBound) {
            return x - moduloVal;
        } else if (typeOpts.unsigned) {
            if (x < 0) {
                x += moduloVal;
            } else if (x === -0) {
                return 0;
            }
        }
        return x;
    };
}
conversions["void"] = function() {
    return undefined;
};
conversions["boolean"] = function(val) {
    return !!val;
};
conversions["byte"] = createNumberConversion(8, {
    unsigned: false
});
conversions["octet"] = createNumberConversion(8, {
    unsigned: true
});
conversions["short"] = createNumberConversion(16, {
    unsigned: false
});
conversions["unsigned short"] = createNumberConversion(16, {
    unsigned: true
});
conversions["long"] = createNumberConversion(32, {
    unsigned: false
});
conversions["unsigned long"] = createNumberConversion(32, {
    unsigned: true
});
conversions["long long"] = createNumberConversion(32, {
    unsigned: false,
    moduloBitLength: 64
});
conversions["unsigned long long"] = createNumberConversion(32, {
    unsigned: true,
    moduloBitLength: 64
});
conversions["double"] = function(V) {
    const x = +V;
    if (!Number.isFinite(x)) {
        throw new TypeError("Argument is not a finite floating-point value");
    }
    return x;
};
conversions["unrestricted double"] = function(V) {
    const x = +V;
    if (isNaN(x)) {
        throw new TypeError("Argument is NaN");
    }
    return x;
};
// not quite valid, but good enough for JS
conversions["float"] = conversions["double"];
conversions["unrestricted float"] = conversions["unrestricted double"];
conversions["DOMString"] = function(V, opts) {
    if (!opts) opts = {};
    if (opts.treatNullAsEmptyString && V === null) {
        return "";
    }
    return String(V);
};
conversions["ByteString"] = function(V, opts) {
    const x = String(V);
    let c = undefined;
    for(let i = 0; (c = x.codePointAt(i)) !== undefined; ++i){
        if (c > 255) {
            throw new TypeError("Argument is not a valid bytestring");
        }
    }
    return x;
};
conversions["USVString"] = function(V) {
    const S = String(V);
    const n = S.length;
    const U = [];
    for(let i = 0; i < n; ++i){
        const c = S.charCodeAt(i);
        if (c < 0xD800 || c > 0xDFFF) {
            U.push(String.fromCodePoint(c));
        } else if (0xDC00 <= c && c <= 0xDFFF) {
            U.push(String.fromCodePoint(0xFFFD));
        } else {
            if (i === n - 1) {
                U.push(String.fromCodePoint(0xFFFD));
            } else {
                const d = S.charCodeAt(i + 1);
                if (0xDC00 <= d && d <= 0xDFFF) {
                    const a = c & 0x3FF;
                    const b = d & 0x3FF;
                    U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
                    ++i;
                } else {
                    U.push(String.fromCodePoint(0xFFFD));
                }
            }
        }
    }
    return U.join('');
};
conversions["Date"] = function(V, opts) {
    if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
    }
    if (isNaN(V)) {
        return undefined;
    }
    return V;
};
conversions["RegExp"] = function(V, opts) {
    if (!(V instanceof RegExp)) {
        V = new RegExp(V);
    }
    return V;
};
}),
"[project]/node_modules/whatwg-url/lib/utils.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports.mixin = function mixin(target, source) {
    const keys = Object.getOwnPropertyNames(source);
    for(let i = 0; i < keys.length; ++i){
        Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
    }
};
module.exports.wrapperSymbol = Symbol("wrapper");
module.exports.implSymbol = Symbol("impl");
module.exports.wrapperForImpl = function(impl) {
    return impl[module.exports.wrapperSymbol];
};
module.exports.implForWrapper = function(wrapper) {
    return wrapper[module.exports.implSymbol];
};
}),
"[project]/node_modules/whatwg-url/lib/url-state-machine.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const punycode = __turbopack_context__.r("[externals]/punycode [external] (punycode, cjs)");
const tr46 = __turbopack_context__.r("[project]/node_modules/tr46/index.js [app-route] (ecmascript)");
const specialSchemes = {
    ftp: 21,
    file: null,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
};
const failure = Symbol("failure");
function countSymbols(str) {
    return punycode.ucs2.decode(str).length;
}
function at(input, idx) {
    const c = input[idx];
    return isNaN(c) ? undefined : String.fromCodePoint(c);
}
function isASCIIDigit(c) {
    return c >= 0x30 && c <= 0x39;
}
function isASCIIAlpha(c) {
    return c >= 0x41 && c <= 0x5A || c >= 0x61 && c <= 0x7A;
}
function isASCIIAlphanumeric(c) {
    return isASCIIAlpha(c) || isASCIIDigit(c);
}
function isASCIIHex(c) {
    return isASCIIDigit(c) || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66;
}
function isSingleDot(buffer) {
    return buffer === "." || buffer.toLowerCase() === "%2e";
}
function isDoubleDot(buffer) {
    buffer = buffer.toLowerCase();
    return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
}
function isWindowsDriveLetterCodePoints(cp1, cp2) {
    return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
}
function isWindowsDriveLetterString(string) {
    return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
}
function isNormalizedWindowsDriveLetterString(string) {
    return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
}
function containsForbiddenHostCodePoint(string) {
    return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
}
function containsForbiddenHostCodePointExcludingPercent(string) {
    return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
}
function isSpecialScheme(scheme) {
    return specialSchemes[scheme] !== undefined;
}
function isSpecial(url) {
    return isSpecialScheme(url.scheme);
}
function defaultPort(scheme) {
    return specialSchemes[scheme];
}
function percentEncode(c) {
    let hex = c.toString(16).toUpperCase();
    if (hex.length === 1) {
        hex = "0" + hex;
    }
    return "%" + hex;
}
function utf8PercentEncode(c) {
    const buf = new Buffer(c);
    let str = "";
    for(let i = 0; i < buf.length; ++i){
        str += percentEncode(buf[i]);
    }
    return str;
}
function utf8PercentDecode(str) {
    const input = new Buffer(str);
    const output = [];
    for(let i = 0; i < input.length; ++i){
        if (input[i] !== 37) {
            output.push(input[i]);
        } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
            output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
            i += 2;
        } else {
            output.push(input[i]);
        }
    }
    return new Buffer(output).toString();
}
function isC0ControlPercentEncode(c) {
    return c <= 0x1F || c > 0x7E;
}
const extraPathPercentEncodeSet = new Set([
    32,
    34,
    35,
    60,
    62,
    63,
    96,
    123,
    125
]);
function isPathPercentEncode(c) {
    return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
}
const extraUserinfoPercentEncodeSet = new Set([
    47,
    58,
    59,
    61,
    64,
    91,
    92,
    93,
    94,
    124
]);
function isUserinfoPercentEncode(c) {
    return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
}
function percentEncodeChar(c, encodeSetPredicate) {
    const cStr = String.fromCodePoint(c);
    if (encodeSetPredicate(c)) {
        return utf8PercentEncode(cStr);
    }
    return cStr;
}
function parseIPv4Number(input) {
    let R = 10;
    if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R = 16;
    } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
    }
    if (input === "") {
        return 0;
    }
    const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
    if (regex.test(input)) {
        return failure;
    }
    return parseInt(input, R);
}
function parseIPv4(input) {
    const parts = input.split(".");
    if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
            parts.pop();
        }
    }
    if (parts.length > 4) {
        return input;
    }
    const numbers = [];
    for (const part of parts){
        if (part === "") {
            return input;
        }
        const n = parseIPv4Number(part);
        if (n === failure) {
            return input;
        }
        numbers.push(n);
    }
    for(let i = 0; i < numbers.length - 1; ++i){
        if (numbers[i] > 255) {
            return failure;
        }
    }
    if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
    }
    let ipv4 = numbers.pop();
    let counter = 0;
    for (const n of numbers){
        ipv4 += n * Math.pow(256, 3 - counter);
        ++counter;
    }
    return ipv4;
}
function serializeIPv4(address) {
    let output = "";
    let n = address;
    for(let i = 1; i <= 4; ++i){
        output = String(n % 256) + output;
        if (i !== 4) {
            output = "." + output;
        }
        n = Math.floor(n / 256);
    }
    return output;
}
function parseIPv6(input) {
    const address = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    ];
    let pieceIndex = 0;
    let compress = null;
    let pointer = 0;
    input = punycode.ucs2.decode(input);
    if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
            return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
    }
    while(pointer < input.length){
        if (pieceIndex === 8) {
            return failure;
        }
        if (input[pointer] === 58) {
            if (compress !== null) {
                return failure;
            }
            ++pointer;
            ++pieceIndex;
            compress = pieceIndex;
            continue;
        }
        let value = 0;
        let length = 0;
        while(length < 4 && isASCIIHex(input[pointer])){
            value = value * 0x10 + parseInt(at(input, pointer), 16);
            ++pointer;
            ++length;
        }
        if (input[pointer] === 46) {
            if (length === 0) {
                return failure;
            }
            pointer -= length;
            if (pieceIndex > 6) {
                return failure;
            }
            let numbersSeen = 0;
            while(input[pointer] !== undefined){
                let ipv4Piece = null;
                if (numbersSeen > 0) {
                    if (input[pointer] === 46 && numbersSeen < 4) {
                        ++pointer;
                    } else {
                        return failure;
                    }
                }
                if (!isASCIIDigit(input[pointer])) {
                    return failure;
                }
                while(isASCIIDigit(input[pointer])){
                    const number = parseInt(at(input, pointer));
                    if (ipv4Piece === null) {
                        ipv4Piece = number;
                    } else if (ipv4Piece === 0) {
                        return failure;
                    } else {
                        ipv4Piece = ipv4Piece * 10 + number;
                    }
                    if (ipv4Piece > 255) {
                        return failure;
                    }
                    ++pointer;
                }
                address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;
                ++numbersSeen;
                if (numbersSeen === 2 || numbersSeen === 4) {
                    ++pieceIndex;
                }
            }
            if (numbersSeen !== 4) {
                return failure;
            }
            break;
        } else if (input[pointer] === 58) {
            ++pointer;
            if (input[pointer] === undefined) {
                return failure;
            }
        } else if (input[pointer] !== undefined) {
            return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
    }
    if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while(pieceIndex !== 0 && swaps > 0){
            const temp = address[compress + swaps - 1];
            address[compress + swaps - 1] = address[pieceIndex];
            address[pieceIndex] = temp;
            --pieceIndex;
            --swaps;
        }
    } else if (compress === null && pieceIndex !== 8) {
        return failure;
    }
    return address;
}
function serializeIPv6(address) {
    let output = "";
    const seqResult = findLongestZeroSequence(address);
    const compress = seqResult.idx;
    let ignore0 = false;
    for(let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex){
        if (ignore0 && address[pieceIndex] === 0) {
            continue;
        } else if (ignore0) {
            ignore0 = false;
        }
        if (compress === pieceIndex) {
            const separator = pieceIndex === 0 ? "::" : ":";
            output += separator;
            ignore0 = true;
            continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
            output += ":";
        }
    }
    return output;
}
function parseHost(input, isSpecialArg) {
    if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
            return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
    }
    if (!isSpecialArg) {
        return parseOpaqueHost(input);
    }
    const domain = utf8PercentDecode(input);
    const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
    if (asciiDomain === null) {
        return failure;
    }
    if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
    }
    const ipv4Host = parseIPv4(asciiDomain);
    if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
    }
    return asciiDomain;
}
function parseOpaqueHost(input) {
    if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
    }
    let output = "";
    const decoded = punycode.ucs2.decode(input);
    for(let i = 0; i < decoded.length; ++i){
        output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
    }
    return output;
}
function findLongestZeroSequence(arr) {
    let maxIdx = null;
    let maxLen = 1; // only find elements > 1
    let currStart = null;
    let currLen = 0;
    for(let i = 0; i < arr.length; ++i){
        if (arr[i] !== 0) {
            if (currLen > maxLen) {
                maxIdx = currStart;
                maxLen = currLen;
            }
            currStart = null;
            currLen = 0;
        } else {
            if (currStart === null) {
                currStart = i;
            }
            ++currLen;
        }
    }
    // if trailing zeros
    if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
    }
    return {
        idx: maxIdx,
        len: maxLen
    };
}
function serializeHost(host) {
    if (typeof host === "number") {
        return serializeIPv4(host);
    }
    // IPv6 serializer
    if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
    }
    return host;
}
function trimControlChars(url) {
    return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
}
function trimTabAndNewline(url) {
    return url.replace(/\u0009|\u000A|\u000D/g, "");
}
function shortenPath(url) {
    const path = url.path;
    if (path.length === 0) {
        return;
    }
    if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
        return;
    }
    path.pop();
}
function includesCredentials(url) {
    return url.username !== "" || url.password !== "";
}
function cannotHaveAUsernamePasswordPort(url) {
    return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
}
function isNormalizedWindowsDriveLetter(string) {
    return /^[A-Za-z]:$/.test(string);
}
function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
    this.pointer = 0;
    this.input = input;
    this.base = base || null;
    this.encodingOverride = encodingOverride || "utf-8";
    this.stateOverride = stateOverride;
    this.url = url;
    this.failure = false;
    this.parseError = false;
    if (!this.url) {
        this.url = {
            scheme: "",
            username: "",
            password: "",
            host: null,
            port: null,
            path: [],
            query: null,
            fragment: null,
            cannotBeABaseURL: false
        };
        const res = trimControlChars(this.input);
        if (res !== this.input) {
            this.parseError = true;
        }
        this.input = res;
    }
    const res = trimTabAndNewline(this.input);
    if (res !== this.input) {
        this.parseError = true;
    }
    this.input = res;
    this.state = stateOverride || "scheme start";
    this.buffer = "";
    this.atFlag = false;
    this.arrFlag = false;
    this.passwordTokenSeenFlag = false;
    this.input = punycode.ucs2.decode(this.input);
    for(; this.pointer <= this.input.length; ++this.pointer){
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);
        // exec state machine
        const ret = this["parse " + this.state](c, cStr);
        if (!ret) {
            break; // terminate algorithm
        } else if (ret === failure) {
            this.failure = true;
            break;
        }
    }
}
URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
    if (isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
    } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
    } else {
        this.parseError = true;
        return failure;
    }
    return true;
};
URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
    if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
        this.buffer += cStr.toLowerCase();
    } else if (c === 58) {
        if (this.stateOverride) {
            if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
                return false;
            }
            if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
                return false;
            }
            if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
                return false;
            }
            if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
                return false;
            }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
            return false;
        }
        if (this.url.scheme === "file") {
            if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
                this.parseError = true;
            }
            this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
            this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
            this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
            this.state = "path or authority";
            ++this.pointer;
        } else {
            this.url.cannotBeABaseURL = true;
            this.url.path.push("");
            this.state = "cannot-be-a-base-URL path";
        }
    } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
    } else {
        this.parseError = true;
        return failure;
    }
    return true;
};
URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
    if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
        return failure;
    } else if (this.base.cannotBeABaseURL && c === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
    } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
    } else {
        this.state = "relative";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
    if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
    } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
    if (c === 47) {
        this.state = "authority";
    } else {
        this.state = "path";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
    this.url.scheme = this.base.scheme;
    if (isNaN(c)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
    } else if (c === 47) {
        this.state = "relative slash";
    } else if (c === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
    } else if (c === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
    } else if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
        this.state = "relative slash";
    } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
    if (isSpecial(this.url) && (c === 47 || c === 92)) {
        if (c === 92) {
            this.parseError = true;
        }
        this.state = "special authority ignore slashes";
    } else if (c === 47) {
        this.state = "authority";
    } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
    if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
    } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
    if (c !== 47 && c !== 92) {
        this.state = "authority";
        --this.pointer;
    } else {
        this.parseError = true;
    }
    return true;
};
URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
    if (c === 64) {
        this.parseError = true;
        if (this.atFlag) {
            this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        // careful, this is based on buffer and has its own pointer (this.pointer != pointer) and inner chars
        const len = countSymbols(this.buffer);
        for(let pointer = 0; pointer < len; ++pointer){
            const codePoint = this.buffer.codePointAt(pointer);
            if (codePoint === 58 && !this.passwordTokenSeenFlag) {
                this.passwordTokenSeenFlag = true;
                continue;
            }
            const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
            if (this.passwordTokenSeenFlag) {
                this.url.password += encodedCodePoints;
            } else {
                this.url.username += encodedCodePoints;
            }
        }
        this.buffer = "";
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        if (this.atFlag && this.buffer === "") {
            this.parseError = true;
            return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
    } else {
        this.buffer += cStr;
    }
    return true;
};
URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
    if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
    } else if (c === 58 && !this.arrFlag) {
        if (this.buffer === "") {
            this.parseError = true;
            return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
            return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
            return false;
        }
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
            this.parseError = true;
            return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
            this.parseError = true;
            return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
            return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
            return false;
        }
    } else {
        if (c === 91) {
            this.arrFlag = true;
        } else if (c === 93) {
            this.arrFlag = false;
        }
        this.buffer += cStr;
    }
    return true;
};
URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
    if (isASCIIDigit(c)) {
        this.buffer += cStr;
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
        if (this.buffer !== "") {
            const port = parseInt(this.buffer);
            if (port > Math.pow(2, 16) - 1) {
                this.parseError = true;
                return failure;
            }
            this.url.port = port === defaultPort(this.url.scheme) ? null : port;
            this.buffer = "";
        }
        if (this.stateOverride) {
            return false;
        }
        this.state = "path start";
        --this.pointer;
    } else {
        this.parseError = true;
        return failure;
    }
    return true;
};
const fileOtherwiseCodePoints = new Set([
    47,
    92,
    63,
    35
]);
URLStateMachine.prototype["parse file"] = function parseFile(c) {
    this.url.scheme = "file";
    if (c === 47 || c === 92) {
        if (c === 92) {
            this.parseError = true;
        }
        this.state = "file slash";
    } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c)) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            this.url.query = this.base.query;
        } else if (c === 63) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            this.url.query = "";
            this.state = "query";
        } else if (c === 35) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            this.url.query = this.base.query;
            this.url.fragment = "";
            this.state = "fragment";
        } else {
            if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
            !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
            !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
                this.url.host = this.base.host;
                this.url.path = this.base.path.slice();
                shortenPath(this.url);
            } else {
                this.parseError = true;
            }
            this.state = "path";
            --this.pointer;
        }
    } else {
        this.state = "path";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
    if (c === 47 || c === 92) {
        if (c === 92) {
            this.parseError = true;
        }
        this.state = "file host";
    } else {
        if (this.base !== null && this.base.scheme === "file") {
            if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
                this.url.path.push(this.base.path[0]);
            } else {
                this.url.host = this.base.host;
            }
        }
        this.state = "path";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
    if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
            this.parseError = true;
            this.state = "path";
        } else if (this.buffer === "") {
            this.url.host = "";
            if (this.stateOverride) {
                return false;
            }
            this.state = "path start";
        } else {
            let host = parseHost(this.buffer, isSpecial(this.url));
            if (host === failure) {
                return failure;
            }
            if (host === "localhost") {
                host = "";
            }
            this.url.host = host;
            if (this.stateOverride) {
                return false;
            }
            this.buffer = "";
            this.state = "path start";
        }
    } else {
        this.buffer += cStr;
    }
    return true;
};
URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
    if (isSpecial(this.url)) {
        if (c === 92) {
            this.parseError = true;
        }
        this.state = "path";
        if (c !== 47 && c !== 92) {
            --this.pointer;
        }
    } else if (!this.stateOverride && c === 63) {
        this.url.query = "";
        this.state = "query";
    } else if (!this.stateOverride && c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
    } else if (c !== undefined) {
        this.state = "path";
        if (c !== 47) {
            --this.pointer;
        }
    }
    return true;
};
URLStateMachine.prototype["parse path"] = function parsePath(c) {
    if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
        if (isSpecial(this.url) && c === 92) {
            this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
            shortenPath(this.url);
            if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
                this.url.path.push("");
            }
        } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
            if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
                if (this.url.host !== "" && this.url.host !== null) {
                    this.parseError = true;
                    this.url.host = "";
                }
                this.buffer = this.buffer[0] + ":";
            }
            this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c === undefined || c === 63 || c === 35)) {
            while(this.url.path.length > 1 && this.url.path[0] === ""){
                this.parseError = true;
                this.url.path.shift();
            }
        }
        if (c === 63) {
            this.url.query = "";
            this.state = "query";
        }
        if (c === 35) {
            this.url.fragment = "";
            this.state = "fragment";
        }
    } else {
        // TODO: If c is not a URL code point and not "%", parse error.
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
        }
        this.buffer += percentEncodeChar(c, isPathPercentEncode);
    }
    return true;
};
URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
    if (c === 63) {
        this.url.query = "";
        this.state = "query";
    } else if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
    } else {
        // TODO: Add: not a URL code point
        if (!isNaN(c) && c !== 37) {
            this.parseError = true;
        }
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
        }
        if (!isNaN(c)) {
            this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
        }
    }
    return true;
};
URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
    if (isNaN(c) || !this.stateOverride && c === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
            this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer); // TODO: Use encoding override instead
        for(let i = 0; i < buffer.length; ++i){
            if (buffer[i] < 0x21 || buffer[i] > 0x7E || buffer[i] === 0x22 || buffer[i] === 0x23 || buffer[i] === 0x3C || buffer[i] === 0x3E) {
                this.url.query += percentEncode(buffer[i]);
            } else {
                this.url.query += String.fromCodePoint(buffer[i]);
            }
        }
        this.buffer = "";
        if (c === 35) {
            this.url.fragment = "";
            this.state = "fragment";
        }
    } else {
        // TODO: If c is not a URL code point and not "%", parse error.
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
        }
        this.buffer += cStr;
    }
    return true;
};
URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
    if (isNaN(c)) {} else if (c === 0x0) {
        this.parseError = true;
    } else {
        // TODO: If c is not a URL code point and not "%", parse error.
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
    }
    return true;
};
function serializeURL(url, excludeFragment) {
    let output = url.scheme + ":";
    if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
            output += url.username;
            if (url.password !== "") {
                output += ":" + url.password;
            }
            output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
            output += ":" + url.port;
        }
    } else if (url.host === null && url.scheme === "file") {
        output += "//";
    }
    if (url.cannotBeABaseURL) {
        output += url.path[0];
    } else {
        for (const string of url.path){
            output += "/" + string;
        }
    }
    if (url.query !== null) {
        output += "?" + url.query;
    }
    if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment;
    }
    return output;
}
function serializeOrigin(tuple) {
    let result = tuple.scheme + "://";
    result += serializeHost(tuple.host);
    if (tuple.port !== null) {
        result += ":" + tuple.port;
    }
    return result;
}
module.exports.serializeURL = serializeURL;
module.exports.serializeURLOrigin = function(url) {
    // https://url.spec.whatwg.org/#concept-url-origin
    switch(url.scheme){
        case "blob":
            try {
                return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
            } catch (e) {
                // serializing an opaque origin returns "null"
                return "null";
            }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
            return serializeOrigin({
                scheme: url.scheme,
                host: url.host,
                port: url.port
            });
        case "file":
            // spec says "exercise to the reader", chrome says "file://"
            return "file://";
        default:
            // serializing an opaque origin returns "null"
            return "null";
    }
};
module.exports.basicURLParse = function(input, options) {
    if (options === undefined) {
        options = {};
    }
    const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
    if (usm.failure) {
        return "failure";
    }
    return usm.url;
};
module.exports.setTheUsername = function(url, username) {
    url.username = "";
    const decoded = punycode.ucs2.decode(username);
    for(let i = 0; i < decoded.length; ++i){
        url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
    }
};
module.exports.setThePassword = function(url, password) {
    url.password = "";
    const decoded = punycode.ucs2.decode(password);
    for(let i = 0; i < decoded.length; ++i){
        url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
    }
};
module.exports.serializeHost = serializeHost;
module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
module.exports.serializeInteger = function(integer) {
    return String(integer);
};
module.exports.parseURL = function(input, options) {
    if (options === undefined) {
        options = {};
    }
    // We don't handle blobs, so this just delegates:
    return module.exports.basicURLParse(input, {
        baseURL: options.baseURL,
        encodingOverride: options.encodingOverride
    });
};
}),
"[project]/node_modules/whatwg-url/lib/URL-impl.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const usm = __turbopack_context__.r("[project]/node_modules/whatwg-url/lib/url-state-machine.js [app-route] (ecmascript)");
exports.implementation = class URLImpl {
    constructor(constructorArgs){
        const url = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== undefined) {
            parsedBase = usm.basicURLParse(base);
            if (parsedBase === "failure") {
                throw new TypeError("Invalid base URL");
            }
        }
        const parsedURL = usm.basicURLParse(url, {
            baseURL: parsedBase
        });
        if (parsedURL === "failure") {
            throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
    // TODO: query stuff
    }
    get href() {
        return usm.serializeURL(this._url);
    }
    set href(v) {
        const parsedURL = usm.basicURLParse(v);
        if (parsedURL === "failure") {
            throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
    }
    get origin() {
        return usm.serializeURLOrigin(this._url);
    }
    get protocol() {
        return this._url.scheme + ":";
    }
    set protocol(v) {
        usm.basicURLParse(v + ":", {
            url: this._url,
            stateOverride: "scheme start"
        });
    }
    get username() {
        return this._url.username;
    }
    set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
            return;
        }
        usm.setTheUsername(this._url, v);
    }
    get password() {
        return this._url.password;
    }
    set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
            return;
        }
        usm.setThePassword(this._url, v);
    }
    get host() {
        const url = this._url;
        if (url.host === null) {
            return "";
        }
        if (url.port === null) {
            return usm.serializeHost(url.host);
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
    }
    set host(v) {
        if (this._url.cannotBeABaseURL) {
            return;
        }
        usm.basicURLParse(v, {
            url: this._url,
            stateOverride: "host"
        });
    }
    get hostname() {
        if (this._url.host === null) {
            return "";
        }
        return usm.serializeHost(this._url.host);
    }
    set hostname(v) {
        if (this._url.cannotBeABaseURL) {
            return;
        }
        usm.basicURLParse(v, {
            url: this._url,
            stateOverride: "hostname"
        });
    }
    get port() {
        if (this._url.port === null) {
            return "";
        }
        return usm.serializeInteger(this._url.port);
    }
    set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
            return;
        }
        if (v === "") {
            this._url.port = null;
        } else {
            usm.basicURLParse(v, {
                url: this._url,
                stateOverride: "port"
            });
        }
    }
    get pathname() {
        if (this._url.cannotBeABaseURL) {
            return this._url.path[0];
        }
        if (this._url.path.length === 0) {
            return "";
        }
        return "/" + this._url.path.join("/");
    }
    set pathname(v) {
        if (this._url.cannotBeABaseURL) {
            return;
        }
        this._url.path = [];
        usm.basicURLParse(v, {
            url: this._url,
            stateOverride: "path start"
        });
    }
    get search() {
        if (this._url.query === null || this._url.query === "") {
            return "";
        }
        return "?" + this._url.query;
    }
    set search(v) {
        // TODO: query stuff
        const url = this._url;
        if (v === "") {
            url.query = null;
            return;
        }
        const input = v[0] === "?" ? v.substring(1) : v;
        url.query = "";
        usm.basicURLParse(input, {
            url,
            stateOverride: "query"
        });
    }
    get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
            return "";
        }
        return "#" + this._url.fragment;
    }
    set hash(v) {
        if (v === "") {
            this._url.fragment = null;
            return;
        }
        const input = v[0] === "#" ? v.substring(1) : v;
        this._url.fragment = "";
        usm.basicURLParse(input, {
            url: this._url,
            stateOverride: "fragment"
        });
    }
    toJSON() {
        return this.href;
    }
};
}),
"[project]/node_modules/whatwg-url/lib/URL.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [app-route] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/whatwg-url/lib/utils.js [app-route] (ecmascript)");
const Impl = __turbopack_context__.r("[project]/node_modules/whatwg-url/lib/URL-impl.js [app-route] (ecmascript)");
const impl = utils.implSymbol;
function URL(url) {
    if (!this || this[impl] || !(this instanceof URL)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
    }
    if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
    }
    const args = [];
    for(let i = 0; i < arguments.length && i < 2; ++i){
        args[i] = arguments[i];
    }
    args[0] = conversions["USVString"](args[0]);
    if (args[1] !== undefined) {
        args[1] = conversions["USVString"](args[1]);
    }
    module.exports.setup(this, args);
}
URL.prototype.toJSON = function toJSON() {
    if (!this || !module.exports.is(this)) {
        throw new TypeError("Illegal invocation");
    }
    const args = [];
    for(let i = 0; i < arguments.length && i < 0; ++i){
        args[i] = arguments[i];
    }
    return this[impl].toJSON.apply(this[impl], args);
};
Object.defineProperty(URL.prototype, "href", {
    get () {
        return this[impl].href;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].href = V;
    },
    enumerable: true,
    configurable: true
});
URL.prototype.toString = function() {
    if (!this || !module.exports.is(this)) {
        throw new TypeError("Illegal invocation");
    }
    return this.href;
};
Object.defineProperty(URL.prototype, "origin", {
    get () {
        return this[impl].origin;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "protocol", {
    get () {
        return this[impl].protocol;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].protocol = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "username", {
    get () {
        return this[impl].username;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].username = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "password", {
    get () {
        return this[impl].password;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].password = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "host", {
    get () {
        return this[impl].host;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].host = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "hostname", {
    get () {
        return this[impl].hostname;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].hostname = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "port", {
    get () {
        return this[impl].port;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].port = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "pathname", {
    get () {
        return this[impl].pathname;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].pathname = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "search", {
    get () {
        return this[impl].search;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].search = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "hash", {
    get () {
        return this[impl].hash;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].hash = V;
    },
    enumerable: true,
    configurable: true
});
module.exports = {
    is (obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
    },
    create (constructorArgs, privateData) {
        let obj = Object.create(URL.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
    },
    setup (obj, constructorArgs, privateData) {
        if (!privateData) privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils.wrapperSymbol] = obj;
    },
    interface: URL,
    expose: {
        Window: {
            URL: URL
        },
        Worker: {
            URL: URL
        }
    }
};
}),
"[project]/node_modules/whatwg-url/lib/public-api.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.URL = __turbopack_context__.r("[project]/node_modules/whatwg-url/lib/URL.js [app-route] (ecmascript)").interface;
exports.serializeURL = __turbopack_context__.r("[project]/node_modules/whatwg-url/lib/url-state-machine.js [app-route] (ecmascript)").serializeURL;
exports.serializeURLOrigin = __turbopack_context__.r("[project]/node_modules/whatwg-url/lib/url-state-machine.js [app-route] (ecmascript)").serializeURLOrigin;
exports.basicURLParse = __turbopack_context__.r("[project]/node_modules/whatwg-url/lib/url-state-machine.js [app-route] (ecmascript)").basicURLParse;
exports.setTheUsername = __turbopack_context__.r("[project]/node_modules/whatwg-url/lib/url-state-machine.js [app-route] (ecmascript)").setTheUsername;
exports.setThePassword = __turbopack_context__.r("[project]/node_modules/whatwg-url/lib/url-state-machine.js [app-route] (ecmascript)").setThePassword;
exports.serializeHost = __turbopack_context__.r("[project]/node_modules/whatwg-url/lib/url-state-machine.js [app-route] (ecmascript)").serializeHost;
exports.serializeInteger = __turbopack_context__.r("[project]/node_modules/whatwg-url/lib/url-state-machine.js [app-route] (ecmascript)").serializeInteger;
exports.parseURL = __turbopack_context__.r("[project]/node_modules/whatwg-url/lib/url-state-machine.js [app-route] (ecmascript)").parseURL;
}),
"[project]/node_modules/node-fetch/lib/index.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AbortError",
    ()=>AbortError,
    "FetchError",
    ()=>FetchError,
    "Headers",
    ()=>Headers,
    "Request",
    ()=>Request,
    "Response",
    ()=>Response,
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/stream [external] (stream, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$http__$5b$external$5d$__$28$http$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/http [external] (http, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/url [external] (url, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$whatwg$2d$url$2f$lib$2f$public$2d$api$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/whatwg-url/lib/public-api.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$https__$5b$external$5d$__$28$https$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/https [external] (https, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/zlib [external] (zlib, cjs)");
;
;
;
;
;
;
// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js
// fix for "Readable" isn't a named export issue
const Readable = __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].Readable;
const BUFFER = Symbol('buffer');
const TYPE = Symbol('type');
class Blob {
    constructor(){
        this[TYPE] = '';
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
            const a = blobParts;
            const length = Number(a.length);
            for(let i = 0; i < length; i++){
                const element = a[i];
                let buffer;
                if (element instanceof Buffer) {
                    buffer = element;
                } else if (ArrayBuffer.isView(element)) {
                    buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
                } else if (element instanceof ArrayBuffer) {
                    buffer = Buffer.from(element);
                } else if (element instanceof Blob) {
                    buffer = element[BUFFER];
                } else {
                    buffer = Buffer.from(typeof element === 'string' ? element : String(element));
                }
                size += buffer.length;
                buffers.push(buffer);
            }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== undefined && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
            this[TYPE] = type;
        }
    }
    get size() {
        return this[BUFFER].length;
    }
    get type() {
        return this[TYPE];
    }
    text() {
        return Promise.resolve(this[BUFFER].toString());
    }
    arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
    }
    stream() {
        const readable = new Readable();
        readable._read = function() {};
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
    }
    toString() {
        return '[object Blob]';
    }
    slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === undefined) {
            relativeStart = 0;
        } else if (start < 0) {
            relativeStart = Math.max(size + start, 0);
        } else {
            relativeStart = Math.min(start, size);
        }
        if (end === undefined) {
            relativeEnd = size;
        } else if (end < 0) {
            relativeEnd = Math.max(size + end, 0);
        } else {
            relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new Blob([], {
            type: arguments[2]
        });
        blob[BUFFER] = slicedBuffer;
        return blob;
    }
}
Object.defineProperties(Blob.prototype, {
    size: {
        enumerable: true
    },
    type: {
        enumerable: true
    },
    slice: {
        enumerable: true
    }
});
Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
    value: 'Blob',
    writable: false,
    enumerable: false,
    configurable: true
});
/**
 * fetch-error.js
 *
 * FetchError interface for operational errors
 */ /**
 * Create FetchError instance
 *
 * @param   String      message      Error message for human
 * @param   String      type         Error type for machine
 * @param   String      systemError  For Node.js system error
 * @return  FetchError
 */ function FetchError(message, type, systemError) {
    Error.call(this, message);
    this.message = message;
    this.type = type;
    // when err.type is `system`, err.code contains system error code
    if (systemError) {
        this.code = this.errno = systemError.code;
    }
    // hide custom error implementation details from end-users
    Error.captureStackTrace(this, this.constructor);
}
FetchError.prototype = Object.create(Error.prototype);
FetchError.prototype.constructor = FetchError;
FetchError.prototype.name = 'FetchError';
let convert;
try {
    convert = (()=>{
        const e = new Error("Cannot find module 'encoding'");
        e.code = 'MODULE_NOT_FOUND';
        throw e;
    })().convert;
} catch (e) {}
const INTERNALS = Symbol('Body internals');
// fix an issue where "PassThrough" isn't a named export for node <10
const PassThrough = __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].PassThrough;
/**
 * Body mixin
 *
 * Ref: https://fetch.spec.whatwg.org/#body
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */ function Body(body) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$size = _ref.size;
    let size = _ref$size === undefined ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;
    if (body == null) {
        // body is undefined or null
        body = null;
    } else if (isURLSearchParams(body)) {
        // body is a URLSearchParams
        body = Buffer.from(body.toString());
    } else if (isBlob(body)) ;
    else if (Buffer.isBuffer(body)) ;
    else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
        // body is ArrayBuffer
        body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
        // body is ArrayBufferView
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"]) ;
    else {
        // none of the above
        // coerce to string then buffer
        body = Buffer.from(String(body));
    }
    this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
    };
    this.size = size;
    this.timeout = timeout;
    if (body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"]) {
        body.on('error', function(err) {
            const error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);
            _this[INTERNALS].error = error;
        });
    }
}
Body.prototype = {
    get body () {
        return this[INTERNALS].body;
    },
    get bodyUsed () {
        return this[INTERNALS].disturbed;
    },
    /**
  * Decode response as ArrayBuffer
  *
  * @return  Promise
  */ arrayBuffer () {
        return consumeBody.call(this).then(function(buf) {
            return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
    },
    /**
  * Return raw response as Blob
  *
  * @return Promise
  */ blob () {
        let ct = this.headers && this.headers.get('content-type') || '';
        return consumeBody.call(this).then(function(buf) {
            return Object.assign(// Prevent copying
            new Blob([], {
                type: ct.toLowerCase()
            }), {
                [BUFFER]: buf
            });
        });
    },
    /**
  * Decode response as json
  *
  * @return  Promise
  */ json () {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
            try {
                return JSON.parse(buffer.toString());
            } catch (err) {
                return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));
            }
        });
    },
    /**
  * Decode response as text
  *
  * @return  Promise
  */ text () {
        return consumeBody.call(this).then(function(buffer) {
            return buffer.toString();
        });
    },
    /**
  * Decode response as buffer (non-spec api)
  *
  * @return  Promise
  */ buffer () {
        return consumeBody.call(this);
    },
    /**
  * Decode response as text, while automatically detecting the encoding and
  * trying to decode to UTF-8 (non-spec api)
  *
  * @return  Promise
  */ textConverted () {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
            return convertBody(buffer, _this3.headers);
        });
    }
};
// In browsers, all properties are enumerable.
Object.defineProperties(Body.prototype, {
    body: {
        enumerable: true
    },
    bodyUsed: {
        enumerable: true
    },
    arrayBuffer: {
        enumerable: true
    },
    blob: {
        enumerable: true
    },
    json: {
        enumerable: true
    },
    text: {
        enumerable: true
    }
});
Body.mixIn = function(proto) {
    for (const name of Object.getOwnPropertyNames(Body.prototype)){
        // istanbul ignore else: future proof
        if (!(name in proto)) {
            const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
            Object.defineProperty(proto, name, desc);
        }
    }
};
/**
 * Consume and convert an entire Body to a Buffer.
 *
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
 *
 * @return  Promise
 */ function consumeBody() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    }
    this[INTERNALS].disturbed = true;
    if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
    }
    let body = this.body;
    // body is null
    if (body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
    }
    // body is blob
    if (isBlob(body)) {
        body = body.stream();
    }
    // body is buffer
    if (Buffer.isBuffer(body)) {
        return Body.Promise.resolve(body);
    }
    // istanbul ignore if: should never happen
    if (!(body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"])) {
        return Body.Promise.resolve(Buffer.alloc(0));
    }
    // body is stream
    // get ready to actually consume the body
    let accum = [];
    let accumBytes = 0;
    let abort = false;
    return new Body.Promise(function(resolve, reject) {
        let resTimeout;
        // allow timeout on slow response body
        if (_this4.timeout) {
            resTimeout = setTimeout(function() {
                abort = true;
                reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));
            }, _this4.timeout);
        }
        // handle stream errors
        body.on('error', function(err) {
            if (err.name === 'AbortError') {
                // if the request was aborted, reject with this Error
                abort = true;
                reject(err);
            } else {
                // other errors, such as incorrect content-encoding
                reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));
            }
        });
        body.on('data', function(chunk) {
            if (abort || chunk === null) {
                return;
            }
            if (_this4.size && accumBytes + chunk.length > _this4.size) {
                abort = true;
                reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));
                return;
            }
            accumBytes += chunk.length;
            accum.push(chunk);
        });
        body.on('end', function() {
            if (abort) {
                return;
            }
            clearTimeout(resTimeout);
            try {
                resolve(Buffer.concat(accum, accumBytes));
            } catch (err) {
                // handle streams that have accumulated too much data (issue #414)
                reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));
            }
        });
    });
}
/**
 * Detect buffer encoding and convert to target encoding
 * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
 *
 * @param   Buffer  buffer    Incoming buffer
 * @param   String  encoding  Target encoding
 * @return  String
 */ function convertBody(buffer, headers) {
    if (typeof convert !== 'function') {
        throw new Error('The package `encoding` must be installed to use the textConverted() function');
    }
    const ct = headers.get('content-type');
    let charset = 'utf-8';
    let res, str;
    // header
    if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
    }
    // no charset in content type, peek at response body for at most 1024 bytes
    str = buffer.slice(0, 1024).toString();
    // html5
    if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    }
    // html4
    if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
            res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
            if (res) {
                res.pop(); // drop last quote
            }
        }
        if (res) {
            res = /charset=(.*)/i.exec(res.pop());
        }
    }
    // xml
    if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    }
    // found charset
    if (res) {
        charset = res.pop();
        // prevent decode issues when sites use incorrect encoding
        // ref: https://hsivonen.fi/encoding-menu/
        if (charset === 'gb2312' || charset === 'gbk') {
            charset = 'gb18030';
        }
    }
    // turn raw buffers into a single utf-8 buffer
    return convert(buffer, 'UTF-8', charset).toString();
}
/**
 * Detect a URLSearchParams object
 * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
 *
 * @param   Object  obj     Object to detect by type or brand
 * @return  String
 */ function isURLSearchParams(obj) {
    // Duck-typing as a necessary condition.
    if (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {
        return false;
    }
    // Brand-checking and more duck-typing as optional condition.
    return obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';
}
/**
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
 * @param  {*} obj
 * @return {boolean}
 */ function isBlob(obj) {
    return typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}
/**
 * Clone body given Res/Req instance
 *
 * @param   Mixed  instance  Response or Request instance
 * @return  Mixed
 */ function clone(instance) {
    let p1, p2;
    let body = instance.body;
    // don't allow cloning a used body
    if (instance.bodyUsed) {
        throw new Error('cannot clone body after it is used');
    }
    // check that body is a stream and not form-data object
    // note: we can't clone the form-data object without having it as a dependency
    if (body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"] && typeof body.getBoundary !== 'function') {
        // tee instance body
        p1 = new PassThrough();
        p2 = new PassThrough();
        body.pipe(p1);
        body.pipe(p2);
        // set instance body to teed body and return the other teed body
        instance[INTERNALS].body = p1;
        body = p2;
    }
    return body;
}
/**
 * Performs the operation "extract a `Content-Type` value from |object|" as
 * specified in the specification:
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 *
 * This function assumes that instance.body is present.
 *
 * @param   Mixed  instance  Any options.body input
 */ function extractContentType(body) {
    if (body === null) {
        // body is null
        return null;
    } else if (typeof body === 'string') {
        // body is string
        return 'text/plain;charset=UTF-8';
    } else if (isURLSearchParams(body)) {
        // body is a URLSearchParams
        return 'application/x-www-form-urlencoded;charset=UTF-8';
    } else if (isBlob(body)) {
        // body is blob
        return body.type || null;
    } else if (Buffer.isBuffer(body)) {
        // body is buffer
        return null;
    } else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
        // body is ArrayBuffer
        return null;
    } else if (ArrayBuffer.isView(body)) {
        // body is ArrayBufferView
        return null;
    } else if (typeof body.getBoundary === 'function') {
        // detect form data input from form-data module
        return `multipart/form-data;boundary=${body.getBoundary()}`;
    } else if (body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"]) {
        // body is stream
        // can't really do much about this
        return null;
    } else {
        // Body constructor defaults other things to string
        return 'text/plain;charset=UTF-8';
    }
}
/**
 * The Fetch Standard treats this as if "total bytes" is a property on the body.
 * For us, we have to explicitly get it with a function.
 *
 * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
 *
 * @param   Body    instance   Instance of Body
 * @return  Number?            Number of bytes, or null if not possible
 */ function getTotalBytes(instance) {
    const body = instance.body;
    if (body === null) {
        // body is null
        return 0;
    } else if (isBlob(body)) {
        return body.size;
    } else if (Buffer.isBuffer(body)) {
        // body is buffer
        return body.length;
    } else if (body && typeof body.getLengthSync === 'function') {
        // detect form data input from form-data module
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
        body.hasKnownLength && body.hasKnownLength()) {
            // 2.x
            return body.getLengthSync();
        }
        return null;
    } else {
        // body is stream
        return null;
    }
}
/**
 * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
 *
 * @param   Body    instance   Instance of Body
 * @return  Void
 */ function writeToStream(dest, instance) {
    const body = instance.body;
    if (body === null) {
        // body is null
        dest.end();
    } else if (isBlob(body)) {
        body.stream().pipe(dest);
    } else if (Buffer.isBuffer(body)) {
        // body is buffer
        dest.write(body);
        dest.end();
    } else {
        // body is stream
        body.pipe(dest);
    }
}
// expose Promise
Body.Promise = /*TURBOPACK member replacement*/ __turbopack_context__.g.Promise;
/**
 * headers.js
 *
 * Headers class offers convenient helpers
 */ const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
function validateName(name) {
    name = `${name}`;
    if (invalidTokenRegex.test(name) || name === '') {
        throw new TypeError(`${name} is not a legal HTTP header name`);
    }
}
function validateValue(value) {
    value = `${value}`;
    if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
    }
}
/**
 * Find the key in the map object given a header name.
 *
 * Returns undefined if not found.
 *
 * @param   String  name  Header name
 * @return  String|Undefined
 */ function find(map, name) {
    name = name.toLowerCase();
    for(const key in map){
        if (key.toLowerCase() === name) {
            return key;
        }
    }
    return undefined;
}
const MAP = Symbol('map');
class Headers {
    /**
  * Headers class
  *
  * @param   Object  headers  Response headers
  * @return  Void
  */ constructor(){
        let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
        this[MAP] = Object.create(null);
        if (init instanceof Headers) {
            const rawHeaders = init.raw();
            const headerNames = Object.keys(rawHeaders);
            for (const headerName of headerNames){
                for (const value of rawHeaders[headerName]){
                    this.append(headerName, value);
                }
            }
            return;
        }
        // We don't worry about converting prop to ByteString here as append()
        // will handle it.
        if (init == null) ;
        else if (typeof init === 'object') {
            const method = init[Symbol.iterator];
            if (method != null) {
                if (typeof method !== 'function') {
                    throw new TypeError('Header pairs must be iterable');
                }
                // sequence<sequence<ByteString>>
                // Note: per spec we have to first exhaust the lists then process them
                const pairs = [];
                for (const pair of init){
                    if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {
                        throw new TypeError('Each header pair must be iterable');
                    }
                    pairs.push(Array.from(pair));
                }
                for (const pair of pairs){
                    if (pair.length !== 2) {
                        throw new TypeError('Each header pair must be a name/value tuple');
                    }
                    this.append(pair[0], pair[1]);
                }
            } else {
                // record<ByteString, ByteString>
                for (const key of Object.keys(init)){
                    const value = init[key];
                    this.append(key, value);
                }
            }
        } else {
            throw new TypeError('Provided initializer must be an object');
        }
    }
    /**
  * Return combined header value given name
  *
  * @param   String  name  Header name
  * @return  Mixed
  */ get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === undefined) {
            return null;
        }
        return this[MAP][key].join(', ');
    }
    /**
  * Iterate over all headers
  *
  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
  * @param   Boolean   thisArg   `this` context for callback function
  * @return  Void
  */ forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
        let pairs = getHeaders(this);
        let i = 0;
        while(i < pairs.length){
            var _pairs$i = pairs[i];
            const name = _pairs$i[0], value = _pairs$i[1];
            callback.call(thisArg, value, name, this);
            pairs = getHeaders(this);
            i++;
        }
    }
    /**
  * Overwrite header values given name
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */ set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== undefined ? key : name] = [
            value
        ];
    }
    /**
  * Append a value onto existing header
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */ append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== undefined) {
            this[MAP][key].push(value);
        } else {
            this[MAP][name] = [
                value
            ];
        }
    }
    /**
  * Check for header name existence
  *
  * @param   String   name  Header name
  * @return  Boolean
  */ has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== undefined;
    }
    /**
  * Delete all header values given name
  *
  * @param   String  name  Header name
  * @return  Void
  */ delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== undefined) {
            delete this[MAP][key];
        }
    }
    /**
  * Return raw headers (non-spec api)
  *
  * @return  Object
  */ raw() {
        return this[MAP];
    }
    /**
  * Get an iterator on keys.
  *
  * @return  Iterator
  */ keys() {
        return createHeadersIterator(this, 'key');
    }
    /**
  * Get an iterator on values.
  *
  * @return  Iterator
  */ values() {
        return createHeadersIterator(this, 'value');
    }
    /**
  * Get an iterator on entries.
  *
  * This is the default iterator of the Headers object.
  *
  * @return  Iterator
  */ [Symbol.iterator]() {
        return createHeadersIterator(this, 'key+value');
    }
}
Headers.prototype.entries = Headers.prototype[Symbol.iterator];
Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
    value: 'Headers',
    writable: false,
    enumerable: false,
    configurable: true
});
Object.defineProperties(Headers.prototype, {
    get: {
        enumerable: true
    },
    forEach: {
        enumerable: true
    },
    set: {
        enumerable: true
    },
    append: {
        enumerable: true
    },
    has: {
        enumerable: true
    },
    delete: {
        enumerable: true
    },
    keys: {
        enumerable: true
    },
    values: {
        enumerable: true
    },
    entries: {
        enumerable: true
    }
});
function getHeaders(headers) {
    let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';
    const keys = Object.keys(headers[MAP]).sort();
    return keys.map(kind === 'key' ? function(k) {
        return k.toLowerCase();
    } : kind === 'value' ? function(k) {
        return headers[MAP][k].join(', ');
    } : function(k) {
        return [
            k.toLowerCase(),
            headers[MAP][k].join(', ')
        ];
    });
}
const INTERNAL = Symbol('internal');
function createHeadersIterator(target, kind) {
    const iterator = Object.create(HeadersIteratorPrototype);
    iterator[INTERNAL] = {
        target,
        kind,
        index: 0
    };
    return iterator;
}
const HeadersIteratorPrototype = Object.setPrototypeOf({
    next () {
        // istanbul ignore if
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
            throw new TypeError('Value of `this` is not a HeadersIterator');
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
            return {
                value: undefined,
                done: true
            };
        }
        this[INTERNAL].index = index + 1;
        return {
            value: values[index],
            done: false
        };
    }
}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
    value: 'HeadersIterator',
    writable: false,
    enumerable: false,
    configurable: true
});
/**
 * Export the Headers object in a form that Node.js can consume.
 *
 * @param   Headers  headers
 * @return  Object
 */ function exportNodeCompatibleHeaders(headers) {
    const obj = Object.assign({
        __proto__: null
    }, headers[MAP]);
    // http.request() only supports string as Host header. This hack makes
    // specifying custom Host header possible.
    const hostHeaderKey = find(headers[MAP], 'Host');
    if (hostHeaderKey !== undefined) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
    }
    return obj;
}
/**
 * Create a Headers object from an object of headers, ignoring those that do
 * not conform to HTTP grammar productions.
 *
 * @param   Object  obj  Object of headers
 * @return  Headers
 */ function createHeadersLenient(obj) {
    const headers = new Headers();
    for (const name of Object.keys(obj)){
        if (invalidTokenRegex.test(name)) {
            continue;
        }
        if (Array.isArray(obj[name])) {
            for (const val of obj[name]){
                if (invalidHeaderCharRegex.test(val)) {
                    continue;
                }
                if (headers[MAP][name] === undefined) {
                    headers[MAP][name] = [
                        val
                    ];
                } else {
                    headers[MAP][name].push(val);
                }
            }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
            headers[MAP][name] = [
                obj[name]
            ];
        }
    }
    return headers;
}
const INTERNALS$1 = Symbol('Response internals');
// fix an issue where "STATUS_CODES" aren't a named export for node <10
const STATUS_CODES = __TURBOPACK__imported__module__$5b$externals$5d2f$http__$5b$external$5d$__$28$http$2c$__cjs$29$__["default"].STATUS_CODES;
/**
 * Response class
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */ class Response {
    constructor(){
        let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has('Content-Type')) {
            const contentType = extractContentType(body);
            if (contentType) {
                headers.append('Content-Type', contentType);
            }
        }
        this[INTERNALS$1] = {
            url: opts.url,
            status,
            statusText: opts.statusText || STATUS_CODES[status],
            headers,
            counter: opts.counter
        };
    }
    get url() {
        return this[INTERNALS$1].url || '';
    }
    get status() {
        return this[INTERNALS$1].status;
    }
    /**
  * Convenience property representing if the request ended normally
  */ get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
    }
    get redirected() {
        return this[INTERNALS$1].counter > 0;
    }
    get statusText() {
        return this[INTERNALS$1].statusText;
    }
    get headers() {
        return this[INTERNALS$1].headers;
    }
    /**
  * Clone this response
  *
  * @return  Response
  */ clone() {
        return new Response(clone(this), {
            url: this.url,
            status: this.status,
            statusText: this.statusText,
            headers: this.headers,
            ok: this.ok,
            redirected: this.redirected
        });
    }
}
Body.mixIn(Response.prototype);
Object.defineProperties(Response.prototype, {
    url: {
        enumerable: true
    },
    status: {
        enumerable: true
    },
    ok: {
        enumerable: true
    },
    redirected: {
        enumerable: true
    },
    statusText: {
        enumerable: true
    },
    headers: {
        enumerable: true
    },
    clone: {
        enumerable: true
    }
});
Object.defineProperty(Response.prototype, Symbol.toStringTag, {
    value: 'Response',
    writable: false,
    enumerable: false,
    configurable: true
});
const INTERNALS$2 = Symbol('Request internals');
const URL = __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["default"].URL || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$whatwg$2d$url$2f$lib$2f$public$2d$api$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].URL;
// fix an issue where "format", "parse" aren't a named export for node <10
const parse_url = __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["default"].parse;
const format_url = __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["default"].format;
/**
 * Wrapper around `new URL` to handle arbitrary URLs
 *
 * @param  {string} urlStr
 * @return {void}
 */ function parseURL(urlStr) {
    /*
 	Check whether the URL is absolute or not
 		Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
 	Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
 */ if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL(urlStr).toString();
    }
    // Fallback to old implementation for arbitrary URLs
    return parse_url(urlStr);
}
const streamDestructionSupported = 'destroy' in __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].Readable.prototype;
/**
 * Check if a value is an instance of Request.
 *
 * @param   Mixed   input
 * @return  Boolean
 */ function isRequest(input) {
    return typeof input === 'object' && typeof input[INTERNALS$2] === 'object';
}
function isAbortSignal(signal) {
    const proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);
    return !!(proto && proto.constructor.name === 'AbortSignal');
}
/**
 * Request class
 *
 * @param   Mixed   input  Url or Request instance
 * @param   Object  init   Custom options
 * @return  Void
 */ class Request {
    constructor(input){
        let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        let parsedURL;
        // normalize input
        if (!isRequest(input)) {
            if (input && input.href) {
                // in order to support Node.js' Url objects; though WHATWG's URL objects
                // will fall into this branch also (since their `toString()` will return
                // `href` property anyway)
                parsedURL = parseURL(input.href);
            } else {
                // coerce input to a string before attempting to parse
                parsedURL = parseURL(`${input}`);
            }
            input = {};
        } else {
            parsedURL = parseURL(input.url);
        }
        let method = init.method || input.method || 'GET';
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
            throw new TypeError('Request with GET/HEAD method cannot have body');
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
            timeout: init.timeout || input.timeout || 0,
            size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody != null && !headers.has('Content-Type')) {
            const contentType = extractContentType(inputBody);
            if (contentType) {
                headers.append('Content-Type', contentType);
            }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ('signal' in init) signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
            throw new TypeError('Expected signal to be an instanceof AbortSignal');
        }
        this[INTERNALS$2] = {
            method,
            redirect: init.redirect || input.redirect || 'follow',
            headers,
            parsedURL,
            signal
        };
        // node-fetch-only options
        this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
        this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
    }
    get method() {
        return this[INTERNALS$2].method;
    }
    get url() {
        return format_url(this[INTERNALS$2].parsedURL);
    }
    get headers() {
        return this[INTERNALS$2].headers;
    }
    get redirect() {
        return this[INTERNALS$2].redirect;
    }
    get signal() {
        return this[INTERNALS$2].signal;
    }
    /**
  * Clone this request
  *
  * @return  Request
  */ clone() {
        return new Request(this);
    }
}
Body.mixIn(Request.prototype);
Object.defineProperty(Request.prototype, Symbol.toStringTag, {
    value: 'Request',
    writable: false,
    enumerable: false,
    configurable: true
});
Object.defineProperties(Request.prototype, {
    method: {
        enumerable: true
    },
    url: {
        enumerable: true
    },
    headers: {
        enumerable: true
    },
    redirect: {
        enumerable: true
    },
    clone: {
        enumerable: true
    },
    signal: {
        enumerable: true
    }
});
/**
 * Convert a Request to Node.js http request options.
 *
 * @param   Request  A Request instance
 * @return  Object   The options object to be passed to http.request
 */ function getNodeRequestOptions(request) {
    const parsedURL = request[INTERNALS$2].parsedURL;
    const headers = new Headers(request[INTERNALS$2].headers);
    // fetch step 1.3
    if (!headers.has('Accept')) {
        headers.set('Accept', '*/*');
    }
    // Basic fetch
    if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError('Only absolute URLs are supported');
    }
    if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError('Only HTTP(S) protocols are supported');
    }
    if (request.signal && request.body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].Readable && !streamDestructionSupported) {
        throw new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');
    }
    // HTTP-network-or-cache fetch steps 2.4-2.7
    let contentLengthValue = null;
    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = '0';
    }
    if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === 'number') {
            contentLengthValue = String(totalBytes);
        }
    }
    if (contentLengthValue) {
        headers.set('Content-Length', contentLengthValue);
    }
    // HTTP-network-or-cache fetch step 2.11
    if (!headers.has('User-Agent')) {
        headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
    }
    // HTTP-network-or-cache fetch step 2.15
    if (request.compress && !headers.has('Accept-Encoding')) {
        headers.set('Accept-Encoding', 'gzip,deflate');
    }
    let agent = request.agent;
    if (typeof agent === 'function') {
        agent = agent(parsedURL);
    }
    // HTTP-network fetch step 4.2
    // chunked encoding is handled by Node.js
    return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
    });
}
/**
 * abort-error.js
 *
 * AbortError interface for cancelled requests
 */ /**
 * Create AbortError instance
 *
 * @param   String      message      Error message for human
 * @return  AbortError
 */ function AbortError(message) {
    Error.call(this, message);
    this.type = 'aborted';
    this.message = message;
    // hide custom error implementation details from end-users
    Error.captureStackTrace(this, this.constructor);
}
AbortError.prototype = Object.create(Error.prototype);
AbortError.prototype.constructor = AbortError;
AbortError.prototype.name = 'AbortError';
const URL$1 = __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["default"].URL || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$whatwg$2d$url$2f$lib$2f$public$2d$api$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].URL;
// fix an issue where "PassThrough", "resolve" aren't a named export for node <10
const PassThrough$1 = __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].PassThrough;
const isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {
    const orig = new URL$1(original).hostname;
    const dest = new URL$1(destination).hostname;
    return orig === dest || orig[orig.length - dest.length - 1] === '.' && orig.endsWith(dest);
};
/**
 * isSameProtocol reports whether the two provided URLs use the same protocol.
 *
 * Both domains must already be in canonical form.
 * @param {string|URL} original
 * @param {string|URL} destination
 */ const isSameProtocol = function isSameProtocol(destination, original) {
    const orig = new URL$1(original).protocol;
    const dest = new URL$1(destination).protocol;
    return orig === dest;
};
/**
 * Fetch function
 *
 * @param   Mixed    url   Absolute url or Request instance
 * @param   Object   opts  Fetch options
 * @return  Promise
 */ function fetch(url, opts) {
    // allow custom promise
    if (!fetch.Promise) {
        throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
    }
    Body.Promise = fetch.Promise;
    // wrap http.request into fetch
    return new fetch.Promise(function(resolve, reject) {
        // build request object
        const request = new Request(url, opts);
        const options = getNodeRequestOptions(request);
        const send = (options.protocol === 'https:' ? __TURBOPACK__imported__module__$5b$externals$5d2f$https__$5b$external$5d$__$28$https$2c$__cjs$29$__["default"] : __TURBOPACK__imported__module__$5b$externals$5d2f$http__$5b$external$5d$__$28$http$2c$__cjs$29$__["default"]).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort() {
            let error = new AbortError('The user aborted a request.');
            reject(error);
            if (request.body && request.body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].Readable) {
                destroyStream(request.body, error);
            }
            if (!response || !response.body) return;
            response.body.emit('error', error);
        };
        if (signal && signal.aborted) {
            abort();
            return;
        }
        const abortAndFinalize = function abortAndFinalize() {
            abort();
            finalize();
        };
        // send request
        const req = send(options);
        let reqTimeout;
        if (signal) {
            signal.addEventListener('abort', abortAndFinalize);
        }
        function finalize() {
            req.abort();
            if (signal) signal.removeEventListener('abort', abortAndFinalize);
            clearTimeout(reqTimeout);
        }
        if (request.timeout) {
            req.once('socket', function(socket) {
                reqTimeout = setTimeout(function() {
                    reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));
                    finalize();
                }, request.timeout);
            });
        }
        req.on('error', function(err) {
            reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));
            if (response && response.body) {
                destroyStream(response.body, err);
            }
            finalize();
        });
        fixResponseChunkedTransferBadEnding(req, function(err) {
            if (signal && signal.aborted) {
                return;
            }
            if (response && response.body) {
                destroyStream(response.body, err);
            }
        });
        /* c8 ignore next 18 */ if (parseInt(process.version.substring(1)) < 14) {
            // Before Node.js 14, pipeline() does not fully support async iterators and does not always
            // properly handle when the socket close/end events are out of order.
            req.on('socket', function(s) {
                s.addListener('close', function(hadError) {
                    // if a data listener is still present we didn't end cleanly
                    const hasDataListener = s.listenerCount('data') > 0;
                    // if end happened before close but the socket didn't emit an error, do it now
                    if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
                        const err = new Error('Premature close');
                        err.code = 'ERR_STREAM_PREMATURE_CLOSE';
                        response.body.emit('error', err);
                    }
                });
            });
        }
        req.on('response', function(res) {
            clearTimeout(reqTimeout);
            const headers = createHeadersLenient(res.headers);
            // HTTP fetch step 5
            if (fetch.isRedirect(res.statusCode)) {
                // HTTP fetch step 5.2
                const location = headers.get('Location');
                // HTTP fetch step 5.3
                let locationURL = null;
                try {
                    locationURL = location === null ? null : new URL$1(location, request.url).toString();
                } catch (err) {
                    // error here can only be invalid URL in Location: header
                    // do not throw when options.redirect == manual
                    // let the user extract the errorneous redirect URL
                    if (request.redirect !== 'manual') {
                        reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));
                        finalize();
                        return;
                    }
                }
                // HTTP fetch step 5.5
                switch(request.redirect){
                    case 'error':
                        reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
                        finalize();
                        return;
                    case 'manual':
                        // node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.
                        if (locationURL !== null) {
                            // handle corrupted header
                            try {
                                headers.set('Location', locationURL);
                            } catch (err) {
                                // istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request
                                reject(err);
                            }
                        }
                        break;
                    case 'follow':
                        // HTTP-redirect fetch step 2
                        if (locationURL === null) {
                            break;
                        }
                        // HTTP-redirect fetch step 5
                        if (request.counter >= request.follow) {
                            reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
                            finalize();
                            return;
                        }
                        // HTTP-redirect fetch step 6 (counter increment)
                        // Create a new Request object.
                        const requestOpts = {
                            headers: new Headers(request.headers),
                            follow: request.follow,
                            counter: request.counter + 1,
                            agent: request.agent,
                            compress: request.compress,
                            method: request.method,
                            body: request.body,
                            signal: request.signal,
                            timeout: request.timeout,
                            size: request.size
                        };
                        if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                            for (const name of [
                                'authorization',
                                'www-authenticate',
                                'cookie',
                                'cookie2'
                            ]){
                                requestOpts.headers.delete(name);
                            }
                        }
                        // HTTP-redirect fetch step 9
                        if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                            reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
                            finalize();
                            return;
                        }
                        // HTTP-redirect fetch step 11
                        if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {
                            requestOpts.method = 'GET';
                            requestOpts.body = undefined;
                            requestOpts.headers.delete('content-length');
                        }
                        // HTTP-redirect fetch step 15
                        resolve(fetch(new Request(locationURL, requestOpts)));
                        finalize();
                        return;
                }
            }
            // prepare response
            res.once('end', function() {
                if (signal) signal.removeEventListener('abort', abortAndFinalize);
            });
            let body = res.pipe(new PassThrough$1());
            const response_options = {
                url: request.url,
                status: res.statusCode,
                statusText: res.statusMessage,
                headers: headers,
                size: request.size,
                timeout: request.timeout,
                counter: request.counter
            };
            // HTTP-network fetch step 12.1.1.3
            const codings = headers.get('Content-Encoding');
            // HTTP-network fetch step 12.1.1.4: handle content codings
            // in following scenarios we ignore compression support
            // 1. compression support is disabled
            // 2. HEAD request
            // 3. no Content-Encoding header
            // 4. no content response (204)
            // 5. content not modified response (304)
            if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {
                response = new Response(body, response_options);
                resolve(response);
                return;
            }
            // For Node v6+
            // Be less strict when decoding compressed responses, since sometimes
            // servers send slightly invalid responses that are still accepted
            // by common browsers.
            // Always using Z_SYNC_FLUSH is what cURL does.
            const zlibOptions = {
                flush: __TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].Z_SYNC_FLUSH,
                finishFlush: __TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].Z_SYNC_FLUSH
            };
            // for gzip
            if (codings == 'gzip' || codings == 'x-gzip') {
                body = body.pipe(__TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createGunzip(zlibOptions));
                response = new Response(body, response_options);
                resolve(response);
                return;
            }
            // for deflate
            if (codings == 'deflate' || codings == 'x-deflate') {
                // handle the infamous raw deflate response from old servers
                // a hack for old IIS and Apache servers
                const raw = res.pipe(new PassThrough$1());
                raw.once('data', function(chunk) {
                    // see http://stackoverflow.com/questions/37519828
                    if ((chunk[0] & 0x0F) === 0x08) {
                        body = body.pipe(__TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createInflate());
                    } else {
                        body = body.pipe(__TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createInflateRaw());
                    }
                    response = new Response(body, response_options);
                    resolve(response);
                });
                raw.on('end', function() {
                    // some old IIS servers return zero-length OK deflate responses, so 'data' is never emitted.
                    if (!response) {
                        response = new Response(body, response_options);
                        resolve(response);
                    }
                });
                return;
            }
            // for br
            if (codings == 'br' && typeof __TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createBrotliDecompress === 'function') {
                body = body.pipe(__TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createBrotliDecompress());
                response = new Response(body, response_options);
                resolve(response);
                return;
            }
            // otherwise, use response as-is
            response = new Response(body, response_options);
            resolve(response);
        });
        writeToStream(req, request);
    });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
    let socket;
    request.on('socket', function(s) {
        socket = s;
    });
    request.on('response', function(response) {
        const headers = response.headers;
        if (headers['transfer-encoding'] === 'chunked' && !headers['content-length']) {
            response.once('close', function(hadError) {
                // tests for socket presence, as in some situations the
                // the 'socket' event is not triggered for the request
                // (happens in deno), avoids `TypeError`
                // if a data listener is still present we didn't end cleanly
                const hasDataListener = socket && socket.listenerCount('data') > 0;
                if (hasDataListener && !hadError) {
                    const err = new Error('Premature close');
                    err.code = 'ERR_STREAM_PREMATURE_CLOSE';
                    errorCallback(err);
                }
            });
        }
    });
}
function destroyStream(stream, err) {
    if (stream.destroy) {
        stream.destroy(err);
    } else {
        // node < 8
        stream.emit('error', err);
        stream.end();
    }
}
/**
 * Redirect code matching
 *
 * @param   Number   code  Status code
 * @return  Boolean
 */ fetch.isRedirect = function(code) {
    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
};
// expose Promise
fetch.Promise = /*TURBOPACK member replacement*/ __turbopack_context__.g.Promise;
const __TURBOPACK__default__export__ = fetch;
;
}),
"[project]/node_modules/ms/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Helpers.
 */ var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */ module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
        return parse(val);
    } else if (type === 'number' && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */ function parse(str) {
    str = String(str);
    if (str.length > 100) {
        return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
        return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch(type){
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
            return n * y;
        case 'weeks':
        case 'week':
        case 'w':
            return n * w;
        case 'days':
        case 'day':
        case 'd':
            return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
            return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
            return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
            return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
            return n;
        default:
            return undefined;
    }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
        return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
}
/**
 * Pluralization helper.
 */ function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}
}),
"[project]/node_modules/debug/src/common.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */ function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = __turbopack_context__.r("[project]/node_modules/ms/index.js [app-route] (ecmascript)");
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key)=>{
        createDebug[key] = env[key];
    });
    /**
	* The currently active debug mode names, and names to skip.
	*/ createDebug.names = [];
    createDebug.skips = [];
    /**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/ createDebug.formatters = {};
    /**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/ function selectColor(namespace) {
        let hash = 0;
        for(let i = 0; i < namespace.length; i++){
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/ function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
            // Disabled?
            if (!debug.enabled) {
                return;
            }
            const self = debug;
            // Set `diff` timestamp
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== 'string') {
                // Anything else let's inspect with %O
                args.unshift('%O');
            }
            // Apply any `formatters` transformations
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                // If we encounter an escaped % then don't increase the array index
                if (match === '%%') {
                    return '%';
                }
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === 'function') {
                    const val = args[index];
                    match = formatter.call(self, val);
                    // Now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });
            // Apply env-specific formatting (colors, etc.)
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
        Object.defineProperty(debug, 'enabled', {
            enumerable: true,
            configurable: false,
            get: ()=>{
                if (enableOverride !== null) {
                    return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                    namespacesCache = createDebug.namespaces;
                    enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
            },
            set: (v)=>{
                enableOverride = v;
            }
        });
        // Env-specific initialization logic for debug instances
        if (typeof createDebug.init === 'function') {
            createDebug.init(debug);
        }
        return debug;
    }
    function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
    }
    /**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/ function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === 'string' ? namespaces : '').trim().replace(/\s+/g, ',').split(',').filter(Boolean);
        for (const ns of split){
            if (ns[0] === '-') {
                createDebug.skips.push(ns.slice(1));
            } else {
                createDebug.names.push(ns);
            }
        }
    }
    /**
	 * Checks if the given string matches a namespace template, honoring
	 * asterisks as wildcards.
	 *
	 * @param {String} search
	 * @param {String} template
	 * @return {Boolean}
	 */ function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while(searchIndex < search.length){
            if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
                // Match character or proceed with wildcard
                if (template[templateIndex] === '*') {
                    starIndex = templateIndex;
                    matchIndex = searchIndex;
                    templateIndex++; // Skip the '*'
                } else {
                    searchIndex++;
                    templateIndex++;
                }
            } else if (starIndex !== -1) {
                // Backtrack to the last '*' and try to match more characters
                templateIndex = starIndex + 1;
                matchIndex++;
                searchIndex = matchIndex;
            } else {
                return false; // No match
            }
        }
        // Handle trailing '*' in template
        while(templateIndex < template.length && template[templateIndex] === '*'){
            templateIndex++;
        }
        return templateIndex === template.length;
    }
    /**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/ function disable() {
        const namespaces = [
            ...createDebug.names,
            ...createDebug.skips.map((namespace)=>'-' + namespace)
        ].join(',');
        createDebug.enable('');
        return namespaces;
    }
    /**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/ function enabled(name) {
        for (const skip of createDebug.skips){
            if (matchesTemplate(name, skip)) {
                return false;
            }
        }
        for (const ns of createDebug.names){
            if (matchesTemplate(name, ns)) {
                return true;
            }
        }
        return false;
    }
    /**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/ function coerce(val) {
        if (val instanceof Error) {
            return val.stack || val.message;
        }
        return val;
    }
    /**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/ function destroy() {
        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
    createDebug.enable(createDebug.load());
    return createDebug;
}
module.exports = setup;
}),
"[project]/node_modules/debug/src/node.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Module dependencies.
 */ const tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
/**
 * This is the Node.js implementation of `debug()`.
 */ exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(()=>{}, 'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
/**
 * Colors.
 */ exports.colors = [
    6,
    2,
    3,
    4,
    5,
    1
];
try {
    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
    // eslint-disable-next-line import/no-extraneous-dependencies
    const supportsColor = __turbopack_context__.r("[project]/node_modules/supports-color/index.js [app-route] (ecmascript)");
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
            20,
            21,
            26,
            27,
            32,
            33,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            56,
            57,
            62,
            63,
            68,
            69,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            92,
            93,
            98,
            99,
            112,
            113,
            128,
            129,
            134,
            135,
            148,
            149,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            178,
            179,
            184,
            185,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            214,
            215,
            220,
            221
        ];
    }
} catch (error) {
// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}
/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */ exports.inspectOpts = Object.keys(process.env).filter((key)=>{
    return /^debug_/i.test(key);
}).reduce((obj, key)=>{
    // Camel-case
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{
        return k.toUpperCase();
    });
    // Coerce string value into JS value
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
    } else if (val === 'null') {
        val = null;
    } else {
        val = Number(val);
    }
    obj[prop] = val;
    return obj;
}, {});
/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */ function useColors() {
    return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
}
/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    const { namespace: name, useColors } = this;
    if (useColors) {
        const c = this.color;
        const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
        const prefix = `  ${colorCode};1m${name} \u001B[0m`;
        args[0] = prefix + args[0].split('\n').join('\n' + prefix);
        args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
    } else {
        args[0] = getDate() + name + ' ' + args[0];
    }
}
function getDate() {
    if (exports.inspectOpts.hideDate) {
        return '';
    }
    return new Date().toISOString() + ' ';
}
/**
 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
 */ function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    if (namespaces) {
        process.env.DEBUG = namespaces;
    } else {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    return process.env.DEBUG;
}
/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */ function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for(let i = 0; i < keys.length; i++){
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/debug/src/common.js [app-route] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %o to `util.inspect()`, all on a single line.
 */ formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split('\n').map((str)=>str.trim()).join(' ');
};
/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */ formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
};
}),
"[project]/node_modules/debug/src/browser.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/* eslint-env browser */ /**
 * This is the web browser implementation of `debug()`.
 */ exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (()=>{
    let warned = false;
    return ()=>{
        if (!warned) {
            warned = true;
            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
    };
})();
/**
 * Colors.
 */ exports.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33'
];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */ // eslint-disable-next-line complexity
function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    // Internet Explorer and Edge do not support colors.
    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
    }
    let m;
    // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    // eslint-disable-next-line no-return-assign
    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || ("TURBOPACK compile-time value", "undefined") !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
    if (!this.useColors) {
        return;
    }
    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit');
    // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match)=>{
        if (match === '%%') {
            return;
        }
        index++;
        if (match === '%c') {
            // We only are interested in the *last* %c
            // (the user may have provided their own)
            lastC = index;
        }
    });
    args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */ exports.log = console.debug || console.log || (()=>{});
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    try {
        if (namespaces) {
            exports.storage.setItem('debug', namespaces);
        } else {
            exports.storage.removeItem('debug');
        }
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    let r;
    try {
        r = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG');
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
    }
    return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */ function localstorage() {
    try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/debug/src/common.js [app-route] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */ formatters.j = function(v) {
    try {
        return JSON.stringify(v);
    } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
    }
};
}),
"[project]/node_modules/debug/src/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */ if (typeof process === 'undefined' || process.type === 'renderer' || ("TURBOPACK compile-time value", false) === true || process.__nwjs) {
    module.exports = __turbopack_context__.r("[project]/node_modules/debug/src/browser.js [app-route] (ecmascript)");
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/debug/src/node.js [app-route] (ecmascript)");
}
}),
"[project]/node_modules/has-flag/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = (flag, argv = process.argv)=>{
    const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf('--');
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};
}),
"[project]/node_modules/supports-color/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
const tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
const hasFlag = __turbopack_context__.r("[project]/node_modules/has-flag/index.js [app-route] (ecmascript)");
const { env } = process;
let forceColor;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
    forceColor = 0;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
    forceColor = 1;
}
if ('FORCE_COLOR' in env) {
    if (env.FORCE_COLOR === 'true') {
        forceColor = 1;
    } else if (env.FORCE_COLOR === 'false') {
        forceColor = 0;
    } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
}
function translateLevel(level) {
    if (level === 0) {
        return false;
    }
    return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
    };
}
function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
        return 0;
    }
    if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
        return 3;
    }
    if (hasFlag('color=256')) {
        return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
        return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === 'dumb') {
        return min;
    }
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    if ('CI' in env) {
        if ([
            'TRAVIS',
            'CIRCLECI',
            'APPVEYOR',
            'GITLAB_CI',
            'GITHUB_ACTIONS',
            'BUILDKITE'
        ].some((sign)=>sign in env) || env.CI_NAME === 'codeship') {
            return 1;
        }
        return min;
    }
    if ('TEAMCITY_VERSION' in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === 'truecolor') {
        return 3;
    }
    if ('TERM_PROGRAM' in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
        switch(env.TERM_PROGRAM){
            case 'iTerm.app':
                return version >= 3 ? 3 : 2;
            case 'Apple_Terminal':
                return 2;
        }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
    }
    if ('COLORTERM' in env) {
        return 1;
    }
    return min;
}
function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
}
module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};
}),
"[project]/node_modules/agent-base/dist/src/promisify.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
function promisify(fn) {
    return function(req, opts) {
        return new Promise((resolve, reject)=>{
            fn.call(this, req, opts, (err, rtn)=>{
                if (err) {
                    reject(err);
                } else {
                    resolve(rtn);
                }
            });
        });
    };
}
exports.default = promisify; //# sourceMappingURL=promisify.js.map
}),
"[project]/node_modules/agent-base/dist/src/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
const events_1 = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
const debug_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)"));
const promisify_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/agent-base/dist/src/promisify.js [app-route] (ecmascript)"));
const debug = debug_1.default('agent-base');
function isAgent(v) {
    return Boolean(v) && typeof v.addRequest === 'function';
}
function isSecureEndpoint() {
    const { stack } = new Error();
    if (typeof stack !== 'string') return false;
    return stack.split('\n').some((l)=>l.indexOf('(https.js:') !== -1 || l.indexOf('node:https:') !== -1);
}
function createAgent(callback, opts) {
    return new createAgent.Agent(callback, opts);
}
(function(createAgent) {
    /**
     * Base `http.Agent` implementation.
     * No pooling/keep-alive is implemented by default.
     *
     * @param {Function} callback
     * @api public
     */ class Agent extends events_1.EventEmitter {
        constructor(callback, _opts){
            super();
            let opts = _opts;
            if (typeof callback === 'function') {
                this.callback = callback;
            } else if (callback) {
                opts = callback;
            }
            // Timeout for the socket to be returned from the callback
            this.timeout = null;
            if (opts && typeof opts.timeout === 'number') {
                this.timeout = opts.timeout;
            }
            // These aren't actually used by `agent-base`, but are required
            // for the TypeScript definition files in `@types/node` :/
            this.maxFreeSockets = 1;
            this.maxSockets = 1;
            this.maxTotalSockets = Infinity;
            this.sockets = {};
            this.freeSockets = {};
            this.requests = {};
            this.options = {};
        }
        get defaultPort() {
            if (typeof this.explicitDefaultPort === 'number') {
                return this.explicitDefaultPort;
            }
            return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
            this.explicitDefaultPort = v;
        }
        get protocol() {
            if (typeof this.explicitProtocol === 'string') {
                return this.explicitProtocol;
            }
            return isSecureEndpoint() ? 'https:' : 'http:';
        }
        set protocol(v) {
            this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
            throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        /**
         * Called by node-core's "_http_client.js" module when creating
         * a new HTTP request with this Agent instance.
         *
         * @api public
         */ addRequest(req, _opts) {
            const opts = Object.assign({}, _opts);
            if (typeof opts.secureEndpoint !== 'boolean') {
                opts.secureEndpoint = isSecureEndpoint();
            }
            if (opts.host == null) {
                opts.host = 'localhost';
            }
            if (opts.port == null) {
                opts.port = opts.secureEndpoint ? 443 : 80;
            }
            if (opts.protocol == null) {
                opts.protocol = opts.secureEndpoint ? 'https:' : 'http:';
            }
            if (opts.host && opts.path) {
                // If both a `host` and `path` are specified then it's most
                // likely the result of a `url.parse()` call... we need to
                // remove the `path` portion so that `net.connect()` doesn't
                // attempt to open that as a unix socket file.
                delete opts.path;
            }
            delete opts.agent;
            delete opts.hostname;
            delete opts._defaultAgent;
            delete opts.defaultPort;
            delete opts.createConnection;
            // Hint to use "Connection: close"
            // XXX: non-documented `http` module API :(
            req._last = true;
            req.shouldKeepAlive = false;
            let timedOut = false;
            let timeoutId = null;
            const timeoutMs = opts.timeout || this.timeout;
            const onerror = (err)=>{
                if (req._hadError) return;
                req.emit('error', err);
                // For Safety. Some additional errors might fire later on
                // and we need to make sure we don't double-fire the error event.
                req._hadError = true;
            };
            const ontimeout = ()=>{
                timeoutId = null;
                timedOut = true;
                const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
                err.code = 'ETIMEOUT';
                onerror(err);
            };
            const callbackError = (err)=>{
                if (timedOut) return;
                if (timeoutId !== null) {
                    clearTimeout(timeoutId);
                    timeoutId = null;
                }
                onerror(err);
            };
            const onsocket = (socket)=>{
                if (timedOut) return;
                if (timeoutId != null) {
                    clearTimeout(timeoutId);
                    timeoutId = null;
                }
                if (isAgent(socket)) {
                    // `socket` is actually an `http.Agent` instance, so
                    // relinquish responsibility for this `req` to the Agent
                    // from here on
                    debug('Callback returned another Agent instance %o', socket.constructor.name);
                    socket.addRequest(req, opts);
                    return;
                }
                if (socket) {
                    socket.once('free', ()=>{
                        this.freeSocket(socket, opts);
                    });
                    req.onSocket(socket);
                    return;
                }
                const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
                onerror(err);
            };
            if (typeof this.callback !== 'function') {
                onerror(new Error('`callback` is not defined'));
                return;
            }
            if (!this.promisifiedCallback) {
                if (this.callback.length >= 3) {
                    debug('Converting legacy callback function to promise');
                    this.promisifiedCallback = promisify_1.default(this.callback);
                } else {
                    this.promisifiedCallback = this.callback;
                }
            }
            if (typeof timeoutMs === 'number' && timeoutMs > 0) {
                timeoutId = setTimeout(ontimeout, timeoutMs);
            }
            if ('port' in opts && typeof opts.port !== 'number') {
                opts.port = Number(opts.port);
            }
            try {
                debug('Resolving socket for %o request: %o', opts.protocol, `${req.method} ${req.path}`);
                Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
            } catch (err) {
                Promise.reject(err).catch(callbackError);
            }
        }
        freeSocket(socket, opts) {
            debug('Freeing socket %o %o', socket.constructor.name, opts);
            socket.destroy();
        }
        destroy() {
            debug('Destroying agent %o', this.constructor.name);
        }
    }
    createAgent.Agent = Agent;
    // So that `instanceof` works correctly
    createAgent.prototype = createAgent.Agent.prototype;
})(createAgent || (createAgent = {}));
module.exports = createAgent; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/https-proxy-agent/dist/parse-proxy-response.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const debug_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)"));
const debug = debug_1.default('https-proxy-agent:parse-proxy-response');
function parseProxyResponse(socket) {
    return new Promise((resolve, reject)=>{
        // we need to buffer any HTTP traffic that happens with the proxy before we get
        // the CONNECT response, so that if the response is anything other than an "200"
        // response code, then we can re-play the "data" events on the socket once the
        // HTTP parser is hooked up...
        let buffersLength = 0;
        const buffers = [];
        function read() {
            const b = socket.read();
            if (b) ondata(b);
            else socket.once('readable', read);
        }
        function cleanup() {
            socket.removeListener('end', onend);
            socket.removeListener('error', onerror);
            socket.removeListener('close', onclose);
            socket.removeListener('readable', read);
        }
        function onclose(err) {
            debug('onclose had error %o', err);
        }
        function onend() {
            debug('onend');
        }
        function onerror(err) {
            cleanup();
            debug('onerror %o', err);
            reject(err);
        }
        function ondata(b) {
            buffers.push(b);
            buffersLength += b.length;
            const buffered = Buffer.concat(buffers, buffersLength);
            const endOfHeaders = buffered.indexOf('\r\n\r\n');
            if (endOfHeaders === -1) {
                // keep buffering
                debug('have not received end of HTTP headers yet...');
                read();
                return;
            }
            const firstLine = buffered.toString('ascii', 0, buffered.indexOf('\r\n'));
            const statusCode = +firstLine.split(' ')[1];
            debug('got proxy server response: %o', firstLine);
            resolve({
                statusCode,
                buffered
            });
        }
        socket.on('error', onerror);
        socket.on('close', onclose);
        socket.on('end', onend);
        read();
    });
}
exports.default = parseProxyResponse; //# sourceMappingURL=parse-proxy-response.js.map
}),
"[project]/node_modules/https-proxy-agent/dist/agent.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const net_1 = __importDefault(__turbopack_context__.r("[externals]/net [external] (net, cjs)"));
const tls_1 = __importDefault(__turbopack_context__.r("[externals]/tls [external] (tls, cjs)"));
const url_1 = __importDefault(__turbopack_context__.r("[externals]/url [external] (url, cjs)"));
const assert_1 = __importDefault(__turbopack_context__.r("[externals]/assert [external] (assert, cjs)"));
const debug_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)"));
const agent_base_1 = __turbopack_context__.r("[project]/node_modules/agent-base/dist/src/index.js [app-route] (ecmascript)");
const parse_proxy_response_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/https-proxy-agent/dist/parse-proxy-response.js [app-route] (ecmascript)"));
const debug = debug_1.default('https-proxy-agent:agent');
/**
 * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to
 * the specified "HTTP(s) proxy server" in order to proxy HTTPS requests.
 *
 * Outgoing HTTP requests are first tunneled through the proxy server using the
 * `CONNECT` HTTP request method to establish a connection to the proxy server,
 * and then the proxy server connects to the destination target and issues the
 * HTTP request from the proxy server.
 *
 * `https:` requests have their socket connection upgraded to TLS once
 * the connection to the proxy server has been established.
 *
 * @api public
 */ class HttpsProxyAgent extends agent_base_1.Agent {
    constructor(_opts){
        let opts;
        if (typeof _opts === 'string') {
            opts = url_1.default.parse(_opts);
        } else {
            opts = _opts;
        }
        if (!opts) {
            throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');
        }
        debug('creating new HttpsProxyAgent instance: %o', opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        // If `true`, then connect to the proxy server over TLS.
        // Defaults to `false`.
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        // Prefer `hostname` over `host`, and set the `port` if needed.
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === 'string') {
            proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
            proxy.port = this.secureProxy ? 443 : 80;
        }
        // ALPN is supported by Node.js >= v5.
        // attempt to negotiate http/1.1 for proxy servers that support http/2
        if (this.secureProxy && !('ALPNProtocols' in proxy)) {
            proxy.ALPNProtocols = [
                'http 1.1'
            ];
        }
        if (proxy.host && proxy.path) {
            // If both a `host` and `path` are specified then it's most likely
            // the result of a `url.parse()` call... we need to remove the
            // `path` portion so that `net.connect()` doesn't attempt to open
            // that as a Unix socket file.
            delete proxy.path;
            delete proxy.pathname;
        }
        this.proxy = proxy;
    }
    /**
     * Called when the node-core HTTP client library is creating a
     * new HTTP request.
     *
     * @api protected
     */ callback(req, opts) {
        return __awaiter(this, void 0, void 0, function*() {
            const { proxy, secureProxy } = this;
            // Create a socket connection to the proxy server.
            let socket;
            if (secureProxy) {
                debug('Creating `tls.Socket`: %o', proxy);
                socket = tls_1.default.connect(proxy);
            } else {
                debug('Creating `net.Socket`: %o', proxy);
                socket = net_1.default.connect(proxy);
            }
            const headers = Object.assign({}, proxy.headers);
            const hostname = `${opts.host}:${opts.port}`;
            let payload = `CONNECT ${hostname} HTTP/1.1\r\n`;
            // Inject the `Proxy-Authorization` header if necessary.
            if (proxy.auth) {
                headers['Proxy-Authorization'] = `Basic ${Buffer.from(proxy.auth).toString('base64')}`;
            }
            // The `Host` header should only include the port
            // number when it is not the default port.
            let { host, port, secureEndpoint } = opts;
            if (!isDefaultPort(port, secureEndpoint)) {
                host += `:${port}`;
            }
            headers.Host = host;
            headers.Connection = 'close';
            for (const name of Object.keys(headers)){
                payload += `${name}: ${headers[name]}\r\n`;
            }
            const proxyResponsePromise = parse_proxy_response_1.default(socket);
            socket.write(`${payload}\r\n`);
            const { statusCode, buffered } = yield proxyResponsePromise;
            if (statusCode === 200) {
                req.once('socket', resume);
                if (opts.secureEndpoint) {
                    // The proxy is connecting to a TLS server, so upgrade
                    // this socket connection to a TLS connection.
                    debug('Upgrading socket connection to TLS');
                    const servername = opts.servername || opts.host;
                    return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, 'host', 'hostname', 'path', 'port')), {
                        socket,
                        servername
                    }));
                }
                return socket;
            }
            // Some other status code that's not 200... need to re-play the HTTP
            // header "data" events onto the socket once the HTTP machinery is
            // attached so that the node core `http` can parse and handle the
            // error status code.
            // Close the original socket, and a new "fake" socket is returned
            // instead, so that the proxy doesn't get the HTTP request
            // written to it (which may contain `Authorization` headers or other
            // sensitive data).
            //
            // See: https://hackerone.com/reports/541502
            socket.destroy();
            const fakeSocket = new net_1.default.Socket({
                writable: false
            });
            fakeSocket.readable = true;
            // Need to wait for the "socket" event to re-play the "data" events.
            req.once('socket', (s)=>{
                debug('replaying proxy buffer for failed request');
                assert_1.default(s.listenerCount('data') > 0);
                // Replay the "buffered" Buffer onto the fake `socket`, since at
                // this point the HTTP module machinery has been hooked up for
                // the user.
                s.push(buffered);
                s.push(null);
            });
            return fakeSocket;
        });
    }
}
exports.default = HttpsProxyAgent;
function resume(socket) {
    socket.resume();
}
function isDefaultPort(port, secure) {
    return Boolean(!secure && port === 80 || secure && port === 443);
}
function isHTTPS(protocol) {
    return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;
}
function omit(obj, ...keys) {
    const ret = {};
    let key;
    for(key in obj){
        if (!keys.includes(key)) {
            ret[key] = obj[key];
        }
    }
    return ret;
} //# sourceMappingURL=agent.js.map
}),
"[project]/node_modules/https-proxy-agent/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
const agent_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/https-proxy-agent/dist/agent.js [app-route] (ecmascript)"));
function createHttpsProxyAgent(opts) {
    return new agent_1.default(opts);
}
(function(createHttpsProxyAgent) {
    createHttpsProxyAgent.HttpsProxyAgent = agent_1.default;
    createHttpsProxyAgent.prototype = agent_1.default.prototype;
})(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
module.exports = createHttpsProxyAgent; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/delayed-stream/lib/delayed_stream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream;
var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
module.exports = DelayedStream;
function DelayedStream() {
    this.source = null;
    this.dataSize = 0;
    this.maxDataSize = 1024 * 1024;
    this.pauseStream = true;
    this._maxDataSizeExceeded = false;
    this._released = false;
    this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);
DelayedStream.create = function(source, options) {
    var delayedStream = new this();
    options = options || {};
    for(var option in options){
        delayedStream[option] = options[option];
    }
    delayedStream.source = source;
    var realEmit = source.emit;
    source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
    };
    source.on('error', function() {});
    if (delayedStream.pauseStream) {
        source.pause();
    }
    return delayedStream;
};
Object.defineProperty(DelayedStream.prototype, 'readable', {
    configurable: true,
    enumerable: true,
    get: function() {
        return this.source.readable;
    }
});
DelayedStream.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments);
};
DelayedStream.prototype.resume = function() {
    if (!this._released) {
        this.release();
    }
    this.source.resume();
};
DelayedStream.prototype.pause = function() {
    this.source.pause();
};
DelayedStream.prototype.release = function() {
    this._released = true;
    this._bufferedEvents.forEach((function(args) {
        this.emit.apply(this, args);
    }).bind(this));
    this._bufferedEvents = [];
};
DelayedStream.prototype.pipe = function() {
    var r = Stream.prototype.pipe.apply(this, arguments);
    this.resume();
    return r;
};
DelayedStream.prototype._handleEmit = function(args) {
    if (this._released) {
        this.emit.apply(this, args);
        return;
    }
    if (args[0] === 'data') {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
    }
    this._bufferedEvents.push(args);
};
DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
    if (this._maxDataSizeExceeded) {
        return;
    }
    if (this.dataSize <= this.maxDataSize) {
        return;
    }
    this._maxDataSizeExceeded = true;
    var message = 'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
    this.emit('error', new Error(message));
};
}),
"[project]/node_modules/combined-stream/lib/combined_stream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream;
var DelayedStream = __turbopack_context__.r("[project]/node_modules/delayed-stream/lib/delayed_stream.js [app-route] (ecmascript)");
module.exports = CombinedStream;
function CombinedStream() {
    this.writable = false;
    this.readable = true;
    this.dataSize = 0;
    this.maxDataSize = 2 * 1024 * 1024;
    this.pauseStreams = true;
    this._released = false;
    this._streams = [];
    this._currentStream = null;
    this._insideLoop = false;
    this._pendingNext = false;
}
util.inherits(CombinedStream, Stream);
CombinedStream.create = function(options) {
    var combinedStream = new this();
    options = options || {};
    for(var option in options){
        combinedStream[option] = options[option];
    }
    return combinedStream;
};
CombinedStream.isStreamLike = function(stream) {
    return typeof stream !== 'function' && typeof stream !== 'string' && typeof stream !== 'boolean' && typeof stream !== 'number' && !Buffer.isBuffer(stream);
};
CombinedStream.prototype.append = function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
            var newStream = DelayedStream.create(stream, {
                maxDataSize: Infinity,
                pauseStream: this.pauseStreams
            });
            stream.on('data', this._checkDataSize.bind(this));
            stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
            stream.pause();
        }
    }
    this._streams.push(stream);
    return this;
};
CombinedStream.prototype.pipe = function(dest, options) {
    Stream.prototype.pipe.call(this, dest, options);
    this.resume();
    return dest;
};
CombinedStream.prototype._getNext = function() {
    this._currentStream = null;
    if (this._insideLoop) {
        this._pendingNext = true;
        return; // defer call
    }
    this._insideLoop = true;
    try {
        do {
            this._pendingNext = false;
            this._realGetNext();
        }while (this._pendingNext)
    } finally{
        this._insideLoop = false;
    }
};
CombinedStream.prototype._realGetNext = function() {
    var stream = this._streams.shift();
    if (typeof stream == 'undefined') {
        this.end();
        return;
    }
    if (typeof stream !== 'function') {
        this._pipeNext(stream);
        return;
    }
    var getStream = stream;
    getStream((function(stream) {
        var isStreamLike = CombinedStream.isStreamLike(stream);
        if (isStreamLike) {
            stream.on('data', this._checkDataSize.bind(this));
            this._handleErrors(stream);
        }
        this._pipeNext(stream);
    }).bind(this));
};
CombinedStream.prototype._pipeNext = function(stream) {
    this._currentStream = stream;
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
        stream.on('end', this._getNext.bind(this));
        stream.pipe(this, {
            end: false
        });
        return;
    }
    var value = stream;
    this.write(value);
    this._getNext();
};
CombinedStream.prototype._handleErrors = function(stream) {
    var self = this;
    stream.on('error', function(err) {
        self._emitError(err);
    });
};
CombinedStream.prototype.write = function(data) {
    this.emit('data', data);
};
CombinedStream.prototype.pause = function() {
    if (!this.pauseStreams) {
        return;
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == 'function') this._currentStream.pause();
    this.emit('pause');
};
CombinedStream.prototype.resume = function() {
    if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == 'function') this._currentStream.resume();
    this.emit('resume');
};
CombinedStream.prototype.end = function() {
    this._reset();
    this.emit('end');
};
CombinedStream.prototype.destroy = function() {
    this._reset();
    this.emit('close');
};
CombinedStream.prototype._reset = function() {
    this.writable = false;
    this._streams = [];
    this._currentStream = null;
};
CombinedStream.prototype._checkDataSize = function() {
    this._updateDataSize();
    if (this.dataSize <= this.maxDataSize) {
        return;
    }
    var message = 'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
    this._emitError(new Error(message));
};
CombinedStream.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var self = this;
    this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
            return;
        }
        self.dataSize += stream.dataSize;
    });
    if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
    }
};
CombinedStream.prototype._emitError = function(err) {
    this._reset();
    this.emit('error', err);
};
}),
"[project]/node_modules/mime-types/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ /**
 * Module dependencies.
 * @private
 */ var db = __turbopack_context__.r("[project]/node_modules/mime-db/index.js [app-route] (ecmascript)");
var extname = __turbopack_context__.r("[externals]/path [external] (path, cjs)").extname;
/**
 * Module variables.
 * @private
 */ var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
var TEXT_TYPE_REGEXP = /^text\//i;
/**
 * Module exports.
 * @public
 */ exports.charset = charset;
exports.charsets = {
    lookup: charset
};
exports.contentType = contentType;
exports.extension = extension;
exports.extensions = Object.create(null);
exports.lookup = lookup;
exports.types = Object.create(null);
// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types);
/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */ function charset(type) {
    if (!type || typeof type !== 'string') {
        return false;
    }
    // TODO: use media-typer
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
        return mime.charset;
    }
    // default text/* to utf-8
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return 'UTF-8';
    }
    return false;
}
/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */ function contentType(str) {
    // TODO: should this even be in this module?
    if (!str || typeof str !== 'string') {
        return false;
    }
    var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;
    if (!mime) {
        return false;
    }
    // TODO: use content-type or other module
    if (mime.indexOf('charset') === -1) {
        var charset = exports.charset(mime);
        if (charset) mime += '; charset=' + charset.toLowerCase();
    }
    return mime;
}
/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */ function extension(type) {
    if (!type || typeof type !== 'string') {
        return false;
    }
    // TODO: use media-typer
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    // get extensions
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
        return false;
    }
    return exts[0];
}
/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */ function lookup(path) {
    if (!path || typeof path !== 'string') {
        return false;
    }
    // get the extension ("ext" or ".ext" or full path)
    var extension = extname('x.' + path).toLowerCase().substr(1);
    if (!extension) {
        return false;
    }
    return exports.types[extension] || false;
}
/**
 * Populate the extensions and types maps.
 * @private
 */ function populateMaps(extensions, types) {
    // source preference (least -> most)
    var preference = [
        'nginx',
        'apache',
        undefined,
        'iana'
    ];
    Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
            return;
        }
        // mime -> extensions
        extensions[type] = exts;
        // extension -> mime
        for(var i = 0; i < exts.length; i++){
            var extension = exts[i];
            if (types[extension]) {
                var from = preference.indexOf(db[types[extension]].source);
                var to = preference.indexOf(mime.source);
                if (types[extension] !== 'application/octet-stream' && (from > to || from === to && types[extension].substr(0, 12) === 'application/')) {
                    continue;
                }
            }
            // set the extension -> mime
            types[extension] = type;
        }
    });
}
}),
"[project]/node_modules/asynckit/lib/defer.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = defer;
/**
 * Runs provided function on next iteration of the event loop
 *
 * @param {function} fn - function to run
 */ function defer(fn) {
    var nextTick = typeof setImmediate == 'function' ? setImmediate : typeof process == 'object' && typeof process.nextTick == 'function' ? process.nextTick : null;
    if (nextTick) {
        nextTick(fn);
    } else {
        setTimeout(fn, 0);
    }
}
}),
"[project]/node_modules/asynckit/lib/async.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var defer = __turbopack_context__.r("[project]/node_modules/asynckit/lib/defer.js [app-route] (ecmascript)");
// API
module.exports = async;
/**
 * Runs provided callback asynchronously
 * even if callback itself is not
 *
 * @param   {function} callback - callback to invoke
 * @returns {function} - augmented callback
 */ function async(callback) {
    var isAsync = false;
    // check if async happened
    defer(function() {
        isAsync = true;
    });
    return function async_callback(err, result) {
        if (isAsync) {
            callback(err, result);
        } else {
            defer(function nextTick_callback() {
                callback(err, result);
            });
        }
    };
}
}),
"[project]/node_modules/asynckit/lib/abort.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// API
module.exports = abort;
/**
 * Aborts leftover active jobs
 *
 * @param {object} state - current state object
 */ function abort(state) {
    Object.keys(state.jobs).forEach(clean.bind(state));
    // reset leftover jobs
    state.jobs = {};
}
/**
 * Cleans up leftover job by invoking abort function for the provided job id
 *
 * @this  state
 * @param {string|number} key - job id to abort
 */ function clean(key) {
    if (typeof this.jobs[key] == 'function') {
        this.jobs[key]();
    }
}
}),
"[project]/node_modules/asynckit/lib/iterate.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var async = __turbopack_context__.r("[project]/node_modules/asynckit/lib/async.js [app-route] (ecmascript)"), abort = __turbopack_context__.r("[project]/node_modules/asynckit/lib/abort.js [app-route] (ecmascript)");
// API
module.exports = iterate;
/**
 * Iterates over each job object
 *
 * @param {array|object} list - array or object (named list) to iterate over
 * @param {function} iterator - iterator to run
 * @param {object} state - current job status
 * @param {function} callback - invoked when all elements processed
 */ function iterate(list, iterator, state, callback) {
    // store current index
    var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;
    state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        // don't repeat yourself
        // skip secondary callbacks
        if (!(key in state.jobs)) {
            return;
        }
        // clean up jobs
        delete state.jobs[key];
        if (error) {
            // don't process rest of the results
            // stop still active jobs
            // and reset the list
            abort(state);
        } else {
            state.results[key] = output;
        }
        // return salvaged results
        callback(error, state.results);
    });
}
/**
 * Runs iterator over provided job element
 *
 * @param   {function} iterator - iterator to invoke
 * @param   {string|number} key - key/index of the element in the list of jobs
 * @param   {mixed} item - job description
 * @param   {function} callback - invoked after iterator is done with the job
 * @returns {function|mixed} - job abort function or something else
 */ function runJob(iterator, key, item, callback) {
    var aborter;
    // allow shortcut if iterator expects only two arguments
    if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
    } else {
        aborter = iterator(item, key, async(callback));
    }
    return aborter;
}
}),
"[project]/node_modules/asynckit/lib/state.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// API
module.exports = state;
/**
 * Creates initial state object
 * for iteration over list
 *
 * @param   {array|object} list - list to iterate over
 * @param   {function|null} sortMethod - function to use for keys sort,
 *                                     or `null` to keep them as is
 * @returns {object} - initial state object
 */ function state(list, sortMethod) {
    var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
    };
    if (sortMethod) {
        // sort array keys based on it's values
        // sort object's keys just on own merit
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
            return sortMethod(list[a], list[b]);
        });
    }
    return initState;
}
}),
"[project]/node_modules/asynckit/lib/terminator.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var abort = __turbopack_context__.r("[project]/node_modules/asynckit/lib/abort.js [app-route] (ecmascript)"), async = __turbopack_context__.r("[project]/node_modules/asynckit/lib/async.js [app-route] (ecmascript)");
// API
module.exports = terminator;
/**
 * Terminates jobs in the attached state context
 *
 * @this  AsyncKitState#
 * @param {function} callback - final callback to invoke after termination
 */ function terminator(callback) {
    if (!Object.keys(this.jobs).length) {
        return;
    }
    // fast forward iteration index
    this.index = this.size;
    // abort jobs
    abort(this);
    // send back results we have so far
    async(callback)(null, this.results);
}
}),
"[project]/node_modules/asynckit/parallel.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var iterate = __turbopack_context__.r("[project]/node_modules/asynckit/lib/iterate.js [app-route] (ecmascript)"), initState = __turbopack_context__.r("[project]/node_modules/asynckit/lib/state.js [app-route] (ecmascript)"), terminator = __turbopack_context__.r("[project]/node_modules/asynckit/lib/terminator.js [app-route] (ecmascript)");
// Public API
module.exports = parallel;
/**
 * Runs iterator over provided array elements in parallel
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */ function parallel(list, iterator, callback) {
    var state = initState(list);
    while(state.index < (state['keyedList'] || list).length){
        iterate(list, iterator, state, function(error, result) {
            if (error) {
                callback(error, result);
                return;
            }
            // looks like it's the last one
            if (Object.keys(state.jobs).length === 0) {
                callback(null, state.results);
                return;
            }
        });
        state.index++;
    }
    return terminator.bind(state, callback);
}
}),
"[project]/node_modules/asynckit/serialOrdered.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var iterate = __turbopack_context__.r("[project]/node_modules/asynckit/lib/iterate.js [app-route] (ecmascript)"), initState = __turbopack_context__.r("[project]/node_modules/asynckit/lib/state.js [app-route] (ecmascript)"), terminator = __turbopack_context__.r("[project]/node_modules/asynckit/lib/terminator.js [app-route] (ecmascript)");
// Public API
module.exports = serialOrdered;
// sorting helpers
module.exports.ascending = ascending;
module.exports.descending = descending;
/**
 * Runs iterator over provided sorted array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} sortMethod - custom sort function
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */ function serialOrdered(list, iterator, sortMethod, callback) {
    var state = initState(list, sortMethod);
    iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
            callback(error, result);
            return;
        }
        state.index++;
        // are we there yet?
        if (state.index < (state['keyedList'] || list).length) {
            iterate(list, iterator, state, iteratorHandler);
            return;
        }
        // done here
        callback(null, state.results);
    });
    return terminator.bind(state, callback);
}
/*
 * -- Sort methods
 */ /**
 * sort helper to sort array elements in ascending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */ function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}
/**
 * sort helper to sort array elements in descending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */ function descending(a, b) {
    return -1 * ascending(a, b);
}
}),
"[project]/node_modules/asynckit/serial.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var serialOrdered = __turbopack_context__.r("[project]/node_modules/asynckit/serialOrdered.js [app-route] (ecmascript)");
// Public API
module.exports = serial;
/**
 * Runs iterator over provided array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */ function serial(list, iterator, callback) {
    return serialOrdered(list, iterator, null, callback);
}
}),
"[project]/node_modules/asynckit/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = {
    parallel: __turbopack_context__.r("[project]/node_modules/asynckit/parallel.js [app-route] (ecmascript)"),
    serial: __turbopack_context__.r("[project]/node_modules/asynckit/serial.js [app-route] (ecmascript)"),
    serialOrdered: __turbopack_context__.r("[project]/node_modules/asynckit/serialOrdered.js [app-route] (ecmascript)")
};
}),
"[project]/node_modules/es-object-atoms/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ module.exports = Object;
}),
"[project]/node_modules/es-errors/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ module.exports = Error;
}),
"[project]/node_modules/es-errors/eval.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./eval')} */ module.exports = EvalError;
}),
"[project]/node_modules/es-errors/range.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./range')} */ module.exports = RangeError;
}),
"[project]/node_modules/es-errors/ref.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./ref')} */ module.exports = ReferenceError;
}),
"[project]/node_modules/es-errors/syntax.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./syntax')} */ module.exports = SyntaxError;
}),
"[project]/node_modules/es-errors/type.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./type')} */ module.exports = TypeError;
}),
"[project]/node_modules/es-errors/uri.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./uri')} */ module.exports = URIError;
}),
"[project]/node_modules/math-intrinsics/abs.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./abs')} */ module.exports = Math.abs;
}),
"[project]/node_modules/math-intrinsics/floor.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./floor')} */ module.exports = Math.floor;
}),
"[project]/node_modules/math-intrinsics/max.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./max')} */ module.exports = Math.max;
}),
"[project]/node_modules/math-intrinsics/min.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./min')} */ module.exports = Math.min;
}),
"[project]/node_modules/math-intrinsics/pow.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./pow')} */ module.exports = Math.pow;
}),
"[project]/node_modules/math-intrinsics/round.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./round')} */ module.exports = Math.round;
}),
"[project]/node_modules/math-intrinsics/isNaN.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./isNaN')} */ module.exports = Number.isNaN || function isNaN(a) {
    return a !== a;
};
}),
"[project]/node_modules/math-intrinsics/sign.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $isNaN = __turbopack_context__.r("[project]/node_modules/math-intrinsics/isNaN.js [app-route] (ecmascript)");
/** @type {import('./sign')} */ module.exports = function sign(number) {
    if ($isNaN(number) || number === 0) {
        return number;
    }
    return number < 0 ? -1 : +1;
};
}),
"[project]/node_modules/gopd/gOPD.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./gOPD')} */ module.exports = Object.getOwnPropertyDescriptor;
}),
"[project]/node_modules/gopd/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ var $gOPD = __turbopack_context__.r("[project]/node_modules/gopd/gOPD.js [app-route] (ecmascript)");
if ($gOPD) {
    try {
        $gOPD([], 'length');
    } catch (e) {
        // IE 8 has a broken gOPD
        $gOPD = null;
    }
}
module.exports = $gOPD;
}),
"[project]/node_modules/es-define-property/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
    try {
        $defineProperty({}, 'a', {
            value: 1
        });
    } catch (e) {
        // IE 8 has a broken defineProperty
        $defineProperty = false;
    }
}
module.exports = $defineProperty;
}),
"[project]/node_modules/has-symbols/shams.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./shams')} */ /* eslint complexity: [2, 18], max-statements: [2, 33] */ module.exports = function hasSymbols() {
    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
        return false;
    }
    if (typeof Symbol.iterator === 'symbol') {
        return true;
    }
    /** @type {{ [k in symbol]?: unknown }} */ var obj = {};
    var sym = Symbol('test');
    var symObj = Object(sym);
    if (typeof sym === 'string') {
        return false;
    }
    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
        return false;
    }
    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
        return false;
    }
    // temp disabled per https://github.com/ljharb/object.assign/issues/17
    // if (sym instanceof Symbol) { return false; }
    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    // if (!(symObj instanceof Symbol)) { return false; }
    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
    var symVal = 42;
    obj[sym] = symVal;
    for(var _ in obj){
        return false;
    } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
        return false;
    }
    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
        return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === 'function') {
        // eslint-disable-next-line no-extra-parens
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
        }
    }
    return true;
};
}),
"[project]/node_modules/has-symbols/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __turbopack_context__.r("[project]/node_modules/has-symbols/shams.js [app-route] (ecmascript)");
/** @type {import('.')} */ module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== 'function') {
        return false;
    }
    if (typeof Symbol !== 'function') {
        return false;
    }
    if (typeof origSymbol('foo') !== 'symbol') {
        return false;
    }
    if (typeof Symbol('bar') !== 'symbol') {
        return false;
    }
    return hasSymbolSham();
};
}),
"[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./Reflect.getPrototypeOf')} */ module.exports = typeof Reflect !== 'undefined' && Reflect.getPrototypeOf || null;
}),
"[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $Object = __turbopack_context__.r("[project]/node_modules/es-object-atoms/index.js [app-route] (ecmascript)");
/** @type {import('./Object.getPrototypeOf')} */ module.exports = $Object.getPrototypeOf || null;
}),
"[project]/node_modules/get-proto/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var reflectGetProto = __turbopack_context__.r("[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-route] (ecmascript)");
var originalGetProto = __turbopack_context__.r("[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-route] (ecmascript)");
var getDunderProto = __turbopack_context__.r("[project]/node_modules/dunder-proto/get.js [app-route] (ecmascript)");
/** @type {import('.')} */ module.exports = reflectGetProto ? function getProto(O) {
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return reflectGetProto(O);
} : originalGetProto ? function getProto(O) {
    if (!O || typeof O !== 'object' && typeof O !== 'function') {
        throw new TypeError('getProto: not an object');
    }
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return originalGetProto(O);
} : getDunderProto ? function getProto(O) {
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return getDunderProto(O);
} : null;
}),
"[project]/node_modules/function-bind/implementation.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';
var concatty = function concatty(a, b) {
    var arr = [];
    for(var i = 0; i < a.length; i += 1){
        arr[i] = a[i];
    }
    for(var j = 0; j < b.length; j += 1){
        arr[j + a.length] = b[j];
    }
    return arr;
};
var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for(var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1){
        arr[j] = arrLike[i];
    }
    return arr;
};
var joiny = function(arr, joiner) {
    var str = '';
    for(var i = 0; i < arr.length; i += 1){
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};
module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
        if (this instanceof bound) {
            var result = target.apply(this, concatty(args, arguments));
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for(var i = 0; i < boundLength; i++){
        boundArgs[i] = '$' + i;
    }
    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }
    return bound;
};
}),
"[project]/node_modules/function-bind/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var implementation = __turbopack_context__.r("[project]/node_modules/function-bind/implementation.js [app-route] (ecmascript)");
module.exports = Function.prototype.bind || implementation;
}),
"[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./functionCall')} */ module.exports = Function.prototype.call;
}),
"[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./functionApply')} */ module.exports = Function.prototype.apply;
}),
"[project]/node_modules/call-bind-apply-helpers/reflectApply.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./reflectApply')} */ module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;
}),
"[project]/node_modules/call-bind-apply-helpers/actualApply.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-route] (ecmascript)");
var $apply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-route] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-route] (ecmascript)");
var $reflectApply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/reflectApply.js [app-route] (ecmascript)");
/** @type {import('./actualApply')} */ module.exports = $reflectApply || bind.call($call, $apply);
}),
"[project]/node_modules/call-bind-apply-helpers/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-route] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-route] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-route] (ecmascript)");
var $actualApply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/actualApply.js [app-route] (ecmascript)");
/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */ module.exports = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== 'function') {
        throw new $TypeError('a function is required');
    }
    return $actualApply(bind, $call, args);
};
}),
"[project]/node_modules/dunder-proto/get.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var callBind = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/index.js [app-route] (ecmascript)");
var gOPD = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-route] (ecmascript)");
var hasProtoAccessor;
try {
    // eslint-disable-next-line no-extra-parens, no-proto
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ [].__proto__ === Array.prototype;
} catch (e) {
    if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
        throw e;
    }
}
// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, '__proto__');
var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;
/** @type {import('./get')} */ module.exports = desc && typeof desc.get === 'function' ? callBind([
    desc.get
]) : typeof $getPrototypeOf === 'function' ? /** @type {import('./get')} */ function getDunder(value) {
    // eslint-disable-next-line eqeqeq
    return $getPrototypeOf(value == null ? value : $Object(value));
} : false;
}),
"[project]/node_modules/hasown/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-route] (ecmascript)");
/** @type {import('.')} */ module.exports = bind.call(call, $hasOwn);
}),
"[project]/node_modules/get-intrinsic/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var undefined1;
var $Object = __turbopack_context__.r("[project]/node_modules/es-object-atoms/index.js [app-route] (ecmascript)");
var $Error = __turbopack_context__.r("[project]/node_modules/es-errors/index.js [app-route] (ecmascript)");
var $EvalError = __turbopack_context__.r("[project]/node_modules/es-errors/eval.js [app-route] (ecmascript)");
var $RangeError = __turbopack_context__.r("[project]/node_modules/es-errors/range.js [app-route] (ecmascript)");
var $ReferenceError = __turbopack_context__.r("[project]/node_modules/es-errors/ref.js [app-route] (ecmascript)");
var $SyntaxError = __turbopack_context__.r("[project]/node_modules/es-errors/syntax.js [app-route] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-route] (ecmascript)");
var $URIError = __turbopack_context__.r("[project]/node_modules/es-errors/uri.js [app-route] (ecmascript)");
var abs = __turbopack_context__.r("[project]/node_modules/math-intrinsics/abs.js [app-route] (ecmascript)");
var floor = __turbopack_context__.r("[project]/node_modules/math-intrinsics/floor.js [app-route] (ecmascript)");
var max = __turbopack_context__.r("[project]/node_modules/math-intrinsics/max.js [app-route] (ecmascript)");
var min = __turbopack_context__.r("[project]/node_modules/math-intrinsics/min.js [app-route] (ecmascript)");
var pow = __turbopack_context__.r("[project]/node_modules/math-intrinsics/pow.js [app-route] (ecmascript)");
var round = __turbopack_context__.r("[project]/node_modules/math-intrinsics/round.js [app-route] (ecmascript)");
var sign = __turbopack_context__.r("[project]/node_modules/math-intrinsics/sign.js [app-route] (ecmascript)");
var $Function = Function;
// eslint-disable-next-line consistent-return
var getEvalledConstructor = function(expressionSyntax) {
    try {
        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
    } catch (e) {}
};
var $gOPD = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-route] (ecmascript)");
var $defineProperty = __turbopack_context__.r("[project]/node_modules/es-define-property/index.js [app-route] (ecmascript)");
var throwTypeError = function() {
    throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function() {
    try {
        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
        arguments.callee; // IE 8 does not throw here
        return throwTypeError;
    } catch (calleeThrows) {
        try {
            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
            return $gOPD(arguments, 'callee').get;
        } catch (gOPDthrows) {
            return throwTypeError;
        }
    }
}() : throwTypeError;
var hasSymbols = __turbopack_context__.r("[project]/node_modules/has-symbols/index.js [app-route] (ecmascript)")();
var getProto = __turbopack_context__.r("[project]/node_modules/get-proto/index.js [app-route] (ecmascript)");
var $ObjectGPO = __turbopack_context__.r("[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-route] (ecmascript)");
var $ReflectGPO = __turbopack_context__.r("[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-route] (ecmascript)");
var $apply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-route] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-route] (ecmascript)");
var needsEval = {};
var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);
var INTRINSICS = {
    __proto__: null,
    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
    '%Array%': Array,
    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
    '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
    '%AsyncFromSyncIteratorPrototype%': undefined,
    '%AsyncFunction%': needsEval,
    '%AsyncGenerator%': needsEval,
    '%AsyncGeneratorFunction%': needsEval,
    '%AsyncIteratorPrototype%': needsEval,
    '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
    '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
    '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
    '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
    '%Boolean%': Boolean,
    '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
    '%Date%': Date,
    '%decodeURI%': decodeURI,
    '%decodeURIComponent%': decodeURIComponent,
    '%encodeURI%': encodeURI,
    '%encodeURIComponent%': encodeURIComponent,
    '%Error%': $Error,
    '%eval%': eval,
    '%EvalError%': $EvalError,
    '%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
    '%Function%': $Function,
    '%GeneratorFunction%': needsEval,
    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
    '%isFinite%': isFinite,
    '%isNaN%': isNaN,
    '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
    '%JSON%': typeof JSON === 'object' ? JSON : undefined,
    '%Map%': typeof Map === 'undefined' ? undefined : Map,
    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
    '%Math%': Math,
    '%Number%': Number,
    '%Object%': $Object,
    '%Object.getOwnPropertyDescriptor%': $gOPD,
    '%parseFloat%': parseFloat,
    '%parseInt%': parseInt,
    '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
    '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
    '%RangeError%': $RangeError,
    '%ReferenceError%': $ReferenceError,
    '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
    '%RegExp%': RegExp,
    '%Set%': typeof Set === 'undefined' ? undefined : Set,
    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
    '%String%': String,
    '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
    '%Symbol%': hasSymbols ? Symbol : undefined,
    '%SyntaxError%': $SyntaxError,
    '%ThrowTypeError%': ThrowTypeError,
    '%TypedArray%': TypedArray,
    '%TypeError%': $TypeError,
    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
    '%URIError%': $URIError,
    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
    '%Function.prototype.call%': $call,
    '%Function.prototype.apply%': $apply,
    '%Object.defineProperty%': $defineProperty,
    '%Object.getPrototypeOf%': $ObjectGPO,
    '%Math.abs%': abs,
    '%Math.floor%': floor,
    '%Math.max%': max,
    '%Math.min%': min,
    '%Math.pow%': pow,
    '%Math.round%': round,
    '%Math.sign%': sign,
    '%Reflect.getPrototypeOf%': $ReflectGPO
};
if (getProto) {
    try {
        null.error; // eslint-disable-line no-unused-expressions
    } catch (e) {
        // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
        var errorProto = getProto(getProto(e));
        INTRINSICS['%Error.prototype%'] = errorProto;
    }
}
var doEval = function doEval(name) {
    var value;
    if (name === '%AsyncFunction%') {
        value = getEvalledConstructor('async function () {}');
    } else if (name === '%GeneratorFunction%') {
        value = getEvalledConstructor('function* () {}');
    } else if (name === '%AsyncGeneratorFunction%') {
        value = getEvalledConstructor('async function* () {}');
    } else if (name === '%AsyncGenerator%') {
        var fn = doEval('%AsyncGeneratorFunction%');
        if (fn) {
            value = fn.prototype;
        }
    } else if (name === '%AsyncIteratorPrototype%') {
        var gen = doEval('%AsyncGenerator%');
        if (gen && getProto) {
            value = getProto(gen.prototype);
        }
    }
    INTRINSICS[name] = value;
    return value;
};
var LEGACY_ALIASES = {
    __proto__: null,
    '%ArrayBufferPrototype%': [
        'ArrayBuffer',
        'prototype'
    ],
    '%ArrayPrototype%': [
        'Array',
        'prototype'
    ],
    '%ArrayProto_entries%': [
        'Array',
        'prototype',
        'entries'
    ],
    '%ArrayProto_forEach%': [
        'Array',
        'prototype',
        'forEach'
    ],
    '%ArrayProto_keys%': [
        'Array',
        'prototype',
        'keys'
    ],
    '%ArrayProto_values%': [
        'Array',
        'prototype',
        'values'
    ],
    '%AsyncFunctionPrototype%': [
        'AsyncFunction',
        'prototype'
    ],
    '%AsyncGenerator%': [
        'AsyncGeneratorFunction',
        'prototype'
    ],
    '%AsyncGeneratorPrototype%': [
        'AsyncGeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%BooleanPrototype%': [
        'Boolean',
        'prototype'
    ],
    '%DataViewPrototype%': [
        'DataView',
        'prototype'
    ],
    '%DatePrototype%': [
        'Date',
        'prototype'
    ],
    '%ErrorPrototype%': [
        'Error',
        'prototype'
    ],
    '%EvalErrorPrototype%': [
        'EvalError',
        'prototype'
    ],
    '%Float32ArrayPrototype%': [
        'Float32Array',
        'prototype'
    ],
    '%Float64ArrayPrototype%': [
        'Float64Array',
        'prototype'
    ],
    '%FunctionPrototype%': [
        'Function',
        'prototype'
    ],
    '%Generator%': [
        'GeneratorFunction',
        'prototype'
    ],
    '%GeneratorPrototype%': [
        'GeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%Int8ArrayPrototype%': [
        'Int8Array',
        'prototype'
    ],
    '%Int16ArrayPrototype%': [
        'Int16Array',
        'prototype'
    ],
    '%Int32ArrayPrototype%': [
        'Int32Array',
        'prototype'
    ],
    '%JSONParse%': [
        'JSON',
        'parse'
    ],
    '%JSONStringify%': [
        'JSON',
        'stringify'
    ],
    '%MapPrototype%': [
        'Map',
        'prototype'
    ],
    '%NumberPrototype%': [
        'Number',
        'prototype'
    ],
    '%ObjectPrototype%': [
        'Object',
        'prototype'
    ],
    '%ObjProto_toString%': [
        'Object',
        'prototype',
        'toString'
    ],
    '%ObjProto_valueOf%': [
        'Object',
        'prototype',
        'valueOf'
    ],
    '%PromisePrototype%': [
        'Promise',
        'prototype'
    ],
    '%PromiseProto_then%': [
        'Promise',
        'prototype',
        'then'
    ],
    '%Promise_all%': [
        'Promise',
        'all'
    ],
    '%Promise_reject%': [
        'Promise',
        'reject'
    ],
    '%Promise_resolve%': [
        'Promise',
        'resolve'
    ],
    '%RangeErrorPrototype%': [
        'RangeError',
        'prototype'
    ],
    '%ReferenceErrorPrototype%': [
        'ReferenceError',
        'prototype'
    ],
    '%RegExpPrototype%': [
        'RegExp',
        'prototype'
    ],
    '%SetPrototype%': [
        'Set',
        'prototype'
    ],
    '%SharedArrayBufferPrototype%': [
        'SharedArrayBuffer',
        'prototype'
    ],
    '%StringPrototype%': [
        'String',
        'prototype'
    ],
    '%SymbolPrototype%': [
        'Symbol',
        'prototype'
    ],
    '%SyntaxErrorPrototype%': [
        'SyntaxError',
        'prototype'
    ],
    '%TypedArrayPrototype%': [
        'TypedArray',
        'prototype'
    ],
    '%TypeErrorPrototype%': [
        'TypeError',
        'prototype'
    ],
    '%Uint8ArrayPrototype%': [
        'Uint8Array',
        'prototype'
    ],
    '%Uint8ClampedArrayPrototype%': [
        'Uint8ClampedArray',
        'prototype'
    ],
    '%Uint16ArrayPrototype%': [
        'Uint16Array',
        'prototype'
    ],
    '%Uint32ArrayPrototype%': [
        'Uint32Array',
        'prototype'
    ],
    '%URIErrorPrototype%': [
        'URIError',
        'prototype'
    ],
    '%WeakMapPrototype%': [
        'WeakMap',
        'prototype'
    ],
    '%WeakSetPrototype%': [
        'WeakSet',
        'prototype'
    ]
};
var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-route] (ecmascript)");
var hasOwn = __turbopack_context__.r("[project]/node_modules/hasown/index.js [app-route] (ecmascript)");
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === '%' && last !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
    } else if (last === '%' && first !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
    });
    return result;
};
/* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = '%' + alias[0] + '%';
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
            value = doEval(intrinsicName);
        }
        if (typeof value === 'undefined' && !allowMissing) {
            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
        }
        return {
            alias: alias,
            name: intrinsicName,
            value: value
        };
    }
    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};
module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== 'string' || name.length === 0) {
        throw new $TypeError('intrinsic name must be a non-empty string');
    }
    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
        throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([
            0,
            1
        ], alias));
    }
    for(var i = 1, isOwn = true; i < parts.length; i += 1){
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
            throw new $SyntaxError('property names with quotes must have matching quotes');
        }
        if (part === 'constructor' || !isOwn) {
            skipFurtherCaching = true;
        }
        intrinsicBaseName += '.' + part;
        intrinsicRealName = '%' + intrinsicBaseName + '%';
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
            if (!(part in value)) {
                if (!allowMissing) {
                    throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                }
                return void undefined;
            }
            if ($gOPD && i + 1 >= parts.length) {
                var desc = $gOPD(value, part);
                isOwn = !!desc;
                // By convention, when a data property is converted to an accessor
                // property to emulate a data property that does not suffer from
                // the override mistake, that accessor's getter is marked with
                // an `originalValue` property. Here, when we detect this, we
                // uphold the illusion by pretending to see that original data
                // property, i.e., returning the value rather than the getter
                // itself.
                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                    value = desc.get;
                } else {
                    value = value[part];
                }
            } else {
                isOwn = hasOwn(value, part);
                value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
                INTRINSICS[intrinsicRealName] = value;
            }
        }
    }
    return value;
};
}),
"[project]/node_modules/has-tostringtag/shams.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var hasSymbols = __turbopack_context__.r("[project]/node_modules/has-symbols/shams.js [app-route] (ecmascript)");
/** @type {import('.')} */ module.exports = function hasToStringTagShams() {
    return hasSymbols() && !!Symbol.toStringTag;
};
}),
"[project]/node_modules/es-set-tostringtag/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var GetIntrinsic = __turbopack_context__.r("[project]/node_modules/get-intrinsic/index.js [app-route] (ecmascript)");
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var hasToStringTag = __turbopack_context__.r("[project]/node_modules/has-tostringtag/shams.js [app-route] (ecmascript)")();
var hasOwn = __turbopack_context__.r("[project]/node_modules/hasown/index.js [app-route] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-route] (ecmascript)");
var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
/** @type {import('.')} */ module.exports = function setToStringTag(object, value) {
    var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
    var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
    if (typeof overrideIfSet !== 'undefined' && typeof overrideIfSet !== 'boolean' || typeof nonConfigurable !== 'undefined' && typeof nonConfigurable !== 'boolean') {
        throw new $TypeError('if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans');
    }
    if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
        if ($defineProperty) {
            $defineProperty(object, toStringTag, {
                configurable: !nonConfigurable,
                enumerable: false,
                value: value,
                writable: false
            });
        } else {
            object[toStringTag] = value; // eslint-disable-line no-param-reassign
        }
    }
};
}),
"[project]/node_modules/form-data/lib/populate.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// populates missing values
module.exports = function(dst, src) {
    Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop]; // eslint-disable-line no-param-reassign
    });
    return dst;
};
}),
"[project]/node_modules/form-data/lib/form_data.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var CombinedStream = __turbopack_context__.r("[project]/node_modules/combined-stream/lib/combined_stream.js [app-route] (ecmascript)");
var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
var path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
var http = __turbopack_context__.r("[externals]/http [external] (http, cjs)");
var https = __turbopack_context__.r("[externals]/https [external] (https, cjs)");
var parseUrl = __turbopack_context__.r("[externals]/url [external] (url, cjs)").parse;
var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream;
var crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
var mime = __turbopack_context__.r("[project]/node_modules/mime-types/index.js [app-route] (ecmascript)");
var asynckit = __turbopack_context__.r("[project]/node_modules/asynckit/index.js [app-route] (ecmascript)");
var setToStringTag = __turbopack_context__.r("[project]/node_modules/es-set-tostringtag/index.js [app-route] (ecmascript)");
var hasOwn = __turbopack_context__.r("[project]/node_modules/hasown/index.js [app-route] (ecmascript)");
var populate = __turbopack_context__.r("[project]/node_modules/form-data/lib/populate.js [app-route] (ecmascript)");
/**
 * Create readable "multipart/form-data" streams.
 * Can be used to submit forms
 * and file uploads to other web applications.
 *
 * @constructor
 * @param {object} options - Properties to be added/overriden for FormData and CombinedStream
 */ function FormData(options) {
    if (!(this instanceof FormData)) {
        return new FormData(options);
    }
    this._overheadLength = 0;
    this._valueLength = 0;
    this._valuesToMeasure = [];
    CombinedStream.call(this);
    options = options || {}; // eslint-disable-line no-param-reassign
    for(var option in options){
        this[option] = options[option];
    }
}
// make it a Stream
util.inherits(FormData, CombinedStream);
FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';
FormData.prototype.append = function(field, value, options) {
    options = options || {}; // eslint-disable-line no-param-reassign
    // allow filename as single option
    if (typeof options === 'string') {
        options = {
            filename: options
        }; // eslint-disable-line no-param-reassign
    }
    var append = CombinedStream.prototype.append.bind(this);
    // all that streamy business can't handle numbers
    if (typeof value === 'number' || value == null) {
        value = String(value); // eslint-disable-line no-param-reassign
    }
    // https://github.com/felixge/node-form-data/issues/38
    if (Array.isArray(value)) {
        /*
     * Please convert your array into string
     * the way web server expects it
     */ this._error(new Error('Arrays are not supported.'));
        return;
    }
    var header = this._multiPartHeader(field, value, options);
    var footer = this._multiPartFooter();
    append(header);
    append(value);
    append(footer);
    // pass along options.knownLength
    this._trackLength(header, value, options);
};
FormData.prototype._trackLength = function(header, value, options) {
    var valueLength = 0;
    /*
   * used w/ getLengthSync(), when length is known.
   * e.g. for streaming directly from a remote server,
   * w/ a known file a size, and not wanting to wait for
   * incoming file to finish to get its size.
   */ if (options.knownLength != null) {
        valueLength += Number(options.knownLength);
    } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
    } else if (typeof value === 'string') {
        valueLength = Buffer.byteLength(value);
    }
    this._valueLength += valueLength;
    // @check why add CRLF? does this account for custom/multiple CRLFs?
    this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;
    // empty or either doesn't have path or not an http response or not a stream
    if (!value || !value.path && !(value.readable && hasOwn(value, 'httpVersion')) && !(value instanceof Stream)) {
        return;
    }
    // no need to bother with the length
    if (!options.knownLength) {
        this._valuesToMeasure.push(value);
    }
};
FormData.prototype._lengthRetriever = function(value, callback) {
    if (hasOwn(value, 'fd')) {
        // take read range into a account
        // `end` = Infinity > read file till the end
        //
        // TODO: Looks like there is bug in Node fs.createReadStream
        // it doesn't respect `end` options without `start` options
        // Fix it when node fixes it.
        // https://github.com/joyent/node/issues/7819
        if (value.end != undefined && value.end != Infinity && value.start != undefined) {
            // when end specified
            // no need to calculate range
            // inclusive, starts with 0
            callback(null, value.end + 1 - (value.start ? value.start : 0)); // eslint-disable-line callback-return
        // not that fast snoopy
        } else {
            // still need to fetch file size from fs
            fs.stat(value.path, function(err, stat) {
                if (err) {
                    callback(err);
                    return;
                }
                // update final size based on the range options
                var fileSize = stat.size - (value.start ? value.start : 0);
                callback(null, fileSize);
            });
        }
    // or http response
    } else if (hasOwn(value, 'httpVersion')) {
        callback(null, Number(value.headers['content-length'])); // eslint-disable-line callback-return
    // or request stream http://github.com/mikeal/request
    } else if (hasOwn(value, 'httpModule')) {
        // wait till response come back
        value.on('response', function(response) {
            value.pause();
            callback(null, Number(response.headers['content-length']));
        });
        value.resume();
    // something else
    } else {
        callback('Unknown stream'); // eslint-disable-line callback-return
    }
};
FormData.prototype._multiPartHeader = function(field, value, options) {
    /*
   * custom header specified (as string)?
   * it becomes responsible for boundary
   * (e.g. to handle extra CRLFs on .NET servers)
   */ if (typeof options.header === 'string') {
        return options.header;
    }
    var contentDisposition = this._getContentDisposition(value, options);
    var contentType = this._getContentType(value, options);
    var contents = '';
    var headers = {
        // add custom disposition as third element or keep it two elements if not
        'Content-Disposition': [
            'form-data',
            'name="' + field + '"'
        ].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        'Content-Type': [].concat(contentType || [])
    };
    // allow custom headers.
    if (typeof options.header === 'object') {
        populate(headers, options.header);
    }
    var header;
    for(var prop in headers){
        if (hasOwn(headers, prop)) {
            header = headers[prop];
            // skip nullish headers.
            if (header == null) {
                continue; // eslint-disable-line no-restricted-syntax, no-continue
            }
            // convert all headers to arrays.
            if (!Array.isArray(header)) {
                header = [
                    header
                ];
            }
            // add non-empty headers.
            if (header.length) {
                contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
            }
        }
    }
    return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
};
FormData.prototype._getContentDisposition = function(value, options) {
    var filename;
    if (typeof options.filepath === 'string') {
        // custom filepath for relative paths
        filename = path.normalize(options.filepath).replace(/\\/g, '/');
    } else if (options.filename || value && (value.name || value.path)) {
        /*
     * custom filename take precedence
     * formidable and the browser add a name property
     * fs- and request- streams have path property
     */ filename = path.basename(options.filename || value && (value.name || value.path));
    } else if (value && value.readable && hasOwn(value, 'httpVersion')) {
        // or try http response
        filename = path.basename(value.client._httpMessage.path || '');
    }
    if (filename) {
        return 'filename="' + filename + '"';
    }
};
FormData.prototype._getContentType = function(value, options) {
    // use custom content-type above all
    var contentType = options.contentType;
    // or try `name` from formidable, browser
    if (!contentType && value && value.name) {
        contentType = mime.lookup(value.name);
    }
    // or try `path` from fs-, request- streams
    if (!contentType && value && value.path) {
        contentType = mime.lookup(value.path);
    }
    // or if it's http-reponse
    if (!contentType && value && value.readable && hasOwn(value, 'httpVersion')) {
        contentType = value.headers['content-type'];
    }
    // or guess it from the filepath or filename
    if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
    }
    // fallback to the default content type if `value` is not simple value
    if (!contentType && value && typeof value === 'object') {
        contentType = FormData.DEFAULT_CONTENT_TYPE;
    }
    return contentType;
};
FormData.prototype._multiPartFooter = function() {
    return (function(next) {
        var footer = FormData.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
            footer += this._lastBoundary();
        }
        next(footer);
    }).bind(this);
};
FormData.prototype._lastBoundary = function() {
    return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
};
FormData.prototype.getHeaders = function(userHeaders) {
    var header;
    var formHeaders = {
        'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
    };
    for(header in userHeaders){
        if (hasOwn(userHeaders, header)) {
            formHeaders[header.toLowerCase()] = userHeaders[header];
        }
    }
    return formHeaders;
};
FormData.prototype.setBoundary = function(boundary) {
    if (typeof boundary !== 'string') {
        throw new TypeError('FormData boundary must be a string');
    }
    this._boundary = boundary;
};
FormData.prototype.getBoundary = function() {
    if (!this._boundary) {
        this._generateBoundary();
    }
    return this._boundary;
};
FormData.prototype.getBuffer = function() {
    var dataBuffer = new Buffer.alloc(0); // eslint-disable-line new-cap
    var boundary = this.getBoundary();
    // Create the form content. Add Line breaks to the end of data.
    for(var i = 0, len = this._streams.length; i < len; i++){
        if (typeof this._streams[i] !== 'function') {
            // Add content to the buffer.
            if (Buffer.isBuffer(this._streams[i])) {
                dataBuffer = Buffer.concat([
                    dataBuffer,
                    this._streams[i]
                ]);
            } else {
                dataBuffer = Buffer.concat([
                    dataBuffer,
                    Buffer.from(this._streams[i])
                ]);
            }
            // Add break after content.
            if (typeof this._streams[i] !== 'string' || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
                dataBuffer = Buffer.concat([
                    dataBuffer,
                    Buffer.from(FormData.LINE_BREAK)
                ]);
            }
        }
    }
    // Add the footer and return the Buffer object.
    return Buffer.concat([
        dataBuffer,
        Buffer.from(this._lastBoundary())
    ]);
};
FormData.prototype._generateBoundary = function() {
    // This generates a 50 character boundary similar to those used by Firefox.
    // They are optimized for boyer-moore parsing.
    this._boundary = '--------------------------' + crypto.randomBytes(12).toString('hex');
};
// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually and add it as knownLength option
FormData.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;
    // Don't get confused, there are 3 "internal" streams for each keyval pair so it basically checks if there is any value added to the form
    if (this._streams.length) {
        knownLength += this._lastBoundary().length;
    }
    // https://github.com/form-data/form-data/issues/40
    if (!this.hasKnownLength()) {
        /*
     * Some async length retrievers are present
     * therefore synchronous length calculation is false.
     * Please use getLength(callback) to get proper length
     */ this._error(new Error('Cannot calculate proper length in synchronous way.'));
    }
    return knownLength;
};
// Public API to check if length of added values is known
// https://github.com/form-data/form-data/issues/196
// https://github.com/form-data/form-data/issues/262
FormData.prototype.hasKnownLength = function() {
    var hasKnownLength = true;
    if (this._valuesToMeasure.length) {
        hasKnownLength = false;
    }
    return hasKnownLength;
};
FormData.prototype.getLength = function(cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
        knownLength += this._lastBoundary().length;
    }
    if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
    }
    asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
            cb(err);
            return;
        }
        values.forEach(function(length) {
            knownLength += length;
        });
        cb(null, knownLength);
    });
};
FormData.prototype.submit = function(params, cb) {
    var request;
    var options;
    var defaults = {
        method: 'post'
    };
    // parse provided url if it's string or treat it as options object
    if (typeof params === 'string') {
        params = parseUrl(params); // eslint-disable-line no-param-reassign
        /* eslint sort-keys: 0 */ options = populate({
            port: params.port,
            path: params.pathname,
            host: params.hostname,
            protocol: params.protocol
        }, defaults);
    } else {
        options = populate(params, defaults);
        // if no port provided use default one
        if (!options.port) {
            options.port = options.protocol === 'https:' ? 443 : 80;
        }
    }
    // put that good code in getHeaders to some use
    options.headers = this.getHeaders(params.headers);
    // https if specified, fallback to http in any other case
    if (options.protocol === 'https:') {
        request = https.request(options);
    } else {
        request = http.request(options);
    }
    // get content length and fire away
    this.getLength((function(err, length) {
        if (err && err !== 'Unknown stream') {
            this._error(err);
            return;
        }
        // add content length
        if (length) {
            request.setHeader('Content-Length', length);
        }
        this.pipe(request);
        if (cb) {
            var onResponse;
            var callback = function(error, responce) {
                request.removeListener('error', callback);
                request.removeListener('response', onResponse);
                return cb.call(this, error, responce);
            };
            onResponse = callback.bind(this, null);
            request.on('error', callback);
            request.on('response', onResponse);
        }
    }).bind(this));
    return request;
};
FormData.prototype._error = function(err) {
    if (!this.error) {
        this.error = err;
        this.pause();
        this.emit('error', err);
    }
};
FormData.prototype.toString = function() {
    return '[object FormData]';
};
setToStringTag(FormData.prototype, 'FormData');
// Public API
module.exports = FormData;
}),
"[project]/node_modules/@sindresorhus/is/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/// <reference lib="es2018"/>
/// <reference lib="dom"/>
/// <reference types="node"/>
Object.defineProperty(exports, "__esModule", {
    value: true
});
const typedArrayTypeNames = [
    'Int8Array',
    'Uint8Array',
    'Uint8ClampedArray',
    'Int16Array',
    'Uint16Array',
    'Int32Array',
    'Uint32Array',
    'Float32Array',
    'Float64Array',
    'BigInt64Array',
    'BigUint64Array'
];
function isTypedArrayName(name) {
    return typedArrayTypeNames.includes(name);
}
const objectTypeNames = [
    'Function',
    'Generator',
    'AsyncGenerator',
    'GeneratorFunction',
    'AsyncGeneratorFunction',
    'AsyncFunction',
    'Observable',
    'Array',
    'Buffer',
    'Blob',
    'Object',
    'RegExp',
    'Date',
    'Error',
    'Map',
    'Set',
    'WeakMap',
    'WeakSet',
    'ArrayBuffer',
    'SharedArrayBuffer',
    'DataView',
    'Promise',
    'URL',
    'FormData',
    'URLSearchParams',
    'HTMLElement',
    ...typedArrayTypeNames
];
function isObjectTypeName(name) {
    return objectTypeNames.includes(name);
}
const primitiveTypeNames = [
    'null',
    'undefined',
    'string',
    'number',
    'bigint',
    'boolean',
    'symbol'
];
function isPrimitiveTypeName(name) {
    return primitiveTypeNames.includes(name);
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isOfType(type) {
    return (value)=>typeof value === type;
}
const { toString } = Object.prototype;
const getObjectType = (value)=>{
    const objectTypeName = toString.call(value).slice(8, -1);
    if (/HTML\w+Element/.test(objectTypeName) && is.domElement(value)) {
        return 'HTMLElement';
    }
    if (isObjectTypeName(objectTypeName)) {
        return objectTypeName;
    }
    return undefined;
};
const isObjectOfType = (type)=>(value)=>getObjectType(value) === type;
function is(value) {
    if (value === null) {
        return 'null';
    }
    switch(typeof value){
        case 'undefined':
            return 'undefined';
        case 'string':
            return 'string';
        case 'number':
            return 'number';
        case 'boolean':
            return 'boolean';
        case 'function':
            return 'Function';
        case 'bigint':
            return 'bigint';
        case 'symbol':
            return 'symbol';
        default:
    }
    if (is.observable(value)) {
        return 'Observable';
    }
    if (is.array(value)) {
        return 'Array';
    }
    if (is.buffer(value)) {
        return 'Buffer';
    }
    const tagType = getObjectType(value);
    if (tagType) {
        return tagType;
    }
    if (value instanceof String || value instanceof Boolean || value instanceof Number) {
        throw new TypeError('Please don\'t use object wrappers for primitive types');
    }
    return 'Object';
}
is.undefined = isOfType('undefined');
is.string = isOfType('string');
const isNumberType = isOfType('number');
is.number = (value)=>isNumberType(value) && !is.nan(value);
is.bigint = isOfType('bigint');
// eslint-disable-next-line @typescript-eslint/ban-types
is.function_ = isOfType('function');
is.null_ = (value)=>value === null;
is.class_ = (value)=>is.function_(value) && value.toString().startsWith('class ');
is.boolean = (value)=>value === true || value === false;
is.symbol = isOfType('symbol');
is.numericString = (value)=>is.string(value) && !is.emptyStringOrWhitespace(value) && !Number.isNaN(Number(value));
is.array = (value, assertion)=>{
    if (!Array.isArray(value)) {
        return false;
    }
    if (!is.function_(assertion)) {
        return true;
    }
    return value.every(assertion);
};
is.buffer = (value)=>{
    var _a, _b, _c, _d;
    return (_d = (_c = (_b = (_a = value) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.isBuffer) === null || _c === void 0 ? void 0 : _c.call(_b, value)) !== null && _d !== void 0 ? _d : false;
};
is.blob = (value)=>isObjectOfType('Blob')(value);
is.nullOrUndefined = (value)=>is.null_(value) || is.undefined(value);
is.object = (value)=>!is.null_(value) && (typeof value === 'object' || is.function_(value));
is.iterable = (value)=>{
    var _a;
    return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.iterator]);
};
is.asyncIterable = (value)=>{
    var _a;
    return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.asyncIterator]);
};
is.generator = (value)=>{
    var _a, _b;
    return is.iterable(value) && is.function_((_a = value) === null || _a === void 0 ? void 0 : _a.next) && is.function_((_b = value) === null || _b === void 0 ? void 0 : _b.throw);
};
is.asyncGenerator = (value)=>is.asyncIterable(value) && is.function_(value.next) && is.function_(value.throw);
is.nativePromise = (value)=>isObjectOfType('Promise')(value);
const hasPromiseAPI = (value)=>{
    var _a, _b;
    return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a.then) && is.function_((_b = value) === null || _b === void 0 ? void 0 : _b.catch);
};
is.promise = (value)=>is.nativePromise(value) || hasPromiseAPI(value);
is.generatorFunction = isObjectOfType('GeneratorFunction');
is.asyncGeneratorFunction = (value)=>getObjectType(value) === 'AsyncGeneratorFunction';
is.asyncFunction = (value)=>getObjectType(value) === 'AsyncFunction';
// eslint-disable-next-line no-prototype-builtins, @typescript-eslint/ban-types
is.boundFunction = (value)=>is.function_(value) && !value.hasOwnProperty('prototype');
is.regExp = isObjectOfType('RegExp');
is.date = isObjectOfType('Date');
is.error = isObjectOfType('Error');
is.map = (value)=>isObjectOfType('Map')(value);
is.set = (value)=>isObjectOfType('Set')(value);
is.weakMap = (value)=>isObjectOfType('WeakMap')(value);
is.weakSet = (value)=>isObjectOfType('WeakSet')(value);
is.int8Array = isObjectOfType('Int8Array');
is.uint8Array = isObjectOfType('Uint8Array');
is.uint8ClampedArray = isObjectOfType('Uint8ClampedArray');
is.int16Array = isObjectOfType('Int16Array');
is.uint16Array = isObjectOfType('Uint16Array');
is.int32Array = isObjectOfType('Int32Array');
is.uint32Array = isObjectOfType('Uint32Array');
is.float32Array = isObjectOfType('Float32Array');
is.float64Array = isObjectOfType('Float64Array');
is.bigInt64Array = isObjectOfType('BigInt64Array');
is.bigUint64Array = isObjectOfType('BigUint64Array');
is.arrayBuffer = isObjectOfType('ArrayBuffer');
is.sharedArrayBuffer = isObjectOfType('SharedArrayBuffer');
is.dataView = isObjectOfType('DataView');
is.enumCase = (value, targetEnum)=>Object.values(targetEnum).includes(value);
is.directInstanceOf = (instance, class_)=>Object.getPrototypeOf(instance) === class_.prototype;
is.urlInstance = (value)=>isObjectOfType('URL')(value);
is.urlString = (value)=>{
    if (!is.string(value)) {
        return false;
    }
    try {
        new URL(value); // eslint-disable-line no-new
        return true;
    } catch (_a) {
        return false;
    }
};
// Example: `is.truthy = (value: unknown): value is (not false | not 0 | not '' | not undefined | not null) => Boolean(value);`
is.truthy = (value)=>Boolean(value);
// Example: `is.falsy = (value: unknown): value is (not true | 0 | '' | undefined | null) => Boolean(value);`
is.falsy = (value)=>!value;
is.nan = (value)=>Number.isNaN(value);
is.primitive = (value)=>is.null_(value) || isPrimitiveTypeName(typeof value);
is.integer = (value)=>Number.isInteger(value);
is.safeInteger = (value)=>Number.isSafeInteger(value);
is.plainObject = (value)=>{
    // From: https://github.com/sindresorhus/is-plain-obj/blob/main/index.js
    if (toString.call(value) !== '[object Object]') {
        return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.getPrototypeOf({});
};
is.typedArray = (value)=>isTypedArrayName(getObjectType(value));
const isValidLength = (value)=>is.safeInteger(value) && value >= 0;
is.arrayLike = (value)=>!is.nullOrUndefined(value) && !is.function_(value) && isValidLength(value.length);
is.inRange = (value, range)=>{
    if (is.number(range)) {
        return value >= Math.min(0, range) && value <= Math.max(range, 0);
    }
    if (is.array(range) && range.length === 2) {
        return value >= Math.min(...range) && value <= Math.max(...range);
    }
    throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
};
const NODE_TYPE_ELEMENT = 1;
const DOM_PROPERTIES_TO_CHECK = [
    'innerHTML',
    'ownerDocument',
    'style',
    'attributes',
    'nodeValue'
];
is.domElement = (value)=>{
    return is.object(value) && value.nodeType === NODE_TYPE_ELEMENT && is.string(value.nodeName) && !is.plainObject(value) && DOM_PROPERTIES_TO_CHECK.every((property)=>property in value);
};
is.observable = (value)=>{
    var _a, _b, _c, _d;
    if (!value) {
        return false;
    }
    // eslint-disable-next-line no-use-extend-native/no-use-extend-native
    if (value === ((_b = (_a = value)[Symbol.observable]) === null || _b === void 0 ? void 0 : _b.call(_a))) {
        return true;
    }
    if (value === ((_d = (_c = value)['@@observable']) === null || _d === void 0 ? void 0 : _d.call(_c))) {
        return true;
    }
    return false;
};
is.nodeStream = (value)=>is.object(value) && is.function_(value.pipe) && !is.observable(value);
is.infinite = (value)=>value === Infinity || value === -Infinity;
const isAbsoluteMod2 = (remainder)=>(value)=>is.integer(value) && Math.abs(value % 2) === remainder;
is.evenInteger = isAbsoluteMod2(0);
is.oddInteger = isAbsoluteMod2(1);
is.emptyArray = (value)=>is.array(value) && value.length === 0;
is.nonEmptyArray = (value)=>is.array(value) && value.length > 0;
is.emptyString = (value)=>is.string(value) && value.length === 0;
const isWhiteSpaceString = (value)=>is.string(value) && !/\S/.test(value);
is.emptyStringOrWhitespace = (value)=>is.emptyString(value) || isWhiteSpaceString(value);
// TODO: Use `not ''` when the `not` operator is available.
is.nonEmptyString = (value)=>is.string(value) && value.length > 0;
// TODO: Use `not ''` when the `not` operator is available.
is.nonEmptyStringAndNotWhitespace = (value)=>is.string(value) && !is.emptyStringOrWhitespace(value);
is.emptyObject = (value)=>is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length === 0;
// TODO: Use `not` operator here to remove `Map` and `Set` from type guard:
// - https://github.com/Microsoft/TypeScript/pull/29317
is.nonEmptyObject = (value)=>is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length > 0;
is.emptySet = (value)=>is.set(value) && value.size === 0;
is.nonEmptySet = (value)=>is.set(value) && value.size > 0;
is.emptyMap = (value)=>is.map(value) && value.size === 0;
is.nonEmptyMap = (value)=>is.map(value) && value.size > 0;
// `PropertyKey` is any value that can be used as an object key (string, number, or symbol)
is.propertyKey = (value)=>is.any([
        is.string,
        is.number,
        is.symbol
    ], value);
is.formData = (value)=>isObjectOfType('FormData')(value);
is.urlSearchParams = (value)=>isObjectOfType('URLSearchParams')(value);
const predicateOnArray = (method, predicate, values)=>{
    if (!is.function_(predicate)) {
        throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
    }
    if (values.length === 0) {
        throw new TypeError('Invalid number of values');
    }
    return method.call(values, predicate);
};
is.any = (predicate, ...values)=>{
    const predicates = is.array(predicate) ? predicate : [
        predicate
    ];
    return predicates.some((singlePredicate)=>predicateOnArray(Array.prototype.some, singlePredicate, values));
};
is.all = (predicate, ...values)=>predicateOnArray(Array.prototype.every, predicate, values);
const assertType = (condition, description, value, options = {})=>{
    if (!condition) {
        const { multipleValues } = options;
        const valuesMessage = multipleValues ? `received values of types ${[
            ...new Set(value.map((singleValue)=>`\`${is(singleValue)}\``))
        ].join(', ')}` : `received value of type \`${is(value)}\``;
        throw new TypeError(`Expected value which is \`${description}\`, ${valuesMessage}.`);
    }
};
exports.assert = {
    // Unknowns.
    undefined: (value)=>assertType(is.undefined(value), 'undefined', value),
    string: (value)=>assertType(is.string(value), 'string', value),
    number: (value)=>assertType(is.number(value), 'number', value),
    bigint: (value)=>assertType(is.bigint(value), 'bigint', value),
    // eslint-disable-next-line @typescript-eslint/ban-types
    function_: (value)=>assertType(is.function_(value), 'Function', value),
    null_: (value)=>assertType(is.null_(value), 'null', value),
    class_: (value)=>assertType(is.class_(value), "Class" /* class_ */ , value),
    boolean: (value)=>assertType(is.boolean(value), 'boolean', value),
    symbol: (value)=>assertType(is.symbol(value), 'symbol', value),
    numericString: (value)=>assertType(is.numericString(value), "string with a number" /* numericString */ , value),
    array: (value, assertion)=>{
        const assert = assertType;
        assert(is.array(value), 'Array', value);
        if (assertion) {
            value.forEach(assertion);
        }
    },
    buffer: (value)=>assertType(is.buffer(value), 'Buffer', value),
    blob: (value)=>assertType(is.blob(value), 'Blob', value),
    nullOrUndefined: (value)=>assertType(is.nullOrUndefined(value), "null or undefined" /* nullOrUndefined */ , value),
    object: (value)=>assertType(is.object(value), 'Object', value),
    iterable: (value)=>assertType(is.iterable(value), "Iterable" /* iterable */ , value),
    asyncIterable: (value)=>assertType(is.asyncIterable(value), "AsyncIterable" /* asyncIterable */ , value),
    generator: (value)=>assertType(is.generator(value), 'Generator', value),
    asyncGenerator: (value)=>assertType(is.asyncGenerator(value), 'AsyncGenerator', value),
    nativePromise: (value)=>assertType(is.nativePromise(value), "native Promise" /* nativePromise */ , value),
    promise: (value)=>assertType(is.promise(value), 'Promise', value),
    generatorFunction: (value)=>assertType(is.generatorFunction(value), 'GeneratorFunction', value),
    asyncGeneratorFunction: (value)=>assertType(is.asyncGeneratorFunction(value), 'AsyncGeneratorFunction', value),
    // eslint-disable-next-line @typescript-eslint/ban-types
    asyncFunction: (value)=>assertType(is.asyncFunction(value), 'AsyncFunction', value),
    // eslint-disable-next-line @typescript-eslint/ban-types
    boundFunction: (value)=>assertType(is.boundFunction(value), 'Function', value),
    regExp: (value)=>assertType(is.regExp(value), 'RegExp', value),
    date: (value)=>assertType(is.date(value), 'Date', value),
    error: (value)=>assertType(is.error(value), 'Error', value),
    map: (value)=>assertType(is.map(value), 'Map', value),
    set: (value)=>assertType(is.set(value), 'Set', value),
    weakMap: (value)=>assertType(is.weakMap(value), 'WeakMap', value),
    weakSet: (value)=>assertType(is.weakSet(value), 'WeakSet', value),
    int8Array: (value)=>assertType(is.int8Array(value), 'Int8Array', value),
    uint8Array: (value)=>assertType(is.uint8Array(value), 'Uint8Array', value),
    uint8ClampedArray: (value)=>assertType(is.uint8ClampedArray(value), 'Uint8ClampedArray', value),
    int16Array: (value)=>assertType(is.int16Array(value), 'Int16Array', value),
    uint16Array: (value)=>assertType(is.uint16Array(value), 'Uint16Array', value),
    int32Array: (value)=>assertType(is.int32Array(value), 'Int32Array', value),
    uint32Array: (value)=>assertType(is.uint32Array(value), 'Uint32Array', value),
    float32Array: (value)=>assertType(is.float32Array(value), 'Float32Array', value),
    float64Array: (value)=>assertType(is.float64Array(value), 'Float64Array', value),
    bigInt64Array: (value)=>assertType(is.bigInt64Array(value), 'BigInt64Array', value),
    bigUint64Array: (value)=>assertType(is.bigUint64Array(value), 'BigUint64Array', value),
    arrayBuffer: (value)=>assertType(is.arrayBuffer(value), 'ArrayBuffer', value),
    sharedArrayBuffer: (value)=>assertType(is.sharedArrayBuffer(value), 'SharedArrayBuffer', value),
    dataView: (value)=>assertType(is.dataView(value), 'DataView', value),
    enumCase: (value, targetEnum)=>assertType(is.enumCase(value, targetEnum), 'EnumCase', value),
    urlInstance: (value)=>assertType(is.urlInstance(value), 'URL', value),
    urlString: (value)=>assertType(is.urlString(value), "string with a URL" /* urlString */ , value),
    truthy: (value)=>assertType(is.truthy(value), "truthy" /* truthy */ , value),
    falsy: (value)=>assertType(is.falsy(value), "falsy" /* falsy */ , value),
    nan: (value)=>assertType(is.nan(value), "NaN" /* nan */ , value),
    primitive: (value)=>assertType(is.primitive(value), "primitive" /* primitive */ , value),
    integer: (value)=>assertType(is.integer(value), "integer" /* integer */ , value),
    safeInteger: (value)=>assertType(is.safeInteger(value), "integer" /* safeInteger */ , value),
    plainObject: (value)=>assertType(is.plainObject(value), "plain object" /* plainObject */ , value),
    typedArray: (value)=>assertType(is.typedArray(value), "TypedArray" /* typedArray */ , value),
    arrayLike: (value)=>assertType(is.arrayLike(value), "array-like" /* arrayLike */ , value),
    domElement: (value)=>assertType(is.domElement(value), "HTMLElement" /* domElement */ , value),
    observable: (value)=>assertType(is.observable(value), 'Observable', value),
    nodeStream: (value)=>assertType(is.nodeStream(value), "Node.js Stream" /* nodeStream */ , value),
    infinite: (value)=>assertType(is.infinite(value), "infinite number" /* infinite */ , value),
    emptyArray: (value)=>assertType(is.emptyArray(value), "empty array" /* emptyArray */ , value),
    nonEmptyArray: (value)=>assertType(is.nonEmptyArray(value), "non-empty array" /* nonEmptyArray */ , value),
    emptyString: (value)=>assertType(is.emptyString(value), "empty string" /* emptyString */ , value),
    emptyStringOrWhitespace: (value)=>assertType(is.emptyStringOrWhitespace(value), "empty string or whitespace" /* emptyStringOrWhitespace */ , value),
    nonEmptyString: (value)=>assertType(is.nonEmptyString(value), "non-empty string" /* nonEmptyString */ , value),
    nonEmptyStringAndNotWhitespace: (value)=>assertType(is.nonEmptyStringAndNotWhitespace(value), "non-empty string and not whitespace" /* nonEmptyStringAndNotWhitespace */ , value),
    emptyObject: (value)=>assertType(is.emptyObject(value), "empty object" /* emptyObject */ , value),
    nonEmptyObject: (value)=>assertType(is.nonEmptyObject(value), "non-empty object" /* nonEmptyObject */ , value),
    emptySet: (value)=>assertType(is.emptySet(value), "empty set" /* emptySet */ , value),
    nonEmptySet: (value)=>assertType(is.nonEmptySet(value), "non-empty set" /* nonEmptySet */ , value),
    emptyMap: (value)=>assertType(is.emptyMap(value), "empty map" /* emptyMap */ , value),
    nonEmptyMap: (value)=>assertType(is.nonEmptyMap(value), "non-empty map" /* nonEmptyMap */ , value),
    propertyKey: (value)=>assertType(is.propertyKey(value), 'PropertyKey', value),
    formData: (value)=>assertType(is.formData(value), 'FormData', value),
    urlSearchParams: (value)=>assertType(is.urlSearchParams(value), 'URLSearchParams', value),
    // Numbers.
    evenInteger: (value)=>assertType(is.evenInteger(value), "even integer" /* evenInteger */ , value),
    oddInteger: (value)=>assertType(is.oddInteger(value), "odd integer" /* oddInteger */ , value),
    // Two arguments.
    directInstanceOf: (instance, class_)=>assertType(is.directInstanceOf(instance, class_), "T" /* directInstanceOf */ , instance),
    inRange: (value, range)=>assertType(is.inRange(value, range), "in range" /* inRange */ , value),
    // Variadic functions.
    any: (predicate, ...values)=>{
        return assertType(is.any(predicate, ...values), "predicate returns truthy for any value" /* any */ , values, {
            multipleValues: true
        });
    },
    all: (predicate, ...values)=>assertType(is.all(predicate, ...values), "predicate returns truthy for all values" /* all */ , values, {
            multipleValues: true
        })
};
// Some few keywords are reserved, but we'll populate them for Node.js users
// See https://github.com/Microsoft/TypeScript/issues/2536
Object.defineProperties(is, {
    class: {
        value: is.class_
    },
    function: {
        value: is.function_
    },
    null: {
        value: is.null_
    }
});
Object.defineProperties(exports.assert, {
    class: {
        value: exports.assert.class_
    },
    function: {
        value: exports.assert.function_
    },
    null: {
        value: exports.assert.null_
    }
});
exports.default = is;
// For CommonJS default export support
module.exports = is;
module.exports.default = is;
module.exports.assert = exports.assert;
}),
"[project]/node_modules/xml2js/lib/defaults.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// Generated by CoffeeScript 1.12.7
(function() {
    exports.defaults = {
        "0.1": {
            explicitCharkey: false,
            trim: true,
            normalize: true,
            normalizeTags: false,
            attrkey: "@",
            charkey: "#",
            explicitArray: false,
            ignoreAttrs: false,
            mergeAttrs: false,
            explicitRoot: false,
            validator: null,
            xmlns: false,
            explicitChildren: false,
            childkey: '@@',
            charsAsChildren: false,
            includeWhiteChars: false,
            async: false,
            strict: true,
            attrNameProcessors: null,
            attrValueProcessors: null,
            tagNameProcessors: null,
            valueProcessors: null,
            emptyTag: ''
        },
        "0.2": {
            explicitCharkey: false,
            trim: false,
            normalize: false,
            normalizeTags: false,
            attrkey: "$",
            charkey: "_",
            explicitArray: true,
            ignoreAttrs: false,
            mergeAttrs: false,
            explicitRoot: true,
            validator: null,
            xmlns: false,
            explicitChildren: false,
            preserveChildrenOrder: false,
            childkey: '$$',
            charsAsChildren: false,
            includeWhiteChars: false,
            async: false,
            strict: true,
            attrNameProcessors: null,
            attrValueProcessors: null,
            tagNameProcessors: null,
            valueProcessors: null,
            rootName: 'root',
            xmldec: {
                'version': '1.0',
                'encoding': 'UTF-8',
                'standalone': true
            },
            doctype: null,
            renderOpts: {
                'pretty': true,
                'indent': '  ',
                'newline': '\n'
            },
            headless: false,
            chunkSize: 10000,
            emptyTag: '',
            cdata: false
        }
    };
}).call(/*TURBOPACK member replacement*/ __turbopack_context__.e);
}),
"[project]/node_modules/xml2js/lib/builder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// Generated by CoffeeScript 1.12.7
(function() {
    "use strict";
    var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
    builder = __turbopack_context__.r("[project]/node_modules/xmlbuilder/lib/index.js [app-route] (ecmascript)");
    defaults = __turbopack_context__.r("[project]/node_modules/xml2js/lib/defaults.js [app-route] (ecmascript)").defaults;
    requiresCDATA = function(entry) {
        return typeof entry === "string" && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);
    };
    wrapCDATA = function(entry) {
        return "<![CDATA[" + escapeCDATA(entry) + "]]>";
    };
    escapeCDATA = function(entry) {
        return entry.replace(']]>', ']]]]><![CDATA[>');
    };
    exports.Builder = function() {
        function Builder(opts) {
            var key, ref, value;
            this.options = {};
            ref = defaults["0.2"];
            for(key in ref){
                if (!hasProp.call(ref, key)) continue;
                value = ref[key];
                this.options[key] = value;
            }
            for(key in opts){
                if (!hasProp.call(opts, key)) continue;
                value = opts[key];
                this.options[key] = value;
            }
        }
        Builder.prototype.buildObject = function(rootObj) {
            var attrkey, charkey, render, rootElement, rootName;
            attrkey = this.options.attrkey;
            charkey = this.options.charkey;
            if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults['0.2'].rootName) {
                rootName = Object.keys(rootObj)[0];
                rootObj = rootObj[rootName];
            } else {
                rootName = this.options.rootName;
            }
            render = function(_this) {
                return function(element, obj) {
                    var attr, child, entry, index, key, value;
                    if (typeof obj !== 'object') {
                        if (_this.options.cdata && requiresCDATA(obj)) {
                            element.raw(wrapCDATA(obj));
                        } else {
                            element.txt(obj);
                        }
                    } else if (Array.isArray(obj)) {
                        for(index in obj){
                            if (!hasProp.call(obj, index)) continue;
                            child = obj[index];
                            for(key in child){
                                entry = child[key];
                                element = render(element.ele(key), entry).up();
                            }
                        }
                    } else {
                        for(key in obj){
                            if (!hasProp.call(obj, key)) continue;
                            child = obj[key];
                            if (key === attrkey) {
                                if (typeof child === "object") {
                                    for(attr in child){
                                        value = child[attr];
                                        element = element.att(attr, value);
                                    }
                                }
                            } else if (key === charkey) {
                                if (_this.options.cdata && requiresCDATA(child)) {
                                    element = element.raw(wrapCDATA(child));
                                } else {
                                    element = element.txt(child);
                                }
                            } else if (Array.isArray(child)) {
                                for(index in child){
                                    if (!hasProp.call(child, index)) continue;
                                    entry = child[index];
                                    if (typeof entry === 'string') {
                                        if (_this.options.cdata && requiresCDATA(entry)) {
                                            element = element.ele(key).raw(wrapCDATA(entry)).up();
                                        } else {
                                            element = element.ele(key, entry).up();
                                        }
                                    } else {
                                        element = render(element.ele(key), entry).up();
                                    }
                                }
                            } else if (typeof child === "object") {
                                element = render(element.ele(key), child).up();
                            } else {
                                if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {
                                    element = element.ele(key).raw(wrapCDATA(child)).up();
                                } else {
                                    if (child == null) {
                                        child = '';
                                    }
                                    element = element.ele(key, child.toString()).up();
                                }
                            }
                        }
                    }
                    return element;
                };
            }(this);
            rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
                headless: this.options.headless,
                allowSurrogateChars: this.options.allowSurrogateChars
            });
            return render(rootElement, rootObj).end(this.options.renderOpts);
        };
        return Builder;
    }();
}).call(/*TURBOPACK member replacement*/ __turbopack_context__.e);
}),
"[project]/node_modules/xml2js/lib/bom.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// Generated by CoffeeScript 1.12.7
(function() {
    "use strict";
    exports.stripBOM = function(str) {
        if (str[0] === '\uFEFF') {
            return str.substring(1);
        } else {
            return str;
        }
    };
}).call(/*TURBOPACK member replacement*/ __turbopack_context__.e);
}),
"[project]/node_modules/xml2js/lib/processors.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// Generated by CoffeeScript 1.12.7
(function() {
    "use strict";
    var prefixMatch;
    prefixMatch = new RegExp(/(?!xmlns)^.*:/);
    exports.normalize = function(str) {
        return str.toLowerCase();
    };
    exports.firstCharLowerCase = function(str) {
        return str.charAt(0).toLowerCase() + str.slice(1);
    };
    exports.stripPrefix = function(str) {
        return str.replace(prefixMatch, '');
    };
    exports.parseNumbers = function(str) {
        if (!isNaN(str)) {
            str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
        }
        return str;
    };
    exports.parseBooleans = function(str) {
        if (/^(?:true|false)$/i.test(str)) {
            str = str.toLowerCase() === 'true';
        }
        return str;
    };
}).call(/*TURBOPACK member replacement*/ __turbopack_context__.e);
}),
"[project]/node_modules/xml2js/lib/parser.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// Generated by CoffeeScript 1.12.7
(function() {
    "use strict";
    var bom, defaults, defineProperty, events, isEmpty, processItem, processors, sax, setImmediate, bind = function(fn, me) {
        return function() {
            return fn.apply(me, arguments);
        };
    }, extend = function(child, parent) {
        for(var key in parent){
            if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    sax = __turbopack_context__.r("[project]/node_modules/sax/lib/sax.js [app-route] (ecmascript)");
    events = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
    bom = __turbopack_context__.r("[project]/node_modules/xml2js/lib/bom.js [app-route] (ecmascript)");
    processors = __turbopack_context__.r("[project]/node_modules/xml2js/lib/processors.js [app-route] (ecmascript)");
    setImmediate = __turbopack_context__.r("[externals]/timers [external] (timers, cjs)").setImmediate;
    defaults = __turbopack_context__.r("[project]/node_modules/xml2js/lib/defaults.js [app-route] (ecmascript)").defaults;
    isEmpty = function(thing) {
        return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
    };
    processItem = function(processors, item, key) {
        var i, len, process;
        for(i = 0, len = processors.length; i < len; i++){
            process = processors[i];
            item = process(item, key);
        }
        return item;
    };
    defineProperty = function(obj, key, value) {
        var descriptor;
        descriptor = Object.create(null);
        descriptor.value = value;
        descriptor.writable = true;
        descriptor.enumerable = true;
        descriptor.configurable = true;
        return Object.defineProperty(obj, key, descriptor);
    };
    exports.Parser = function(superClass) {
        extend(Parser, superClass);
        function Parser(opts) {
            this.parseStringPromise = bind(this.parseStringPromise, this);
            this.parseString = bind(this.parseString, this);
            this.reset = bind(this.reset, this);
            this.assignOrPush = bind(this.assignOrPush, this);
            this.processAsync = bind(this.processAsync, this);
            var key, ref, value;
            if (!(this instanceof exports.Parser)) {
                return new exports.Parser(opts);
            }
            this.options = {};
            ref = defaults["0.2"];
            for(key in ref){
                if (!hasProp.call(ref, key)) continue;
                value = ref[key];
                this.options[key] = value;
            }
            for(key in opts){
                if (!hasProp.call(opts, key)) continue;
                value = opts[key];
                this.options[key] = value;
            }
            if (this.options.xmlns) {
                this.options.xmlnskey = this.options.attrkey + "ns";
            }
            if (this.options.normalizeTags) {
                if (!this.options.tagNameProcessors) {
                    this.options.tagNameProcessors = [];
                }
                this.options.tagNameProcessors.unshift(processors.normalize);
            }
            this.reset();
        }
        Parser.prototype.processAsync = function() {
            var chunk, err;
            try {
                if (this.remaining.length <= this.options.chunkSize) {
                    chunk = this.remaining;
                    this.remaining = '';
                    this.saxParser = this.saxParser.write(chunk);
                    return this.saxParser.close();
                } else {
                    chunk = this.remaining.substr(0, this.options.chunkSize);
                    this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
                    this.saxParser = this.saxParser.write(chunk);
                    return setImmediate(this.processAsync);
                }
            } catch (error1) {
                err = error1;
                if (!this.saxParser.errThrown) {
                    this.saxParser.errThrown = true;
                    return this.emit(err);
                }
            }
        };
        Parser.prototype.assignOrPush = function(obj, key, newValue) {
            if (!(key in obj)) {
                if (!this.options.explicitArray) {
                    return defineProperty(obj, key, newValue);
                } else {
                    return defineProperty(obj, key, [
                        newValue
                    ]);
                }
            } else {
                if (!(obj[key] instanceof Array)) {
                    defineProperty(obj, key, [
                        obj[key]
                    ]);
                }
                return obj[key].push(newValue);
            }
        };
        Parser.prototype.reset = function() {
            var attrkey, charkey, ontext, stack;
            this.removeAllListeners();
            this.saxParser = sax.parser(this.options.strict, {
                trim: false,
                normalize: false,
                xmlns: this.options.xmlns
            });
            this.saxParser.errThrown = false;
            this.saxParser.onerror = function(_this) {
                return function(error) {
                    _this.saxParser.resume();
                    if (!_this.saxParser.errThrown) {
                        _this.saxParser.errThrown = true;
                        return _this.emit("error", error);
                    }
                };
            }(this);
            this.saxParser.onend = function(_this) {
                return function() {
                    if (!_this.saxParser.ended) {
                        _this.saxParser.ended = true;
                        return _this.emit("end", _this.resultObject);
                    }
                };
            }(this);
            this.saxParser.ended = false;
            this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
            this.resultObject = null;
            stack = [];
            attrkey = this.options.attrkey;
            charkey = this.options.charkey;
            this.saxParser.onopentag = function(_this) {
                return function(node) {
                    var key, newValue, obj, processedKey, ref;
                    obj = {};
                    obj[charkey] = "";
                    if (!_this.options.ignoreAttrs) {
                        ref = node.attributes;
                        for(key in ref){
                            if (!hasProp.call(ref, key)) continue;
                            if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                                obj[attrkey] = {};
                            }
                            newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                            processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                            if (_this.options.mergeAttrs) {
                                _this.assignOrPush(obj, processedKey, newValue);
                            } else {
                                defineProperty(obj[attrkey], processedKey, newValue);
                            }
                        }
                    }
                    obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
                    if (_this.options.xmlns) {
                        obj[_this.options.xmlnskey] = {
                            uri: node.uri,
                            local: node.local
                        };
                    }
                    return stack.push(obj);
                };
            }(this);
            this.saxParser.onclosetag = function(_this) {
                return function() {
                    var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
                    obj = stack.pop();
                    nodeName = obj["#name"];
                    if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
                        delete obj["#name"];
                    }
                    if (obj.cdata === true) {
                        cdata = obj.cdata;
                        delete obj.cdata;
                    }
                    s = stack[stack.length - 1];
                    if (obj[charkey].match(/^\s*$/) && !cdata) {
                        emptyStr = obj[charkey];
                        delete obj[charkey];
                    } else {
                        if (_this.options.trim) {
                            obj[charkey] = obj[charkey].trim();
                        }
                        if (_this.options.normalize) {
                            obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                        }
                        obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
                        if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                            obj = obj[charkey];
                        }
                    }
                    if (isEmpty(obj)) {
                        if (typeof _this.options.emptyTag === 'function') {
                            obj = _this.options.emptyTag();
                        } else {
                            obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;
                        }
                    }
                    if (_this.options.validator != null) {
                        xpath = "/" + (function() {
                            var i, len, results;
                            results = [];
                            for(i = 0, len = stack.length; i < len; i++){
                                node = stack[i];
                                results.push(node["#name"]);
                            }
                            return results;
                        })().concat(nodeName).join("/");
                        (function() {
                            var err;
                            try {
                                return obj = _this.options.validator(xpath, s && s[nodeName], obj);
                            } catch (error1) {
                                err = error1;
                                return _this.emit("error", err);
                            }
                        })();
                    }
                    if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
                        if (!_this.options.preserveChildrenOrder) {
                            node = {};
                            if (_this.options.attrkey in obj) {
                                node[_this.options.attrkey] = obj[_this.options.attrkey];
                                delete obj[_this.options.attrkey];
                            }
                            if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                                node[_this.options.charkey] = obj[_this.options.charkey];
                                delete obj[_this.options.charkey];
                            }
                            if (Object.getOwnPropertyNames(obj).length > 0) {
                                node[_this.options.childkey] = obj;
                            }
                            obj = node;
                        } else if (s) {
                            s[_this.options.childkey] = s[_this.options.childkey] || [];
                            objClone = {};
                            for(key in obj){
                                if (!hasProp.call(obj, key)) continue;
                                defineProperty(objClone, key, obj[key]);
                            }
                            s[_this.options.childkey].push(objClone);
                            delete obj["#name"];
                            if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                                obj = obj[charkey];
                            }
                        }
                    }
                    if (stack.length > 0) {
                        return _this.assignOrPush(s, nodeName, obj);
                    } else {
                        if (_this.options.explicitRoot) {
                            old = obj;
                            obj = {};
                            defineProperty(obj, nodeName, old);
                        }
                        _this.resultObject = obj;
                        _this.saxParser.ended = true;
                        return _this.emit("end", _this.resultObject);
                    }
                };
            }(this);
            ontext = function(_this) {
                return function(text) {
                    var charChild, s;
                    s = stack[stack.length - 1];
                    if (s) {
                        s[charkey] += text;
                        if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, '').trim() !== '')) {
                            s[_this.options.childkey] = s[_this.options.childkey] || [];
                            charChild = {
                                '#name': '__text__'
                            };
                            charChild[charkey] = text;
                            if (_this.options.normalize) {
                                charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                            }
                            s[_this.options.childkey].push(charChild);
                        }
                        return s;
                    }
                };
            }(this);
            this.saxParser.ontext = ontext;
            return this.saxParser.oncdata = function(_this) {
                return function(text) {
                    var s;
                    s = ontext(text);
                    if (s) {
                        return s.cdata = true;
                    }
                };
            }(this);
        };
        Parser.prototype.parseString = function(str, cb) {
            var err;
            if (cb != null && typeof cb === "function") {
                this.on("end", function(result) {
                    this.reset();
                    return cb(null, result);
                });
                this.on("error", function(err) {
                    this.reset();
                    return cb(err);
                });
            }
            try {
                str = str.toString();
                if (str.trim() === '') {
                    this.emit("end", null);
                    return true;
                }
                str = bom.stripBOM(str);
                if (this.options.async) {
                    this.remaining = str;
                    setImmediate(this.processAsync);
                    return this.saxParser;
                }
                return this.saxParser.write(str).close();
            } catch (error1) {
                err = error1;
                if (!(this.saxParser.errThrown || this.saxParser.ended)) {
                    this.emit('error', err);
                    return this.saxParser.errThrown = true;
                } else if (this.saxParser.ended) {
                    throw err;
                }
            }
        };
        Parser.prototype.parseStringPromise = function(str) {
            return new Promise(function(_this) {
                return function(resolve, reject) {
                    return _this.parseString(str, function(err, value) {
                        if (err) {
                            return reject(err);
                        } else {
                            return resolve(value);
                        }
                    });
                };
            }(this));
        };
        return Parser;
    }(events);
    exports.parseString = function(str, a, b) {
        var cb, options, parser;
        if (b != null) {
            if (typeof b === 'function') {
                cb = b;
            }
            if (typeof a === 'object') {
                options = a;
            }
        } else {
            if (typeof a === 'function') {
                cb = a;
            }
            options = {};
        }
        parser = new exports.Parser(options);
        return parser.parseString(str, cb);
    };
    exports.parseStringPromise = function(str, a) {
        var options, parser;
        if (typeof a === 'object') {
            options = a;
        }
        parser = new exports.Parser(options);
        return parser.parseStringPromise(str);
    };
}).call(/*TURBOPACK member replacement*/ __turbopack_context__.e);
}),
"[project]/node_modules/xml2js/lib/xml2js.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// Generated by CoffeeScript 1.12.7
(function() {
    "use strict";
    var builder, defaults, parser, processors, extend = function(child, parent) {
        for(var key in parent){
            if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    defaults = __turbopack_context__.r("[project]/node_modules/xml2js/lib/defaults.js [app-route] (ecmascript)");
    builder = __turbopack_context__.r("[project]/node_modules/xml2js/lib/builder.js [app-route] (ecmascript)");
    parser = __turbopack_context__.r("[project]/node_modules/xml2js/lib/parser.js [app-route] (ecmascript)");
    processors = __turbopack_context__.r("[project]/node_modules/xml2js/lib/processors.js [app-route] (ecmascript)");
    exports.defaults = defaults.defaults;
    exports.processors = processors;
    exports.ValidationError = function(superClass) {
        extend(ValidationError, superClass);
        function ValidationError(message) {
            this.message = message;
        }
        return ValidationError;
    }(Error);
    exports.Builder = builder.Builder;
    exports.Parser = parser.Parser;
    exports.parseString = parser.parseString;
    exports.parseStringPromise = parser.parseStringPromise;
}).call(/*TURBOPACK member replacement*/ __turbopack_context__.e);
}),
"[project]/node_modules/sax/lib/sax.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

;
(function(sax) {
    // wrapper for non-node envs
    sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
    };
    sax.SAXParser = SAXParser;
    sax.SAXStream = SAXStream;
    sax.createStream = createStream;
    // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
    // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
    // since that's the earliest that a buffer overrun could occur.  This way, checks are
    // as rare as required, but as often as necessary to ensure never crossing this bound.
    // Furthermore, buffers are only tested at most once per write(), so passing a very
    // large string into write() might have undesirable effects, but this is manageable by
    // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
    // edge case, result in creating at most one complete copy of the string passed in.
    // Set to Infinity to have unlimited buffers.
    sax.MAX_BUFFER_LENGTH = 64 * 1024;
    var buffers = [
        'comment',
        'sgmlDecl',
        'textNode',
        'tagName',
        'doctype',
        'procInstName',
        'procInstBody',
        'entity',
        'attribName',
        'attribValue',
        'cdata',
        'script'
    ];
    sax.EVENTS = [
        'text',
        'processinginstruction',
        'sgmldeclaration',
        'doctype',
        'comment',
        'opentagstart',
        'attribute',
        'opentag',
        'closetag',
        'opencdata',
        'cdata',
        'closecdata',
        'error',
        'end',
        'ready',
        'script',
        'opennamespace',
        'closenamespace'
    ];
    function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
            return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = '';
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        // namespaces form a prototype chain.
        // it always points at the current tag,
        // which protos to its parent tag.
        if (parser.opt.xmlns) {
            parser.ns = Object.create(rootNS);
        }
        // disallow unquoted attribute values if not otherwise configured
        // and strict mode is true
        if (parser.opt.unquotedAttributeValues === undefined) {
            parser.opt.unquotedAttributeValues = !strict;
        }
        // mostly just for error reporting
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
            parser.position = parser.line = parser.column = 0;
        }
        emit(parser, 'onready');
    }
    if (!Object.create) {
        Object.create = function(o) {
            function F() {}
            F.prototype = o;
            var newf = new F();
            return newf;
        };
    }
    if (!Object.keys) {
        Object.keys = function(o) {
            var a = [];
            for(var i in o)if (o.hasOwnProperty(i)) a.push(i);
            return a;
        };
    }
    function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for(var i = 0, l = buffers.length; i < l; i++){
            var len = parser[buffers[i]].length;
            if (len > maxAllowed) {
                // Text/cdata nodes can get big, and since they're buffered,
                // we can get here under normal conditions.
                // Avoid issues by emitting the text node now,
                // so at least it won't get any bigger.
                switch(buffers[i]){
                    case 'textNode':
                        closeText(parser);
                        break;
                    case 'cdata':
                        emitNode(parser, 'oncdata', parser.cdata);
                        parser.cdata = '';
                        break;
                    case 'script':
                        emitNode(parser, 'onscript', parser.script);
                        parser.script = '';
                        break;
                    default:
                        error(parser, 'Max buffer length exceeded: ' + buffers[i]);
                }
            }
            maxActual = Math.max(maxActual, len);
        }
        // schedule the next check for the earliest possible buffer overrun.
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
    }
    function clearBuffers(parser) {
        for(var i = 0, l = buffers.length; i < l; i++){
            parser[buffers[i]] = '';
        }
    }
    function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== '') {
            emitNode(parser, 'oncdata', parser.cdata);
            parser.cdata = '';
        }
        if (parser.script !== '') {
            emitNode(parser, 'onscript', parser.script);
            parser.script = '';
        }
    }
    SAXParser.prototype = {
        end: function() {
            end(this);
        },
        write: write,
        resume: function() {
            this.error = null;
            return this;
        },
        close: function() {
            return this.write(null);
        },
        flush: function() {
            flushBuffers(this);
        }
    };
    var Stream;
    try {
        Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream;
    } catch (ex) {
        Stream = function() {};
    }
    if (!Stream) Stream = function() {};
    var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== 'error' && ev !== 'end';
    });
    function createStream(strict, opt) {
        return new SAXStream(strict, opt);
    }
    function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
            return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
            me.emit('end');
        };
        this._parser.onerror = function(er) {
            me.emit('error', er);
            // if didn't throw, then means error was handled.
            // go ahead and clear error, so we can write again.
            me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
            Object.defineProperty(me, 'on' + ev, {
                get: function() {
                    return me._parser['on' + ev];
                },
                set: function(h) {
                    if (!h) {
                        me.removeAllListeners(ev);
                        me._parser['on' + ev] = h;
                        return h;
                    }
                    me.on(ev, h);
                },
                enumerable: true,
                configurable: false
            });
        });
    }
    SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
            value: SAXStream
        }
    });
    SAXStream.prototype.write = function(data) {
        if (typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(data)) {
            if (!this._decoder) {
                var SD = __turbopack_context__.r("[externals]/string_decoder [external] (string_decoder, cjs)").StringDecoder;
                this._decoder = new SD('utf8');
            }
            data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit('data', data);
        return true;
    };
    SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
            this.write(chunk);
        }
        this._parser.end();
        return true;
    };
    SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
            me._parser['on' + ev] = function() {
                var args = arguments.length === 1 ? [
                    arguments[0]
                ] : Array.apply(null, arguments);
                args.splice(0, 0, ev);
                me.emit.apply(me, args);
            };
        }
        return Stream.prototype.on.call(me, ev, handler);
    };
    // this really needs to be replaced with character classes.
    // XML allows all manner of ridiculous numbers and digits.
    var CDATA = '[CDATA[';
    var DOCTYPE = 'DOCTYPE';
    var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
    var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
    var rootNS = {
        xml: XML_NAMESPACE,
        xmlns: XMLNS_NAMESPACE
    };
    // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
    // This implementation works on strings, a single character at a time
    // as such, it cannot ever support astral-plane characters (10000-EFFFF)
    // without a significant breaking change to either this  parser, or the
    // JavaScript language.  Implementation of an emoji-capable xml parser
    // is left as an exercise for the reader.
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace(c) {
        return c === ' ' || c === '\n' || c === '\r' || c === '\t';
    }
    function isQuote(c) {
        return c === '"' || c === "'";
    }
    function isAttribEnd(c) {
        return c === '>' || isWhitespace(c);
    }
    function isMatch(regex, c) {
        return regex.test(c);
    }
    function notMatch(regex, c) {
        return !isMatch(regex, c);
    }
    var S = 0;
    sax.STATE = {
        BEGIN: S++,
        BEGIN_WHITESPACE: S++,
        TEXT: S++,
        TEXT_ENTITY: S++,
        OPEN_WAKA: S++,
        SGML_DECL: S++,
        SGML_DECL_QUOTED: S++,
        DOCTYPE: S++,
        DOCTYPE_QUOTED: S++,
        DOCTYPE_DTD: S++,
        DOCTYPE_DTD_QUOTED: S++,
        COMMENT_STARTING: S++,
        COMMENT: S++,
        COMMENT_ENDING: S++,
        COMMENT_ENDED: S++,
        CDATA: S++,
        CDATA_ENDING: S++,
        CDATA_ENDING_2: S++,
        PROC_INST: S++,
        PROC_INST_BODY: S++,
        PROC_INST_ENDING: S++,
        OPEN_TAG: S++,
        OPEN_TAG_SLASH: S++,
        ATTRIB: S++,
        ATTRIB_NAME: S++,
        ATTRIB_NAME_SAW_WHITE: S++,
        ATTRIB_VALUE: S++,
        ATTRIB_VALUE_QUOTED: S++,
        ATTRIB_VALUE_CLOSED: S++,
        ATTRIB_VALUE_UNQUOTED: S++,
        ATTRIB_VALUE_ENTITY_Q: S++,
        ATTRIB_VALUE_ENTITY_U: S++,
        CLOSE_TAG: S++,
        CLOSE_TAG_SAW_WHITE: S++,
        SCRIPT: S++,
        SCRIPT_ENDING: S++
    };
    sax.XML_ENTITIES = {
        amp: '&',
        gt: '>',
        lt: '<',
        quot: '"',
        apos: "'"
    };
    sax.ENTITIES = {
        amp: '&',
        gt: '>',
        lt: '<',
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
    };
    Object.keys(sax.ENTITIES).forEach(function(key) {
        var e = sax.ENTITIES[key];
        var s = typeof e === 'number' ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s;
    });
    for(var s in sax.STATE){
        sax.STATE[sax.STATE[s]] = s;
    }
    // shorthand
    S = sax.STATE;
    function emit(parser, event, data) {
        parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data);
    }
    function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, 'ontext', parser.textNode);
        parser.textNode = '';
    }
    function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, ' ');
        return text;
    }
    function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
            er += '\nLine: ' + parser.line + '\nColumn: ' + parser.column + '\nChar: ' + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, 'onerror', er);
        return parser;
    }
    function end(parser) {
        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag');
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
            error(parser, 'Unexpected end');
        }
        closeText(parser);
        parser.c = '';
        parser.closed = true;
        emit(parser, 'onend');
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
    }
    function strictFail(parser, message) {
        if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
            throw new Error('bad call to strictFail');
        }
        if (parser.strict) {
            error(parser, message);
        }
    }
    function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = {
            name: parser.tagName,
            attributes: {}
        };
        // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
        if (parser.opt.xmlns) {
            tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, 'onopentagstart', tag);
    }
    function qname(name, attribute) {
        var i = name.indexOf(':');
        var qualName = i < 0 ? [
            '',
            name
        ] : name.split(':');
        var prefix = qualName[0];
        var local = qualName[1];
        // <x "xmlns"="http://foo">
        if (attribute && name === 'xmlns') {
            prefix = 'xmlns';
            local = '';
        }
        return {
            prefix: prefix,
            local: local
        };
    }
    function attrib(parser) {
        if (!parser.strict) {
            parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
            parser.attribName = parser.attribValue = '';
            return;
        }
        if (parser.opt.xmlns) {
            var qn = qname(parser.attribName, true);
            var prefix = qn.prefix;
            var local = qn.local;
            if (prefix === 'xmlns') {
                // namespace binding attribute. push the binding into scope
                if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
                    strictFail(parser, 'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
                } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
                    strictFail(parser, 'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
                } else {
                    var tag = parser.tag;
                    var parent = parser.tags[parser.tags.length - 1] || parser;
                    if (tag.ns === parent.ns) {
                        tag.ns = Object.create(parent.ns);
                    }
                    tag.ns[local] = parser.attribValue;
                }
            }
            // defer onattribute events until all attributes have been seen
            // so any new bindings can take effect. preserve attribute order
            // so deferred events can be emitted in document order
            parser.attribList.push([
                parser.attribName,
                parser.attribValue
            ]);
        } else {
            // in non-xmlns mode, we can emit the event right away
            parser.tag.attributes[parser.attribName] = parser.attribValue;
            emitNode(parser, 'onattribute', {
                name: parser.attribName,
                value: parser.attribValue
            });
        }
        parser.attribName = parser.attribValue = '';
    }
    function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
            // emit namespace binding events
            var tag = parser.tag;
            // add namespace info to tag
            var qn = qname(parser.tagName);
            tag.prefix = qn.prefix;
            tag.local = qn.local;
            tag.uri = tag.ns[qn.prefix] || '';
            if (tag.prefix && !tag.uri) {
                strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(parser.tagName));
                tag.uri = qn.prefix;
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns && parent.ns !== tag.ns) {
                Object.keys(tag.ns).forEach(function(p) {
                    emitNode(parser, 'onopennamespace', {
                        prefix: p,
                        uri: tag.ns[p]
                    });
                });
            }
            // handle deferred onattribute events
            // Note: do not apply default ns to attributes:
            //   http://www.w3.org/TR/REC-xml-names/#defaulting
            for(var i = 0, l = parser.attribList.length; i < l; i++){
                var nv = parser.attribList[i];
                var name = nv[0];
                var value = nv[1];
                var qualName = qname(name, true);
                var prefix = qualName.prefix;
                var local = qualName.local;
                var uri = prefix === '' ? '' : tag.ns[prefix] || '';
                var a = {
                    name: name,
                    value: value,
                    prefix: prefix,
                    local: local,
                    uri: uri
                };
                // if there's any attributes with an undefined namespace,
                // then fail on them now.
                if (prefix && prefix !== 'xmlns' && !uri) {
                    strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(prefix));
                    a.uri = prefix;
                }
                parser.tag.attributes[name] = a;
                emitNode(parser, 'onattribute', a);
            }
            parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        // process the tag
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, 'onopentag', parser.tag);
        if (!selfClosing) {
            // special case for <script> in non-strict mode.
            if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
                parser.state = S.SCRIPT;
            } else {
                parser.state = S.TEXT;
            }
            parser.tag = null;
            parser.tagName = '';
        }
        parser.attribName = parser.attribValue = '';
        parser.attribList.length = 0;
    }
    function closeTag(parser) {
        if (!parser.tagName) {
            strictFail(parser, 'Weird empty close tag.');
            parser.textNode += '</>';
            parser.state = S.TEXT;
            return;
        }
        if (parser.script) {
            if (parser.tagName !== 'script') {
                parser.script += '</' + parser.tagName + '>';
                parser.tagName = '';
                parser.state = S.SCRIPT;
                return;
            }
            emitNode(parser, 'onscript', parser.script);
            parser.script = '';
        }
        // first make sure that the closing tag actually exists.
        // <a><b></c></b></a> will close everything, otherwise.
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
            tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while(t--){
            var close = parser.tags[t];
            if (close.name !== closeTo) {
                // fail the first time in strict mode
                strictFail(parser, 'Unexpected close tag');
            } else {
                break;
            }
        }
        // didn't find it.  we already failed for strict, so just abort.
        if (t < 0) {
            strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);
            parser.textNode += '</' + parser.tagName + '>';
            parser.state = S.TEXT;
            return;
        }
        parser.tagName = tagName;
        var s = parser.tags.length;
        while(s-- > t){
            var tag = parser.tag = parser.tags.pop();
            parser.tagName = parser.tag.name;
            emitNode(parser, 'onclosetag', parser.tagName);
            var x = {};
            for(var i in tag.ns){
                x[i] = tag.ns[i];
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (parser.opt.xmlns && tag.ns !== parent.ns) {
                // remove namespace bindings introduced by tag
                Object.keys(tag.ns).forEach(function(p) {
                    var n = tag.ns[p];
                    emitNode(parser, 'onclosenamespace', {
                        prefix: p,
                        uri: n
                    });
                });
            }
        }
        if (t === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = '';
        parser.attribList.length = 0;
        parser.state = S.TEXT;
    }
    function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = '';
        if (parser.ENTITIES[entity]) {
            return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
            return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === '#') {
            if (entity.charAt(1) === 'x') {
                entity = entity.slice(2);
                num = parseInt(entity, 16);
                numStr = num.toString(16);
            } else {
                entity = entity.slice(1);
                num = parseInt(entity, 10);
                numStr = num.toString(10);
            }
        }
        entity = entity.replace(/^0+/, '');
        if (isNaN(num) || numStr.toLowerCase() !== entity || num < 0 || num > 0x10ffff) {
            strictFail(parser, 'Invalid character entity');
            return '&' + parser.entity + ';';
        }
        return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser, c) {
        if (c === '<') {
            parser.state = S.OPEN_WAKA;
            parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
            // have to process this as a text node.
            // weird, but happens.
            strictFail(parser, 'Non-whitespace before first tag.');
            parser.textNode = c;
            parser.state = S.TEXT;
        }
    }
    function charAt(chunk, i) {
        var result = '';
        if (i < chunk.length) {
            result = chunk.charAt(i);
        }
        return result;
    }
    function write(chunk) {
        var parser = this;
        if (this.error) {
            throw this.error;
        }
        if (parser.closed) {
            return error(parser, 'Cannot write after close. Assign an onready handler.');
        }
        if (chunk === null) {
            return end(parser);
        }
        if (typeof chunk === 'object') {
            chunk = chunk.toString();
        }
        var i = 0;
        var c = '';
        while(true){
            c = charAt(chunk, i++);
            parser.c = c;
            if (!c) {
                break;
            }
            if (parser.trackPosition) {
                parser.position++;
                if (c === '\n') {
                    parser.line++;
                    parser.column = 0;
                } else {
                    parser.column++;
                }
            }
            switch(parser.state){
                case S.BEGIN:
                    parser.state = S.BEGIN_WHITESPACE;
                    if (c === '\uFEFF') {
                        continue;
                    }
                    beginWhiteSpace(parser, c);
                    continue;
                case S.BEGIN_WHITESPACE:
                    beginWhiteSpace(parser, c);
                    continue;
                case S.TEXT:
                    if (parser.sawRoot && !parser.closedRoot) {
                        var starti = i - 1;
                        while(c && c !== '<' && c !== '&'){
                            c = charAt(chunk, i++);
                            if (c && parser.trackPosition) {
                                parser.position++;
                                if (c === '\n') {
                                    parser.line++;
                                    parser.column = 0;
                                } else {
                                    parser.column++;
                                }
                            }
                        }
                        parser.textNode += chunk.substring(starti, i - 1);
                    }
                    if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                        parser.state = S.OPEN_WAKA;
                        parser.startTagPosition = parser.position;
                    } else {
                        if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                            strictFail(parser, 'Text data outside of root node.');
                        }
                        if (c === '&') {
                            parser.state = S.TEXT_ENTITY;
                        } else {
                            parser.textNode += c;
                        }
                    }
                    continue;
                case S.SCRIPT:
                    // only non-strict
                    if (c === '<') {
                        parser.state = S.SCRIPT_ENDING;
                    } else {
                        parser.script += c;
                    }
                    continue;
                case S.SCRIPT_ENDING:
                    if (c === '/') {
                        parser.state = S.CLOSE_TAG;
                    } else {
                        parser.script += '<' + c;
                        parser.state = S.SCRIPT;
                    }
                    continue;
                case S.OPEN_WAKA:
                    // either a /, ?, !, or text is coming next.
                    if (c === '!') {
                        parser.state = S.SGML_DECL;
                        parser.sgmlDecl = '';
                    } else if (isWhitespace(c)) {
                    // wait for it...
                    } else if (isMatch(nameStart, c)) {
                        parser.state = S.OPEN_TAG;
                        parser.tagName = c;
                    } else if (c === '/') {
                        parser.state = S.CLOSE_TAG;
                        parser.tagName = '';
                    } else if (c === '?') {
                        parser.state = S.PROC_INST;
                        parser.procInstName = parser.procInstBody = '';
                    } else {
                        strictFail(parser, 'Unencoded <');
                        // if there was some whitespace, then add that in.
                        if (parser.startTagPosition + 1 < parser.position) {
                            var pad = parser.position - parser.startTagPosition;
                            c = new Array(pad).join(' ') + c;
                        }
                        parser.textNode += '<' + c;
                        parser.state = S.TEXT;
                    }
                    continue;
                case S.SGML_DECL:
                    if (parser.sgmlDecl + c === '--') {
                        parser.state = S.COMMENT;
                        parser.comment = '';
                        parser.sgmlDecl = '';
                        continue;
                    }
                    if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {
                        parser.state = S.DOCTYPE_DTD;
                        parser.doctype += '<!' + parser.sgmlDecl + c;
                        parser.sgmlDecl = '';
                    } else if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                        emitNode(parser, 'onopencdata');
                        parser.state = S.CDATA;
                        parser.sgmlDecl = '';
                        parser.cdata = '';
                    } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                        parser.state = S.DOCTYPE;
                        if (parser.doctype || parser.sawRoot) {
                            strictFail(parser, 'Inappropriately located doctype declaration');
                        }
                        parser.doctype = '';
                        parser.sgmlDecl = '';
                    } else if (c === '>') {
                        emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);
                        parser.sgmlDecl = '';
                        parser.state = S.TEXT;
                    } else if (isQuote(c)) {
                        parser.state = S.SGML_DECL_QUOTED;
                        parser.sgmlDecl += c;
                    } else {
                        parser.sgmlDecl += c;
                    }
                    continue;
                case S.SGML_DECL_QUOTED:
                    if (c === parser.q) {
                        parser.state = S.SGML_DECL;
                        parser.q = '';
                    }
                    parser.sgmlDecl += c;
                    continue;
                case S.DOCTYPE:
                    if (c === '>') {
                        parser.state = S.TEXT;
                        emitNode(parser, 'ondoctype', parser.doctype);
                        parser.doctype = true; // just remember that we saw it.
                    } else {
                        parser.doctype += c;
                        if (c === '[') {
                            parser.state = S.DOCTYPE_DTD;
                        } else if (isQuote(c)) {
                            parser.state = S.DOCTYPE_QUOTED;
                            parser.q = c;
                        }
                    }
                    continue;
                case S.DOCTYPE_QUOTED:
                    parser.doctype += c;
                    if (c === parser.q) {
                        parser.q = '';
                        parser.state = S.DOCTYPE;
                    }
                    continue;
                case S.DOCTYPE_DTD:
                    if (c === ']') {
                        parser.doctype += c;
                        parser.state = S.DOCTYPE;
                    } else if (c === '<') {
                        parser.state = S.OPEN_WAKA;
                        parser.startTagPosition = parser.position;
                    } else if (isQuote(c)) {
                        parser.doctype += c;
                        parser.state = S.DOCTYPE_DTD_QUOTED;
                        parser.q = c;
                    } else {
                        parser.doctype += c;
                    }
                    continue;
                case S.DOCTYPE_DTD_QUOTED:
                    parser.doctype += c;
                    if (c === parser.q) {
                        parser.state = S.DOCTYPE_DTD;
                        parser.q = '';
                    }
                    continue;
                case S.COMMENT:
                    if (c === '-') {
                        parser.state = S.COMMENT_ENDING;
                    } else {
                        parser.comment += c;
                    }
                    continue;
                case S.COMMENT_ENDING:
                    if (c === '-') {
                        parser.state = S.COMMENT_ENDED;
                        parser.comment = textopts(parser.opt, parser.comment);
                        if (parser.comment) {
                            emitNode(parser, 'oncomment', parser.comment);
                        }
                        parser.comment = '';
                    } else {
                        parser.comment += '-' + c;
                        parser.state = S.COMMENT;
                    }
                    continue;
                case S.COMMENT_ENDED:
                    if (c !== '>') {
                        strictFail(parser, 'Malformed comment');
                        // allow <!-- blah -- bloo --> in non-strict mode,
                        // which is a comment of " blah -- bloo "
                        parser.comment += '--' + c;
                        parser.state = S.COMMENT;
                    } else if (parser.doctype && parser.doctype !== true) {
                        parser.state = S.DOCTYPE_DTD;
                    } else {
                        parser.state = S.TEXT;
                    }
                    continue;
                case S.CDATA:
                    var starti = i - 1;
                    while(c && c !== ']'){
                        c = charAt(chunk, i++);
                        if (c && parser.trackPosition) {
                            parser.position++;
                            if (c === '\n') {
                                parser.line++;
                                parser.column = 0;
                            } else {
                                parser.column++;
                            }
                        }
                    }
                    parser.cdata += chunk.substring(starti, i - 1);
                    if (c === ']') {
                        parser.state = S.CDATA_ENDING;
                    }
                    continue;
                case S.CDATA_ENDING:
                    if (c === ']') {
                        parser.state = S.CDATA_ENDING_2;
                    } else {
                        parser.cdata += ']' + c;
                        parser.state = S.CDATA;
                    }
                    continue;
                case S.CDATA_ENDING_2:
                    if (c === '>') {
                        if (parser.cdata) {
                            emitNode(parser, 'oncdata', parser.cdata);
                        }
                        emitNode(parser, 'onclosecdata');
                        parser.cdata = '';
                        parser.state = S.TEXT;
                    } else if (c === ']') {
                        parser.cdata += ']';
                    } else {
                        parser.cdata += ']]' + c;
                        parser.state = S.CDATA;
                    }
                    continue;
                case S.PROC_INST:
                    if (c === '?') {
                        parser.state = S.PROC_INST_ENDING;
                    } else if (isWhitespace(c)) {
                        parser.state = S.PROC_INST_BODY;
                    } else {
                        parser.procInstName += c;
                    }
                    continue;
                case S.PROC_INST_BODY:
                    if (!parser.procInstBody && isWhitespace(c)) {
                        continue;
                    } else if (c === '?') {
                        parser.state = S.PROC_INST_ENDING;
                    } else {
                        parser.procInstBody += c;
                    }
                    continue;
                case S.PROC_INST_ENDING:
                    if (c === '>') {
                        emitNode(parser, 'onprocessinginstruction', {
                            name: parser.procInstName,
                            body: parser.procInstBody
                        });
                        parser.procInstName = parser.procInstBody = '';
                        parser.state = S.TEXT;
                    } else {
                        parser.procInstBody += '?' + c;
                        parser.state = S.PROC_INST_BODY;
                    }
                    continue;
                case S.OPEN_TAG:
                    if (isMatch(nameBody, c)) {
                        parser.tagName += c;
                    } else {
                        newTag(parser);
                        if (c === '>') {
                            openTag(parser);
                        } else if (c === '/') {
                            parser.state = S.OPEN_TAG_SLASH;
                        } else {
                            if (!isWhitespace(c)) {
                                strictFail(parser, 'Invalid character in tag name');
                            }
                            parser.state = S.ATTRIB;
                        }
                    }
                    continue;
                case S.OPEN_TAG_SLASH:
                    if (c === '>') {
                        openTag(parser, true);
                        closeTag(parser);
                    } else {
                        strictFail(parser, 'Forward-slash in opening tag not followed by >');
                        parser.state = S.ATTRIB;
                    }
                    continue;
                case S.ATTRIB:
                    // haven't read the attribute name yet.
                    if (isWhitespace(c)) {
                        continue;
                    } else if (c === '>') {
                        openTag(parser);
                    } else if (c === '/') {
                        parser.state = S.OPEN_TAG_SLASH;
                    } else if (isMatch(nameStart, c)) {
                        parser.attribName = c;
                        parser.attribValue = '';
                        parser.state = S.ATTRIB_NAME;
                    } else {
                        strictFail(parser, 'Invalid attribute name');
                    }
                    continue;
                case S.ATTRIB_NAME:
                    if (c === '=') {
                        parser.state = S.ATTRIB_VALUE;
                    } else if (c === '>') {
                        strictFail(parser, 'Attribute without value');
                        parser.attribValue = parser.attribName;
                        attrib(parser);
                        openTag(parser);
                    } else if (isWhitespace(c)) {
                        parser.state = S.ATTRIB_NAME_SAW_WHITE;
                    } else if (isMatch(nameBody, c)) {
                        parser.attribName += c;
                    } else {
                        strictFail(parser, 'Invalid attribute name');
                    }
                    continue;
                case S.ATTRIB_NAME_SAW_WHITE:
                    if (c === '=') {
                        parser.state = S.ATTRIB_VALUE;
                    } else if (isWhitespace(c)) {
                        continue;
                    } else {
                        strictFail(parser, 'Attribute without value');
                        parser.tag.attributes[parser.attribName] = '';
                        parser.attribValue = '';
                        emitNode(parser, 'onattribute', {
                            name: parser.attribName,
                            value: ''
                        });
                        parser.attribName = '';
                        if (c === '>') {
                            openTag(parser);
                        } else if (isMatch(nameStart, c)) {
                            parser.attribName = c;
                            parser.state = S.ATTRIB_NAME;
                        } else {
                            strictFail(parser, 'Invalid attribute name');
                            parser.state = S.ATTRIB;
                        }
                    }
                    continue;
                case S.ATTRIB_VALUE:
                    if (isWhitespace(c)) {
                        continue;
                    } else if (isQuote(c)) {
                        parser.q = c;
                        parser.state = S.ATTRIB_VALUE_QUOTED;
                    } else {
                        if (!parser.opt.unquotedAttributeValues) {
                            error(parser, 'Unquoted attribute value');
                        }
                        parser.state = S.ATTRIB_VALUE_UNQUOTED;
                        parser.attribValue = c;
                    }
                    continue;
                case S.ATTRIB_VALUE_QUOTED:
                    if (c !== parser.q) {
                        if (c === '&') {
                            parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                        } else {
                            parser.attribValue += c;
                        }
                        continue;
                    }
                    attrib(parser);
                    parser.q = '';
                    parser.state = S.ATTRIB_VALUE_CLOSED;
                    continue;
                case S.ATTRIB_VALUE_CLOSED:
                    if (isWhitespace(c)) {
                        parser.state = S.ATTRIB;
                    } else if (c === '>') {
                        openTag(parser);
                    } else if (c === '/') {
                        parser.state = S.OPEN_TAG_SLASH;
                    } else if (isMatch(nameStart, c)) {
                        strictFail(parser, 'No whitespace between attributes');
                        parser.attribName = c;
                        parser.attribValue = '';
                        parser.state = S.ATTRIB_NAME;
                    } else {
                        strictFail(parser, 'Invalid attribute name');
                    }
                    continue;
                case S.ATTRIB_VALUE_UNQUOTED:
                    if (!isAttribEnd(c)) {
                        if (c === '&') {
                            parser.state = S.ATTRIB_VALUE_ENTITY_U;
                        } else {
                            parser.attribValue += c;
                        }
                        continue;
                    }
                    attrib(parser);
                    if (c === '>') {
                        openTag(parser);
                    } else {
                        parser.state = S.ATTRIB;
                    }
                    continue;
                case S.CLOSE_TAG:
                    if (!parser.tagName) {
                        if (isWhitespace(c)) {
                            continue;
                        } else if (notMatch(nameStart, c)) {
                            if (parser.script) {
                                parser.script += '</' + c;
                                parser.state = S.SCRIPT;
                            } else {
                                strictFail(parser, 'Invalid tagname in closing tag.');
                            }
                        } else {
                            parser.tagName = c;
                        }
                    } else if (c === '>') {
                        closeTag(parser);
                    } else if (isMatch(nameBody, c)) {
                        parser.tagName += c;
                    } else if (parser.script) {
                        parser.script += '</' + parser.tagName;
                        parser.tagName = '';
                        parser.state = S.SCRIPT;
                    } else {
                        if (!isWhitespace(c)) {
                            strictFail(parser, 'Invalid tagname in closing tag');
                        }
                        parser.state = S.CLOSE_TAG_SAW_WHITE;
                    }
                    continue;
                case S.CLOSE_TAG_SAW_WHITE:
                    if (isWhitespace(c)) {
                        continue;
                    }
                    if (c === '>') {
                        closeTag(parser);
                    } else {
                        strictFail(parser, 'Invalid characters in closing tag');
                    }
                    continue;
                case S.TEXT_ENTITY:
                case S.ATTRIB_VALUE_ENTITY_Q:
                case S.ATTRIB_VALUE_ENTITY_U:
                    var returnState;
                    var buffer;
                    switch(parser.state){
                        case S.TEXT_ENTITY:
                            returnState = S.TEXT;
                            buffer = 'textNode';
                            break;
                        case S.ATTRIB_VALUE_ENTITY_Q:
                            returnState = S.ATTRIB_VALUE_QUOTED;
                            buffer = 'attribValue';
                            break;
                        case S.ATTRIB_VALUE_ENTITY_U:
                            returnState = S.ATTRIB_VALUE_UNQUOTED;
                            buffer = 'attribValue';
                            break;
                    }
                    if (c === ';') {
                        var parsedEntity = parseEntity(parser);
                        if (parser.opt.unparsedEntities && !Object.values(sax.XML_ENTITIES).includes(parsedEntity)) {
                            parser.entity = '';
                            parser.state = returnState;
                            parser.write(parsedEntity);
                        } else {
                            parser[buffer] += parsedEntity;
                            parser.entity = '';
                            parser.state = returnState;
                        }
                    } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                        parser.entity += c;
                    } else {
                        strictFail(parser, 'Invalid character in entity name');
                        parser[buffer] += '&' + parser.entity + c;
                        parser.entity = '';
                        parser.state = returnState;
                    }
                    continue;
                default:
                    /* istanbul ignore next */ {
                        throw new Error(parser, 'Unknown state: ' + parser.state);
                    }
            }
        } // while
        if (parser.position >= parser.bufferCheckPosition) {
            checkBufferLength(parser);
        }
        return parser;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */ /* istanbul ignore next */ if (!String.fromCodePoint) {
        ;
        (function() {
            var stringFromCharCode = String.fromCharCode;
            var floor = Math.floor;
            var fromCodePoint = function() {
                var MAX_SIZE = 0x4000;
                var codeUnits = [];
                var highSurrogate;
                var lowSurrogate;
                var index = -1;
                var length = arguments.length;
                if (!length) {
                    return '';
                }
                var result = '';
                while(++index < length){
                    var codePoint = Number(arguments[index]);
                    if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                    codePoint < 0 || // not a valid Unicode code point
                    codePoint > 0x10ffff || // not a valid Unicode code point
                    floor(codePoint) !== codePoint // not an integer
                    ) {
                        throw RangeError('Invalid code point: ' + codePoint);
                    }
                    if (codePoint <= 0xffff) {
                        // BMP code point
                        codeUnits.push(codePoint);
                    } else {
                        // Astral code point; split in surrogate halves
                        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                        codePoint -= 0x10000;
                        highSurrogate = (codePoint >> 10) + 0xd800;
                        lowSurrogate = codePoint % 0x400 + 0xdc00;
                        codeUnits.push(highSurrogate, lowSurrogate);
                    }
                    if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                        result += stringFromCharCode.apply(null, codeUnits);
                        codeUnits.length = 0;
                    }
                }
                return result;
            };
            /* istanbul ignore next */ if (Object.defineProperty) {
                Object.defineProperty(String, 'fromCodePoint', {
                    value: fromCodePoint,
                    configurable: true,
                    writable: true
                });
            } else {
                String.fromCodePoint = fromCodePoint;
            }
        })();
    }
})(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : exports);
}),
"[project]/node_modules/csv-stringify/dist/cjs/index.cjs [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
class CsvError extends Error {
    constructor(code, message, ...contexts){
        if (Array.isArray(message)) message = message.join(" ");
        super(message);
        if (Error.captureStackTrace !== undefined) {
            Error.captureStackTrace(this, CsvError);
        }
        this.code = code;
        for (const context of contexts){
            for(const key in context){
                const value = context[key];
                this[key] = Buffer.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value));
            }
        }
    }
}
const is_object = function(obj) {
    return typeof obj === "object" && obj !== null && !Array.isArray(obj);
};
// Lodash implementation of `get`
const charCodeOfDot = ".".charCodeAt(0);
const reEscapeChar = /\\(\\)?/g;
const rePropName = RegExp(// Match anything that isn't a dot or bracket.
"[^.[\\]]+" + "|" + // Or match property names within brackets.
"\\[(?:" + // Match a non-string expression.
"([^\"'][^[]*)" + "|" + // Or match strings (supports escaping characters).
"([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2" + ")\\]" + "|" + // Or match "" as the space between consecutive dots or empty brackets.
"(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))", "g");
const reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
const reIsPlainProp = /^\w*$/;
const getTag = function(value) {
    // if (!value) value === undefined ? "[object Undefined]" : "[object Null]";
    return Object.prototype.toString.call(value);
};
const isSymbol = function(value) {
    const type = typeof value;
    return type === "symbol" || type === "object" && value && getTag(value) === "[object Symbol]";
};
const isKey = function(value, object) {
    if (Array.isArray(value)) {
        return false;
    }
    const type = typeof value;
    if (type === "number" || type === "symbol" || type === "boolean" || !value || isSymbol(value)) {
        return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
};
const stringToPath = function(string) {
    const result = [];
    if (string.charCodeAt(0) === charCodeOfDot) {
        result.push("");
    }
    string.replace(rePropName, function(match, expression, quote, subString) {
        let key = match;
        if (quote) {
            key = subString.replace(reEscapeChar, "$1");
        } else if (expression) {
            key = expression.trim();
        }
        result.push(key);
    });
    return result;
};
const castPath = function(value, object) {
    if (Array.isArray(value)) {
        return value;
    } else {
        return isKey(value, object) ? [
            value
        ] : stringToPath(value);
    }
};
const toKey = function(value) {
    if (typeof value === "string" || isSymbol(value)) return value;
    const result = `${value}`;
    // eslint-disable-next-line
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
};
const get = function(object, path) {
    path = castPath(path, object);
    let index = 0;
    const length = path.length;
    while(object != null && index < length){
        object = object[toKey(path[index++])];
    }
    return index && index === length ? object : undefined;
};
const normalize_columns = function(columns) {
    if (columns === undefined || columns === null) {
        return [
            undefined,
            undefined
        ];
    }
    if (typeof columns !== "object") {
        return [
            Error('Invalid option "columns": expect an array or an object')
        ];
    }
    if (!Array.isArray(columns)) {
        const newcolumns = [];
        for(const k in columns){
            newcolumns.push({
                key: k,
                header: columns[k]
            });
        }
        columns = newcolumns;
    } else {
        const newcolumns = [];
        for (const column of columns){
            if (typeof column === "string") {
                newcolumns.push({
                    key: column,
                    header: column
                });
            } else if (typeof column === "object" && column !== null && !Array.isArray(column)) {
                if (!column.key) {
                    return [
                        Error('Invalid column definition: property "key" is required')
                    ];
                }
                if (column.header === undefined) {
                    column.header = column.key;
                }
                newcolumns.push(column);
            } else {
                return [
                    Error("Invalid column definition: expect a string or an object")
                ];
            }
        }
        columns = newcolumns;
    }
    return [
        undefined,
        columns
    ];
};
const underscore = function(str) {
    return str.replace(/([A-Z])/g, function(_, match) {
        return "_" + match.toLowerCase();
    });
};
const normalize_options = function(opts) {
    const options = {};
    // Merge with user options
    for(const opt in opts){
        options[underscore(opt)] = opts[opt];
    }
    // Normalize option `bom`
    if (options.bom === undefined || options.bom === null || options.bom === false) {
        options.bom = false;
    } else if (options.bom !== true) {
        return [
            new CsvError("CSV_OPTION_BOOLEAN_INVALID_TYPE", [
                "option `bom` is optional and must be a boolean value,",
                `got ${JSON.stringify(options.bom)}`
            ])
        ];
    }
    // Normalize option `delimiter`
    if (options.delimiter === undefined || options.delimiter === null) {
        options.delimiter = ",";
    } else if (Buffer.isBuffer(options.delimiter)) {
        options.delimiter = options.delimiter.toString();
    } else if (typeof options.delimiter !== "string") {
        return [
            new CsvError("CSV_OPTION_DELIMITER_INVALID_TYPE", [
                "option `delimiter` must be a buffer or a string,",
                `got ${JSON.stringify(options.delimiter)}`
            ])
        ];
    }
    // Normalize option `quote`
    if (options.quote === undefined || options.quote === null) {
        options.quote = '"';
    } else if (options.quote === true) {
        options.quote = '"';
    } else if (options.quote === false) {
        options.quote = "";
    } else if (Buffer.isBuffer(options.quote)) {
        options.quote = options.quote.toString();
    } else if (typeof options.quote !== "string") {
        return [
            new CsvError("CSV_OPTION_QUOTE_INVALID_TYPE", [
                "option `quote` must be a boolean, a buffer or a string,",
                `got ${JSON.stringify(options.quote)}`
            ])
        ];
    }
    // Normalize option `quoted`
    if (options.quoted === undefined || options.quoted === null) {
        options.quoted = false;
    }
    // Normalize option `escape_formulas`
    if (options.escape_formulas === undefined || options.escape_formulas === null) {
        options.escape_formulas = false;
    } else if (typeof options.escape_formulas !== "boolean") {
        return [
            new CsvError("CSV_OPTION_ESCAPE_FORMULAS_INVALID_TYPE", [
                "option `escape_formulas` must be a boolean,",
                `got ${JSON.stringify(options.escape_formulas)}`
            ])
        ];
    }
    // Normalize option `quoted_empty`
    if (options.quoted_empty === undefined || options.quoted_empty === null) {
        options.quoted_empty = undefined;
    }
    // Normalize option `quoted_match`
    if (options.quoted_match === undefined || options.quoted_match === null || options.quoted_match === false) {
        options.quoted_match = null;
    } else if (!Array.isArray(options.quoted_match)) {
        options.quoted_match = [
            options.quoted_match
        ];
    }
    if (options.quoted_match) {
        for (const quoted_match of options.quoted_match){
            const isString = typeof quoted_match === "string";
            const isRegExp = quoted_match instanceof RegExp;
            if (!isString && !isRegExp) {
                return [
                    Error(`Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`)
                ];
            }
        }
    }
    // Normalize option `quoted_string`
    if (options.quoted_string === undefined || options.quoted_string === null) {
        options.quoted_string = false;
    }
    // Normalize option `eof`
    if (options.eof === undefined || options.eof === null) {
        options.eof = true;
    }
    // Normalize option `escape`
    if (options.escape === undefined || options.escape === null) {
        options.escape = '"';
    } else if (Buffer.isBuffer(options.escape)) {
        options.escape = options.escape.toString();
    } else if (typeof options.escape !== "string") {
        return [
            Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`)
        ];
    }
    if (options.escape.length > 1) {
        return [
            Error(`Invalid Option: escape must be one character, got ${options.escape.length} characters`)
        ];
    }
    // Normalize option `header`
    if (options.header === undefined || options.header === null) {
        options.header = false;
    }
    // Normalize option `columns`
    const [errColumns, columns] = normalize_columns(options.columns);
    if (errColumns !== undefined) return [
        errColumns
    ];
    options.columns = columns;
    // Normalize option `quoted`
    if (options.quoted === undefined || options.quoted === null) {
        options.quoted = false;
    }
    // Normalize option `cast`
    if (options.cast === undefined || options.cast === null) {
        options.cast = {};
    }
    // Normalize option cast.bigint
    if (options.cast.bigint === undefined || options.cast.bigint === null) {
        // Cast boolean to string by default
        options.cast.bigint = (value)=>"" + value;
    }
    // Normalize option cast.boolean
    if (options.cast.boolean === undefined || options.cast.boolean === null) {
        // Cast boolean to string by default
        options.cast.boolean = (value)=>value ? "1" : "";
    }
    // Normalize option cast.date
    if (options.cast.date === undefined || options.cast.date === null) {
        // Cast date to timestamp string by default
        options.cast.date = (value)=>"" + value.getTime();
    }
    // Normalize option cast.number
    if (options.cast.number === undefined || options.cast.number === null) {
        // Cast number to string using native casting by default
        options.cast.number = (value)=>"" + value;
    }
    // Normalize option cast.object
    if (options.cast.object === undefined || options.cast.object === null) {
        // Stringify object as JSON by default
        options.cast.object = (value)=>JSON.stringify(value);
    }
    // Normalize option cast.string
    if (options.cast.string === undefined || options.cast.string === null) {
        // Leave string untouched
        options.cast.string = function(value) {
            return value;
        };
    }
    // Normalize option `on_record`
    if (options.on_record !== undefined && typeof options.on_record !== "function") {
        return [
            Error(`Invalid Option: "on_record" must be a function.`)
        ];
    }
    // Normalize option `record_delimiter`
    if (options.record_delimiter === undefined || options.record_delimiter === null) {
        options.record_delimiter = "\n";
    } else if (Buffer.isBuffer(options.record_delimiter)) {
        options.record_delimiter = options.record_delimiter.toString();
    } else if (typeof options.record_delimiter !== "string") {
        return [
            Error(`Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`)
        ];
    }
    switch(options.record_delimiter){
        case "unix":
            options.record_delimiter = "\n";
            break;
        case "mac":
            options.record_delimiter = "\r";
            break;
        case "windows":
            options.record_delimiter = "\r\n";
            break;
        case "ascii":
            options.record_delimiter = "\u001e";
            break;
        case "unicode":
            options.record_delimiter = "\u2028";
            break;
    }
    return [
        undefined,
        options
    ];
};
const bom_utf8 = Buffer.from([
    239,
    187,
    191
]);
const stringifier = function(options, state, info) {
    return {
        options: options,
        state: state,
        info: info,
        __transform: function(chunk, push) {
            // Chunk validation
            if (!Array.isArray(chunk) && typeof chunk !== "object") {
                return Error(`Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`);
            }
            // Detect columns from the first record
            if (this.info.records === 0) {
                if (Array.isArray(chunk)) {
                    if (this.options.header === true && this.options.columns === undefined) {
                        return Error("Undiscoverable Columns: header option requires column option or object records");
                    }
                } else if (this.options.columns === undefined) {
                    const [err, columns] = normalize_columns(Object.keys(chunk));
                    if (err) return;
                    this.options.columns = columns;
                }
            }
            // Emit the header
            if (this.info.records === 0) {
                this.bom(push);
                const err = this.headers(push);
                if (err) return err;
            }
            // Emit and stringify the record if an object or an array
            try {
                // this.emit('record', chunk, this.info.records);
                if (this.options.on_record) {
                    this.options.on_record(chunk, this.info.records);
                }
            } catch (err) {
                return err;
            }
            // Convert the record into a string
            let err, chunk_string;
            if (this.options.eof) {
                [err, chunk_string] = this.stringify(chunk);
                if (err) return err;
                if (chunk_string === undefined) {
                    return;
                } else {
                    chunk_string = chunk_string + this.options.record_delimiter;
                }
            } else {
                [err, chunk_string] = this.stringify(chunk);
                if (err) return err;
                if (chunk_string === undefined) {
                    return;
                } else {
                    if (this.options.header || this.info.records) {
                        chunk_string = this.options.record_delimiter + chunk_string;
                    }
                }
            }
            // Emit the csv
            this.info.records++;
            push(chunk_string);
        },
        stringify: function(chunk, chunkIsHeader = false) {
            if (typeof chunk !== "object") {
                return [
                    undefined,
                    chunk
                ];
            }
            const { columns } = this.options;
            const record = [];
            // Record is an array
            if (Array.isArray(chunk)) {
                // We are getting an array but the user has specified output columns. In
                // this case, we respect the columns indexes
                if (columns) {
                    chunk.splice(columns.length);
                }
                // Cast record elements
                for(let i = 0; i < chunk.length; i++){
                    const field = chunk[i];
                    const [err, value] = this.__cast(field, {
                        index: i,
                        column: i,
                        records: this.info.records,
                        header: chunkIsHeader
                    });
                    if (err) return [
                        err
                    ];
                    record[i] = [
                        value,
                        field
                    ];
                }
            // Record is a literal object
            // `columns` is always defined: it is either provided or discovered.
            } else {
                for(let i = 0; i < columns.length; i++){
                    const field = get(chunk, columns[i].key);
                    const [err, value] = this.__cast(field, {
                        index: i,
                        column: columns[i].key,
                        records: this.info.records,
                        header: chunkIsHeader
                    });
                    if (err) return [
                        err
                    ];
                    record[i] = [
                        value,
                        field
                    ];
                }
            }
            let csvrecord = "";
            for(let i = 0; i < record.length; i++){
                let options, err;
                let [value, field] = record[i];
                if (typeof value === "string") {
                    options = this.options;
                } else if (is_object(value)) {
                    options = value;
                    value = options.value;
                    delete options.value;
                    if (typeof value !== "string" && value !== undefined && value !== null) {
                        if (err) return [
                            Error(`Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`)
                        ];
                    }
                    options = {
                        ...this.options,
                        ...options
                    };
                    [err, options] = normalize_options(options);
                    if (err !== undefined) {
                        return [
                            err
                        ];
                    }
                } else if (value === undefined || value === null) {
                    options = this.options;
                } else {
                    return [
                        Error(`Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`)
                    ];
                }
                const { delimiter, escape, quote, quoted, quoted_empty, quoted_string, quoted_match, record_delimiter, escape_formulas } = options;
                if ("" === value && "" === field) {
                    let quotedMatch = quoted_match && quoted_match.filter((quoted_match)=>{
                        if (typeof quoted_match === "string") {
                            return value.indexOf(quoted_match) !== -1;
                        } else {
                            return quoted_match.test(value);
                        }
                    });
                    quotedMatch = quotedMatch && quotedMatch.length > 0;
                    const shouldQuote = quotedMatch || true === quoted_empty || true === quoted_string && false !== quoted_empty;
                    if (shouldQuote === true) {
                        value = quote + value + quote;
                    }
                    csvrecord += value;
                } else if (value) {
                    if (typeof value !== "string") {
                        return [
                            Error(`Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`)
                        ];
                    }
                    const containsdelimiter = delimiter.length && value.indexOf(delimiter) >= 0;
                    const containsQuote = quote !== "" && value.indexOf(quote) >= 0;
                    const containsEscape = value.indexOf(escape) >= 0 && escape !== quote;
                    const containsRecordDelimiter = value.indexOf(record_delimiter) >= 0;
                    const quotedString = quoted_string && typeof field === "string";
                    let quotedMatch = quoted_match && quoted_match.filter((quoted_match)=>{
                        if (typeof quoted_match === "string") {
                            return value.indexOf(quoted_match) !== -1;
                        } else {
                            return quoted_match.test(value);
                        }
                    });
                    quotedMatch = quotedMatch && quotedMatch.length > 0;
                    // See https://github.com/adaltas/node-csv/pull/387
                    // More about CSV injection or formula injection, when websites embed
                    // untrusted input inside CSV files:
                    // https://owasp.org/www-community/attacks/CSV_Injection
                    // http://georgemauer.net/2017/10/07/csv-injection.html
                    // Apple Numbers unicode normalization is empirical from testing
                    if (escape_formulas) {
                        switch(value[0]){
                            case "=":
                            case "+":
                            case "-":
                            case "@":
                            case "\t":
                            case "\r":
                            case "\uFF1D":
                            case "\uFF0B":
                            case "\uFF0D":
                            case "\uFF20":
                                value = `'${value}`;
                                break;
                        }
                    }
                    const shouldQuote = containsQuote === true || containsdelimiter || containsRecordDelimiter || quoted || quotedString || quotedMatch;
                    if (shouldQuote === true && containsEscape === true) {
                        const regexp = escape === "\\" ? new RegExp(escape + escape, "g") : new RegExp(escape, "g");
                        value = value.replace(regexp, escape + escape);
                    }
                    if (containsQuote === true) {
                        const regexp = new RegExp(quote, "g");
                        value = value.replace(regexp, escape + quote);
                    }
                    if (shouldQuote === true) {
                        value = quote + value + quote;
                    }
                    csvrecord += value;
                } else if (quoted_empty === true || field === "" && quoted_string === true && quoted_empty !== false) {
                    csvrecord += quote + quote;
                }
                if (i !== record.length - 1) {
                    csvrecord += delimiter;
                }
            }
            return [
                undefined,
                csvrecord
            ];
        },
        bom: function(push) {
            if (this.options.bom !== true) {
                return;
            }
            push(bom_utf8);
        },
        headers: function(push) {
            if (this.options.header === false) {
                return;
            }
            if (this.options.columns === undefined) {
                return;
            }
            let err;
            let headers = this.options.columns.map((column)=>column.header);
            if (this.options.eof) {
                [err, headers] = this.stringify(headers, true);
                headers += this.options.record_delimiter;
            } else {
                [err, headers] = this.stringify(headers);
            }
            if (err) return err;
            push(headers);
        },
        __cast: function(value, context) {
            const type = typeof value;
            try {
                if (type === "string") {
                    // Fine for 99% of the cases
                    return [
                        undefined,
                        this.options.cast.string(value, context)
                    ];
                } else if (type === "bigint") {
                    return [
                        undefined,
                        this.options.cast.bigint(value, context)
                    ];
                } else if (type === "number") {
                    return [
                        undefined,
                        this.options.cast.number(value, context)
                    ];
                } else if (type === "boolean") {
                    return [
                        undefined,
                        this.options.cast.boolean(value, context)
                    ];
                } else if (value instanceof Date) {
                    return [
                        undefined,
                        this.options.cast.date(value, context)
                    ];
                } else if (type === "object" && value !== null) {
                    return [
                        undefined,
                        this.options.cast.object(value, context)
                    ];
                } else {
                    return [
                        undefined,
                        value,
                        value
                    ];
                }
            } catch (err) {
                return [
                    err
                ];
            }
        }
    };
};
/*
CSV Stringify

Please look at the [project documentation](https://csv.js.org/stringify/) for
additional information.
*/ class Stringifier extends stream.Transform {
    constructor(opts = {}){
        super({
            ...{
                writableObjectMode: true
            },
            ...opts
        });
        const [err, options] = normalize_options(opts);
        if (err !== undefined) throw err;
        // Expose options
        this.options = options;
        // Internal state
        this.state = {
            stop: false
        };
        // Information
        this.info = {
            records: 0
        };
        this.api = stringifier(this.options, this.state, this.info);
        this.api.options.on_record = (...args)=>{
            this.emit("record", ...args);
        };
    }
    _transform(chunk, encoding, callback) {
        if (this.state.stop === true) {
            return;
        }
        const err = this.api.__transform(chunk, this.push.bind(this));
        if (err !== undefined) {
            this.state.stop = true;
        }
        callback(err);
    }
    _flush(callback) {
        if (this.state.stop === true) {
            // Note, Node.js 12 call flush even after an error, we must prevent
            // `callback` from being called in flush without any error.
            return;
        }
        if (this.info.records === 0) {
            this.api.bom(this.push.bind(this));
            const err = this.api.headers(this.push.bind(this));
            if (err) callback(err);
        }
        callback();
    }
}
const stringify = function() {
    let data, options, callback;
    for(const i in arguments){
        const argument = arguments[i];
        const type = typeof argument;
        if (data === undefined && Array.isArray(argument)) {
            data = argument;
        } else if (options === undefined && is_object(argument)) {
            options = argument;
        } else if (callback === undefined && type === "function") {
            callback = argument;
        } else {
            throw new CsvError("CSV_INVALID_ARGUMENT", [
                "Invalid argument:",
                `got ${JSON.stringify(argument)} at index ${i}`
            ]);
        }
    }
    const stringifier = new Stringifier(options);
    if (callback) {
        const chunks = [];
        stringifier.on("readable", function() {
            let chunk;
            while((chunk = this.read()) !== null){
                chunks.push(chunk);
            }
        });
        stringifier.on("error", function(err) {
            callback(err);
        });
        stringifier.on("end", function() {
            try {
                callback(undefined, chunks.join(""));
            } catch (err) {
                // This can happen if the `chunks` is extremely long; it may throw
                // "Cannot create a string longer than 0x1fffffe8 characters"
                // See [#386](https://github.com/adaltas/node-csv/pull/386)
                callback(err);
                return;
            }
        });
    }
    if (data !== undefined) {
        const writer = function() {
            for (const record of data){
                stringifier.write(record);
            }
            stringifier.end();
        };
        // Support Deno, Rollup doesnt provide a shim for setImmediate
        if (typeof setImmediate === "function") {
            setImmediate(writer);
        } else {
            setTimeout(writer, 0);
        }
    }
    return stringifier;
};
exports.CsvError = CsvError;
exports.Stringifier = Stringifier;
exports.stringify = stringify;
}),
"[project]/node_modules/csv-stringify/dist/cjs/sync.cjs [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Lodash implementation of `get`
const charCodeOfDot = ".".charCodeAt(0);
const reEscapeChar = /\\(\\)?/g;
const rePropName = RegExp(// Match anything that isn't a dot or bracket.
"[^.[\\]]+" + "|" + // Or match property names within brackets.
"\\[(?:" + // Match a non-string expression.
"([^\"'][^[]*)" + "|" + // Or match strings (supports escaping characters).
"([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2" + ")\\]" + "|" + // Or match "" as the space between consecutive dots or empty brackets.
"(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))", "g");
const reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
const reIsPlainProp = /^\w*$/;
const getTag = function(value) {
    // if (!value) value === undefined ? "[object Undefined]" : "[object Null]";
    return Object.prototype.toString.call(value);
};
const isSymbol = function(value) {
    const type = typeof value;
    return type === "symbol" || type === "object" && value && getTag(value) === "[object Symbol]";
};
const isKey = function(value, object) {
    if (Array.isArray(value)) {
        return false;
    }
    const type = typeof value;
    if (type === "number" || type === "symbol" || type === "boolean" || !value || isSymbol(value)) {
        return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
};
const stringToPath = function(string) {
    const result = [];
    if (string.charCodeAt(0) === charCodeOfDot) {
        result.push("");
    }
    string.replace(rePropName, function(match, expression, quote, subString) {
        let key = match;
        if (quote) {
            key = subString.replace(reEscapeChar, "$1");
        } else if (expression) {
            key = expression.trim();
        }
        result.push(key);
    });
    return result;
};
const castPath = function(value, object) {
    if (Array.isArray(value)) {
        return value;
    } else {
        return isKey(value, object) ? [
            value
        ] : stringToPath(value);
    }
};
const toKey = function(value) {
    if (typeof value === "string" || isSymbol(value)) return value;
    const result = `${value}`;
    // eslint-disable-next-line
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
};
const get = function(object, path) {
    path = castPath(path, object);
    let index = 0;
    const length = path.length;
    while(object != null && index < length){
        object = object[toKey(path[index++])];
    }
    return index && index === length ? object : undefined;
};
const is_object = function(obj) {
    return typeof obj === "object" && obj !== null && !Array.isArray(obj);
};
const normalize_columns = function(columns) {
    if (columns === undefined || columns === null) {
        return [
            undefined,
            undefined
        ];
    }
    if (typeof columns !== "object") {
        return [
            Error('Invalid option "columns": expect an array or an object')
        ];
    }
    if (!Array.isArray(columns)) {
        const newcolumns = [];
        for(const k in columns){
            newcolumns.push({
                key: k,
                header: columns[k]
            });
        }
        columns = newcolumns;
    } else {
        const newcolumns = [];
        for (const column of columns){
            if (typeof column === "string") {
                newcolumns.push({
                    key: column,
                    header: column
                });
            } else if (typeof column === "object" && column !== null && !Array.isArray(column)) {
                if (!column.key) {
                    return [
                        Error('Invalid column definition: property "key" is required')
                    ];
                }
                if (column.header === undefined) {
                    column.header = column.key;
                }
                newcolumns.push(column);
            } else {
                return [
                    Error("Invalid column definition: expect a string or an object")
                ];
            }
        }
        columns = newcolumns;
    }
    return [
        undefined,
        columns
    ];
};
class CsvError extends Error {
    constructor(code, message, ...contexts){
        if (Array.isArray(message)) message = message.join(" ");
        super(message);
        if (Error.captureStackTrace !== undefined) {
            Error.captureStackTrace(this, CsvError);
        }
        this.code = code;
        for (const context of contexts){
            for(const key in context){
                const value = context[key];
                this[key] = Buffer.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value));
            }
        }
    }
}
const underscore = function(str) {
    return str.replace(/([A-Z])/g, function(_, match) {
        return "_" + match.toLowerCase();
    });
};
const normalize_options = function(opts) {
    const options = {};
    // Merge with user options
    for(const opt in opts){
        options[underscore(opt)] = opts[opt];
    }
    // Normalize option `bom`
    if (options.bom === undefined || options.bom === null || options.bom === false) {
        options.bom = false;
    } else if (options.bom !== true) {
        return [
            new CsvError("CSV_OPTION_BOOLEAN_INVALID_TYPE", [
                "option `bom` is optional and must be a boolean value,",
                `got ${JSON.stringify(options.bom)}`
            ])
        ];
    }
    // Normalize option `delimiter`
    if (options.delimiter === undefined || options.delimiter === null) {
        options.delimiter = ",";
    } else if (Buffer.isBuffer(options.delimiter)) {
        options.delimiter = options.delimiter.toString();
    } else if (typeof options.delimiter !== "string") {
        return [
            new CsvError("CSV_OPTION_DELIMITER_INVALID_TYPE", [
                "option `delimiter` must be a buffer or a string,",
                `got ${JSON.stringify(options.delimiter)}`
            ])
        ];
    }
    // Normalize option `quote`
    if (options.quote === undefined || options.quote === null) {
        options.quote = '"';
    } else if (options.quote === true) {
        options.quote = '"';
    } else if (options.quote === false) {
        options.quote = "";
    } else if (Buffer.isBuffer(options.quote)) {
        options.quote = options.quote.toString();
    } else if (typeof options.quote !== "string") {
        return [
            new CsvError("CSV_OPTION_QUOTE_INVALID_TYPE", [
                "option `quote` must be a boolean, a buffer or a string,",
                `got ${JSON.stringify(options.quote)}`
            ])
        ];
    }
    // Normalize option `quoted`
    if (options.quoted === undefined || options.quoted === null) {
        options.quoted = false;
    }
    // Normalize option `escape_formulas`
    if (options.escape_formulas === undefined || options.escape_formulas === null) {
        options.escape_formulas = false;
    } else if (typeof options.escape_formulas !== "boolean") {
        return [
            new CsvError("CSV_OPTION_ESCAPE_FORMULAS_INVALID_TYPE", [
                "option `escape_formulas` must be a boolean,",
                `got ${JSON.stringify(options.escape_formulas)}`
            ])
        ];
    }
    // Normalize option `quoted_empty`
    if (options.quoted_empty === undefined || options.quoted_empty === null) {
        options.quoted_empty = undefined;
    }
    // Normalize option `quoted_match`
    if (options.quoted_match === undefined || options.quoted_match === null || options.quoted_match === false) {
        options.quoted_match = null;
    } else if (!Array.isArray(options.quoted_match)) {
        options.quoted_match = [
            options.quoted_match
        ];
    }
    if (options.quoted_match) {
        for (const quoted_match of options.quoted_match){
            const isString = typeof quoted_match === "string";
            const isRegExp = quoted_match instanceof RegExp;
            if (!isString && !isRegExp) {
                return [
                    Error(`Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`)
                ];
            }
        }
    }
    // Normalize option `quoted_string`
    if (options.quoted_string === undefined || options.quoted_string === null) {
        options.quoted_string = false;
    }
    // Normalize option `eof`
    if (options.eof === undefined || options.eof === null) {
        options.eof = true;
    }
    // Normalize option `escape`
    if (options.escape === undefined || options.escape === null) {
        options.escape = '"';
    } else if (Buffer.isBuffer(options.escape)) {
        options.escape = options.escape.toString();
    } else if (typeof options.escape !== "string") {
        return [
            Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`)
        ];
    }
    if (options.escape.length > 1) {
        return [
            Error(`Invalid Option: escape must be one character, got ${options.escape.length} characters`)
        ];
    }
    // Normalize option `header`
    if (options.header === undefined || options.header === null) {
        options.header = false;
    }
    // Normalize option `columns`
    const [errColumns, columns] = normalize_columns(options.columns);
    if (errColumns !== undefined) return [
        errColumns
    ];
    options.columns = columns;
    // Normalize option `quoted`
    if (options.quoted === undefined || options.quoted === null) {
        options.quoted = false;
    }
    // Normalize option `cast`
    if (options.cast === undefined || options.cast === null) {
        options.cast = {};
    }
    // Normalize option cast.bigint
    if (options.cast.bigint === undefined || options.cast.bigint === null) {
        // Cast boolean to string by default
        options.cast.bigint = (value)=>"" + value;
    }
    // Normalize option cast.boolean
    if (options.cast.boolean === undefined || options.cast.boolean === null) {
        // Cast boolean to string by default
        options.cast.boolean = (value)=>value ? "1" : "";
    }
    // Normalize option cast.date
    if (options.cast.date === undefined || options.cast.date === null) {
        // Cast date to timestamp string by default
        options.cast.date = (value)=>"" + value.getTime();
    }
    // Normalize option cast.number
    if (options.cast.number === undefined || options.cast.number === null) {
        // Cast number to string using native casting by default
        options.cast.number = (value)=>"" + value;
    }
    // Normalize option cast.object
    if (options.cast.object === undefined || options.cast.object === null) {
        // Stringify object as JSON by default
        options.cast.object = (value)=>JSON.stringify(value);
    }
    // Normalize option cast.string
    if (options.cast.string === undefined || options.cast.string === null) {
        // Leave string untouched
        options.cast.string = function(value) {
            return value;
        };
    }
    // Normalize option `on_record`
    if (options.on_record !== undefined && typeof options.on_record !== "function") {
        return [
            Error(`Invalid Option: "on_record" must be a function.`)
        ];
    }
    // Normalize option `record_delimiter`
    if (options.record_delimiter === undefined || options.record_delimiter === null) {
        options.record_delimiter = "\n";
    } else if (Buffer.isBuffer(options.record_delimiter)) {
        options.record_delimiter = options.record_delimiter.toString();
    } else if (typeof options.record_delimiter !== "string") {
        return [
            Error(`Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`)
        ];
    }
    switch(options.record_delimiter){
        case "unix":
            options.record_delimiter = "\n";
            break;
        case "mac":
            options.record_delimiter = "\r";
            break;
        case "windows":
            options.record_delimiter = "\r\n";
            break;
        case "ascii":
            options.record_delimiter = "\u001e";
            break;
        case "unicode":
            options.record_delimiter = "\u2028";
            break;
    }
    return [
        undefined,
        options
    ];
};
const bom_utf8 = Buffer.from([
    239,
    187,
    191
]);
const stringifier = function(options, state, info) {
    return {
        options: options,
        state: state,
        info: info,
        __transform: function(chunk, push) {
            // Chunk validation
            if (!Array.isArray(chunk) && typeof chunk !== "object") {
                return Error(`Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`);
            }
            // Detect columns from the first record
            if (this.info.records === 0) {
                if (Array.isArray(chunk)) {
                    if (this.options.header === true && this.options.columns === undefined) {
                        return Error("Undiscoverable Columns: header option requires column option or object records");
                    }
                } else if (this.options.columns === undefined) {
                    const [err, columns] = normalize_columns(Object.keys(chunk));
                    if (err) return;
                    this.options.columns = columns;
                }
            }
            // Emit the header
            if (this.info.records === 0) {
                this.bom(push);
                const err = this.headers(push);
                if (err) return err;
            }
            // Emit and stringify the record if an object or an array
            try {
                // this.emit('record', chunk, this.info.records);
                if (this.options.on_record) {
                    this.options.on_record(chunk, this.info.records);
                }
            } catch (err) {
                return err;
            }
            // Convert the record into a string
            let err, chunk_string;
            if (this.options.eof) {
                [err, chunk_string] = this.stringify(chunk);
                if (err) return err;
                if (chunk_string === undefined) {
                    return;
                } else {
                    chunk_string = chunk_string + this.options.record_delimiter;
                }
            } else {
                [err, chunk_string] = this.stringify(chunk);
                if (err) return err;
                if (chunk_string === undefined) {
                    return;
                } else {
                    if (this.options.header || this.info.records) {
                        chunk_string = this.options.record_delimiter + chunk_string;
                    }
                }
            }
            // Emit the csv
            this.info.records++;
            push(chunk_string);
        },
        stringify: function(chunk, chunkIsHeader = false) {
            if (typeof chunk !== "object") {
                return [
                    undefined,
                    chunk
                ];
            }
            const { columns } = this.options;
            const record = [];
            // Record is an array
            if (Array.isArray(chunk)) {
                // We are getting an array but the user has specified output columns. In
                // this case, we respect the columns indexes
                if (columns) {
                    chunk.splice(columns.length);
                }
                // Cast record elements
                for(let i = 0; i < chunk.length; i++){
                    const field = chunk[i];
                    const [err, value] = this.__cast(field, {
                        index: i,
                        column: i,
                        records: this.info.records,
                        header: chunkIsHeader
                    });
                    if (err) return [
                        err
                    ];
                    record[i] = [
                        value,
                        field
                    ];
                }
            // Record is a literal object
            // `columns` is always defined: it is either provided or discovered.
            } else {
                for(let i = 0; i < columns.length; i++){
                    const field = get(chunk, columns[i].key);
                    const [err, value] = this.__cast(field, {
                        index: i,
                        column: columns[i].key,
                        records: this.info.records,
                        header: chunkIsHeader
                    });
                    if (err) return [
                        err
                    ];
                    record[i] = [
                        value,
                        field
                    ];
                }
            }
            let csvrecord = "";
            for(let i = 0; i < record.length; i++){
                let options, err;
                let [value, field] = record[i];
                if (typeof value === "string") {
                    options = this.options;
                } else if (is_object(value)) {
                    options = value;
                    value = options.value;
                    delete options.value;
                    if (typeof value !== "string" && value !== undefined && value !== null) {
                        if (err) return [
                            Error(`Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`)
                        ];
                    }
                    options = {
                        ...this.options,
                        ...options
                    };
                    [err, options] = normalize_options(options);
                    if (err !== undefined) {
                        return [
                            err
                        ];
                    }
                } else if (value === undefined || value === null) {
                    options = this.options;
                } else {
                    return [
                        Error(`Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`)
                    ];
                }
                const { delimiter, escape, quote, quoted, quoted_empty, quoted_string, quoted_match, record_delimiter, escape_formulas } = options;
                if ("" === value && "" === field) {
                    let quotedMatch = quoted_match && quoted_match.filter((quoted_match)=>{
                        if (typeof quoted_match === "string") {
                            return value.indexOf(quoted_match) !== -1;
                        } else {
                            return quoted_match.test(value);
                        }
                    });
                    quotedMatch = quotedMatch && quotedMatch.length > 0;
                    const shouldQuote = quotedMatch || true === quoted_empty || true === quoted_string && false !== quoted_empty;
                    if (shouldQuote === true) {
                        value = quote + value + quote;
                    }
                    csvrecord += value;
                } else if (value) {
                    if (typeof value !== "string") {
                        return [
                            Error(`Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`)
                        ];
                    }
                    const containsdelimiter = delimiter.length && value.indexOf(delimiter) >= 0;
                    const containsQuote = quote !== "" && value.indexOf(quote) >= 0;
                    const containsEscape = value.indexOf(escape) >= 0 && escape !== quote;
                    const containsRecordDelimiter = value.indexOf(record_delimiter) >= 0;
                    const quotedString = quoted_string && typeof field === "string";
                    let quotedMatch = quoted_match && quoted_match.filter((quoted_match)=>{
                        if (typeof quoted_match === "string") {
                            return value.indexOf(quoted_match) !== -1;
                        } else {
                            return quoted_match.test(value);
                        }
                    });
                    quotedMatch = quotedMatch && quotedMatch.length > 0;
                    // See https://github.com/adaltas/node-csv/pull/387
                    // More about CSV injection or formula injection, when websites embed
                    // untrusted input inside CSV files:
                    // https://owasp.org/www-community/attacks/CSV_Injection
                    // http://georgemauer.net/2017/10/07/csv-injection.html
                    // Apple Numbers unicode normalization is empirical from testing
                    if (escape_formulas) {
                        switch(value[0]){
                            case "=":
                            case "+":
                            case "-":
                            case "@":
                            case "\t":
                            case "\r":
                            case "\uFF1D":
                            case "\uFF0B":
                            case "\uFF0D":
                            case "\uFF20":
                                value = `'${value}`;
                                break;
                        }
                    }
                    const shouldQuote = containsQuote === true || containsdelimiter || containsRecordDelimiter || quoted || quotedString || quotedMatch;
                    if (shouldQuote === true && containsEscape === true) {
                        const regexp = escape === "\\" ? new RegExp(escape + escape, "g") : new RegExp(escape, "g");
                        value = value.replace(regexp, escape + escape);
                    }
                    if (containsQuote === true) {
                        const regexp = new RegExp(quote, "g");
                        value = value.replace(regexp, escape + quote);
                    }
                    if (shouldQuote === true) {
                        value = quote + value + quote;
                    }
                    csvrecord += value;
                } else if (quoted_empty === true || field === "" && quoted_string === true && quoted_empty !== false) {
                    csvrecord += quote + quote;
                }
                if (i !== record.length - 1) {
                    csvrecord += delimiter;
                }
            }
            return [
                undefined,
                csvrecord
            ];
        },
        bom: function(push) {
            if (this.options.bom !== true) {
                return;
            }
            push(bom_utf8);
        },
        headers: function(push) {
            if (this.options.header === false) {
                return;
            }
            if (this.options.columns === undefined) {
                return;
            }
            let err;
            let headers = this.options.columns.map((column)=>column.header);
            if (this.options.eof) {
                [err, headers] = this.stringify(headers, true);
                headers += this.options.record_delimiter;
            } else {
                [err, headers] = this.stringify(headers);
            }
            if (err) return err;
            push(headers);
        },
        __cast: function(value, context) {
            const type = typeof value;
            try {
                if (type === "string") {
                    // Fine for 99% of the cases
                    return [
                        undefined,
                        this.options.cast.string(value, context)
                    ];
                } else if (type === "bigint") {
                    return [
                        undefined,
                        this.options.cast.bigint(value, context)
                    ];
                } else if (type === "number") {
                    return [
                        undefined,
                        this.options.cast.number(value, context)
                    ];
                } else if (type === "boolean") {
                    return [
                        undefined,
                        this.options.cast.boolean(value, context)
                    ];
                } else if (value instanceof Date) {
                    return [
                        undefined,
                        this.options.cast.date(value, context)
                    ];
                } else if (type === "object" && value !== null) {
                    return [
                        undefined,
                        this.options.cast.object(value, context)
                    ];
                } else {
                    return [
                        undefined,
                        value,
                        value
                    ];
                }
            } catch (err) {
                return [
                    err
                ];
            }
        }
    };
};
const stringify = function(records, opts = {}) {
    const data = [];
    const [err, options] = normalize_options(opts);
    if (err !== undefined) throw err;
    const state = {
        stop: false
    };
    // Information
    const info = {
        records: 0
    };
    const api = stringifier(options, state, info);
    for (const record of records){
        const err = api.__transform(record, function(record) {
            data.push(record);
        });
        if (err !== undefined) throw err;
    }
    if (data.length === 0) {
        api.bom((d)=>{
            data.push(d);
        });
        const err = api.headers((headers)=>{
            data.push(headers);
        });
        if (err !== undefined) throw err;
    }
    return data.join("");
};
exports.stringify = stringify;
}),
"[project]/node_modules/inherits/inherits_browser.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
        }
    };
} else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {};
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
        }
    };
}
}),
"[project]/node_modules/inherits/inherits.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

try {
    var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
    /* istanbul ignore next */ if (typeof util.inherits !== 'function') throw '';
    module.exports = util.inherits;
} catch (e) {
    /* istanbul ignore next */ module.exports = __turbopack_context__.r("[project]/node_modules/inherits/inherits_browser.js [app-route] (ecmascript)");
}
}),
"[project]/node_modules/readable-stream/lib/internal/streams/stream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
}),
"[project]/node_modules/readable-stream/lib/internal/streams/buffer_list.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
var _require = __turbopack_context__.r("[externals]/buffer [external] (buffer, cjs)"), Buffer = _require.Buffer;
var _require2 = __turbopack_context__.r("[externals]/util [external] (util, cjs)"), inspect = _require2.inspect;
var custom = inspect && inspect.custom || 'inspect';
function copyBuffer(src, target, offset) {
    Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/ function() {
    function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    _createClass(BufferList, [
        {
            key: "push",
            value: function push(v) {
                var entry = {
                    data: v,
                    next: null
                };
                if (this.length > 0) this.tail.next = entry;
                else this.head = entry;
                this.tail = entry;
                ++this.length;
            }
        },
        {
            key: "unshift",
            value: function unshift(v) {
                var entry = {
                    data: v,
                    next: this.head
                };
                if (this.length === 0) this.tail = entry;
                this.head = entry;
                ++this.length;
            }
        },
        {
            key: "shift",
            value: function shift() {
                if (this.length === 0) return;
                var ret = this.head.data;
                if (this.length === 1) this.head = this.tail = null;
                else this.head = this.head.next;
                --this.length;
                return ret;
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.head = this.tail = null;
                this.length = 0;
            }
        },
        {
            key: "join",
            value: function join(s) {
                if (this.length === 0) return '';
                var p = this.head;
                var ret = '' + p.data;
                while(p = p.next)ret += s + p.data;
                return ret;
            }
        },
        {
            key: "concat",
            value: function concat(n) {
                if (this.length === 0) return Buffer.alloc(0);
                var ret = Buffer.allocUnsafe(n >>> 0);
                var p = this.head;
                var i = 0;
                while(p){
                    copyBuffer(p.data, ret, i);
                    i += p.data.length;
                    p = p.next;
                }
                return ret;
            }
        },
        {
            key: "consume",
            value: function consume(n, hasStrings) {
                var ret;
                if (n < this.head.data.length) {
                    // `slice` is the same for buffers and strings.
                    ret = this.head.data.slice(0, n);
                    this.head.data = this.head.data.slice(n);
                } else if (n === this.head.data.length) {
                    // First chunk is a perfect match.
                    ret = this.shift();
                } else {
                    // Result spans more than one buffer.
                    ret = hasStrings ? this._getString(n) : this._getBuffer(n);
                }
                return ret;
            }
        },
        {
            key: "first",
            value: function first() {
                return this.head.data;
            }
        },
        {
            key: "_getString",
            value: function _getString(n) {
                var p = this.head;
                var c = 1;
                var ret = p.data;
                n -= ret.length;
                while(p = p.next){
                    var str = p.data;
                    var nb = n > str.length ? str.length : n;
                    if (nb === str.length) ret += str;
                    else ret += str.slice(0, n);
                    n -= nb;
                    if (n === 0) {
                        if (nb === str.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = str.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            }
        },
        {
            key: "_getBuffer",
            value: function _getBuffer(n) {
                var ret = Buffer.allocUnsafe(n);
                var p = this.head;
                var c = 1;
                p.data.copy(ret);
                n -= p.data.length;
                while(p = p.next){
                    var buf = p.data;
                    var nb = n > buf.length ? buf.length : n;
                    buf.copy(ret, ret.length - n, 0, nb);
                    n -= nb;
                    if (n === 0) {
                        if (nb === buf.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = buf.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            }
        },
        {
            key: custom,
            value: function value(_, options) {
                return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
                    // Only inspect one level.
                    depth: 0,
                    // It should not recurse.
                    customInspect: false
                }));
            }
        }
    ]);
    return BufferList;
}();
}),
"[project]/node_modules/readable-stream/lib/internal/streams/destroy.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
        if (cb) {
            cb(err);
        } else if (err) {
            if (!this._writableState) {
                process.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
                this._writableState.errorEmitted = true;
                process.nextTick(emitErrorNT, this, err);
            }
        }
        return this;
    }
    // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks
    if (this._readableState) {
        this._readableState.destroyed = true;
    }
    // if this is a duplex stream mark the writable part as destroyed as well
    if (this._writableState) {
        this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err) {
        if (!cb && err) {
            if (!_this._writableState) {
                process.nextTick(emitErrorAndCloseNT, _this, err);
            } else if (!_this._writableState.errorEmitted) {
                _this._writableState.errorEmitted = true;
                process.nextTick(emitErrorAndCloseNT, _this, err);
            } else {
                process.nextTick(emitCloseNT, _this);
            }
        } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err);
        } else {
            process.nextTick(emitCloseNT, _this);
        }
    });
    return this;
}
function emitErrorAndCloseNT(self, err) {
    emitErrorNT(self, err);
    emitCloseNT(self);
}
function emitCloseNT(self) {
    if (self._writableState && !self._writableState.emitClose) return;
    if (self._readableState && !self._readableState.emitClose) return;
    self.emit('close');
}
function undestroy() {
    if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
    }
    if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
    }
}
function emitErrorNT(self, err) {
    self.emit('error', err);
}
function errorOrDestroy(stream, err) {
    // We have tests that rely on errors being emitted
    // in the same tick, so changing this is semver major.
    // For now when you opt-in to autoDestroy we allow
    // the error to be emitted nextTick. In a future
    // semver major update we should change the default to this.
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
    else stream.emit('error', err);
}
module.exports = {
    destroy: destroy,
    undestroy: undestroy,
    errorOrDestroy: errorOrDestroy
};
}),
"[project]/node_modules/readable-stream/errors.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const codes = {};
function createErrorType(code, message, Base) {
    if (!Base) {
        Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
        if (typeof message === 'string') {
            return message;
        } else {
            return message(arg1, arg2, arg3);
        }
    }
    class NodeError extends Base {
        constructor(arg1, arg2, arg3){
            super(getMessage(arg1, arg2, arg3));
        }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
}
// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i)=>String(i));
        if (len > 2) {
            return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` + expected[len - 1];
        } else if (len === 2) {
            return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
            return `of ${thing} ${expected[0]}`;
        }
    } else {
        return `of ${thing} ${String(expected)}`;
    }
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) {
        this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
    if (typeof start !== 'number') {
        start = 0;
    }
    if (start + search.length > str.length) {
        return false;
    } else {
        return str.indexOf(search, start) !== -1;
    }
}
createErrorType('ERR_INVALID_OPT_VALUE', function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function(name, expected, actual) {
    // determiner: 'must be' or 'must not be'
    let determiner;
    if (typeof expected === 'string' && startsWith(expected, 'not ')) {
        determiner = 'must not be';
        expected = expected.replace(/^not /, '');
    } else {
        determiner = 'must be';
    }
    let msg;
    if (endsWith(name, ' argument')) {
        // For cases like 'first argument'
        msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
    } else {
        const type = includes(name, '.') ? 'property' : 'argument';
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, 'type')}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function(name) {
    return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function(name) {
    return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function(arg) {
    return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;
}),
"[project]/node_modules/readable-stream/lib/internal/streams/state.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var ERR_INVALID_OPT_VALUE = __turbopack_context__.r("[project]/node_modules/readable-stream/errors.js [app-route] (ecmascript)").codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : 'highWaterMark';
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
    }
    // Default value
    return state.objectMode ? 16 : 16 * 1024;
}
module.exports = {
    getHighWaterMark: getHighWaterMark
};
}),
"[project]/node_modules/readable-stream/lib/_stream_writable.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
module.exports = Writable;
/* <replacement> */ function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
}
// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
        onCorkedFinish(_this, state);
    };
}
/* </replacement> */ /*<replacement>*/ var Duplex;
/*</replacement>*/ Writable.WritableState = WritableState;
/*<replacement>*/ var internalUtil = {
    deprecate: __turbopack_context__.r("[project]/node_modules/util-deprecate/node.js [app-route] (ecmascript)")
};
/*</replacement>*/ /*<replacement>*/ var Stream = __turbopack_context__.r("[project]/node_modules/readable-stream/lib/internal/streams/stream.js [app-route] (ecmascript)");
/*</replacement>*/ var Buffer = __turbopack_context__.r("[externals]/buffer [external] (buffer, cjs)").Buffer;
var OurUint8Array = (("TURBOPACK compile-time truthy", 1) ? /*TURBOPACK member replacement*/ __turbopack_context__.g : "TURBOPACK unreachable").Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = __turbopack_context__.r("[project]/node_modules/readable-stream/lib/internal/streams/destroy.js [app-route] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/readable-stream/lib/internal/streams/state.js [app-route] (ecmascript)"), getHighWaterMark = _require.getHighWaterMark;
var _require$codes = __turbopack_context__.r("[project]/node_modules/readable-stream/errors.js [app-route] (ecmascript)").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
__turbopack_context__.r("[project]/node_modules/inherits/inherits.js [app-route] (ecmascript)")(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || __turbopack_context__.r("[project]/node_modules/readable-stream/lib/_stream_duplex.js [app-route] (ecmascript)");
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream,
    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
    if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;
    // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);
    // if _final has been called
    this.finalCalled = false;
    // drain event flag.
    this.needDrain = false;
    // at the start of calling end()
    this.ending = false;
    // when end() has been called, and returned
    this.ended = false;
    // when 'finish' is emitted
    this.finished = false;
    // has it been destroyed
    this.destroyed = false;
    // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || 'utf8';
    // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0;
    // a flag to see when we're in the middle of a write.
    this.writing = false;
    // when true all writes will be buffered until .uncork() call
    this.corked = 0;
    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;
    // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false;
    // the callback that's passed to _write(chunk,cb)
    this.onwrite = function(er) {
        onwrite(stream, er);
    };
    // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null;
    // the amount that is being written when _write is called.
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0;
    // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false;
    // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false;
    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false;
    // Should .destroy() be called after 'finish' (and potentially 'end')
    this.autoDestroy = !!options.autoDestroy;
    // count buffered requests
    this.bufferedRequestCount = 0;
    // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while(current){
        out.push(current);
        current = current.next;
    }
    return out;
};
(function() {
    try {
        Object.defineProperty(WritableState.prototype, 'buffer', {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
                return this.getBuffer();
            }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
        });
    } catch (_) {}
})();
// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
            if (realHasInstance.call(this, object)) return true;
            if (this !== Writable) return false;
            return object && object._writableState instanceof WritableState;
        }
    });
} else {
    realHasInstance = function realHasInstance(object) {
        return object instanceof this;
    };
}
function Writable(options) {
    Duplex = Duplex || __turbopack_context__.r("[project]/node_modules/readable-stream/lib/_stream_duplex.js [app-route] (ecmascript)");
    // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.
    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the WritableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    // legacy.
    this.writable = true;
    if (options) {
        if (typeof options.write === 'function') this._write = options.write;
        if (typeof options.writev === 'function') this._writev = options.writev;
        if (typeof options.destroy === 'function') this._destroy = options.destroy;
        if (typeof options.final === 'function') this._final = options.final;
    }
    Stream.call(this);
}
// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    // TODO: defer error events consistently everywhere, not just the cb
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
}
// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== 'string' && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE('chunk', [
            'string',
            'Buffer'
        ], chunk);
    }
    if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
    }
    return true;
}
Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
    }
    if (isBuf) encoding = 'buffer';
    else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== 'function') cb = nop;
    if (state.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
};
Writable.prototype.cork = function() {
    this._writableState.corked++;
};
Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === 'string') encoding = encoding.toLowerCase();
    if (!([
        'hex',
        'utf8',
        'utf-8',
        'ascii',
        'binary',
        'base64',
        'ucs2',
        'ucs-2',
        'utf16le',
        'utf-16le',
        'raw'
    ].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
};
Object.defineProperty(Writable.prototype, 'writableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
        chunk = Buffer.from(chunk, encoding);
    }
    return chunk;
}
Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
});
// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
            isBuf = true;
            encoding = 'buffer';
            chunk = newChunk;
        }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    // we must ensure that previous needDrain will not be reset to false.
    if (!ret) state.needDrain = true;
    if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
            chunk: chunk,
            encoding: encoding,
            isBuf: isBuf,
            callback: cb,
            next: null
        };
        if (last) {
            last.next = state.lastBufferedRequest;
        } else {
            state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
    } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));
    else if (writev) stream._writev(chunk, state.onwrite);
    else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
        // defer the callback if we are being called synchronously
        // to avoid piling up things on the stack
        process.nextTick(cb, er);
        // this can emit finish, and it will always happen
        // after error
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
    } else {
        // the caller expect this to happen before if
        // it is async
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        // this can emit finish, but finish must
        // always follow error
        finishMaybe(stream, state);
    }
}
function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
}
function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er) onwriteError(stream, state, sync, er, cb);
    else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
        }
        if (sync) {
            process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
            afterWrite(stream, state, finished, cb);
        }
    }
}
function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
}
// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
    }
}
// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while(entry){
            buffer[count] = entry;
            if (!entry.isBuf) allBuffers = false;
            entry = entry.next;
            count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, '', holder.finish);
        // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
        } else {
            state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
    } else {
        // Slow case, write chunks one-by-one
        while(entry){
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            // if we didn't call the onwrite immediately, then
            // it means that we need to wait until it does.
            // also, that means that the chunk and cb are currently
            // being processed, so move the buffer counter past them.
            if (state.writing) {
                break;
            }
        }
        if (entry === null) state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
    }
    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
    // .end() fully uncorks
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    }
    // ignore unnecessary end() calls.
    if (!state.ending) endWritable(this, state, cb);
    return this;
};
Object.defineProperty(Writable.prototype, 'writableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
});
function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
    stream._final(function(err) {
        state.pendingcb--;
        if (err) {
            errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit('prefinish');
        finishMaybe(stream, state);
    });
}
function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === 'function' && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
        } else {
            state.prefinished = true;
            stream.emit('prefinish');
        }
    }
}
function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit('finish');
            if (state.autoDestroy) {
                // In case of duplex streams we need a way to detect
                // if the readable side is ready for autoDestroy as well
                var rState = stream._readableState;
                if (!rState || rState.autoDestroy && rState.endEmitted) {
                    stream.destroy();
                }
            }
        }
    }
    return need;
}
function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
        if (state.finished) process.nextTick(cb);
        else stream.once('finish', cb);
    }
    state.ended = true;
    stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while(entry){
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
    }
    // reuse the free corkReq.
    state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._writableState === undefined) {
            return false;
        }
        return this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._writableState) {
            return;
        }
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._writableState.destroyed = value;
    }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function(err, cb) {
    cb(err);
};
}),
"[project]/node_modules/readable-stream/lib/_stream_duplex.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
/*<replacement>*/ var objectKeys = Object.keys || function(obj) {
    var keys = [];
    for(var key in obj)keys.push(key);
    return keys;
};
/*</replacement>*/ module.exports = Duplex;
var Readable = __turbopack_context__.r("[project]/node_modules/readable-stream/lib/_stream_readable.js [app-route] (ecmascript)");
var Writable = __turbopack_context__.r("[project]/node_modules/readable-stream/lib/_stream_writable.js [app-route] (ecmascript)");
__turbopack_context__.r("[project]/node_modules/inherits/inherits.js [app-route] (ecmascript)")(Duplex, Readable);
{
    // Allow the keys array to be GC'ed.
    var keys = objectKeys(Writable.prototype);
    for(var v = 0; v < keys.length; v++){
        var method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
}function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once('end', onend);
        }
    }
}
Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
});
// the no-half-open enforcer
function onend() {
    // If the writable side ended, then we're ok.
    if (this._writableState.ended) return;
    // no more data can be written.
    // But allow more writes to happen in this tick.
    process.nextTick(onEndNT, this);
}
function onEndNT(self) {
    self.end();
}
Object.defineProperty(Duplex.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined || this._writableState === undefined) {
            return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (this._readableState === undefined || this._writableState === undefined) {
            return;
        }
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
    }
});
}),
"[project]/node_modules/readable-stream/lib/internal/streams/end-of-stream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
var ERR_STREAM_PREMATURE_CLOSE = __turbopack_context__.r("[project]/node_modules/readable-stream/errors.js [app-route] (ecmascript)").codes.ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
    var called = false;
    return function() {
        if (called) return;
        called = true;
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        callback.apply(this, args);
    };
}
function noop() {}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === 'function';
}
function eos(stream, opts, callback) {
    if (typeof opts === 'function') return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish() {
        if (!stream.writable) onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
    };
    var onerror = function onerror(err) {
        callback.call(stream, err);
    };
    var onclose = function onclose() {
        var err;
        if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
    };
    var onrequest = function onrequest() {
        stream.req.on('finish', onfinish);
    };
    if (isRequest(stream)) {
        stream.on('complete', onfinish);
        stream.on('abort', onclose);
        if (stream.req) onrequest();
        else stream.on('request', onrequest);
    } else if (writable && !stream._writableState) {
        // legacy streams
        stream.on('end', onlegacyfinish);
        stream.on('close', onlegacyfinish);
    }
    stream.on('end', onend);
    stream.on('finish', onfinish);
    if (opts.error !== false) stream.on('error', onerror);
    stream.on('close', onclose);
    return function() {
        stream.removeListener('complete', onfinish);
        stream.removeListener('abort', onclose);
        stream.removeListener('request', onrequest);
        if (stream.req) stream.req.removeListener('finish', onfinish);
        stream.removeListener('end', onlegacyfinish);
        stream.removeListener('close', onlegacyfinish);
        stream.removeListener('finish', onfinish);
        stream.removeListener('end', onend);
        stream.removeListener('error', onerror);
        stream.removeListener('close', onclose);
    };
}
module.exports = eos;
}),
"[project]/node_modules/readable-stream/lib/internal/streams/async_iterator.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _Object$setPrototypeO;
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
var finished = __turbopack_context__.r("[project]/node_modules/readable-stream/lib/internal/streams/end-of-stream.js [app-route] (ecmascript)");
var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');
function createIterResult(value, done) {
    return {
        value: value,
        done: done
    };
}
function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
        var data = iter[kStream].read();
        // we defer if data is null
        // we can be expecting either 'end' or
        // 'error'
        if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
        }
    }
}
function onReadable(iter) {
    // we wait for the next tick, because it might
    // emit an error with process.nextTick
    process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
        lastPromise.then(function() {
            if (iter[kEnded]) {
                resolve(createIterResult(undefined, true));
                return;
            }
            iter[kHandlePromise](resolve, reject);
        }, reject);
    };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function() {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream () {
        return this[kStream];
    },
    next: function next() {
        var _this = this;
        // if we have detected an error in the meanwhile
        // reject straight away
        var error = this[kError];
        if (error !== null) {
            return Promise.reject(error);
        }
        if (this[kEnded]) {
            return Promise.resolve(createIterResult(undefined, true));
        }
        if (this[kStream].destroyed) {
            // We need to defer via nextTick because if .destroy(err) is
            // called, the error will be emitted via nextTick, and
            // we cannot guarantee that there is no error lingering around
            // waiting to be emitted.
            return new Promise(function(resolve, reject) {
                process.nextTick(function() {
                    if (_this[kError]) {
                        reject(_this[kError]);
                    } else {
                        resolve(createIterResult(undefined, true));
                    }
                });
            });
        }
        // if we have multiple next() calls
        // we will wait for the previous Promise to finish
        // this logic is optimized to support for await loops,
        // where next() is only called once at a time
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
        } else {
            // fast path needed to support multiple this.push()
            // without triggering the next() queue
            var data = this[kStream].read();
            if (data !== null) {
                return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
    }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    // destroy(err, cb) is a private API
    // we can guarantee we have that here, because we control the
    // Readable class this is attached to
    return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
            if (err) {
                reject(err);
                return;
            }
            resolve(createIterResult(undefined, true));
        });
    });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                resolve(createIterResult(data, false));
            } else {
                iterator[kLastResolve] = resolve;
                iterator[kLastReject] = reject;
            }
        },
        writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
        if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
            var reject = iterator[kLastReject];
            // reject if we are waiting for data in the Promise
            // returned by next() and store the error
            if (reject !== null) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                reject(err);
            }
            iterator[kError] = err;
            return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(undefined, true));
        }
        iterator[kEnded] = true;
    });
    stream.on('readable', onReadable.bind(null, iterator));
    return iterator;
};
module.exports = createReadableStreamAsyncIterator;
}),
"[project]/node_modules/readable-stream/lib/internal/streams/from.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
var ERR_INVALID_ARG_TYPE = __turbopack_context__.r("[project]/node_modules/readable-stream/errors.js [app-route] (ecmascript)").codes.ERR_INVALID_ARG_TYPE;
function from(Readable, iterable, opts) {
    var iterator;
    if (iterable && typeof iterable.next === 'function') {
        iterator = iterable;
    } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();
    else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();
    else throw new ERR_INVALID_ARG_TYPE('iterable', [
        'Iterable'
    ], iterable);
    var readable = new Readable(_objectSpread({
        objectMode: true
    }, opts));
    // Reading boolean to protect against _read
    // being called before last iteration completion.
    var reading = false;
    readable._read = function() {
        if (!reading) {
            reading = true;
            next();
        }
    };
    function next() {
        return _next2.apply(this, arguments);
    }
    function _next2() {
        _next2 = _asyncToGenerator(function*() {
            try {
                var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
                if (done) {
                    readable.push(null);
                } else if (readable.push((yield value))) {
                    next();
                } else {
                    reading = false;
                }
            } catch (err) {
                readable.destroy(err);
            }
        });
        return _next2.apply(this, arguments);
    }
    return readable;
}
module.exports = from;
}),
"[project]/node_modules/readable-stream/lib/_stream_readable.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Readable;
/*<replacement>*/ var Duplex;
/*</replacement>*/ Readable.ReadableState = ReadableState;
/*<replacement>*/ var EE = __turbopack_context__.r("[externals]/events [external] (events, cjs)").EventEmitter;
var EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
};
/*</replacement>*/ /*<replacement>*/ var Stream = __turbopack_context__.r("[project]/node_modules/readable-stream/lib/internal/streams/stream.js [app-route] (ecmascript)");
/*</replacement>*/ var Buffer = __turbopack_context__.r("[externals]/buffer [external] (buffer, cjs)").Buffer;
var OurUint8Array = (("TURBOPACK compile-time truthy", 1) ? /*TURBOPACK member replacement*/ __turbopack_context__.g : "TURBOPACK unreachable").Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/ var debugUtil = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
var debug;
if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog('stream');
} else {
    debug = function debug() {};
}
/*</replacement>*/ var BufferList = __turbopack_context__.r("[project]/node_modules/readable-stream/lib/internal/streams/buffer_list.js [app-route] (ecmascript)");
var destroyImpl = __turbopack_context__.r("[project]/node_modules/readable-stream/lib/internal/streams/destroy.js [app-route] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/readable-stream/lib/internal/streams/state.js [app-route] (ecmascript)"), getHighWaterMark = _require.getHighWaterMark;
var _require$codes = __turbopack_context__.r("[project]/node_modules/readable-stream/errors.js [app-route] (ecmascript)").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
// Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
__turbopack_context__.r("[project]/node_modules/inherits/inherits.js [app-route] (ecmascript)")(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = [
    'error',
    'close',
    'destroy',
    'pause',
    'resume'
];
function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [
        fn,
        emitter._events[event]
    ];
}
function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || __turbopack_context__.r("[project]/node_modules/readable-stream/lib/_stream_duplex.js [app-route] (ecmascript)");
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;
    // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);
    // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    this.sync = true;
    // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false;
    // Should .destroy() be called after 'end' (and potentially 'finish')
    this.autoDestroy = !!options.autoDestroy;
    // has it been destroyed
    this.destroyed = false;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || 'utf8';
    // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0;
    // if true, a maybeReadMore has been scheduled
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
        if (!StringDecoder) StringDecoder = __turbopack_context__.f({
            "string_decoder": {
                id: ()=>"[project]/node_modules/string_decoder/lib/string_decoder.js [app-route] (ecmascript)",
                module: ()=>__turbopack_context__.r("[project]/node_modules/string_decoder/lib/string_decoder.js [app-route] (ecmascript)")
            },
            "string_decoder/": {
                id: ()=>"[project]/node_modules/string_decoder/lib/string_decoder.js [app-route] (ecmascript)",
                module: ()=>__turbopack_context__.r("[project]/node_modules/string_decoder/lib/string_decoder.js [app-route] (ecmascript)")
            }
        })('string_decoder/').StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}
function Readable(options) {
    Duplex = Duplex || __turbopack_context__.r("[project]/node_modules/readable-stream/lib/_stream_duplex.js [app-route] (ecmascript)");
    if (!(this instanceof Readable)) return new Readable(options);
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the ReadableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    // legacy
    this.readable = true;
    if (options) {
        if (typeof options.read === 'function') this._read = options.read;
        if (typeof options.destroy === 'function') this._destroy = options.destroy;
    }
    Stream.call(this);
}
Object.defineProperty(Readable.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined) {
            return false;
        }
        return this._readableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._readableState) {
            return;
        }
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
    }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function(err, cb) {
    cb(err);
};
// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
        if (typeof chunk === 'string') {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
                chunk = Buffer.from(chunk, encoding);
                encoding = '';
            }
            skipChunkCheck = true;
        }
    } else {
        skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};
// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug('readableAddChunk', chunk);
    var state = stream._readableState;
    if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
    } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
            errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
                if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                else addChunk(stream, state, chunk, true);
            } else if (state.ended) {
                errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
                return false;
            } else {
                state.reading = false;
                if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
                    else maybeReadMore(stream, state);
                } else {
                    addChunk(stream, state, chunk, false);
                }
            }
        } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
        }
    }
    // We can push more data if we are below the highWaterMark.
    // Also, if we have no data yet, we can stand some more bytes.
    // This is to work around cases where hwm=0, such as the repl.
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit('data', chunk);
    } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE('chunk', [
            'string',
            'Buffer',
            'Uint8Array'
        ], chunk);
    }
    return er;
}
Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
};
// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = __turbopack_context__.f({
        "string_decoder": {
            id: ()=>"[project]/node_modules/string_decoder/lib/string_decoder.js [app-route] (ecmascript)",
            module: ()=>__turbopack_context__.r("[project]/node_modules/string_decoder/lib/string_decoder.js [app-route] (ecmascript)")
        },
        "string_decoder/": {
            id: ()=>"[project]/node_modules/string_decoder/lib/string_decoder.js [app-route] (ecmascript)",
            module: ()=>__turbopack_context__.r("[project]/node_modules/string_decoder/lib/string_decoder.js [app-route] (ecmascript)")
        }
    })('string_decoder/').StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    // If setEncoding(null), decoder.encoding equals utf8
    this._readableState.encoding = this._readableState.decoder.encoding;
    // Iterate over current buffer to convert already stored Buffers:
    var p = this._readableState.buffer.head;
    var content = '';
    while(p !== null){
        content += decoder.write(p.data);
        p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== '') this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
};
// Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
        // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
        n = MAX_HWM;
    } else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
}
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
    }
    // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n;
    // Don't have enough
    if (!state.ended) {
        state.needReadable = true;
        return 0;
    }
    return state.length;
}
// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
    debug('read', n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false;
    // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
    }
    n = howMuchToRead(n, state);
    // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
    }
    // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    debug('need readable', doRead);
    // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug('length less than watermark', doRead);
    }
    // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
        doRead = false;
        debug('reading or ended', doRead);
    } else if (doRead) {
        debug('do read');
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0) state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
        // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0) ret = fromList(n, state);
    else ret = null;
    if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
    } else {
        state.length -= n;
        state.awaitDrain = 0;
    }
    if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true;
        // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) endReadable(this);
    }
    if (ret !== null) this.emit('data', ret);
    return ret;
};
function onEofChunk(stream, state) {
    debug('onEofChunk');
    if (state.ended) return;
    if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;
    if (state.sync) {
        // if we are sync, wait until next tick to emit the data.
        // Otherwise we risk emitting data in the flow()
        // the readable code triggers during a read() call
        emitReadable(stream);
    } else {
        // emit 'readable' now to make sure it gets picked up.
        state.needReadable = false;
        if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
        }
    }
}
// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
    var state = stream._readableState;
    debug('emitReadable', state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
        debug('emitReadable', state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
    }
}
function emitReadable_(stream) {
    var state = stream._readableState;
    debug('emitReadable_', state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
        stream.emit('readable');
        state.emittedReadable = false;
    }
    // The stream needs another readable event if
    // 1. It is not flowing, as the flow mechanism will take
    //    care of it.
    // 2. It is not ended.
    // 3. It is below the highWaterMark, so we can schedule
    //    another readable later.
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
}
// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
    if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
    }
}
function maybeReadMore_(stream, state) {
    // Attempt to read more data if we should.
    //
    // The conditions for reading more data are (one of):
    // - Not enough data buffered (state.length < state.highWaterMark). The loop
    //   is responsible for filling the buffer with enough data if such data
    //   is available. If highWaterMark is 0 and we are not in the flowing mode
    //   we should _not_ attempt to buffer any extra data. We'll get more data
    //   when the stream consumer calls read() instead.
    // - No data in the buffer, and the stream is in flowing mode. In this mode
    //   the loop below is responsible for ensuring read() is called. Failing to
    //   call read here would abort the flow and there's no other mechanism for
    //   continuing the flow if the stream consumer has just subscribed to the
    //   'data' event.
    //
    // In addition to the above conditions to keep reading data, the following
    // conditions prevent the data from being read:
    // - The stream has ended (state.ended).
    // - There is already a pending 'read' operation (state.reading). This is a
    //   case where the the stream has called the implementation defined _read()
    //   method, but they are processing the call asynchronously and have _not_
    //   called push() with new data. In this case we skip performing more
    //   read()s. The execution ends in this method again after the _read() ends
    //   up calling push() with more data.
    while(!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)){
        var len = state.length;
        debug('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length) break;
    }
    state.readingMore = false;
}
// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch(state.pipesCount){
        case 0:
            state.pipes = dest;
            break;
        case 1:
            state.pipes = [
                state.pipes,
                dest
            ];
            break;
        default:
            state.pipes.push(dest);
            break;
    }
    state.pipesCount += 1;
    debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) process.nextTick(endFn);
    else src.once('end', endFn);
    dest.on('unpipe', onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug('onunpipe');
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        debug('onend');
        dest.end();
    }
    // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = pipeOnDrain(src);
    dest.on('drain', ondrain);
    var cleanedUp = false;
    function cleanup() {
        debug('cleanup');
        // cleanup event handlers once the pipe is broken
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', unpipe);
        src.removeListener('data', ondata);
        cleanedUp = true;
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on('data', ondata);
    function ondata(chunk) {
        debug('ondata');
        var ret = dest.write(chunk);
        debug('dest.write', ret);
        if (ret === false) {
            // If the user unpiped during `dest.write()`, it is possible
            // to get stuck in a permanently paused state if that write
            // also returned false.
            // => Check whether `dest` is still a piping destination.
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                debug('false write response, pause', state.awaitDrain);
                state.awaitDrain++;
            }
            src.pause();
        }
    }
    // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
        debug('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
    }
    // Make sure our error handler is attached before userland ones.
    prependListener(dest, 'error', onerror);
    // Both close and finish should trigger unpipe, but only once.
    function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
    }
    dest.once('close', onclose);
    function onfinish() {
        debug('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
    }
    dest.once('finish', onfinish);
    function unpipe() {
        debug('unpipe');
        src.unpipe(dest);
    }
    // tell the dest that it's being piped to
    dest.emit('pipe', src);
    // start the flow if it hasn't been started already.
    if (!state.flowing) {
        debug('pipe resume');
        src.resume();
    }
    return dest;
};
function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
            state.flowing = true;
            flow(src);
        }
    };
}
Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
        hasUnpiped: false
    };
    // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this;
    // just one destination.  most common case.
    if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit('unpipe', this, unpipeInfo);
        return this;
    }
    // slow case. multiple pipe destinations.
    if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for(var i = 0; i < len; i++)dests[i].emit('unpipe', this, {
            hasUnpiped: false
        });
        return this;
    }
    // try to find the right one.
    var index = indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit('unpipe', this, unpipeInfo);
    return this;
};
// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === 'data') {
        // update readableListening so that resume() may be a no-op
        // a few lines down. This is needed to support once('readable').
        state.readableListening = this.listenerCount('readable') > 0;
        // Try start flowing on next tick if stream isn't explicitly paused
        if (state.flowing !== false) this.resume();
    } else if (ev === 'readable') {
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug('on readable', state.length, state.reading);
            if (state.length) {
                emitReadable(this);
            } else if (!state.reading) {
                process.nextTick(nReadingNextTick, this);
            }
        }
    }
    return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === 'readable') {
        // We need to check if there is someone still listening to
        // readable and reset the state. However this needs to happen
        // after readable has been emitted but before I/O (nextTick) to
        // support once('readable', fn) cycles. This means that calling
        // resume within the same tick will have no
        // effect.
        process.nextTick(updateReadableListening, this);
    }
    return res;
};
Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === 'readable' || ev === undefined) {
        // We need to check if there is someone still listening to
        // readable and reset the state. However this needs to happen
        // after readable has been emitted but before I/O (nextTick) to
        // support once('readable', fn) cycles. This means that calling
        // resume within the same tick will have no
        // effect.
        process.nextTick(updateReadableListening, this);
    }
    return res;
};
function updateReadableListening(self) {
    var state = self._readableState;
    state.readableListening = self.listenerCount('readable') > 0;
    if (state.resumeScheduled && !state.paused) {
        // flowing needs to be set to true now, otherwise
        // the upcoming resume will not flow.
        state.flowing = true;
    // crude way to check if we should resume
    } else if (self.listenerCount('data') > 0) {
        self.resume();
    }
}
function nReadingNextTick(self) {
    debug('readable nexttick read 0');
    self.read(0);
}
// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
        debug('resume');
        // we flow only if there is no one listening
        // for readable, but we still have to call
        // resume()
        state.flowing = !state.readableListening;
        resume(this, state);
    }
    state.paused = false;
    return this;
};
function resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
    }
}
function resume_(stream, state) {
    debug('resume', state.reading);
    if (!state.reading) {
        stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit('resume');
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function() {
    debug('call pause flowing=%j', this._readableState.flowing);
    if (this._readableState.flowing !== false) {
        debug('pause');
        this._readableState.flowing = false;
        this.emit('pause');
    }
    this._readableState.paused = true;
    return this;
};
function flow(stream) {
    var state = stream._readableState;
    debug('flow', state.flowing);
    while(state.flowing && stream.read() !== null);
}
// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on('end', function() {
        debug('wrapped end');
        if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
    });
    stream.on('data', function(chunk) {
        debug('wrapped data');
        if (state.decoder) chunk = state.decoder.write(chunk);
        // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
            paused = true;
            stream.pause();
        }
    });
    // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for(var i in stream){
        if (this[i] === undefined && typeof stream[i] === 'function') {
            this[i] = function methodWrap(method) {
                return function methodWrapReturnFunction() {
                    return stream[method].apply(stream, arguments);
                };
            }(i);
        }
    }
    // proxy certain important events.
    for(var n = 0; n < kProxyEvents.length; n++){
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    this._read = function(n) {
        debug('wrapped _read', n);
        if (paused) {
            paused = false;
            stream.resume();
        }
    };
    return this;
};
if (typeof Symbol === 'function') {
    Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === undefined) {
            createReadableStreamAsyncIterator = __turbopack_context__.r("[project]/node_modules/readable-stream/lib/internal/streams/async_iterator.js [app-route] (ecmascript)");
        }
        return createReadableStreamAsyncIterator(this);
    };
}
Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.highWaterMark;
    }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState && this._readableState.buffer;
    }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.flowing;
    },
    set: function set(state) {
        if (this._readableState) {
            this._readableState.flowing = state;
        }
    }
});
// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.length;
    }
});
// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();
    else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join('');
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
    } else {
        // read part of list
        ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
}
function endReadable(stream) {
    var state = stream._readableState;
    debug('endReadable', state.endEmitted);
    if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
    }
}
function endReadableNT(state, stream) {
    debug('endReadableNT', state.endEmitted, state.length);
    // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
        if (state.autoDestroy) {
            // In case of duplex streams we need a way to detect
            // if the writable side is ready for autoDestroy as well
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
                stream.destroy();
            }
        }
    }
}
if (typeof Symbol === 'function') {
    Readable.from = function(iterable, opts) {
        if (from === undefined) {
            from = __turbopack_context__.r("[project]/node_modules/readable-stream/lib/internal/streams/from.js [app-route] (ecmascript)");
        }
        return from(Readable, iterable, opts);
    };
}
function indexOf(xs, x) {
    for(var i = 0, l = xs.length; i < l; i++){
        if (xs[i] === x) return i;
    }
    return -1;
}
}),
"[project]/node_modules/readable-stream/lib/_stream_transform.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
module.exports = Transform;
var _require$codes = __turbopack_context__.r("[project]/node_modules/readable-stream/errors.js [app-route] (ecmascript)").codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = __turbopack_context__.r("[project]/node_modules/readable-stream/lib/_stream_duplex.js [app-route] (ecmascript)");
__turbopack_context__.r("[project]/node_modules/inherits/inherits.js [app-route] (ecmascript)")(Transform, Duplex);
function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
        return this.emit('error', new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
    }
}
function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
    };
    // start out asking for a readable event once data is transformed.
    this._readableState.needReadable = true;
    // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;
    if (options) {
        if (typeof options.transform === 'function') this._transform = options.transform;
        if (typeof options.flush === 'function') this._flush = options.flush;
    }
    // When the writable side finishes, then flush out anything remaining.
    this.on('prefinish', prefinish);
}
function prefinish() {
    var _this = this;
    if (typeof this._flush === 'function' && !this._readableState.destroyed) {
        this._flush(function(er, data) {
            done(_this, er, data);
        });
    } else {
        done(this, null, null);
    }
}
Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
};
// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};
Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
};
// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
    }
};
Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
    });
};
function done(stream, er, data) {
    if (er) return stream.emit('error', er);
    if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);
    // TODO(BridgeAR): Write a test for these two error cases
    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided
    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
}
}),
"[project]/node_modules/readable-stream/lib/_stream_passthrough.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
module.exports = PassThrough;
var Transform = __turbopack_context__.r("[project]/node_modules/readable-stream/lib/_stream_transform.js [app-route] (ecmascript)");
__turbopack_context__.r("[project]/node_modules/inherits/inherits.js [app-route] (ecmascript)")(PassThrough, Transform);
function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
};
}),
"[project]/node_modules/readable-stream/lib/internal/streams/pipeline.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
var eos;
function once(callback) {
    var called = false;
    return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
    };
}
var _require$codes = __turbopack_context__.r("[project]/node_modules/readable-stream/errors.js [app-route] (ecmascript)").codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
    // Rethrow the error if it exists to avoid swallowing it
    if (err) throw err;
}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === 'function';
}
function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on('close', function() {
        closed = true;
    });
    if (eos === undefined) eos = __turbopack_context__.r("[project]/node_modules/readable-stream/lib/internal/streams/end-of-stream.js [app-route] (ecmascript)");
    eos(stream, {
        readable: reading,
        writable: writing
    }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
    });
    var destroyed = false;
    return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        // request.destroy just do .end - .abort is what we want
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === 'function') return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED('pipe'));
    };
}
function call(fn) {
    fn();
}
function pipe(from, to) {
    return from.pipe(to);
}
function popCallback(streams) {
    if (!streams.length) return noop;
    if (typeof streams[streams.length - 1] !== 'function') return noop;
    return streams.pop();
}
function pipeline() {
    for(var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++){
        streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) {
        throw new ERR_MISSING_ARGS('streams');
    }
    var error;
    var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
            if (!error) error = err;
            if (err) destroys.forEach(call);
            if (reading) return;
            destroys.forEach(call);
            callback(error);
        });
    });
    return streams.reduce(pipe);
}
module.exports = pipeline;
}),
"[project]/node_modules/readable-stream/readable.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
if (process.env.READABLE_STREAM === 'disable' && Stream) {
    module.exports = Stream.Readable;
    Object.assign(module.exports, Stream);
    module.exports.Stream = Stream;
} else {
    exports = module.exports = __turbopack_context__.r("[project]/node_modules/readable-stream/lib/_stream_readable.js [app-route] (ecmascript)");
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = __turbopack_context__.r("[project]/node_modules/readable-stream/lib/_stream_writable.js [app-route] (ecmascript)");
    exports.Duplex = __turbopack_context__.r("[project]/node_modules/readable-stream/lib/_stream_duplex.js [app-route] (ecmascript)");
    exports.Transform = __turbopack_context__.r("[project]/node_modules/readable-stream/lib/_stream_transform.js [app-route] (ecmascript)");
    exports.PassThrough = __turbopack_context__.r("[project]/node_modules/readable-stream/lib/_stream_passthrough.js [app-route] (ecmascript)");
    exports.finished = __turbopack_context__.r("[project]/node_modules/readable-stream/lib/internal/streams/end-of-stream.js [app-route] (ecmascript)");
    exports.pipeline = __turbopack_context__.r("[project]/node_modules/readable-stream/lib/internal/streams/pipeline.js [app-route] (ecmascript)");
}
}),
"[project]/node_modules/util-deprecate/node.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * For Node.js, simply re-export the core `util.deprecate` function.
 */ module.exports = __turbopack_context__.r("[externals]/util [external] (util, cjs)").deprecate;
}),
"[project]/node_modules/safe-buffer/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* eslint-disable node/no-deprecated-api */ var buffer = __turbopack_context__.r("[externals]/buffer [external] (buffer, cjs)");
var Buffer = buffer.Buffer;
// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
    for(var key in src){
        dst[key] = src[key];
    }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer;
} else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
}
SafeBuffer.prototype = Object.create(Buffer.prototype);
// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
        throw new TypeError('Argument must not be a number');
    }
    return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    var buf = Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === 'string') {
            buf.fill(fill, encoding);
        } else {
            buf.fill(fill);
        }
    } else {
        buf.fill(0);
    }
    return buf;
};
SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    return buffer.SlowBuffer(size);
};
}),
"[project]/node_modules/string_decoder/lib/string_decoder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
/*<replacement>*/ var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-route] (ecmascript)").Buffer;
/*</replacement>*/ var isEncoding = Buffer.isEncoding || function(encoding) {
    encoding = '' + encoding;
    switch(encoding && encoding.toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
        case 'raw':
            return true;
        default:
            return false;
    }
};
function _normalizeEncoding(enc) {
    if (!enc) return 'utf8';
    var retried;
    while(true){
        switch(enc){
            case 'utf8':
            case 'utf-8':
                return 'utf8';
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
                return 'utf16le';
            case 'latin1':
            case 'binary':
                return 'latin1';
            case 'base64':
            case 'ascii':
            case 'hex':
                return enc;
            default:
                if (retried) return; // undefined
                enc = ('' + enc).toLowerCase();
                retried = true;
        }
    }
}
;
// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
    return nenc || enc;
}
// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch(this.encoding){
        case 'utf16le':
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
        case 'utf8':
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
        case 'base64':
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
        default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer.allocUnsafe(nb);
}
StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return '';
    var r;
    var i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return '';
        i = this.lastNeed;
        this.lastNeed = 0;
    } else {
        i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || '';
};
StringDecoder.prototype.end = utf8End;
// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;
// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
};
// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
    if (byte <= 0x7F) return 0;
    else if (byte >> 5 === 0x06) return 2;
    else if (byte >> 4 === 0x0E) return 3;
    else if (byte >> 3 === 0x1E) return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
}
// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return '\ufffd';
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return '\ufffd';
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
                self.lastNeed = 2;
                return '\ufffd';
            }
        }
    }
}
// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString('utf8', i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString('utf8', i, end);
}
// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) return r + '\ufffd';
    return r;
}
// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
        var r = buf.toString('utf16le', i);
        if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 0xD800 && c <= 0xDBFF) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
            }
        }
        return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString('utf16le', i, buf.length - 1);
}
// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString('utf16le', 0, end);
    }
    return r;
}
function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString('base64', i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
    } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString('base64', i, buf.length - n);
}
function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
    return r;
}
// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : '';
}
}),
"[project]/node_modules/multistream/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = MultiStream;
var inherits = __turbopack_context__.r("[project]/node_modules/inherits/inherits.js [app-route] (ecmascript)");
var stream = __turbopack_context__.r("[project]/node_modules/readable-stream/readable.js [app-route] (ecmascript)");
inherits(MultiStream, stream.Readable);
function MultiStream(streams, opts) {
    var self = this;
    if (!(self instanceof MultiStream)) return new MultiStream(streams, opts);
    stream.Readable.call(self, opts);
    self.destroyed = false;
    self._drained = false;
    self._forwarding = false;
    self._current = null;
    self._toStreams2 = opts && opts.objectMode ? toStreams2Obj : toStreams2Buf;
    if (typeof streams === 'function') {
        self._queue = streams;
    } else {
        self._queue = streams.map(self._toStreams2);
        self._queue.forEach(function(stream) {
            if (typeof stream !== 'function') self._attachErrorListener(stream);
        });
    }
    self._next();
}
MultiStream.obj = function(streams) {
    return new MultiStream(streams, {
        objectMode: true,
        highWaterMark: 16
    });
};
MultiStream.prototype._read = function() {
    this._drained = true;
    this._forward();
};
MultiStream.prototype._forward = function() {
    if (this._forwarding || !this._drained || !this._current) return;
    this._forwarding = true;
    var chunk;
    while((chunk = this._current.read()) !== null && this._drained){
        this._drained = this.push(chunk);
    }
    this._forwarding = false;
};
MultiStream.prototype.destroy = function(err) {
    if (this.destroyed) return;
    this.destroyed = true;
    if (this._current && this._current.destroy) this._current.destroy();
    if (typeof this._queue !== 'function') {
        this._queue.forEach(function(stream) {
            if (stream.destroy) stream.destroy();
        });
    }
    if (err) this.emit('error', err);
    this.emit('close');
};
MultiStream.prototype._next = function() {
    var self = this;
    self._current = null;
    if (typeof self._queue === 'function') {
        self._queue(function(err, stream) {
            if (err) return self.destroy(err);
            stream = self._toStreams2(stream);
            self._attachErrorListener(stream);
            self._gotNextStream(stream);
        });
    } else {
        var stream = self._queue.shift();
        if (typeof stream === 'function') {
            stream = self._toStreams2(stream());
            self._attachErrorListener(stream);
        }
        self._gotNextStream(stream);
    }
};
MultiStream.prototype._gotNextStream = function(stream) {
    var self = this;
    if (!stream) {
        self.push(null);
        self.destroy();
        return;
    }
    self._current = stream;
    self._forward();
    stream.on('readable', onReadable);
    stream.once('end', onEnd);
    stream.once('close', onClose);
    function onReadable() {
        self._forward();
    }
    function onClose() {
        if (!stream._readableState.ended) {
            self.destroy();
        }
    }
    function onEnd() {
        self._current = null;
        stream.removeListener('readable', onReadable);
        stream.removeListener('end', onEnd);
        stream.removeListener('close', onClose);
        self._next();
    }
};
MultiStream.prototype._attachErrorListener = function(stream) {
    var self = this;
    if (!stream) return;
    stream.once('error', onError);
    function onError(err) {
        stream.removeListener('error', onError);
        self.destroy(err);
    }
};
function toStreams2Obj(s) {
    return toStreams2(s, {
        objectMode: true,
        highWaterMark: 16
    });
}
function toStreams2Buf(s) {
    return toStreams2(s);
}
function toStreams2(s, opts) {
    if (!s || typeof s === 'function' || s._readableState) return s;
    var wrap = new stream.Readable(opts).wrap(s);
    if (s.destroy) {
        wrap.destroy = s.destroy.bind(s);
    }
    return wrap;
}
}),
"[project]/node_modules/faye/src/util/constants.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = {
    VERSION: '1.4.1',
    BAYEUX_VERSION: '1.0',
    ID_LENGTH: 160,
    JSONP_CALLBACK: 'jsonpcallback',
    CONNECTION_TYPES: [
        'long-polling',
        'cross-origin-long-polling',
        'callback-polling',
        'websocket',
        'eventsource',
        'in-process'
    ],
    MANDATORY_CONNECTION_TYPES: [
        'long-polling',
        'callback-polling',
        'in-process'
    ]
};
}),
"[project]/node_modules/faye/src/util/to_json.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// http://assanka.net/content/tech/2009/09/02/json2-js-vs-prototype/
module.exports = function(object) {
    return JSON.stringify(object, function(key, value) {
        return this[key] instanceof Array ? this[key] : value;
    });
};
}),
"[project]/node_modules/faye/src/mixins/logging.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var toJSON = __turbopack_context__.r("[project]/node_modules/faye/src/util/to_json.js [app-route] (ecmascript)");
var Logging = {
    LOG_LEVELS: {
        fatal: 4,
        error: 3,
        warn: 2,
        info: 1,
        debug: 0
    },
    writeLog: function(messageArgs, level) {
        var logger = Logging.logger || (Logging.wrapper || Logging).logger;
        if (!logger) return;
        var args = Array.prototype.slice.apply(messageArgs), banner = '[Faye', klass = this.className, message = args.shift().replace(/\?/g, function() {
            try {
                return toJSON(args.shift());
            } catch (error) {
                return '[Object]';
            }
        });
        if (klass) banner += '.' + klass;
        banner += '] ';
        if (typeof logger[level] === 'function') logger[level](banner + message);
        else if (typeof logger === 'function') logger(banner + message);
    }
};
for(var key in Logging.LOG_LEVELS)(function(level) {
    Logging[level] = function() {
        this.writeLog(arguments, level);
    };
})(key);
module.exports = Logging;
}),
"[project]/node_modules/faye/src/util/assign.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var forEach = Array.prototype.forEach, hasOwn = Object.prototype.hasOwnProperty;
module.exports = function(target) {
    forEach.call(arguments, function(source, i) {
        if (i === 0) return;
        for(var key in source){
            if (hasOwn.call(source, key)) target[key] = source[key];
        }
    });
    return target;
};
}),
"[project]/node_modules/faye/src/util/class.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var assign = __turbopack_context__.r("[project]/node_modules/faye/src/util/assign.js [app-route] (ecmascript)");
module.exports = function(parent, methods) {
    if (typeof parent !== 'function') {
        methods = parent;
        parent = Object;
    }
    var klass = function() {
        if (!this.initialize) return this;
        return this.initialize.apply(this, arguments) || this;
    };
    var bridge = function() {};
    bridge.prototype = parent.prototype;
    klass.prototype = new bridge();
    assign(klass.prototype, methods);
    return klass;
};
}),
"[project]/node_modules/faye/src/util/promise.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var asap = __turbopack_context__.r("[project]/node_modules/asap/asap.js [app-route] (ecmascript)");
var PENDING = -1, FULFILLED = 0, REJECTED = 1;
var Promise = function(task) {
    this._state = PENDING;
    this._value = null;
    this._defer = [];
    execute(this, task);
};
Promise.prototype.then = function(onFulfilled, onRejected) {
    var promise = new Promise();
    var deferred = {
        promise: promise,
        onFulfilled: onFulfilled,
        onRejected: onRejected
    };
    if (this._state === PENDING) this._defer.push(deferred);
    else propagate(this, deferred);
    return promise;
};
Promise.prototype['catch'] = function(onRejected) {
    return this.then(null, onRejected);
};
var execute = function(promise, task) {
    if (typeof task !== 'function') return;
    var calls = 0;
    var resolvePromise = function(value) {
        if (calls++ === 0) resolve(promise, value);
    };
    var rejectPromise = function(reason) {
        if (calls++ === 0) reject(promise, reason);
    };
    try {
        task(resolvePromise, rejectPromise);
    } catch (error) {
        rejectPromise(error);
    }
};
var propagate = function(promise, deferred) {
    var state = promise._state, value = promise._value, next = deferred.promise, handler = [
        deferred.onFulfilled,
        deferred.onRejected
    ][state], pass = [
        resolve,
        reject
    ][state];
    if (typeof handler !== 'function') return pass(next, value);
    asap(function() {
        try {
            resolve(next, handler(value));
        } catch (error) {
            reject(next, error);
        }
    });
};
var resolve = function(promise, value) {
    if (promise === value) return reject(promise, new TypeError('Recursive promise chain detected'));
    var then;
    try {
        then = getThen(value);
    } catch (error) {
        return reject(promise, error);
    }
    if (!then) return fulfill(promise, value);
    execute(promise, function(resolvePromise, rejectPromise) {
        then.call(value, resolvePromise, rejectPromise);
    });
};
var getThen = function(value) {
    var type = typeof value, then = (type === 'object' || type === 'function') && value && value.then;
    return typeof then === 'function' ? then : null;
};
var fulfill = function(promise, value) {
    settle(promise, FULFILLED, value);
};
var reject = function(promise, reason) {
    settle(promise, REJECTED, reason);
};
var settle = function(promise, state, value) {
    var defer = promise._defer, i = 0;
    promise._state = state;
    promise._value = value;
    promise._defer = null;
    if (defer.length === 0) return;
    while(i < defer.length)propagate(promise, defer[i++]);
};
Promise.resolve = function(value) {
    try {
        if (getThen(value)) return value;
    } catch (error) {
        return Promise.reject(error);
    }
    return new Promise(function(resolve, reject) {
        resolve(value);
    });
};
Promise.reject = function(reason) {
    return new Promise(function(resolve, reject) {
        reject(reason);
    });
};
Promise.all = function(promises) {
    return new Promise(function(resolve, reject) {
        var list = [], n = promises.length, i;
        if (n === 0) return resolve(list);
        var push = function(promise, i) {
            Promise.resolve(promise).then(function(value) {
                list[i] = value;
                if (--n === 0) resolve(list);
            }, reject);
        };
        for(i = 0; i < n; i++)push(promises[i], i);
    });
};
Promise.race = function(promises) {
    return new Promise(function(resolve, reject) {
        for(var i = 0, n = promises.length; i < n; i++)Promise.resolve(promises[i]).then(resolve, reject);
    });
};
Promise.deferred = function() {
    var tuple = {};
    tuple.promise = new Promise(function(resolve, reject) {
        tuple.resolve = resolve;
        tuple.reject = reject;
    });
    return tuple;
};
module.exports = Promise;
}),
"[project]/node_modules/faye/src/util/array.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {
    commonElement: function(lista, listb) {
        for(var i = 0, n = lista.length; i < n; i++){
            if (this.indexOf(listb, lista[i]) !== -1) return lista[i];
        }
        return null;
    },
    indexOf: function(list, needle) {
        if (list.indexOf) return list.indexOf(needle);
        for(var i = 0, n = list.length; i < n; i++){
            if (list[i] === needle) return i;
        }
        return -1;
    },
    map: function(object, callback, context) {
        if (object.map) return object.map(callback, context);
        var result = [];
        if (object instanceof Array) {
            for(var i = 0, n = object.length; i < n; i++){
                result.push(callback.call(context || null, object[i], i));
            }
        } else {
            for(var key in object){
                if (!object.hasOwnProperty(key)) continue;
                result.push(callback.call(context || null, key, object[key]));
            }
        }
        return result;
    },
    filter: function(array, callback, context) {
        if (array.filter) return array.filter(callback, context);
        var result = [];
        for(var i = 0, n = array.length; i < n; i++){
            if (callback.call(context || null, array[i], i)) result.push(array[i]);
        }
        return result;
    },
    asyncEach: function(list, iterator, callback, context) {
        var n = list.length, i = -1, calls = 0, looping = false;
        var iterate = function() {
            calls -= 1;
            i += 1;
            if (i === n) return callback && callback.call(context);
            iterator(list[i], resume);
        };
        var loop = function() {
            if (looping) return;
            looping = true;
            while(calls > 0)iterate();
            looping = false;
        };
        var resume = function() {
            calls += 1;
            loop();
        };
        resume();
    }
};
}),
"[project]/node_modules/faye/src/util/browser/node_shim.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {};
}),
"[project]/node_modules/faye/src/util/validate_options.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var array = __turbopack_context__.r("[project]/node_modules/faye/src/util/array.js [app-route] (ecmascript)");
module.exports = function(options, validKeys) {
    for(var key in options){
        if (array.indexOf(validKeys, key) < 0) throw new Error('Unrecognized option: ' + key);
    }
};
}),
"[project]/node_modules/faye/src/mixins/deferrable.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Promise = __turbopack_context__.r("[project]/node_modules/faye/src/util/promise.js [app-route] (ecmascript)");
module.exports = {
    then: function(callback, errback) {
        var self = this;
        if (!this._promise) this._promise = new Promise(function(resolve, reject) {
            self._resolve = resolve;
            self._reject = reject;
        });
        if (arguments.length === 0) return this._promise;
        else return this._promise.then(callback, errback);
    },
    callback: function(callback, context) {
        return this.then(function(value) {
            callback.call(context, value);
        });
    },
    errback: function(callback, context) {
        return this.then(null, function(reason) {
            callback.call(context, reason);
        });
    },
    timeout: function(seconds, message) {
        this.then();
        var self = this;
        this._timer = /*TURBOPACK member replacement*/ __turbopack_context__.g.setTimeout(function() {
            self._reject(message);
        }, seconds * 1000);
    },
    setDeferredStatus: function(status, value) {
        if (this._timer) /*TURBOPACK member replacement*/ __turbopack_context__.g.clearTimeout(this._timer);
        this.then();
        if (status === 'succeeded') this._resolve(value);
        else if (status === 'failed') this._reject(value);
        else delete this._promise;
    }
};
}),
"[project]/node_modules/faye/src/util/event_emitter.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*
Copyright Joyent, Inc. and other Node contributors. All rights reserved.
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/ var isArray = typeof Array.isArray === 'function' ? Array.isArray : function(xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};
function indexOf(xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for(var i = 0; i < xs.length; i++){
        if (x === xs[i]) return i;
    }
    return -1;
}
function EventEmitter() {}
module.exports = EventEmitter;
EventEmitter.prototype.emit = function(type) {
    // If there is no 'error' event listener then throw.
    if (type === 'error') {
        if (!this._events || !this._events.error || isArray(this._events.error) && !this._events.error.length) {
            if (arguments[1] instanceof Error) {
                throw arguments[1]; // Unhandled 'error' event
            } else {
                throw new Error("Uncaught, unspecified 'error' event.");
            }
            return false;
        }
    }
    if (!this._events) return false;
    var handler = this._events[type];
    if (!handler) return false;
    if (typeof handler == 'function') {
        switch(arguments.length){
            // fast cases
            case 1:
                handler.call(this);
                break;
            case 2:
                handler.call(this, arguments[1]);
                break;
            case 3:
                handler.call(this, arguments[1], arguments[2]);
                break;
            // slower
            default:
                var args = Array.prototype.slice.call(arguments, 1);
                handler.apply(this, args);
        }
        return true;
    } else if (isArray(handler)) {
        var args = Array.prototype.slice.call(arguments, 1);
        var listeners = handler.slice();
        for(var i = 0, l = listeners.length; i < l; i++){
            listeners[i].apply(this, args);
        }
        return true;
    } else {
        return false;
    }
};
// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
    if ('function' !== typeof listener) {
        throw new Error('addListener only takes instances of Function');
    }
    if (!this._events) this._events = {};
    // To avoid recursion in the case that type == "newListeners"! Before
    // adding it to the listeners, first emit "newListeners".
    this.emit('newListener', type, listener);
    if (!this._events[type]) {
        // Optimize the case of one listener. Don't need the extra array object.
        this._events[type] = listener;
    } else if (isArray(this._events[type])) {
        // If we've already got an array, just append.
        this._events[type].push(listener);
    } else {
        // Adding the second element, need to change to array.
        this._events[type] = [
            this._events[type],
            listener
        ];
    }
    return this;
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.once = function(type, listener) {
    var self = this;
    self.on(type, function g() {
        self.removeListener(type, g);
        listener.apply(this, arguments);
    });
    return this;
};
EventEmitter.prototype.removeListener = function(type, listener) {
    if ('function' !== typeof listener) {
        throw new Error('removeListener only takes instances of Function');
    }
    // does not use listeners(), so no side effect of creating _events[type]
    if (!this._events || !this._events[type]) return this;
    var list = this._events[type];
    if (isArray(list)) {
        var i = indexOf(list, listener);
        if (i < 0) return this;
        list.splice(i, 1);
        if (list.length == 0) delete this._events[type];
    } else if (this._events[type] === listener) {
        delete this._events[type];
    }
    return this;
};
EventEmitter.prototype.removeAllListeners = function(type) {
    if (arguments.length === 0) {
        this._events = {};
        return this;
    }
    // does not use listeners(), so no side effect of creating _events[type]
    if (type && this._events && this._events[type]) this._events[type] = null;
    return this;
};
EventEmitter.prototype.listeners = function(type) {
    if (!this._events) this._events = {};
    if (!this._events[type]) this._events[type] = [];
    if (!isArray(this._events[type])) {
        this._events[type] = [
            this._events[type]
        ];
    }
    return this._events[type];
};
}),
"[project]/node_modules/faye/src/mixins/publisher.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var assign = __turbopack_context__.r("[project]/node_modules/faye/src/util/assign.js [app-route] (ecmascript)"), EventEmitter = __turbopack_context__.r("[project]/node_modules/faye/src/util/event_emitter.js [app-route] (ecmascript)");
var Publisher = {
    countListeners: function(eventType) {
        return this.listeners(eventType).length;
    },
    bind: function(eventType, listener, context) {
        var slice = Array.prototype.slice, handler = function() {
            listener.apply(context, slice.call(arguments));
        };
        this._listeners = this._listeners || [];
        this._listeners.push([
            eventType,
            listener,
            context,
            handler
        ]);
        return this.on(eventType, handler);
    },
    unbind: function(eventType, listener, context) {
        this._listeners = this._listeners || [];
        var n = this._listeners.length, tuple;
        while(n--){
            tuple = this._listeners[n];
            if (tuple[0] !== eventType) continue;
            if (listener && (tuple[1] !== listener || tuple[2] !== context)) continue;
            this._listeners.splice(n, 1);
            this.removeListener(eventType, tuple[3]);
        }
    }
};
assign(Publisher, EventEmitter.prototype);
Publisher.trigger = Publisher.emit;
module.exports = Publisher;
}),
"[project]/node_modules/faye/src/protocol/grammar.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {
    CHANNEL_NAME: /^\/(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)))+(\/(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)))+)*$/,
    CHANNEL_PATTERN: /^(\/(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)))+)*\/\*{1,2}$/,
    ERROR: /^([0-9][0-9][0-9]:(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*(,(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*)*:(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*|[0-9][0-9][0-9]::(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*)$/,
    VERSION: /^([0-9])+(\.(([a-z]|[A-Z])|[0-9])(((([a-z]|[A-Z])|[0-9])|\-|\_))*)*$/
};
}),
"[project]/node_modules/faye/src/protocol/channel.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Class = __turbopack_context__.r("[project]/node_modules/faye/src/util/class.js [app-route] (ecmascript)"), assign = __turbopack_context__.r("[project]/node_modules/faye/src/util/assign.js [app-route] (ecmascript)"), Publisher = __turbopack_context__.r("[project]/node_modules/faye/src/mixins/publisher.js [app-route] (ecmascript)"), Grammar = __turbopack_context__.r("[project]/node_modules/faye/src/protocol/grammar.js [app-route] (ecmascript)");
var Channel = Class({
    initialize: function(name) {
        this.id = this.name = name;
    },
    push: function(message) {
        this.trigger('message', message);
    },
    isUnused: function() {
        return this.countListeners('message') === 0;
    }
});
assign(Channel.prototype, Publisher);
assign(Channel, {
    HANDSHAKE: '/meta/handshake',
    CONNECT: '/meta/connect',
    SUBSCRIBE: '/meta/subscribe',
    UNSUBSCRIBE: '/meta/unsubscribe',
    DISCONNECT: '/meta/disconnect',
    META: 'meta',
    SERVICE: 'service',
    expand: function(name) {
        var segments = this.parse(name), channels = [
            '/**',
            name
        ];
        var copy = segments.slice();
        copy[copy.length - 1] = '*';
        channels.push(this.unparse(copy));
        for(var i = 1, n = segments.length; i < n; i++){
            copy = segments.slice(0, i);
            copy.push('**');
            channels.push(this.unparse(copy));
        }
        return channels;
    },
    isValid: function(name) {
        return Grammar.CHANNEL_NAME.test(name) || Grammar.CHANNEL_PATTERN.test(name);
    },
    parse: function(name) {
        if (!this.isValid(name)) return null;
        return name.split('/').slice(1);
    },
    unparse: function(segments) {
        return '/' + segments.join('/');
    },
    isMeta: function(name) {
        var segments = this.parse(name);
        return segments ? segments[0] === this.META : null;
    },
    isService: function(name) {
        var segments = this.parse(name);
        return segments ? segments[0] === this.SERVICE : null;
    },
    isSubscribable: function(name) {
        if (!this.isValid(name)) return null;
        return !this.isMeta(name) && !this.isService(name);
    },
    Set: Class({
        initialize: function() {
            this._channels = {};
        },
        getKeys: function() {
            var keys = [];
            for(var key in this._channels)keys.push(key);
            return keys;
        },
        remove: function(name) {
            delete this._channels[name];
        },
        hasSubscription: function(name) {
            return this._channels.hasOwnProperty(name);
        },
        subscribe: function(names, subscription) {
            var name;
            for(var i = 0, n = names.length; i < n; i++){
                name = names[i];
                var channel = this._channels[name] = this._channels[name] || new Channel(name);
                channel.bind('message', subscription);
            }
        },
        unsubscribe: function(name, subscription) {
            var channel = this._channels[name];
            if (!channel) return false;
            channel.unbind('message', subscription);
            if (channel.isUnused()) {
                this.remove(name);
                return true;
            } else {
                return false;
            }
        },
        distributeMessage: function(message) {
            var channels = Channel.expand(message.channel);
            for(var i = 0, n = channels.length; i < n; i++){
                var channel = this._channels[channels[i]];
                if (channel) channel.trigger('message', message);
            }
        }
    })
});
module.exports = Channel;
}),
"[project]/node_modules/faye/src/util/uri.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {
    isURI: function(uri) {
        return uri && uri.protocol && uri.host && uri.path;
    },
    isSameOrigin: function(uri) {
        return uri.protocol === location.protocol && uri.hostname === location.hostname && uri.port === location.port;
    },
    parse: function(url) {
        if (typeof url !== 'string') return url;
        var uri = {}, parts, query, pairs, i, n, data;
        var consume = function(name, pattern) {
            url = url.replace(pattern, function(match) {
                uri[name] = match;
                return '';
            });
            uri[name] = uri[name] || '';
        };
        consume('protocol', /^[a-z]+\:/i);
        consume('host', /^\/\/[^\/\?#]+/);
        if (!/^\//.test(url) && !uri.host) url = location.pathname.replace(/[^\/]*$/, '') + url;
        consume('pathname', /^[^\?#]*/);
        consume('search', /^\?[^#]*/);
        consume('hash', /^#.*/);
        uri.protocol = uri.protocol || location.protocol;
        if (uri.host) {
            uri.host = uri.host.substr(2);
            if (/@/.test(uri.host)) {
                uri.auth = uri.host.split('@')[0];
                uri.host = uri.host.split('@')[1];
            }
            parts = uri.host.match(/^\[([^\]]+)\]|^[^:]+/);
            uri.hostname = parts[1] || parts[0];
            uri.port = (uri.host.match(/:(\d+)$/) || [])[1] || '';
        } else {
            uri.host = location.host;
            uri.hostname = location.hostname;
            uri.port = location.port;
        }
        uri.pathname = uri.pathname || '/';
        uri.path = uri.pathname + uri.search;
        query = uri.search.replace(/^\?/, '');
        pairs = query ? query.split('&') : [];
        data = {};
        for(i = 0, n = pairs.length; i < n; i++){
            parts = pairs[i].split('=');
            data[decodeURIComponent(parts[0] || '')] = decodeURIComponent(parts[1] || '');
        }
        uri.query = data;
        uri.href = this.stringify(uri);
        return uri;
    },
    stringify: function(uri) {
        var auth = uri.auth ? uri.auth + '@' : '', string = uri.protocol + '//' + auth + uri.host;
        string += uri.pathname + this.queryString(uri.query) + (uri.hash || '');
        return string;
    },
    queryString: function(query) {
        var pairs = [];
        for(var key in query){
            if (!query.hasOwnProperty(key)) continue;
            pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(query[key]));
        }
        if (pairs.length === 0) return '';
        return '?' + pairs.join('&');
    }
};
}),
"[project]/node_modules/faye/src/util/cookies/node_cookies.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/tough-cookie/dist/index.cjs [app-route] (ecmascript)");
}),
"[project]/node_modules/faye/src/mixins/timeouts.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {
    addTimeout: function(name, delay, callback, context) {
        this._timeouts = this._timeouts || {};
        if (this._timeouts.hasOwnProperty(name)) return;
        var self = this;
        this._timeouts[name] = /*TURBOPACK member replacement*/ __turbopack_context__.g.setTimeout(function() {
            delete self._timeouts[name];
            callback.call(context);
        }, 1000 * delay);
    },
    removeTimeout: function(name) {
        this._timeouts = this._timeouts || {};
        var timeout = this._timeouts[name];
        if (!timeout) return;
        /*TURBOPACK member replacement*/ __turbopack_context__.g.clearTimeout(timeout);
        delete this._timeouts[name];
    },
    removeAllTimeouts: function() {
        this._timeouts = this._timeouts || {};
        for(var name in this._timeouts)this.removeTimeout(name);
    }
};
}),
"[project]/node_modules/faye/src/transport/transport.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Class = __turbopack_context__.r("[project]/node_modules/faye/src/util/class.js [app-route] (ecmascript)"), Cookie = __turbopack_context__.r("[project]/node_modules/faye/src/util/cookies/node_cookies.js [app-route] (ecmascript)").Cookie, Promise = __turbopack_context__.r("[project]/node_modules/faye/src/util/promise.js [app-route] (ecmascript)"), array = __turbopack_context__.r("[project]/node_modules/faye/src/util/array.js [app-route] (ecmascript)"), assign = __turbopack_context__.r("[project]/node_modules/faye/src/util/assign.js [app-route] (ecmascript)"), Logging = __turbopack_context__.r("[project]/node_modules/faye/src/mixins/logging.js [app-route] (ecmascript)"), Timeouts = __turbopack_context__.r("[project]/node_modules/faye/src/mixins/timeouts.js [app-route] (ecmascript)"), Channel = __turbopack_context__.r("[project]/node_modules/faye/src/protocol/channel.js [app-route] (ecmascript)");
var Transport = assign(Class({
    className: 'Transport',
    DEFAULT_PORTS: {
        'http:': 80,
        'https:': 443,
        'ws:': 80,
        'wss:': 443
    },
    MAX_DELAY: 0,
    batching: true,
    initialize: function(dispatcher, endpoint) {
        this._dispatcher = dispatcher;
        this.endpoint = endpoint;
        this._outbox = [];
        this._proxy = assign({}, this._dispatcher.proxy);
        if (!this._proxy.origin) this._proxy.origin = this._findProxy();
    },
    close: function() {},
    encode: function(messages) {
        return '';
    },
    sendMessage: function(message) {
        this.debug('Client ? sending message to ?: ?', this._dispatcher.clientId, this.endpoint.href, message);
        if (!this.batching) return Promise.resolve(this.request([
            message
        ]));
        this._outbox.push(message);
        this._flushLargeBatch();
        if (message.channel === Channel.HANDSHAKE) return this._publish(0.01);
        if (message.channel === Channel.CONNECT) this._connectMessage = message;
        return this._publish(this.MAX_DELAY);
    },
    _makePromise: function() {
        var self = this;
        this._requestPromise = this._requestPromise || new Promise(function(resolve) {
            self._resolvePromise = resolve;
        });
    },
    _publish: function(delay) {
        this._makePromise();
        this.addTimeout('publish', delay, function() {
            this._flush();
            delete this._requestPromise;
        }, this);
        return this._requestPromise;
    },
    _flush: function() {
        this.removeTimeout('publish');
        if (this._outbox.length > 1 && this._connectMessage) this._connectMessage.advice = {
            timeout: 0
        };
        this._resolvePromise(this.request(this._outbox));
        this._connectMessage = null;
        this._outbox = [];
    },
    _flushLargeBatch: function() {
        var string = this.encode(this._outbox);
        if (string.length < this._dispatcher.maxRequestSize) return;
        var last = this._outbox.pop();
        this._makePromise();
        this._flush();
        if (last) this._outbox.push(last);
    },
    _receive: function(replies) {
        if (!replies) return;
        replies = [].concat(replies);
        this.debug('Client ? received from ? via ?: ?', this._dispatcher.clientId, this.endpoint.href, this.connectionType, replies);
        for(var i = 0, n = replies.length; i < n; i++)this._dispatcher.handleResponse(replies[i]);
    },
    _handleError: function(messages, immediate) {
        messages = [].concat(messages);
        this.debug('Client ? failed to send to ? via ?: ?', this._dispatcher.clientId, this.endpoint.href, this.connectionType, messages);
        for(var i = 0, n = messages.length; i < n; i++)this._dispatcher.handleError(messages[i]);
    },
    _getCookies: function() {
        var cookies = this._dispatcher.cookies, url = this.endpoint.href;
        if (!cookies) return '';
        return array.map(cookies.getCookiesSync(url), function(cookie) {
            return cookie.cookieString();
        }).join('; ');
    },
    _storeCookies: function(setCookie) {
        var cookies = this._dispatcher.cookies, url = this.endpoint.href, cookie;
        if (!setCookie || !cookies) return;
        setCookie = [].concat(setCookie);
        for(var i = 0, n = setCookie.length; i < n; i++){
            cookie = Cookie.parse(setCookie[i]);
            cookies.setCookieSync(cookie, url);
        }
    },
    _findProxy: function() {
        if (typeof process === 'undefined') return undefined;
        var protocol = this.endpoint.protocol;
        if (!protocol) return undefined;
        var name = protocol.replace(/:$/, '').toLowerCase() + '_proxy', upcase = name.toUpperCase(), env = process.env, keys, proxy;
        if (name === 'http_proxy' && env.REQUEST_METHOD) {
            keys = Object.keys(env).filter(function(k) {
                return /^http_proxy$/i.test(k);
            });
            if (keys.length === 1) {
                if (keys[0] === name && env[upcase] === undefined) proxy = env[name];
            } else if (keys.length > 1) {
                proxy = env[name];
            }
            proxy = proxy || env['CGI_' + upcase];
        } else {
            proxy = env[name] || env[upcase];
            if (proxy && !env[name]) console.warn('The environment variable ' + upcase + ' is discouraged. Use ' + name + '.');
        }
        return proxy;
    }
}), {
    get: function(dispatcher, allowed, disabled, callback, context) {
        var endpoint = dispatcher.endpoint;
        array.asyncEach(this._transports, function(pair, resume) {
            var connType = pair[0], klass = pair[1], connEndpoint = dispatcher.endpointFor(connType);
            if (array.indexOf(disabled, connType) >= 0) return resume();
            if (array.indexOf(allowed, connType) < 0) {
                klass.isUsable(dispatcher, connEndpoint, function() {});
                return resume();
            }
            klass.isUsable(dispatcher, connEndpoint, function(isUsable) {
                if (!isUsable) return resume();
                var transport = klass.hasOwnProperty('create') ? klass.create(dispatcher, connEndpoint) : new klass(dispatcher, connEndpoint);
                callback.call(context, transport);
            });
        }, function() {
            throw new Error('Could not find a usable connection type for ' + endpoint.href);
        });
    },
    register: function(type, klass) {
        this._transports.push([
            type,
            klass
        ]);
        klass.prototype.connectionType = type;
    },
    getConnectionTypes: function() {
        return array.map(this._transports, function(t) {
            return t[0];
        });
    },
    disable: function(feature) {
        if (feature !== 'autodisconnect') return;
        for(var i = 0; i < this._transports.length; i++)this._transports[i][1]._unloaded = false;
    },
    _transports: []
});
assign(Transport.prototype, Logging);
assign(Transport.prototype, Timeouts);
module.exports = Transport;
}),
"[project]/node_modules/faye/src/util/copy_object.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var copyObject = function(object) {
    var clone, i, key;
    if (object instanceof Array) {
        clone = [];
        i = object.length;
        while(i--)clone[i] = copyObject(object[i]);
        return clone;
    } else if (typeof object === 'object') {
        clone = object === null ? null : {};
        for(key in object)clone[key] = copyObject(object[key]);
        return clone;
    } else {
        return object;
    }
};
module.exports = copyObject;
}),
"[project]/node_modules/faye/src/util/random.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var csprng = __turbopack_context__.r("[project]/node_modules/csprng/lib/csprng.js [app-route] (ecmascript)"), constants = __turbopack_context__.r("[project]/node_modules/faye/src/util/constants.js [app-route] (ecmascript)");
module.exports = function(bitlength) {
    bitlength = bitlength || constants.ID_LENGTH;
    var maxLength = Math.ceil(bitlength * Math.log(2) / Math.log(36));
    var string = csprng(bitlength, 36);
    while(string.length < maxLength)string = '0' + string;
    return string;
};
}),
"[project]/node_modules/faye/src/engines/connection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Class = __turbopack_context__.r("[project]/node_modules/faye/src/util/class.js [app-route] (ecmascript)"), assign = __turbopack_context__.r("[project]/node_modules/faye/src/util/assign.js [app-route] (ecmascript)"), Deferrable = __turbopack_context__.r("[project]/node_modules/faye/src/mixins/deferrable.js [app-route] (ecmascript)"), Timeouts = __turbopack_context__.r("[project]/node_modules/faye/src/mixins/timeouts.js [app-route] (ecmascript)");
var Connection = Class({
    initialize: function(engine, id, options) {
        this._engine = engine;
        this._id = id;
        this._options = options;
        this._inbox = [];
    },
    deliver: function(message) {
        delete message.clientId;
        if (this.socket) return this.socket.send(message);
        this._inbox.push(message);
        this._beginDeliveryTimeout();
    },
    connect: function(options, callback, context) {
        options = options || {};
        var timeout = options.timeout !== undefined ? options.timeout / 1000 : this._engine.timeout;
        this.setDeferredStatus('unknown');
        this.callback(callback, context);
        this._beginDeliveryTimeout();
        this._beginConnectionTimeout(timeout);
    },
    flush: function() {
        this.removeTimeout('connection');
        this.removeTimeout('delivery');
        this.setDeferredStatus('succeeded', this._inbox);
        this._inbox = [];
        if (!this.socket) this._engine.closeConnection(this._id);
    },
    _beginDeliveryTimeout: function() {
        if (this._inbox.length === 0) return;
        this.addTimeout('delivery', this._engine.MAX_DELAY, this.flush, this);
    },
    _beginConnectionTimeout: function(timeout) {
        this.addTimeout('connection', timeout, this.flush, this);
    }
});
assign(Connection.prototype, Deferrable);
assign(Connection.prototype, Timeouts);
module.exports = Connection;
}),
"[project]/node_modules/faye/src/util/namespace.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Class = __turbopack_context__.r("[project]/node_modules/faye/src/util/class.js [app-route] (ecmascript)"), random = __turbopack_context__.r("[project]/node_modules/faye/src/util/random.js [app-route] (ecmascript)");
module.exports = Class({
    initialize: function() {
        this._used = {};
    },
    exists: function(id) {
        return this._used.hasOwnProperty(id);
    },
    generate: function() {
        var name = random();
        while(this._used.hasOwnProperty(name))name = random();
        return this._used[name] = name;
    },
    release: function(id) {
        delete this._used[id];
    }
});
}),
"[project]/node_modules/faye/src/util/set.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Class = __turbopack_context__.r("[project]/node_modules/faye/src/util/class.js [app-route] (ecmascript)");
module.exports = Class({
    initialize: function() {
        this._index = {};
    },
    add: function(item) {
        var key = item.id !== undefined ? item.id : item;
        if (this._index.hasOwnProperty(key)) return false;
        this._index[key] = item;
        return true;
    },
    forEach: function(block, context) {
        for(var key in this._index){
            if (this._index.hasOwnProperty(key)) block.call(context, this._index[key]);
        }
    },
    isEmpty: function() {
        for(var key in this._index){
            if (this._index.hasOwnProperty(key)) return false;
        }
        return true;
    },
    member: function(item) {
        for(var key in this._index){
            if (this._index[key] === item) return true;
        }
        return false;
    },
    remove: function(item) {
        var key = item.id !== undefined ? item.id : item;
        var removed = this._index[key];
        delete this._index[key];
        return removed;
    },
    toArray: function() {
        var array = [];
        this.forEach(function(item) {
            array.push(item);
        });
        return array;
    }
});
}),
"[project]/node_modules/faye/src/engines/memory.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var copyObject = __turbopack_context__.r("[project]/node_modules/faye/src/util/copy_object.js [app-route] (ecmascript)"), assign = __turbopack_context__.r("[project]/node_modules/faye/src/util/assign.js [app-route] (ecmascript)"), Namespace = __turbopack_context__.r("[project]/node_modules/faye/src/util/namespace.js [app-route] (ecmascript)"), Set = __turbopack_context__.r("[project]/node_modules/faye/src/util/set.js [app-route] (ecmascript)"), Timeouts = __turbopack_context__.r("[project]/node_modules/faye/src/mixins/timeouts.js [app-route] (ecmascript)");
var Memory = function(server, options) {
    this._server = server;
    this._options = options || {};
    this.reset();
};
Memory.create = function(server, options) {
    return new Memory(server, options);
};
Memory.prototype = {
    disconnect: function() {
        this.reset();
        this.removeAllTimeouts();
    },
    reset: function() {
        this._namespace = new Namespace();
        this._clients = {};
        this._channels = {};
        this._messages = {};
    },
    createClient: function(callback, context) {
        var clientId = this._namespace.generate();
        this._server.debug('Created new client ?', clientId);
        this.ping(clientId);
        this._server.trigger('handshake', clientId);
        callback.call(context, clientId);
    },
    destroyClient: function(clientId, callback, context) {
        if (!this._namespace.exists(clientId)) return;
        var clients = this._clients;
        if (clients[clientId]) clients[clientId].forEach(function(channel) {
            this.unsubscribe(clientId, channel);
        }, this);
        this.removeTimeout(clientId);
        this._namespace.release(clientId);
        delete this._messages[clientId];
        this._server.debug('Destroyed client ?', clientId);
        this._server.trigger('disconnect', clientId);
        this._server.trigger('close', clientId);
        if (callback) callback.call(context);
    },
    clientExists: function(clientId, callback, context) {
        callback.call(context, this._namespace.exists(clientId));
    },
    ping: function(clientId) {
        var timeout = this._server.timeout;
        if (typeof timeout !== 'number') return;
        this._server.debug('Ping ?, ?', clientId, timeout);
        this.removeTimeout(clientId);
        this.addTimeout(clientId, 2 * timeout, function() {
            this.destroyClient(clientId);
        }, this);
    },
    subscribe: function(clientId, channel, callback, context) {
        var clients = this._clients, channels = this._channels;
        clients[clientId] = clients[clientId] || new Set();
        var trigger = clients[clientId].add(channel);
        channels[channel] = channels[channel] || new Set();
        channels[channel].add(clientId);
        this._server.debug('Subscribed client ? to channel ?', clientId, channel);
        if (trigger) this._server.trigger('subscribe', clientId, channel);
        if (callback) callback.call(context, true);
    },
    unsubscribe: function(clientId, channel, callback, context) {
        var clients = this._clients, channels = this._channels, trigger = false;
        if (clients[clientId]) {
            trigger = clients[clientId].remove(channel);
            if (clients[clientId].isEmpty()) delete clients[clientId];
        }
        if (channels[channel]) {
            channels[channel].remove(clientId);
            if (channels[channel].isEmpty()) delete channels[channel];
        }
        this._server.debug('Unsubscribed client ? from channel ?', clientId, channel);
        if (trigger) this._server.trigger('unsubscribe', clientId, channel);
        if (callback) callback.call(context, true);
    },
    publish: function(message, channels) {
        this._server.debug('Publishing message ?', message);
        var messages = this._messages, clients = new Set(), subs;
        for(var i = 0, n = channels.length; i < n; i++){
            subs = this._channels[channels[i]];
            if (!subs) continue;
            subs.forEach(clients.add, clients);
        }
        clients.forEach(function(clientId) {
            this._server.debug('Queueing for client ?: ?', clientId, message);
            messages[clientId] = messages[clientId] || [];
            messages[clientId].push(copyObject(message));
            this.emptyQueue(clientId);
        }, this);
        this._server.trigger('publish', message.clientId, message.channel, message.data);
    },
    emptyQueue: function(clientId) {
        if (!this._server.hasConnection(clientId)) return;
        this._server.deliver(clientId, this._messages[clientId]);
        delete this._messages[clientId];
    }
};
assign(Memory.prototype, Timeouts);
module.exports = Memory;
}),
"[project]/node_modules/faye/src/engines/proxy.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var asap = __turbopack_context__.r("[project]/node_modules/asap/asap.js [app-route] (ecmascript)"), assign = __turbopack_context__.r("[project]/node_modules/faye/src/util/assign.js [app-route] (ecmascript)"), random = __turbopack_context__.r("[project]/node_modules/faye/src/util/random.js [app-route] (ecmascript)"), Class = __turbopack_context__.r("[project]/node_modules/faye/src/util/class.js [app-route] (ecmascript)"), Promise = __turbopack_context__.r("[project]/node_modules/faye/src/util/promise.js [app-route] (ecmascript)"), Logging = __turbopack_context__.r("[project]/node_modules/faye/src/mixins/logging.js [app-route] (ecmascript)"), Publisher = __turbopack_context__.r("[project]/node_modules/faye/src/mixins/publisher.js [app-route] (ecmascript)"), Channel = __turbopack_context__.r("[project]/node_modules/faye/src/protocol/channel.js [app-route] (ecmascript)"), Connection = __turbopack_context__.r("[project]/node_modules/faye/src/engines/connection.js [app-route] (ecmascript)"), Memory = __turbopack_context__.r("[project]/node_modules/faye/src/engines/memory.js [app-route] (ecmascript)");
var Proxy = assign(Class({
    className: 'Engine.Proxy',
    MAX_DELAY: 0,
    INTERVAL: 0,
    TIMEOUT: 60,
    initialize: function(options) {
        this._options = options || {};
        this._connections = {};
        this.interval = this._options.interval || this.INTERVAL;
        this.timeout = this._options.timeout || this.TIMEOUT;
        var engineClass = this._options.type || Memory;
        this._engine = engineClass.create(this, this._options);
        this.bind('close', function(clientId) {
            var self = this;
            asap(function() {
                self.flushConnection(clientId);
            });
        }, this);
        this.debug('Created new engine: ?', this._options);
    },
    connect: function(clientId, options, callback, context) {
        this.debug('Accepting connection from ?', clientId);
        this._engine.ping(clientId);
        var conn = this.connection(clientId, true);
        conn.connect(options, callback, context);
        this._engine.emptyQueue(clientId);
    },
    hasConnection: function(clientId) {
        return this._connections.hasOwnProperty(clientId);
    },
    connection: function(clientId, create) {
        var conn = this._connections[clientId];
        if (conn || !create) return conn;
        this._connections[clientId] = new Connection(this, clientId);
        this.trigger('connection:open', clientId);
        return this._connections[clientId];
    },
    closeConnection: function(clientId) {
        this.debug('Closing connection for ?', clientId);
        var conn = this._connections[clientId];
        if (!conn) return;
        if (conn.socket) conn.socket.close();
        this.trigger('connection:close', clientId);
        delete this._connections[clientId];
    },
    openSocket: function(clientId, socket) {
        var conn = this.connection(clientId, true);
        conn.socket = socket;
    },
    deliver: function(clientId, messages) {
        if (!messages || messages.length === 0) return false;
        var conn = this.connection(clientId, false);
        if (!conn) return false;
        for(var i = 0, n = messages.length; i < n; i++){
            conn.deliver(messages[i]);
        }
        return true;
    },
    generateId: function() {
        return random();
    },
    flushConnection: function(clientId, close) {
        if (!clientId) return;
        this.debug('Flushing connection for ?', clientId);
        var conn = this.connection(clientId, false);
        if (!conn) return;
        if (close === false) conn.socket = null;
        conn.flush();
        this.closeConnection(clientId);
    },
    close: function() {
        for(var clientId in this._connections)this.flushConnection(clientId);
        this._engine.disconnect();
    },
    disconnect: function() {
        if (this._engine.disconnect) return this._engine.disconnect();
    },
    publish: function(message) {
        var channels = Channel.expand(message.channel);
        return this._engine.publish(message, channels);
    }
}), {
    get: function(options) {
        return new Proxy(options);
    }
});
var METHODS = [
    'createClient',
    'clientExists',
    'destroyClient',
    'ping',
    'subscribe',
    'unsubscribe'
];
METHODS.forEach(function(method) {
    Proxy.prototype[method] = function() {
        return this._engine[method].apply(this._engine, arguments);
    };
});
assign(Proxy.prototype, Publisher);
assign(Proxy.prototype, Logging);
module.exports = Proxy;
}),
"[project]/node_modules/faye/src/protocol/error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Class = __turbopack_context__.r("[project]/node_modules/faye/src/util/class.js [app-route] (ecmascript)"), Grammar = __turbopack_context__.r("[project]/node_modules/faye/src/protocol/grammar.js [app-route] (ecmascript)");
var Error = Class({
    initialize: function(code, params, message) {
        this.code = code;
        this.params = Array.prototype.slice.call(params);
        this.message = message;
    },
    toString: function() {
        return this.code + ':' + this.params.join(',') + ':' + this.message;
    }
});
Error.parse = function(message) {
    message = message || '';
    if (!Grammar.ERROR.test(message)) return new Error(null, [], message);
    var parts = message.split(':'), code = parseInt(parts[0]), params = parts[1].split(','), message = parts[2];
    return new Error(code, params, message);
};
// http://code.google.com/p/cometd/wiki/BayeuxCodes
var errors = {
    versionMismatch: [
        300,
        'Version mismatch'
    ],
    conntypeMismatch: [
        301,
        'Connection types not supported'
    ],
    extMismatch: [
        302,
        'Extension mismatch'
    ],
    badRequest: [
        400,
        'Bad request'
    ],
    clientUnknown: [
        401,
        'Unknown client'
    ],
    parameterMissing: [
        402,
        'Missing required parameter'
    ],
    channelForbidden: [
        403,
        'Forbidden channel'
    ],
    channelUnknown: [
        404,
        'Unknown channel'
    ],
    channelInvalid: [
        405,
        'Invalid channel'
    ],
    extUnknown: [
        406,
        'Unknown extension'
    ],
    publishFailed: [
        407,
        'Failed to publish'
    ],
    serverError: [
        500,
        'Internal server error'
    ]
};
for(var name in errors)(function(name) {
    Error[name] = function() {
        return new Error(errors[name][0], arguments, errors[name][1]).toString();
    };
})(name);
module.exports = Error;
}),
"[project]/node_modules/faye/src/protocol/extensible.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var assign = __turbopack_context__.r("[project]/node_modules/faye/src/util/assign.js [app-route] (ecmascript)"), Logging = __turbopack_context__.r("[project]/node_modules/faye/src/mixins/logging.js [app-route] (ecmascript)");
var Extensible = {
    addExtension: function(extension) {
        this._extensions = this._extensions || [];
        this._extensions.push(extension);
        if (extension.added) extension.added(this);
    },
    removeExtension: function(extension) {
        if (!this._extensions) return;
        var i = this._extensions.length;
        while(i--){
            if (this._extensions[i] !== extension) continue;
            this._extensions.splice(i, 1);
            if (extension.removed) extension.removed(this);
        }
    },
    pipeThroughExtensions: function(stage, message, request, callback, context) {
        this.debug('Passing through ? extensions: ?', stage, message);
        if (!this._extensions) return callback.call(context, message);
        var extensions = this._extensions.slice();
        var pipe = function(message) {
            if (!message) return callback.call(context, message);
            var extension = extensions.shift();
            if (!extension) return callback.call(context, message);
            var fn = extension[stage];
            if (!fn) return pipe(message);
            if (fn.length >= 3) extension[stage](message, request, pipe);
            else extension[stage](message, pipe);
        };
        pipe(message);
    }
};
assign(Extensible, Logging);
module.exports = Extensible;
}),
"[project]/node_modules/faye/src/protocol/socket.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Class = __turbopack_context__.r("[project]/node_modules/faye/src/util/class.js [app-route] (ecmascript)"), toJSON = __turbopack_context__.r("[project]/node_modules/faye/src/util/to_json.js [app-route] (ecmascript)");
module.exports = Class({
    initialize: function(server, socket, request) {
        this._server = server;
        this._socket = socket;
        this._request = request;
    },
    send: function(message) {
        this._server.pipeThroughExtensions('outgoing', message, this._request, function(pipedMessage) {
            if (this._socket) this._socket.send(toJSON([
                pipedMessage
            ]));
        }, this);
    },
    close: function() {
        if (this._socket) this._socket.close();
        delete this._socket;
    }
});
}),
"[project]/node_modules/faye/src/protocol/server.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Class = __turbopack_context__.r("[project]/node_modules/faye/src/util/class.js [app-route] (ecmascript)"), array = __turbopack_context__.r("[project]/node_modules/faye/src/util/array.js [app-route] (ecmascript)"), assign = __turbopack_context__.r("[project]/node_modules/faye/src/util/assign.js [app-route] (ecmascript)"), constants = __turbopack_context__.r("[project]/node_modules/faye/src/util/constants.js [app-route] (ecmascript)"), Logging = __turbopack_context__.r("[project]/node_modules/faye/src/mixins/logging.js [app-route] (ecmascript)"), Engine = __turbopack_context__.r("[project]/node_modules/faye/src/engines/proxy.js [app-route] (ecmascript)"), Channel = __turbopack_context__.r("[project]/node_modules/faye/src/protocol/channel.js [app-route] (ecmascript)"), Error = __turbopack_context__.r("[project]/node_modules/faye/src/protocol/error.js [app-route] (ecmascript)"), Extensible = __turbopack_context__.r("[project]/node_modules/faye/src/protocol/extensible.js [app-route] (ecmascript)"), Grammar = __turbopack_context__.r("[project]/node_modules/faye/src/protocol/grammar.js [app-route] (ecmascript)"), Socket = __turbopack_context__.r("[project]/node_modules/faye/src/protocol/socket.js [app-route] (ecmascript)");
var Server = Class({
    className: 'Server',
    initialize: function(options) {
        this._options = options || {};
        var engineOpts = this._options.engine || {};
        engineOpts.timeout = this._options.timeout;
        this._engine = Engine.get(engineOpts);
        this.info('Created new server: ?', this._options);
    },
    close: function() {
        return this._engine.close();
    },
    openSocket: function(clientId, socket, request) {
        if (!clientId || !socket) return;
        this._engine.openSocket(clientId, new Socket(this, socket, request));
    },
    closeSocket: function(clientId, close) {
        this._engine.flushConnection(clientId, close);
    },
    process: function(messages, request, callback, context) {
        var local = request === null;
        messages = [].concat(messages);
        this.info('Processing messages: ? (local: ?)', messages, local);
        if (messages.length === 0) return callback.call(context, []);
        var processed = 0, responses = [], self = this;
        var gatherReplies = function(replies) {
            responses = responses.concat(replies);
            processed += 1;
            if (processed < messages.length) return;
            var n = responses.length;
            while(n--){
                if (!responses[n]) responses.splice(n, 1);
            }
            self.info('Returning replies: ?', responses);
            callback.call(context, responses);
        };
        var handleReply = function(replies) {
            var assigned = 0, expected = replies.length;
            if (expected === 0) gatherReplies(replies);
            for(var i = 0, n = replies.length; i < n; i++){
                this.debug('Processing reply: ?', replies[i]);
                (function(index) {
                    self.pipeThroughExtensions('outgoing', replies[index], request, function(message) {
                        replies[index] = message;
                        assigned += 1;
                        if (assigned === expected) gatherReplies(replies);
                    });
                })(i);
            }
        };
        for(var i = 0, n = messages.length; i < n; i++){
            this.pipeThroughExtensions('incoming', messages[i], request, function(pipedMessage) {
                this._handle(pipedMessage, local, handleReply, this);
            }, this);
        }
    },
    _makeResponse: function(message) {
        var response = {};
        if (message.id) response.id = message.id;
        if (message.clientId) response.clientId = message.clientId;
        if (message.channel) response.channel = message.channel;
        if (message.error) response.error = message.error;
        response.successful = !response.error;
        return response;
    },
    _handle: function(message, local, callback, context) {
        if (!message) return callback.call(context, []);
        this.info('Handling message: ? (local: ?)', message, local);
        var channelName = message.channel, error = message.error, response;
        if (Channel.isMeta(channelName)) return this._handleMeta(message, local, callback, context);
        if (!Grammar.CHANNEL_NAME.test(channelName)) error = Error.channelInvalid(channelName);
        if (message.data === undefined) error = Error.parameterMissing('data');
        if (!error) this._engine.publish(message);
        response = this._makeResponse(message);
        if (error) response.error = error;
        response.successful = !response.error;
        callback.call(context, [
            response
        ]);
    },
    _handleMeta: function(message, local, callback, context) {
        var method = this._methodFor(message), response;
        if (method === null) {
            response = this._makeResponse(message);
            response.error = Error.channelForbidden(message.channel);
            response.successful = false;
            return callback.call(context, [
                response
            ]);
        }
        this[method](message, local, function(responses) {
            responses = [].concat(responses);
            for(var i = 0, n = responses.length; i < n; i++)this._advize(responses[i], message.connectionType);
            callback.call(context, responses);
        }, this);
    },
    _methodFor: function(message) {
        var channel = message.channel;
        if (channel === Channel.HANDSHAKE) return 'handshake';
        if (channel === Channel.CONNECT) return 'connect';
        if (channel === Channel.SUBSCRIBE) return 'subscribe';
        if (channel === Channel.UNSUBSCRIBE) return 'unsubscribe';
        if (channel === Channel.DISCONNECT) return 'disconnect';
        return null;
    },
    _advize: function(response, connectionType) {
        if (array.indexOf([
            Channel.HANDSHAKE,
            Channel.CONNECT
        ], response.channel) < 0) return;
        var interval, timeout;
        if (connectionType === 'eventsource') {
            interval = Math.floor(this._engine.timeout * 1000);
            timeout = 0;
        } else {
            interval = Math.floor(this._engine.interval * 1000);
            timeout = Math.floor(this._engine.timeout * 1000);
        }
        response.advice = response.advice || {};
        if (response.error) {
            assign(response.advice, {
                reconnect: 'handshake'
            }, false);
        } else {
            assign(response.advice, {
                reconnect: 'retry',
                interval: interval,
                timeout: timeout
            }, false);
        }
    },
    // MUST contain  * version
    //               * supportedConnectionTypes
    // MAY contain   * minimumVersion
    //               * ext
    //               * id
    handshake: function(message, local, callback, context) {
        var response = this._makeResponse(message);
        response.version = constants.BAYEUX_VERSION;
        if (!message.version) response.error = Error.parameterMissing('version');
        var clientConns = message.supportedConnectionTypes, commonConns;
        response.supportedConnectionTypes = constants.CONNECTION_TYPES;
        if (clientConns) {
            commonConns = array.filter(clientConns, function(conn) {
                return array.indexOf(constants.CONNECTION_TYPES, conn) >= 0;
            });
            if (commonConns.length === 0) response.error = Error.conntypeMismatch(clientConns);
        } else {
            response.error = Error.parameterMissing('supportedConnectionTypes');
        }
        response.successful = !response.error;
        if (!response.successful) return callback.call(context, response);
        this._engine.createClient(function(clientId) {
            response.clientId = clientId;
            callback.call(context, response);
        }, this);
    },
    // MUST contain  * clientId
    //               * connectionType
    // MAY contain   * ext
    //               * id
    connect: function(message, local, callback, context) {
        var response = this._makeResponse(message), clientId = message.clientId, connectionType = message.connectionType;
        this._engine.clientExists(clientId, function(exists) {
            if (!exists) response.error = Error.clientUnknown(clientId);
            if (!clientId) response.error = Error.parameterMissing('clientId');
            if (array.indexOf(constants.CONNECTION_TYPES, connectionType) < 0) response.error = Error.conntypeMismatch(connectionType);
            if (!connectionType) response.error = Error.parameterMissing('connectionType');
            response.successful = !response.error;
            if (!response.successful) {
                delete response.clientId;
                return callback.call(context, response);
            }
            if (message.connectionType === 'eventsource') {
                message.advice = message.advice || {};
                message.advice.timeout = 0;
            }
            this._engine.connect(response.clientId, message.advice, function(events) {
                callback.call(context, [
                    response
                ].concat(events));
            });
        }, this);
    },
    // MUST contain  * clientId
    // MAY contain   * ext
    //               * id
    disconnect: function(message, local, callback, context) {
        var response = this._makeResponse(message), clientId = message.clientId;
        this._engine.clientExists(clientId, function(exists) {
            if (!exists) response.error = Error.clientUnknown(clientId);
            if (!clientId) response.error = Error.parameterMissing('clientId');
            response.successful = !response.error;
            if (!response.successful) delete response.clientId;
            if (response.successful) this._engine.destroyClient(clientId);
            callback.call(context, response);
        }, this);
    },
    // MUST contain  * clientId
    //               * subscription
    // MAY contain   * ext
    //               * id
    subscribe: function(message, local, callback, context) {
        var response = this._makeResponse(message), clientId = message.clientId, subscription = message.subscription, channel;
        subscription = subscription ? [].concat(subscription) : [];
        this._engine.clientExists(clientId, function(exists) {
            if (!exists) response.error = Error.clientUnknown(clientId);
            if (!clientId) response.error = Error.parameterMissing('clientId');
            if (!message.subscription) response.error = Error.parameterMissing('subscription');
            response.subscription = message.subscription || [];
            for(var i = 0, n = subscription.length; i < n; i++){
                channel = subscription[i];
                if (response.error) break;
                if (!local && !Channel.isSubscribable(channel)) response.error = Error.channelForbidden(channel);
                if (!Channel.isValid(channel)) response.error = Error.channelInvalid(channel);
                if (response.error) break;
                this._engine.subscribe(clientId, channel);
            }
            response.successful = !response.error;
            callback.call(context, response);
        }, this);
    },
    // MUST contain  * clientId
    //               * subscription
    // MAY contain   * ext
    //               * id
    unsubscribe: function(message, local, callback, context) {
        var response = this._makeResponse(message), clientId = message.clientId, subscription = message.subscription, channel;
        subscription = subscription ? [].concat(subscription) : [];
        this._engine.clientExists(clientId, function(exists) {
            if (!exists) response.error = Error.clientUnknown(clientId);
            if (!clientId) response.error = Error.parameterMissing('clientId');
            if (!message.subscription) response.error = Error.parameterMissing('subscription');
            response.subscription = message.subscription || [];
            for(var i = 0, n = subscription.length; i < n; i++){
                channel = subscription[i];
                if (response.error) break;
                if (!local && !Channel.isSubscribable(channel)) response.error = Error.channelForbidden(channel);
                if (!Channel.isValid(channel)) response.error = Error.channelInvalid(channel);
                if (response.error) break;
                this._engine.unsubscribe(clientId, channel);
            }
            response.successful = !response.error;
            callback.call(context, response);
        }, this);
    }
});
Server.create = function(options) {
    return new Server(options);
};
assign(Server.prototype, Logging);
assign(Server.prototype, Extensible);
module.exports = Server;
}),
"[project]/node_modules/faye/src/transport/node_local.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var asap = __turbopack_context__.r("[project]/node_modules/asap/asap.js [app-route] (ecmascript)"), Class = __turbopack_context__.r("[project]/node_modules/faye/src/util/class.js [app-route] (ecmascript)"), URI = __turbopack_context__.r("[project]/node_modules/faye/src/util/uri.js [app-route] (ecmascript)"), copyObject = __turbopack_context__.r("[project]/node_modules/faye/src/util/copy_object.js [app-route] (ecmascript)"), assign = __turbopack_context__.r("[project]/node_modules/faye/src/util/assign.js [app-route] (ecmascript)"), Server = __turbopack_context__.r("[project]/node_modules/faye/src/protocol/server.js [app-route] (ecmascript)"), Transport = __turbopack_context__.r("[project]/node_modules/faye/src/transport/transport.js [app-route] (ecmascript)");
var NodeLocal = assign(Class(Transport, {
    batching: false,
    request: function(messages) {
        messages = copyObject(messages);
        var self = this;
        asap(function() {
            self.endpoint.process(messages, null, function(replies) {
                self._receive(copyObject(replies));
            });
        });
    }
}), {
    isUsable: function(client, endpoint, callback, context) {
        callback.call(context, endpoint instanceof Server);
    }
});
module.exports = NodeLocal;
}),
"[project]/node_modules/faye/src/util/websocket/node_websocket.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var WS = __turbopack_context__.r("[project]/node_modules/faye-websocket/lib/faye/websocket.js [app-route] (ecmascript)").Client;
module.exports = {
    create: function(url, protocols, options) {
        return new WS(url, protocols, options);
    }
};
}),
"[project]/node_modules/faye/src/transport/web_socket.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Class = __turbopack_context__.r("[project]/node_modules/faye/src/util/class.js [app-route] (ecmascript)"), Promise = __turbopack_context__.r("[project]/node_modules/faye/src/util/promise.js [app-route] (ecmascript)"), Set = __turbopack_context__.r("[project]/node_modules/faye/src/util/set.js [app-route] (ecmascript)"), URI = __turbopack_context__.r("[project]/node_modules/faye/src/util/uri.js [app-route] (ecmascript)"), browser = __turbopack_context__.r("[project]/node_modules/faye/src/util/browser/node_shim.js [app-route] (ecmascript)"), copyObject = __turbopack_context__.r("[project]/node_modules/faye/src/util/copy_object.js [app-route] (ecmascript)"), assign = __turbopack_context__.r("[project]/node_modules/faye/src/util/assign.js [app-route] (ecmascript)"), toJSON = __turbopack_context__.r("[project]/node_modules/faye/src/util/to_json.js [app-route] (ecmascript)"), ws = __turbopack_context__.r("[project]/node_modules/faye/src/util/websocket/node_websocket.js [app-route] (ecmascript)"), Deferrable = __turbopack_context__.r("[project]/node_modules/faye/src/mixins/deferrable.js [app-route] (ecmascript)"), Transport = __turbopack_context__.r("[project]/node_modules/faye/src/transport/transport.js [app-route] (ecmascript)");
var WebSocket = assign(Class(Transport, {
    UNCONNECTED: 1,
    CONNECTING: 2,
    CONNECTED: 3,
    batching: false,
    isUsable: function(callback, context) {
        this.callback(function() {
            callback.call(context, true);
        });
        this.errback(function() {
            callback.call(context, false);
        });
        this.connect();
    },
    request: function(messages) {
        this._pending = this._pending || new Set();
        for(var i = 0, n = messages.length; i < n; i++)this._pending.add(messages[i]);
        var self = this;
        var promise = new Promise(function(resolve, reject) {
            self.callback(function(socket) {
                if (!socket || socket.readyState !== 1) return;
                socket.send(toJSON(messages));
                resolve(socket);
            });
            self.connect();
        });
        return {
            abort: function() {
                promise.then(function(ws) {
                    ws.close();
                });
            }
        };
    },
    connect: function() {
        if (WebSocket._unloaded) return;
        this._state = this._state || this.UNCONNECTED;
        if (this._state !== this.UNCONNECTED) return;
        this._state = this.CONNECTING;
        var socket = this._createSocket();
        if (!socket) return this.setDeferredStatus('failed');
        var self = this;
        socket.onopen = function() {
            if (socket.headers) self._storeCookies(socket.headers['set-cookie']);
            self._socket = socket;
            self._state = self.CONNECTED;
            self._everConnected = true;
            self.setDeferredStatus('succeeded', socket);
        };
        var closed = false;
        socket.onclose = socket.onerror = function() {
            if (closed) return;
            closed = true;
            var wasConnected = self._state === self.CONNECTED;
            socket.onopen = socket.onclose = socket.onerror = socket.onmessage = null;
            delete self._socket;
            self._state = self.UNCONNECTED;
            var pending = self._pending ? self._pending.toArray() : [];
            delete self._pending;
            if (wasConnected || self._everConnected) {
                self.setDeferredStatus('unknown');
                self._handleError(pending, wasConnected);
            } else {
                self.setDeferredStatus('failed');
            }
        };
        socket.onmessage = function(event) {
            var replies;
            try {
                replies = JSON.parse(event.data);
            } catch (error) {}
            if (!replies) return;
            replies = [].concat(replies);
            for(var i = 0, n = replies.length; i < n; i++){
                if (replies[i].successful === undefined) continue;
                self._pending.remove(replies[i]);
            }
            self._receive(replies);
        };
    },
    close: function() {
        if (!this._socket) return;
        this._socket.close();
    },
    _createSocket: function() {
        var url = WebSocket.getSocketUrl(this.endpoint), headers = this._dispatcher.headers, extensions = this._dispatcher.wsExtensions, cookie = this._getCookies(), tls = this._dispatcher.tls, options = {
            extensions: extensions,
            headers: headers,
            proxy: this._proxy,
            tls: tls
        };
        if (cookie !== '') options.headers['Cookie'] = cookie;
        try {
            return ws.create(url, [], options);
        } catch (e) {
        // catch CSP error to allow transport to fallback to next connType
        }
    }
}), {
    PROTOCOLS: {
        'http:': 'ws:',
        'https:': 'wss:'
    },
    create: function(dispatcher, endpoint) {
        var sockets = dispatcher.transports.websocket = dispatcher.transports.websocket || {};
        sockets[endpoint.href] = sockets[endpoint.href] || new this(dispatcher, endpoint);
        return sockets[endpoint.href];
    },
    getSocketUrl: function(endpoint) {
        endpoint = copyObject(endpoint);
        endpoint.protocol = this.PROTOCOLS[endpoint.protocol];
        return URI.stringify(endpoint);
    },
    isUsable: function(dispatcher, endpoint, callback, context) {
        this.create(dispatcher, endpoint).isUsable(callback, context);
    }
});
assign(WebSocket.prototype, Deferrable);
if (browser.Event && /*TURBOPACK member replacement*/ __turbopack_context__.g.onbeforeunload !== undefined) {
    browser.Event.on(/*TURBOPACK member replacement*/ __turbopack_context__.g, 'beforeunload', function() {
        if (WebSocket._unloaded === undefined) WebSocket._unloaded = true;
    });
}
module.exports = WebSocket;
}),
"[project]/node_modules/faye/src/transport/node_http.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-route] (ecmascript)").Buffer, http = __turbopack_context__.r("[externals]/http [external] (http, cjs)"), https = __turbopack_context__.r("[externals]/https [external] (https, cjs)"), tunnel = __turbopack_context__.r("[project]/node_modules/tunnel-agent/index.js [app-route] (ecmascript)");
var Class = __turbopack_context__.r("[project]/node_modules/faye/src/util/class.js [app-route] (ecmascript)"), URI = __turbopack_context__.r("[project]/node_modules/faye/src/util/uri.js [app-route] (ecmascript)"), assign = __turbopack_context__.r("[project]/node_modules/faye/src/util/assign.js [app-route] (ecmascript)"), toJSON = __turbopack_context__.r("[project]/node_modules/faye/src/util/to_json.js [app-route] (ecmascript)"), Transport = __turbopack_context__.r("[project]/node_modules/faye/src/transport/transport.js [app-route] (ecmascript)");
var NodeHttp = assign(Class(Transport, {
    className: 'NodeHttp',
    SECURE_PROTOCOLS: [
        'https:',
        'wss:'
    ],
    initialize: function() {
        Transport.prototype.initialize.apply(this, arguments);
        this._endpointSecure = this.SECURE_PROTOCOLS.indexOf(this.endpoint.protocol) >= 0;
        this._httpClient = this._endpointSecure ? https : http;
        var proxy = this._proxy;
        if (!proxy.origin) return;
        this._proxyUri = URI.parse(proxy.origin);
        this._proxySecure = this.SECURE_PROTOCOLS.indexOf(this._proxyUri.protocol) >= 0;
        if (!this._endpointSecure) {
            this._httpClient = this._proxySecure ? https : http;
            return;
        }
        var options = assign({
            proxy: {
                host: this._proxyUri.hostname,
                port: this._proxyUri.port || this.DEFAULT_PORTS[this._proxyUri.protocol],
                proxyAuth: this._proxyUri.auth,
                headers: assign({
                    host: this.endpoint.host
                }, proxy.headers)
            }
        }, this._dispatcher.tls);
        if (this._proxySecure) {
            assign(options.proxy, proxy.tls);
            this._tunnel = tunnel.httpsOverHttps(options);
        } else {
            this._tunnel = tunnel.httpsOverHttp(options);
        }
    },
    encode: function(messages) {
        return toJSON(messages);
    },
    request: function(messages) {
        var content = Buffer.from(this.encode(messages), 'utf8'), params = this._buildParams(content), request = this._httpClient.request(params), self = this;
        request.on('response', function(response) {
            self._handleResponse(messages, response);
            self._storeCookies(response.headers['set-cookie']);
        });
        request.on('error', function(error) {
            self.error('HTTP error: ' + error.message);
            self._handleError(messages);
        });
        request.end(content);
        return request;
    },
    _buildParams: function(content) {
        var uri = this.endpoint, proxy = this._proxyUri, target = this._tunnel ? uri : proxy || uri;
        var headers = {
            'Content-Length': content.length,
            'Content-Type': 'application/json',
            'Host': uri.host
        };
        if (uri.auth) headers['Authorization'] = 'Basic ' + Buffer.from(uri.auth, 'utf8').toString('base64');
        var params = {
            method: 'POST',
            host: target.hostname,
            port: target.port || this.DEFAULT_PORTS[target.protocol],
            path: uri.path,
            headers: assign(headers, this._dispatcher.headers)
        };
        var cookie = this._getCookies();
        if (cookie !== '') params.headers['Cookie'] = cookie;
        if (this._tunnel) {
            params.agent = this._tunnel;
        } else if (this._endpointSecure) {
            assign(params, this._dispatcher.tls);
        } else if (proxy) {
            params.path = this.endpoint.href;
            assign(params, this._proxy.tls);
            if (proxy.auth) params.headers['Proxy-Authorization'] = Buffer.from(proxy.auth, 'utf8').toString('base64');
        }
        return params;
    },
    _handleResponse: function(messages, response) {
        var body = '', self = this;
        response.setEncoding('utf8');
        response.on('data', function(chunk) {
            body += chunk;
        });
        response.on('end', function() {
            var replies;
            try {
                replies = JSON.parse(body);
            } catch (error) {}
            if (replies) self._receive(replies);
            else self._handleError(messages);
        });
    }
}), {
    isUsable: function(dispatcher, endpoint, callback, context) {
        callback.call(context, URI.isURI(endpoint));
    }
});
module.exports = NodeHttp;
}),
"[project]/node_modules/faye/src/transport/node_transports.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Transport = __turbopack_context__.r("[project]/node_modules/faye/src/transport/transport.js [app-route] (ecmascript)");
Transport.register('in-process', __turbopack_context__.r("[project]/node_modules/faye/src/transport/node_local.js [app-route] (ecmascript)"));
Transport.register('websocket', __turbopack_context__.r("[project]/node_modules/faye/src/transport/web_socket.js [app-route] (ecmascript)"));
Transport.register('long-polling', __turbopack_context__.r("[project]/node_modules/faye/src/transport/node_http.js [app-route] (ecmascript)"));
module.exports = Transport;
}),
"[project]/node_modules/faye/src/protocol/scheduler.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var assign = __turbopack_context__.r("[project]/node_modules/faye/src/util/assign.js [app-route] (ecmascript)");
var Scheduler = function(message, options) {
    this.message = message;
    this.options = options;
    this.attempts = 0;
};
assign(Scheduler.prototype, {
    getTimeout: function() {
        return this.options.timeout;
    },
    getInterval: function() {
        return this.options.interval;
    },
    isDeliverable: function() {
        var attempts = this.options.attempts, made = this.attempts, deadline = this.options.deadline, now = new Date().getTime();
        if (attempts !== undefined && made >= attempts) return false;
        if (deadline !== undefined && now > deadline) return false;
        return true;
    },
    send: function() {
        this.attempts += 1;
    },
    succeed: function() {},
    fail: function() {},
    abort: function() {}
});
module.exports = Scheduler;
}),
"[project]/node_modules/faye/src/protocol/dispatcher.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Class = __turbopack_context__.r("[project]/node_modules/faye/src/util/class.js [app-route] (ecmascript)"), URI = __turbopack_context__.r("[project]/node_modules/faye/src/util/uri.js [app-route] (ecmascript)"), cookies = __turbopack_context__.r("[project]/node_modules/faye/src/util/cookies/node_cookies.js [app-route] (ecmascript)"), assign = __turbopack_context__.r("[project]/node_modules/faye/src/util/assign.js [app-route] (ecmascript)"), Logging = __turbopack_context__.r("[project]/node_modules/faye/src/mixins/logging.js [app-route] (ecmascript)"), Publisher = __turbopack_context__.r("[project]/node_modules/faye/src/mixins/publisher.js [app-route] (ecmascript)"), Transport = __turbopack_context__.r("[project]/node_modules/faye/src/transport/node_transports.js [app-route] (ecmascript)"), Scheduler = __turbopack_context__.r("[project]/node_modules/faye/src/protocol/scheduler.js [app-route] (ecmascript)");
var Dispatcher = Class({
    className: 'Dispatcher',
    MAX_REQUEST_SIZE: 2048,
    DEFAULT_RETRY: 5,
    UP: 1,
    DOWN: 2,
    initialize: function(client, endpoint, options) {
        this._client = client;
        this.endpoint = URI.parse(endpoint);
        this._alternates = options.endpoints || {};
        this.cookies = cookies.CookieJar && new cookies.CookieJar();
        this._disabled = [];
        this._envelopes = {};
        this.headers = {};
        this.retry = options.retry || this.DEFAULT_RETRY;
        this._scheduler = options.scheduler || Scheduler;
        this._state = 0;
        this.transports = {};
        this.wsExtensions = [];
        this.proxy = options.proxy || {};
        if (typeof this._proxy === 'string') this._proxy = {
            origin: this._proxy
        };
        var exts = options.websocketExtensions;
        if (exts) {
            exts = [].concat(exts);
            for(var i = 0, n = exts.length; i < n; i++)this.addWebsocketExtension(exts[i]);
        }
        this.tls = options.tls || {};
        this.tls.ca = this.tls.ca || options.ca;
        for(var type in this._alternates)this._alternates[type] = URI.parse(this._alternates[type]);
        this.maxRequestSize = this.MAX_REQUEST_SIZE;
    },
    endpointFor: function(connectionType) {
        return this._alternates[connectionType] || this.endpoint;
    },
    addWebsocketExtension: function(extension) {
        this.wsExtensions.push(extension);
    },
    disable: function(feature) {
        this._disabled.push(feature);
        Transport.disable(feature);
    },
    setHeader: function(name, value) {
        this.headers[name] = value;
    },
    close: function() {
        var transport = this._transport;
        delete this._transport;
        if (transport) transport.close();
    },
    getConnectionTypes: function() {
        return Transport.getConnectionTypes();
    },
    selectTransport: function(transportTypes) {
        Transport.get(this, transportTypes, this._disabled, function(transport) {
            this.debug('Selected ? transport for ?', transport.connectionType, transport.endpoint.href);
            if (transport === this._transport) return;
            if (this._transport) this._transport.close();
            this._transport = transport;
            this.connectionType = transport.connectionType;
        }, this);
    },
    sendMessage: function(message, timeout, options) {
        options = options || {};
        var id = message.id, attempts = options.attempts, deadline = options.deadline && new Date().getTime() + options.deadline * 1000, envelope = this._envelopes[id], scheduler;
        if (!envelope) {
            scheduler = new this._scheduler(message, {
                timeout: timeout,
                interval: this.retry,
                attempts: attempts,
                deadline: deadline
            });
            envelope = this._envelopes[id] = {
                message: message,
                scheduler: scheduler
            };
        }
        this._sendEnvelope(envelope);
    },
    _sendEnvelope: function(envelope) {
        if (!this._transport) return;
        if (envelope.request || envelope.timer) return;
        var message = envelope.message, scheduler = envelope.scheduler, self = this;
        if (!scheduler.isDeliverable()) {
            scheduler.abort();
            delete this._envelopes[message.id];
            return;
        }
        envelope.timer = /*TURBOPACK member replacement*/ __turbopack_context__.g.setTimeout(function() {
            self.handleError(message);
        }, scheduler.getTimeout() * 1000);
        scheduler.send();
        envelope.request = this._transport.sendMessage(message);
    },
    handleResponse: function(reply) {
        var envelope = this._envelopes[reply.id];
        if (reply.successful !== undefined && envelope) {
            envelope.scheduler.succeed();
            delete this._envelopes[reply.id];
            /*TURBOPACK member replacement*/ __turbopack_context__.g.clearTimeout(envelope.timer);
        }
        this.trigger('message', reply);
        if (this._state === this.UP) return;
        this._state = this.UP;
        this._client.trigger('transport:up');
    },
    handleError: function(message, immediate) {
        var envelope = this._envelopes[message.id], request = envelope && envelope.request, self = this;
        if (!request) return;
        request.then(function(req) {
            if (req && req.abort) req.abort();
        });
        var scheduler = envelope.scheduler;
        scheduler.fail();
        /*TURBOPACK member replacement*/ __turbopack_context__.g.clearTimeout(envelope.timer);
        envelope.request = envelope.timer = null;
        if (immediate) {
            this._sendEnvelope(envelope);
        } else {
            envelope.timer = /*TURBOPACK member replacement*/ __turbopack_context__.g.setTimeout(function() {
                envelope.timer = null;
                self._sendEnvelope(envelope);
            }, scheduler.getInterval() * 1000);
        }
        if (this._state === this.DOWN) return;
        this._state = this.DOWN;
        this._client.trigger('transport:down');
    }
});
Dispatcher.create = function(client, endpoint, options) {
    return new Dispatcher(client, endpoint, options);
};
assign(Dispatcher.prototype, Publisher);
assign(Dispatcher.prototype, Logging);
module.exports = Dispatcher;
}),
"[project]/node_modules/faye/src/protocol/publication.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Class = __turbopack_context__.r("[project]/node_modules/faye/src/util/class.js [app-route] (ecmascript)"), Deferrable = __turbopack_context__.r("[project]/node_modules/faye/src/mixins/deferrable.js [app-route] (ecmascript)");
module.exports = Class(Deferrable);
}),
"[project]/node_modules/faye/src/protocol/subscription.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Class = __turbopack_context__.r("[project]/node_modules/faye/src/util/class.js [app-route] (ecmascript)"), assign = __turbopack_context__.r("[project]/node_modules/faye/src/util/assign.js [app-route] (ecmascript)"), Deferrable = __turbopack_context__.r("[project]/node_modules/faye/src/mixins/deferrable.js [app-route] (ecmascript)");
var Subscription = Class({
    initialize: function(client, channels, callback, context) {
        this._client = client;
        this._channels = channels;
        this._callback = callback;
        this._context = context;
        this._cancelled = false;
    },
    withChannel: function(callback, context) {
        this._withChannel = [
            callback,
            context
        ];
        return this;
    },
    apply: function(context, args) {
        var message = args[0];
        if (this._callback) this._callback.call(this._context, message.data);
        if (this._withChannel) this._withChannel[0].call(this._withChannel[1], message.channel, message.data);
    },
    cancel: function() {
        if (this._cancelled) return;
        this._client.unsubscribe(this._channels, this);
        this._cancelled = true;
    },
    unsubscribe: function() {
        this.cancel();
    }
});
assign(Subscription.prototype, Deferrable);
module.exports = Subscription;
}),
"[project]/node_modules/faye/src/protocol/client.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var asap = __turbopack_context__.r("[project]/node_modules/asap/asap.js [app-route] (ecmascript)"), Class = __turbopack_context__.r("[project]/node_modules/faye/src/util/class.js [app-route] (ecmascript)"), Promise = __turbopack_context__.r("[project]/node_modules/faye/src/util/promise.js [app-route] (ecmascript)"), array = __turbopack_context__.r("[project]/node_modules/faye/src/util/array.js [app-route] (ecmascript)"), browser = __turbopack_context__.r("[project]/node_modules/faye/src/util/browser/node_shim.js [app-route] (ecmascript)"), constants = __turbopack_context__.r("[project]/node_modules/faye/src/util/constants.js [app-route] (ecmascript)"), assign = __turbopack_context__.r("[project]/node_modules/faye/src/util/assign.js [app-route] (ecmascript)"), validateOptions = __turbopack_context__.r("[project]/node_modules/faye/src/util/validate_options.js [app-route] (ecmascript)"), Deferrable = __turbopack_context__.r("[project]/node_modules/faye/src/mixins/deferrable.js [app-route] (ecmascript)"), Logging = __turbopack_context__.r("[project]/node_modules/faye/src/mixins/logging.js [app-route] (ecmascript)"), Publisher = __turbopack_context__.r("[project]/node_modules/faye/src/mixins/publisher.js [app-route] (ecmascript)"), Channel = __turbopack_context__.r("[project]/node_modules/faye/src/protocol/channel.js [app-route] (ecmascript)"), Dispatcher = __turbopack_context__.r("[project]/node_modules/faye/src/protocol/dispatcher.js [app-route] (ecmascript)"), Error = __turbopack_context__.r("[project]/node_modules/faye/src/protocol/error.js [app-route] (ecmascript)"), Extensible = __turbopack_context__.r("[project]/node_modules/faye/src/protocol/extensible.js [app-route] (ecmascript)"), Publication = __turbopack_context__.r("[project]/node_modules/faye/src/protocol/publication.js [app-route] (ecmascript)"), Subscription = __turbopack_context__.r("[project]/node_modules/faye/src/protocol/subscription.js [app-route] (ecmascript)");
var Client = Class({
    className: 'Client',
    UNCONNECTED: 1,
    CONNECTING: 2,
    CONNECTED: 3,
    DISCONNECTED: 4,
    HANDSHAKE: 'handshake',
    RETRY: 'retry',
    NONE: 'none',
    CONNECTION_TIMEOUT: 60,
    DEFAULT_ENDPOINT: '/bayeux',
    INTERVAL: 0,
    initialize: function(endpoint, options) {
        this.info('New client created for ?', endpoint);
        options = options || {};
        validateOptions(options, [
            'interval',
            'timeout',
            'endpoints',
            'proxy',
            'retry',
            'scheduler',
            'websocketExtensions',
            'tls',
            'ca'
        ]);
        this._channels = new Channel.Set();
        this._dispatcher = Dispatcher.create(this, endpoint || this.DEFAULT_ENDPOINT, options);
        this._messageId = 0;
        this._state = this.UNCONNECTED;
        this._responseCallbacks = {};
        this._advice = {
            reconnect: this.RETRY,
            interval: 1000 * (options.interval || this.INTERVAL),
            timeout: 1000 * (options.timeout || this.CONNECTION_TIMEOUT)
        };
        this._dispatcher.timeout = this._advice.timeout / 1000;
        this._dispatcher.bind('message', this._receiveMessage, this);
        if (browser.Event && /*TURBOPACK member replacement*/ __turbopack_context__.g.onbeforeunload !== undefined) browser.Event.on(/*TURBOPACK member replacement*/ __turbopack_context__.g, 'beforeunload', function() {
            if (array.indexOf(this._dispatcher._disabled, 'autodisconnect') < 0) this.disconnect();
        }, this);
    },
    addWebsocketExtension: function(extension) {
        return this._dispatcher.addWebsocketExtension(extension);
    },
    disable: function(feature) {
        return this._dispatcher.disable(feature);
    },
    setHeader: function(name, value) {
        return this._dispatcher.setHeader(name, value);
    },
    // Request
    // MUST include:  * channel
    //                * version
    //                * supportedConnectionTypes
    // MAY include:   * minimumVersion
    //                * ext
    //                * id
    //
    // Success Response                             Failed Response
    // MUST include:  * channel                     MUST include:  * channel
    //                * version                                    * successful
    //                * supportedConnectionTypes                   * error
    //                * clientId                    MAY include:   * supportedConnectionTypes
    //                * successful                                 * advice
    // MAY include:   * minimumVersion                             * version
    //                * advice                                     * minimumVersion
    //                * ext                                        * ext
    //                * id                                         * id
    //                * authSuccessful
    handshake: function(callback, context) {
        if (this._advice.reconnect === this.NONE) return;
        if (this._state !== this.UNCONNECTED) return;
        this._state = this.CONNECTING;
        var self = this;
        this.info('Initiating handshake with ?', this._dispatcher.endpoint.href);
        this._dispatcher.selectTransport(constants.MANDATORY_CONNECTION_TYPES);
        this._sendMessage({
            channel: Channel.HANDSHAKE,
            version: constants.BAYEUX_VERSION,
            supportedConnectionTypes: this._dispatcher.getConnectionTypes()
        }, {}, function(response) {
            if (response.successful) {
                this._state = this.CONNECTED;
                this._dispatcher.clientId = response.clientId;
                this._dispatcher.selectTransport(response.supportedConnectionTypes);
                this.info('Handshake successful: ?', this._dispatcher.clientId);
                this.subscribe(this._channels.getKeys(), true);
                if (callback) asap(function() {
                    callback.call(context);
                });
            } else {
                this.info('Handshake unsuccessful');
                /*TURBOPACK member replacement*/ __turbopack_context__.g.setTimeout(function() {
                    self.handshake(callback, context);
                }, this._dispatcher.retry * 1000);
                this._state = this.UNCONNECTED;
            }
        }, this);
    },
    // Request                              Response
    // MUST include:  * channel             MUST include:  * channel
    //                * clientId                           * successful
    //                * connectionType                     * clientId
    // MAY include:   * ext                 MAY include:   * error
    //                * id                                 * advice
    //                                                     * ext
    //                                                     * id
    //                                                     * timestamp
    connect: function(callback, context) {
        if (this._advice.reconnect === this.NONE) return;
        if (this._state === this.DISCONNECTED) return;
        if (this._state === this.UNCONNECTED) return this.handshake(function() {
            this.connect(callback, context);
        }, this);
        this.callback(callback, context);
        if (this._state !== this.CONNECTED) return;
        this.info('Calling deferred actions for ?', this._dispatcher.clientId);
        this.setDeferredStatus('succeeded');
        this.setDeferredStatus('unknown');
        if (this._connectRequest) return;
        this._connectRequest = true;
        this.info('Initiating connection for ?', this._dispatcher.clientId);
        this._sendMessage({
            channel: Channel.CONNECT,
            clientId: this._dispatcher.clientId,
            connectionType: this._dispatcher.connectionType
        }, {}, this._cycleConnection, this);
    },
    // Request                              Response
    // MUST include:  * channel             MUST include:  * channel
    //                * clientId                           * successful
    // MAY include:   * ext                                * clientId
    //                * id                  MAY include:   * error
    //                                                     * ext
    //                                                     * id
    disconnect: function() {
        if (this._state !== this.CONNECTED) return;
        this._state = this.DISCONNECTED;
        this.info('Disconnecting ?', this._dispatcher.clientId);
        var promise = new Publication();
        this._sendMessage({
            channel: Channel.DISCONNECT,
            clientId: this._dispatcher.clientId
        }, {}, function(response) {
            if (response.successful) {
                this._dispatcher.close();
                promise.setDeferredStatus('succeeded');
            } else {
                promise.setDeferredStatus('failed', Error.parse(response.error));
            }
        }, this);
        this.info('Clearing channel listeners for ?', this._dispatcher.clientId);
        this._channels = new Channel.Set();
        return promise;
    },
    // Request                              Response
    // MUST include:  * channel             MUST include:  * channel
    //                * clientId                           * successful
    //                * subscription                       * clientId
    // MAY include:   * ext                                * subscription
    //                * id                  MAY include:   * error
    //                                                     * advice
    //                                                     * ext
    //                                                     * id
    //                                                     * timestamp
    subscribe: function(channel, callback, context) {
        if (channel instanceof Array) return array.map(channel, function(c) {
            return this.subscribe(c, callback, context);
        }, this);
        var subscription = new Subscription(this, channel, callback, context), force = callback === true, hasSubscribe = this._channels.hasSubscription(channel);
        if (hasSubscribe && !force) {
            this._channels.subscribe([
                channel
            ], subscription);
            subscription.setDeferredStatus('succeeded');
            return subscription;
        }
        this.connect(function() {
            this.info('Client ? attempting to subscribe to ?', this._dispatcher.clientId, channel);
            if (!force) this._channels.subscribe([
                channel
            ], subscription);
            this._sendMessage({
                channel: Channel.SUBSCRIBE,
                clientId: this._dispatcher.clientId,
                subscription: channel
            }, {}, function(response) {
                if (!response.successful) {
                    subscription.setDeferredStatus('failed', Error.parse(response.error));
                    return this._channels.unsubscribe(channel, subscription);
                }
                var channels = [].concat(response.subscription);
                this.info('Subscription acknowledged for ? to ?', this._dispatcher.clientId, channels);
                subscription.setDeferredStatus('succeeded');
            }, this);
        }, this);
        return subscription;
    },
    // Request                              Response
    // MUST include:  * channel             MUST include:  * channel
    //                * clientId                           * successful
    //                * subscription                       * clientId
    // MAY include:   * ext                                * subscription
    //                * id                  MAY include:   * error
    //                                                     * advice
    //                                                     * ext
    //                                                     * id
    //                                                     * timestamp
    unsubscribe: function(channel, subscription) {
        if (channel instanceof Array) return array.map(channel, function(c) {
            return this.unsubscribe(c, subscription);
        }, this);
        var dead = this._channels.unsubscribe(channel, subscription);
        if (!dead) return;
        this.connect(function() {
            this.info('Client ? attempting to unsubscribe from ?', this._dispatcher.clientId, channel);
            this._sendMessage({
                channel: Channel.UNSUBSCRIBE,
                clientId: this._dispatcher.clientId,
                subscription: channel
            }, {}, function(response) {
                if (!response.successful) return;
                var channels = [].concat(response.subscription);
                this.info('Unsubscription acknowledged for ? from ?', this._dispatcher.clientId, channels);
            }, this);
        }, this);
    },
    // Request                              Response
    // MUST include:  * channel             MUST include:  * channel
    //                * data                               * successful
    // MAY include:   * clientId            MAY include:   * id
    //                * id                                 * error
    //                * ext                                * ext
    publish: function(channel, data, options) {
        validateOptions(options || {}, [
            'attempts',
            'deadline'
        ]);
        var publication = new Publication();
        this.connect(function() {
            this.info('Client ? queueing published message to ?: ?', this._dispatcher.clientId, channel, data);
            this._sendMessage({
                channel: channel,
                data: data,
                clientId: this._dispatcher.clientId
            }, options, function(response) {
                if (response.successful) publication.setDeferredStatus('succeeded');
                else publication.setDeferredStatus('failed', Error.parse(response.error));
            }, this);
        }, this);
        return publication;
    },
    _sendMessage: function(message, options, callback, context) {
        message.id = this._generateMessageId();
        var timeout = this._advice.timeout ? 1.2 * this._advice.timeout / 1000 : 1.2 * this._dispatcher.retry;
        this.pipeThroughExtensions('outgoing', message, null, function(message) {
            if (!message) return;
            if (callback) this._responseCallbacks[message.id] = [
                callback,
                context
            ];
            this._dispatcher.sendMessage(message, timeout, options || {});
        }, this);
    },
    _generateMessageId: function() {
        this._messageId += 1;
        if (this._messageId >= Math.pow(2, 32)) this._messageId = 0;
        return this._messageId.toString(36);
    },
    _receiveMessage: function(message) {
        var id = message.id, callback;
        if (message.successful !== undefined) {
            callback = this._responseCallbacks[id];
            delete this._responseCallbacks[id];
        }
        this.pipeThroughExtensions('incoming', message, null, function(message) {
            if (!message) return;
            if (message.advice) this._handleAdvice(message.advice);
            this._deliverMessage(message);
            if (callback) callback[0].call(callback[1], message);
        }, this);
    },
    _handleAdvice: function(advice) {
        assign(this._advice, advice);
        this._dispatcher.timeout = this._advice.timeout / 1000;
        if (this._advice.reconnect === this.HANDSHAKE && this._state !== this.DISCONNECTED) {
            this._state = this.UNCONNECTED;
            this._dispatcher.clientId = null;
            this._cycleConnection();
        }
    },
    _deliverMessage: function(message) {
        if (!message.channel || message.data === undefined) return;
        this.info('Client ? calling listeners for ? with ?', this._dispatcher.clientId, message.channel, message.data);
        this._channels.distributeMessage(message);
    },
    _cycleConnection: function() {
        if (this._connectRequest) {
            this._connectRequest = null;
            this.info('Closed connection for ?', this._dispatcher.clientId);
        }
        var self = this;
        /*TURBOPACK member replacement*/ __turbopack_context__.g.setTimeout(function() {
            self.connect();
        }, this._advice.interval);
    }
});
assign(Client.prototype, Deferrable);
assign(Client.prototype, Publisher);
assign(Client.prototype, Logging);
assign(Client.prototype, Extensible);
module.exports = Client;
}),
"[project]/node_modules/faye/src/util/id_from_messages.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var array = __turbopack_context__.r("[project]/node_modules/faye/src/util/array.js [app-route] (ecmascript)");
module.exports = function(messages) {
    var connect = array.filter([].concat(messages), function(message) {
        return message.channel === '/meta/connect';
    });
    return connect[0] && connect[0].clientId;
};
}),
"[project]/node_modules/faye/src/adapters/content_types.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = {
    TYPE_JSON: {
        'Content-Type': 'application/json; charset=utf-8'
    },
    TYPE_SCRIPT: {
        'Content-Type': 'text/javascript; charset=utf-8'
    },
    TYPE_TEXT: {
        'Content-Type': 'text/plain; charset=utf-8'
    }
};
}),
"[project]/node_modules/faye/src/adapters/static_server.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)"), fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)"), path = __turbopack_context__.r("[externals]/path [external] (path, cjs)"), url = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
var Class = __turbopack_context__.r("[project]/node_modules/faye/src/util/class.js [app-route] (ecmascript)"), assign = __turbopack_context__.r("[project]/node_modules/faye/src/util/assign.js [app-route] (ecmascript)"), contenttypes = __turbopack_context__.r("[project]/node_modules/faye/src/adapters/content_types.js [app-route] (ecmascript)");
var StaticServer = Class({
    initialize: function(directory, pathRegex) {
        this._directory = directory;
        this._pathRegex = pathRegex;
        this._pathMap = {};
        this._index = {};
    },
    map: function(requestPath, filename) {
        this._pathMap[requestPath] = filename;
    },
    test: function(pathname) {
        return this._pathRegex.test(pathname);
    },
    call: function(request, response) {
        var pathname = url.parse(request.url, true).pathname, filename = path.basename(pathname);
        filename = this._pathMap[filename] || filename;
        this._index[filename] = this._index[filename] || {};
        var cache = this._index[filename], fullpath = path.join(this._directory, filename);
        try {
            cache.content = cache.content || fs.readFileSync(fullpath);
            cache.digest = cache.digest || crypto.createHash('sha1').update(cache.content).digest('hex');
            cache.mtime = cache.mtime || fs.statSync(fullpath).mtime;
        } catch (error) {
            response.writeHead(404, {});
            return response.end();
        }
        var type = /\.js$/.test(pathname) ? 'TYPE_SCRIPT' : 'TYPE_JSON', ims = request.headers['if-modified-since'];
        var headers = {
            'ETag': cache.digest,
            'Last-Modified': cache.mtime.toGMTString()
        };
        if (request.headers['if-none-match'] === cache.digest) {
            response.writeHead(304, headers);
            response.end();
        } else if (ims && cache.mtime <= new Date(ims)) {
            response.writeHead(304, headers);
            response.end();
        } else {
            headers['Content-Length'] = cache.content.length;
            assign(headers, contenttypes[type]);
            response.writeHead(200, headers);
            response.end(cache.content);
        }
    }
});
module.exports = StaticServer;
}),
"[project]/node_modules/faye/src/adapters/node_adapter.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-route] (ecmascript)").Buffer, path = __turbopack_context__.r("[externals]/path [external] (path, cjs)"), querystring = __turbopack_context__.r("[externals]/querystring [external] (querystring, cjs)"), url = __turbopack_context__.r("[externals]/url [external] (url, cjs)"), WebSocket = __turbopack_context__.r("[project]/node_modules/faye-websocket/lib/faye/websocket.js [app-route] (ecmascript)"), EventSource = WebSocket.EventSource;
var constants = __turbopack_context__.r("[project]/node_modules/faye/src/util/constants.js [app-route] (ecmascript)"), assign = __turbopack_context__.r("[project]/node_modules/faye/src/util/assign.js [app-route] (ecmascript)"), idFromMessages = __turbopack_context__.r("[project]/node_modules/faye/src/util/id_from_messages.js [app-route] (ecmascript)"), toJSON = __turbopack_context__.r("[project]/node_modules/faye/src/util/to_json.js [app-route] (ecmascript)"), validateOptions = __turbopack_context__.r("[project]/node_modules/faye/src/util/validate_options.js [app-route] (ecmascript)"), Class = __turbopack_context__.r("[project]/node_modules/faye/src/util/class.js [app-route] (ecmascript)"), Logging = __turbopack_context__.r("[project]/node_modules/faye/src/mixins/logging.js [app-route] (ecmascript)"), Publisher = __turbopack_context__.r("[project]/node_modules/faye/src/mixins/publisher.js [app-route] (ecmascript)"), Client = __turbopack_context__.r("[project]/node_modules/faye/src/protocol/client.js [app-route] (ecmascript)"), Server = __turbopack_context__.r("[project]/node_modules/faye/src/protocol/server.js [app-route] (ecmascript)"), contenttypes = __turbopack_context__.r("[project]/node_modules/faye/src/adapters/content_types.js [app-route] (ecmascript)"), StaticServer = __turbopack_context__.r("[project]/node_modules/faye/src/adapters/static_server.js [app-route] (ecmascript)");
var NodeAdapter = Class({
    className: 'NodeAdapter',
    DEFAULT_ENDPOINT: '/bayeux',
    SCRIPT_PATH: 'faye-browser-min.js',
    VALID_JSONP_CALLBACK: /^[a-z_\$][a-z0-9_\$]*(\.[a-z_\$][a-z0-9_\$]*)*$/i,
    initialize: function(options) {
        this._options = options || {};
        validateOptions(this._options, [
            'engine',
            'mount',
            'ping',
            'timeout',
            'extensions',
            'websocketExtensions'
        ]);
        this._extensions = [];
        this._endpoint = this._options.mount || this.DEFAULT_ENDPOINT;
        this._endpointRe = new RegExp('^' + this._endpoint.replace(/\/$/, '') + '(/[^/]*)*(\\.[^\\.]+)?$');
        this._server = Server.create(this._options);
        this._static = new StaticServer(path.join(("TURBOPACK compile-time value", "/ROOT/node_modules/faye/src/adapters"), '..', '..', 'client'), /\.(?:js|map)$/);
        this._static.map(path.basename(this._endpoint) + '.js', this.SCRIPT_PATH);
        this._static.map('client.js', this.SCRIPT_PATH);
        var extensions = this._options.extensions, websocketExtensions = this._options.websocketExtensions, i, n;
        if (extensions) {
            extensions = [].concat(extensions);
            for(i = 0, n = extensions.length; i < n; i++)this.addExtension(extensions[i]);
        }
        if (websocketExtensions) {
            websocketExtensions = [].concat(websocketExtensions);
            for(i = 0, n = websocketExtensions.length; i < n; i++)this.addWebsocketExtension(websocketExtensions[i]);
        }
    },
    listen: function() {
        throw new Error('The listen() method is deprecated - use the attach() method to bind Faye to an http.Server');
    },
    addExtension: function(extension) {
        return this._server.addExtension(extension);
    },
    removeExtension: function(extension) {
        return this._server.removeExtension(extension);
    },
    addWebsocketExtension: function(extension) {
        this._extensions.push(extension);
    },
    close: function() {
        return this._server.close();
    },
    getClient: function() {
        return this._client = this._client || new Client(this._server);
    },
    attach: function(httpServer) {
        this._overrideListeners(httpServer, 'request', 'handle');
        this._overrideListeners(httpServer, 'upgrade', 'handleUpgrade');
    },
    _overrideListeners: function(httpServer, event, method) {
        var listeners = httpServer.listeners(event), self = this;
        httpServer.removeAllListeners(event);
        httpServer.on(event, function(request) {
            if (self.check(request)) return self[method].apply(self, arguments);
            for(var i = 0, n = listeners.length; i < n; i++)listeners[i].apply(this, arguments);
        });
    },
    check: function(request) {
        var path = url.parse(request.url, true).pathname;
        return !!this._endpointRe.test(path);
    },
    handle: function(request, response) {
        var requestUrl = url.parse(request.url, true), requestMethod = request.method, self = this;
        request.originalUrl = request.url;
        request.on('error', function(error) {
            self._returnError(response, error);
        });
        response.on('error', function(error) {
            self._returnError(null, error);
        });
        if (this._static.test(requestUrl.pathname)) return this._static.call(request, response);
        // http://groups.google.com/group/faye-users/browse_thread/thread/4a01bb7d25d3636a
        if (requestMethod === 'OPTIONS' || request.headers['access-control-request-method'] === 'POST') return this._handleOptions(request, response);
        if (EventSource.isEventSource(request)) return this.handleEventSource(request, response);
        if (requestMethod === 'GET') return this._callWithParams(request, response, requestUrl.query);
        if (requestMethod === 'POST') return this._concatStream(request, function(data) {
            var type = (request.headers['content-type'] || '').split(';')[0], params = type === 'application/json' ? {
                message: data
            } : querystring.parse(data);
            request.body = data;
            this._callWithParams(request, response, params);
        }, this);
        this._returnError(response, {
            message: 'Unrecognized request type'
        });
    },
    _callWithParams: function(request, response, params) {
        if (!params.message) return this._returnError(response, {
            message: 'Received request with no message: ' + this._formatRequest(request)
        });
        try {
            this.debug('Received message via HTTP ' + request.method + ': ?', params.message);
            var message = this._parseJSON(params.message), jsonp = params.jsonp || constants.JSONP_CALLBACK, isGet = request.method === 'GET', type = isGet ? contenttypes.TYPE_SCRIPT : contenttypes.TYPE_JSON, headers = assign({}, type), origin = request.headers.origin;
            if (!this.VALID_JSONP_CALLBACK.test(jsonp)) return this._returnError(response, {
                message: 'Invalid JSON-P callback: ' + jsonp
            });
            headers['Cache-Control'] = 'no-cache, no-store';
            headers['X-Content-Type-Options'] = 'nosniff';
            if (origin) {
                headers['Access-Control-Allow-Credentials'] = 'true';
                headers['Access-Control-Allow-Origin'] = origin;
            }
            this._server.process(message, request, function(replies) {
                var body = toJSON(replies);
                if (isGet) {
                    body = '/**/' + jsonp + '(' + this._jsonpEscape(body) + ');';
                    headers['Content-Disposition'] = 'attachment; filename=f.txt';
                }
                headers['Content-Length'] = Buffer.from(body, 'utf8').length.toString();
                this.debug('HTTP response: ?', body);
                response.writeHead(200, headers);
                response.end(body);
            }, this);
        } catch (error) {
            this._returnError(response, error);
        }
    },
    _jsonpEscape: function(json) {
        return json.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
    },
    handleUpgrade: function(request, socket, head) {
        var options = {
            extensions: this._extensions,
            ping: this._options.ping
        }, ws = new WebSocket(request, socket, head, [], options), clientId = null, self = this;
        request.originalUrl = request.url;
        ws.onmessage = function(event) {
            try {
                self.debug('Received message via WebSocket[' + ws.version + ']: ?', event.data);
                var message = self._parseJSON(event.data), cid = idFromMessages(message);
                if (clientId && cid && cid !== clientId) self._server.closeSocket(clientId, false);
                self._server.openSocket(cid, ws, request);
                if (cid) clientId = cid;
                self._server.process(message, request, function(replies) {
                    if (ws) ws.send(toJSON(replies));
                });
            } catch (error) {
                console.log(error.stack);
                self.error(error.message + '\nBacktrace:\n' + error.stack);
            }
        };
        ws.onclose = function(event) {
            self._server.closeSocket(clientId);
            ws = null;
        };
    },
    handleEventSource: function(request, response) {
        var es = new EventSource(request, response, {
            ping: this._options.ping
        }), clientId = es.url.split('/').pop(), self = this;
        this.debug('Opened EventSource connection for ?', clientId);
        this._server.openSocket(clientId, es, request);
        es.onclose = function(event) {
            self._server.closeSocket(clientId);
            es = null;
        };
    },
    _handleOptions: function(request, response) {
        var origin = request.headers.origin || request.headers.referer;
        var headers = {
            'Access-Control-Allow-Credentials': 'true',
            'Access-Control-Allow-Headers': 'Accept, Authorization, Content-Type, Pragma, X-Requested-With',
            'Access-Control-Allow-Methods': 'POST, GET',
            'Access-Control-Allow-Origin': origin || '*',
            'Access-Control-Max-Age': '86400'
        };
        response.writeHead(200, headers);
        response.end('');
    },
    _concatStream: function(stream, callback, context) {
        var chunks = [], length = 0;
        stream.on('data', function(chunk) {
            chunks.push(chunk);
            length += chunk.length;
        });
        stream.on('end', function() {
            var buffer = Buffer.alloc(length), offset = 0;
            for(var i = 0, n = chunks.length; i < n; i++){
                chunks[i].copy(buffer, offset);
                offset += chunks[i].length;
            }
            callback.call(context, buffer.toString('utf8'));
        });
    },
    _parseJSON: function(json) {
        var data = JSON.parse(json);
        if (typeof data === 'object') return data;
        throw new SyntaxError('JSON messages must contain an object or array');
    },
    _formatRequest: function(request) {
        var method = request.method.toUpperCase(), string = 'curl -X ' + method;
        string += " 'http://" + request.headers.host + request.url + "'";
        if (method === 'POST') {
            string += " -H 'Content-Type: " + request.headers['content-type'] + "'";
            string += " -d '" + request.body + "'";
        }
        return string;
    },
    _returnError: function(response, error) {
        var message = error.message;
        if (error.stack) message += '\nBacktrace:\n' + error.stack;
        this.error(message);
        if (!response) return;
        response.writeHead(400, contenttypes.TYPE_TEXT);
        response.end('Bad request');
    }
});
for(var method in Publisher)(function(method) {
    NodeAdapter.prototype[method] = function() {
        return this._server._engine[method].apply(this._server._engine, arguments);
    };
})(method);
assign(NodeAdapter.prototype, Logging);
module.exports = NodeAdapter;
}),
"[project]/node_modules/faye/src/faye_node.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var constants = __turbopack_context__.r("[project]/node_modules/faye/src/util/constants.js [app-route] (ecmascript)"), Logging = __turbopack_context__.r("[project]/node_modules/faye/src/mixins/logging.js [app-route] (ecmascript)");
var Faye = {
    VERSION: constants.VERSION,
    Client: __turbopack_context__.r("[project]/node_modules/faye/src/protocol/client.js [app-route] (ecmascript)"),
    Scheduler: __turbopack_context__.r("[project]/node_modules/faye/src/protocol/scheduler.js [app-route] (ecmascript)"),
    NodeAdapter: __turbopack_context__.r("[project]/node_modules/faye/src/adapters/node_adapter.js [app-route] (ecmascript)")
};
Logging.wrapper = Faye;
module.exports = Faye;
}),
"[project]/node_modules/asap/raw.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var domain; // The domain module is executed on demand
var hasSetImmediate = typeof setImmediate === "function";
// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including network IO events in Node.js.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
module.exports = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing = true;
    }
    // Avoids a function call
    queue[queue.length] = task;
}
var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.
var flushing = false;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory excaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;
// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush() {
    while(index < queue.length){
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for(var scan = 0, newLength = queue.length - index; scan < newLength; scan++){
                queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
    flushing = false;
}
rawAsap.requestFlush = requestFlush;
function requestFlush() {
    // Ensure flushing is not bound to any domain.
    // It is not sufficient to exit the domain, because domains exist on a stack.
    // To execute code outside of any domain, the following dance is necessary.
    var parentDomain = process.domain;
    if (parentDomain) {
        if (!domain) {
            // Lazy execute the domain module.
            // Only employed if the user elects to use domains.
            domain = __turbopack_context__.r("[externals]/domain [external] (domain, cjs)");
        }
        domain.active = process.domain = null;
    }
    // `setImmediate` is slower that `process.nextTick`, but `process.nextTick`
    // cannot handle recursion.
    // `requestFlush` will only be called recursively from `asap.js`, to resume
    // flushing after an error is thrown into a domain.
    // Conveniently, `setImmediate` was introduced in the same version
    // `process.nextTick` started throwing recursion errors.
    if (flushing && hasSetImmediate) {
        setImmediate(flush);
    } else {
        process.nextTick(flush);
    }
    if (parentDomain) {
        domain.active = process.domain = parentDomain;
    }
}
}),
"[project]/node_modules/asap/asap.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var rawAsap = __turbopack_context__.r("[project]/node_modules/asap/raw.js [app-route] (ecmascript)");
var freeTasks = [];
/**
 * Calls a task as soon as possible after returning, in its own event, with
 * priority over IO events. An exception thrown in a task can be handled by
 * `process.on("uncaughtException") or `domain.on("error")`, but will otherwise
 * crash the process. If the error is handled, all subsequent tasks will
 * resume.
 *
 * @param {{call}} task A callable object, typically a function that takes no
 * arguments.
 */ module.exports = asap;
function asap(task) {
    var rawTask;
    if (freeTasks.length) {
        rawTask = freeTasks.pop();
    } else {
        rawTask = new RawTask();
    }
    rawTask.task = task;
    rawTask.domain = process.domain;
    rawAsap(rawTask);
}
function RawTask() {
    this.task = null;
    this.domain = null;
}
RawTask.prototype.call = function() {
    if (this.domain) {
        this.domain.enter();
    }
    var threw = true;
    try {
        this.task.call();
        threw = false;
        // If the task throws an exception (presumably) Node.js restores the
        // domain stack for the next event.
        if (this.domain) {
            this.domain.exit();
        }
    } finally{
        // We use try/finally and a threw flag to avoid messing up stack traces
        // when we catch and release errors.
        if (threw) {
            // In Node.js, uncaught exceptions are considered fatal errors.
            // Re-throw them to interrupt flushing!
            // Ensure that flushing continues if an uncaught exception is
            // suppressed listening process.on("uncaughtException") or
            // domain.on("error").
            rawAsap.requestFlush();
        }
        // If the task threw an error, we do not want to exit the domain here.
        // Exiting the domain would prevent the domain from catching the error.
        this.task = null;
        this.domain = null;
        freeTasks.push(this);
    }
};
}),
"[project]/node_modules/tldts-core/dist/es6/src/domain.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Check if `vhost` is a valid suffix of `hostname` (top-domain)
 *
 * It means that `vhost` needs to be a suffix of `hostname` and we then need to
 * make sure that: either they are equal, or the character preceding `vhost` in
 * `hostname` is a '.' (it should not be a partial label).
 *
 * * hostname = 'not.evil.com' and vhost = 'vil.com'      => not ok
 * * hostname = 'not.evil.com' and vhost = 'evil.com'     => ok
 * * hostname = 'not.evil.com' and vhost = 'not.evil.com' => ok
 */ __turbopack_context__.s([
    "default",
    ()=>getDomain
]);
function shareSameDomainSuffix(hostname, vhost) {
    if (hostname.endsWith(vhost)) {
        return hostname.length === vhost.length || hostname[hostname.length - vhost.length - 1] === '.';
    }
    return false;
}
/**
 * Given a hostname and its public suffix, extract the general domain.
 */ function extractDomainWithSuffix(hostname, publicSuffix) {
    // Locate the index of the last '.' in the part of the `hostname` preceding
    // the public suffix.
    //
    // examples:
    //   1. not.evil.co.uk  => evil.co.uk
    //         ^    ^
    //         |    | start of public suffix
    //         | index of the last dot
    //
    //   2. example.co.uk   => example.co.uk
    //     ^       ^
    //     |       | start of public suffix
    //     |
    //     | (-1) no dot found before the public suffix
    const publicSuffixIndex = hostname.length - publicSuffix.length - 2;
    const lastDotBeforeSuffixIndex = hostname.lastIndexOf('.', publicSuffixIndex);
    // No '.' found, then `hostname` is the general domain (no sub-domain)
    if (lastDotBeforeSuffixIndex === -1) {
        return hostname;
    }
    // Extract the part between the last '.'
    return hostname.slice(lastDotBeforeSuffixIndex + 1);
}
function getDomain(suffix, hostname, options) {
    // Check if `hostname` ends with a member of `validHosts`.
    if (options.validHosts !== null) {
        const validHosts = options.validHosts;
        for (const vhost of validHosts){
            if (/*@__INLINE__*/ shareSameDomainSuffix(hostname, vhost)) {
                return vhost;
            }
        }
    }
    let numberOfLeadingDots = 0;
    if (hostname.startsWith('.')) {
        while(numberOfLeadingDots < hostname.length && hostname[numberOfLeadingDots] === '.'){
            numberOfLeadingDots += 1;
        }
    }
    // If `hostname` is a valid public suffix, then there is no domain to return.
    // Since we already know that `getPublicSuffix` returns a suffix of `hostname`
    // there is no need to perform a string comparison and we only compare the
    // size.
    if (suffix.length === hostname.length - numberOfLeadingDots) {
        return null;
    }
    // To extract the general domain, we start by identifying the public suffix
    // (if any), then consider the domain to be the public suffix with one added
    // level of depth. (e.g.: if hostname is `not.evil.co.uk` and public suffix:
    // `co.uk`, then we take one more level: `evil`, giving the final result:
    // `evil.co.uk`).
    return /*@__INLINE__*/ extractDomainWithSuffix(hostname, suffix);
} //# sourceMappingURL=domain.js.map
}),
"[project]/node_modules/tldts-core/dist/es6/src/domain-without-suffix.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Return the part of domain without suffix.
 *
 * Example: for domain 'foo.com', the result would be 'foo'.
 */ __turbopack_context__.s([
    "default",
    ()=>getDomainWithoutSuffix
]);
function getDomainWithoutSuffix(domain, suffix) {
    // Note: here `domain` and `suffix` cannot have the same length because in
    // this case we set `domain` to `null` instead. It is thus safe to assume
    // that `suffix` is shorter than `domain`.
    return domain.slice(0, -suffix.length - 1);
} //# sourceMappingURL=domain-without-suffix.js.map
}),
"[project]/node_modules/tldts-core/dist/es6/src/extract-hostname.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @param url - URL we want to extract a hostname from.
 * @param urlIsValidHostname - hint from caller; true if `url` is already a valid hostname.
 */ __turbopack_context__.s([
    "default",
    ()=>extractHostname
]);
function extractHostname(url, urlIsValidHostname) {
    let start = 0;
    let end = url.length;
    let hasUpper = false;
    // If url is not already a valid hostname, then try to extract hostname.
    if (!urlIsValidHostname) {
        // Special handling of data URLs
        if (url.startsWith('data:')) {
            return null;
        }
        // Trim leading spaces
        while(start < url.length && url.charCodeAt(start) <= 32){
            start += 1;
        }
        // Trim trailing spaces
        while(end > start + 1 && url.charCodeAt(end - 1) <= 32){
            end -= 1;
        }
        // Skip scheme.
        if (url.charCodeAt(start) === 47 /* '/' */  && url.charCodeAt(start + 1) === 47 /* '/' */ ) {
            start += 2;
        } else {
            const indexOfProtocol = url.indexOf(':/', start);
            if (indexOfProtocol !== -1) {
                // Implement fast-path for common protocols. We expect most protocols
                // should be one of these 4 and thus we will not need to perform the
                // more expansive validity check most of the time.
                const protocolSize = indexOfProtocol - start;
                const c0 = url.charCodeAt(start);
                const c1 = url.charCodeAt(start + 1);
                const c2 = url.charCodeAt(start + 2);
                const c3 = url.charCodeAt(start + 3);
                const c4 = url.charCodeAt(start + 4);
                if (protocolSize === 5 && c0 === 104 /* 'h' */  && c1 === 116 /* 't' */  && c2 === 116 /* 't' */  && c3 === 112 /* 'p' */  && c4 === 115 /* 's' */ ) {
                // https
                } else if (protocolSize === 4 && c0 === 104 /* 'h' */  && c1 === 116 /* 't' */  && c2 === 116 /* 't' */  && c3 === 112 /* 'p' */ ) {
                // http
                } else if (protocolSize === 3 && c0 === 119 /* 'w' */  && c1 === 115 /* 's' */  && c2 === 115 /* 's' */ ) {
                // wss
                } else if (protocolSize === 2 && c0 === 119 /* 'w' */  && c1 === 115 /* 's' */ ) {
                // ws
                } else {
                    // Check that scheme is valid
                    for(let i = start; i < indexOfProtocol; i += 1){
                        const lowerCaseCode = url.charCodeAt(i) | 32;
                        if (!(lowerCaseCode >= 97 && lowerCaseCode <= 122 || lowerCaseCode >= 48 && lowerCaseCode <= 57 || // [0, 9]
                        lowerCaseCode === 46 || // '.'
                        lowerCaseCode === 45 || // '-'
                        lowerCaseCode === 43) // '+'
                        ) {
                            return null;
                        }
                    }
                }
                // Skip 0, 1 or more '/' after ':/'
                start = indexOfProtocol + 2;
                while(url.charCodeAt(start) === 47 /* '/' */ ){
                    start += 1;
                }
            }
        }
        // Detect first occurrence of '/', '?' or '#'. We also keep track of the
        // last occurrence of '@', ']' or ':' to speed-up subsequent parsing of
        // (respectively), identifier, ipv6 or port.
        let indexOfIdentifier = -1;
        let indexOfClosingBracket = -1;
        let indexOfPort = -1;
        for(let i = start; i < end; i += 1){
            const code = url.charCodeAt(i);
            if (code === 35 || // '#'
            code === 47 || // '/'
            code === 63 // '?'
            ) {
                end = i;
                break;
            } else if (code === 64) {
                // '@'
                indexOfIdentifier = i;
            } else if (code === 93) {
                // ']'
                indexOfClosingBracket = i;
            } else if (code === 58) {
                // ':'
                indexOfPort = i;
            } else if (code >= 65 && code <= 90) {
                hasUpper = true;
            }
        }
        // Detect identifier: '@'
        if (indexOfIdentifier !== -1 && indexOfIdentifier > start && indexOfIdentifier < end) {
            start = indexOfIdentifier + 1;
        }
        // Handle ipv6 addresses
        if (url.charCodeAt(start) === 91 /* '[' */ ) {
            if (indexOfClosingBracket !== -1) {
                return url.slice(start + 1, indexOfClosingBracket).toLowerCase();
            }
            return null;
        } else if (indexOfPort !== -1 && indexOfPort > start && indexOfPort < end) {
            // Detect port: ':'
            end = indexOfPort;
        }
    }
    // Trim trailing dots
    while(end > start + 1 && url.charCodeAt(end - 1) === 46 /* '.' */ ){
        end -= 1;
    }
    const hostname = start !== 0 || end !== url.length ? url.slice(start, end) : url;
    if (hasUpper) {
        return hostname.toLowerCase();
    }
    return hostname;
} //# sourceMappingURL=extract-hostname.js.map
}),
"[project]/node_modules/tldts-core/dist/es6/src/is-ip.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Check if a hostname is an IP. You should be aware that this only works
 * because `hostname` is already garanteed to be a valid hostname!
 */ __turbopack_context__.s([
    "default",
    ()=>isIp
]);
function isProbablyIpv4(hostname) {
    // Cannot be shorted than 1.1.1.1
    if (hostname.length < 7) {
        return false;
    }
    // Cannot be longer than: 255.255.255.255
    if (hostname.length > 15) {
        return false;
    }
    let numberOfDots = 0;
    for(let i = 0; i < hostname.length; i += 1){
        const code = hostname.charCodeAt(i);
        if (code === 46 /* '.' */ ) {
            numberOfDots += 1;
        } else if (code < 48 /* '0' */  || code > 57 /* '9' */ ) {
            return false;
        }
    }
    return numberOfDots === 3 && hostname.charCodeAt(0) !== 46 /* '.' */  && hostname.charCodeAt(hostname.length - 1) !== 46 /* '.' */ ;
}
/**
 * Similar to isProbablyIpv4.
 */ function isProbablyIpv6(hostname) {
    if (hostname.length < 3) {
        return false;
    }
    let start = hostname.startsWith('[') ? 1 : 0;
    let end = hostname.length;
    if (hostname[end - 1] === ']') {
        end -= 1;
    }
    // We only consider the maximum size of a normal IPV6. Note that this will
    // fail on so-called "IPv4 mapped IPv6 addresses" but this is a corner-case
    // and a proper validation library should be used for these.
    if (end - start > 39) {
        return false;
    }
    let hasColon = false;
    for(; start < end; start += 1){
        const code = hostname.charCodeAt(start);
        if (code === 58 /* ':' */ ) {
            hasColon = true;
        } else if (!(code >= 48 && code <= 57 || code >= 97 && code <= 102 || code >= 65 && code <= 90) // A-F
        ) {
            return false;
        }
    }
    return hasColon;
}
function isIp(hostname) {
    return isProbablyIpv6(hostname) || isProbablyIpv4(hostname);
} //# sourceMappingURL=is-ip.js.map
}),
"[project]/node_modules/tldts-core/dist/es6/src/is-valid.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Implements fast shallow verification of hostnames. This does not perform a
 * struct check on the content of labels (classes of Unicode characters, etc.)
 * but instead check that the structure is valid (number of labels, length of
 * labels, etc.).
 *
 * If you need stricter validation, consider using an external library.
 */ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
function isValidAscii(code) {
    return code >= 97 && code <= 122 || code >= 48 && code <= 57 || code > 127;
}
function __TURBOPACK__default__export__(hostname) {
    if (hostname.length > 255) {
        return false;
    }
    if (hostname.length === 0) {
        return false;
    }
    if (/*@__INLINE__*/ !isValidAscii(hostname.charCodeAt(0)) && hostname.charCodeAt(0) !== 46 && // '.' (dot)
    hostname.charCodeAt(0) !== 95 // '_' (underscore)
    ) {
        return false;
    }
    // Validate hostname according to RFC
    let lastDotIndex = -1;
    let lastCharCode = -1;
    const len = hostname.length;
    for(let i = 0; i < len; i += 1){
        const code = hostname.charCodeAt(i);
        if (code === 46 /* '.' */ ) {
            if (// Check that previous label is < 63 bytes long (64 = 63 + '.')
            i - lastDotIndex > 64 || // Check that previous character was not already a '.'
            lastCharCode === 46 || // Check that the previous label does not end with a '-' (dash)
            lastCharCode === 45 || // Check that the previous label does not end with a '_' (underscore)
            lastCharCode === 95) {
                return false;
            }
            lastDotIndex = i;
        } else if (!/*@__INLINE__*/ (isValidAscii(code) || code === 45 || code === 95)) {
            // Check if there is a forbidden character in the label
            return false;
        }
        lastCharCode = code;
    }
    return(// Check that last label is shorter than 63 chars
    len - lastDotIndex - 1 <= 63 && // Check that the last character is an allowed trailing label character.
    // Since we already checked that the char is a valid hostname character,
    // we only need to check that it's different from '-'.
    lastCharCode !== 45);
} //# sourceMappingURL=is-valid.js.map
}),
"[project]/node_modules/tldts-core/dist/es6/src/options.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "setDefaults",
    ()=>setDefaults
]);
function setDefaultsImpl({ allowIcannDomains = true, allowPrivateDomains = false, detectIp = true, extractHostname = true, mixedInputs = true, validHosts = null, validateHostname = true }) {
    return {
        allowIcannDomains,
        allowPrivateDomains,
        detectIp,
        extractHostname,
        mixedInputs,
        validHosts,
        validateHostname
    };
}
const DEFAULT_OPTIONS = /*@__INLINE__*/ setDefaultsImpl({});
function setDefaults(options) {
    if (options === undefined) {
        return DEFAULT_OPTIONS;
    }
    return /*@__INLINE__*/ setDefaultsImpl(options);
} //# sourceMappingURL=options.js.map
}),
"[project]/node_modules/tldts-core/dist/es6/src/subdomain.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Returns the subdomain of a hostname string
 */ __turbopack_context__.s([
    "default",
    ()=>getSubdomain
]);
function getSubdomain(hostname, domain) {
    // If `hostname` and `domain` are the same, then there is no sub-domain
    if (domain.length === hostname.length) {
        return '';
    }
    return hostname.slice(0, -domain.length - 1);
} //# sourceMappingURL=subdomain.js.map
}),
"[project]/node_modules/tldts-core/dist/es6/src/factory.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Implement a factory allowing to plug different implementations of suffix
 * lookup (e.g.: using a trie or the packed hashes datastructures). This is used
 * and exposed in `tldts.ts` and `tldts-experimental.ts` bundle entrypoints.
 */ __turbopack_context__.s([
    "getEmptyResult",
    ()=>getEmptyResult,
    "parseImpl",
    ()=>parseImpl,
    "resetResult",
    ()=>resetResult
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$domain$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tldts-core/dist/es6/src/domain.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$domain$2d$without$2d$suffix$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tldts-core/dist/es6/src/domain-without-suffix.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$extract$2d$hostname$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tldts-core/dist/es6/src/extract-hostname.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$is$2d$ip$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tldts-core/dist/es6/src/is-ip.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$is$2d$valid$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tldts-core/dist/es6/src/is-valid.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$options$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tldts-core/dist/es6/src/options.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$subdomain$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tldts-core/dist/es6/src/subdomain.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
function getEmptyResult() {
    return {
        domain: null,
        domainWithoutSuffix: null,
        hostname: null,
        isIcann: null,
        isIp: null,
        isPrivate: null,
        publicSuffix: null,
        subdomain: null
    };
}
function resetResult(result) {
    result.domain = null;
    result.domainWithoutSuffix = null;
    result.hostname = null;
    result.isIcann = null;
    result.isIp = null;
    result.isPrivate = null;
    result.publicSuffix = null;
    result.subdomain = null;
}
function parseImpl(url, step, suffixLookup, partialOptions, result) {
    const options = /*@__INLINE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$options$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setDefaults"])(partialOptions);
    // Very fast approximate check to make sure `url` is a string. This is needed
    // because the library will not necessarily be used in a typed setup and
    // values of arbitrary types might be given as argument.
    if (typeof url !== 'string') {
        return result;
    }
    // Extract hostname from `url` only if needed. This can be made optional
    // using `options.extractHostname`. This option will typically be used
    // whenever we are sure the inputs to `parse` are already hostnames and not
    // arbitrary URLs.
    //
    // `mixedInput` allows to specify if we expect a mix of URLs and hostnames
    // as input. If only hostnames are expected then `extractHostname` can be
    // set to `false` to speed-up parsing. If only URLs are expected then
    // `mixedInputs` can be set to `false`. The `mixedInputs` is only a hint
    // and will not change the behavior of the library.
    if (!options.extractHostname) {
        result.hostname = url;
    } else if (options.mixedInputs) {
        result.hostname = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$extract$2d$hostname$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(url, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$is$2d$valid$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(url));
    } else {
        result.hostname = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$extract$2d$hostname$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(url, false);
    }
    // Check if `hostname` is a valid ip address
    if (options.detectIp && result.hostname !== null) {
        result.isIp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$is$2d$ip$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(result.hostname);
        if (result.isIp) {
            return result;
        }
    }
    // Perform hostname validation if enabled. If hostname is not valid, no need to
    // go further as there will be no valid domain or sub-domain. This validation
    // is applied before any early returns to ensure consistent behavior across
    // all API methods including getHostname().
    if (options.validateHostname && options.extractHostname && result.hostname !== null && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$is$2d$valid$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(result.hostname)) {
        result.hostname = null;
        return result;
    }
    if (step === 0 /* FLAG.HOSTNAME */  || result.hostname === null) {
        return result;
    }
    // Extract public suffix
    suffixLookup(result.hostname, options, result);
    if (step === 2 /* FLAG.PUBLIC_SUFFIX */  || result.publicSuffix === null) {
        return result;
    }
    // Extract domain
    result.domain = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$domain$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(result.publicSuffix, result.hostname, options);
    if (step === 3 /* FLAG.DOMAIN */  || result.domain === null) {
        return result;
    }
    // Extract subdomain
    result.subdomain = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$subdomain$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(result.hostname, result.domain);
    if (step === 4 /* FLAG.SUB_DOMAIN */ ) {
        return result;
    }
    // Extract domain without suffix
    result.domainWithoutSuffix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$domain$2d$without$2d$suffix$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(result.domain, result.publicSuffix);
    return result;
} //# sourceMappingURL=factory.js.map
}),
"[project]/node_modules/tldts-core/dist/es6/src/lookup/fast-path.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
function __TURBOPACK__default__export__(hostname, options, out) {
    // Fast path for very popular suffixes; this allows to by-pass lookup
    // completely as well as any extra allocation or string manipulation.
    if (!options.allowPrivateDomains && hostname.length > 3) {
        const last = hostname.length - 1;
        const c3 = hostname.charCodeAt(last);
        const c2 = hostname.charCodeAt(last - 1);
        const c1 = hostname.charCodeAt(last - 2);
        const c0 = hostname.charCodeAt(last - 3);
        if (c3 === 109 /* 'm' */  && c2 === 111 /* 'o' */  && c1 === 99 /* 'c' */  && c0 === 46 /* '.' */ ) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'com';
            return true;
        } else if (c3 === 103 /* 'g' */  && c2 === 114 /* 'r' */  && c1 === 111 /* 'o' */  && c0 === 46 /* '.' */ ) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'org';
            return true;
        } else if (c3 === 117 /* 'u' */  && c2 === 100 /* 'd' */  && c1 === 101 /* 'e' */  && c0 === 46 /* '.' */ ) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'edu';
            return true;
        } else if (c3 === 118 /* 'v' */  && c2 === 111 /* 'o' */  && c1 === 103 /* 'g' */  && c0 === 46 /* '.' */ ) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'gov';
            return true;
        } else if (c3 === 116 /* 't' */  && c2 === 101 /* 'e' */  && c1 === 110 /* 'n' */  && c0 === 46 /* '.' */ ) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'net';
            return true;
        } else if (c3 === 101 /* 'e' */  && c2 === 100 /* 'd' */  && c1 === 46 /* '.' */ ) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'de';
            return true;
        }
    }
    return false;
} //# sourceMappingURL=fast-path.js.map
}),
"[project]/node_modules/tldts-core/dist/es6/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$factory$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tldts-core/dist/es6/src/factory.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$lookup$2f$fast$2d$path$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tldts-core/dist/es6/src/lookup/fast-path.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$options$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tldts-core/dist/es6/src/options.js [app-route] (ecmascript)"); //# sourceMappingURL=index.js.map
;
;
;
}),
"[project]/node_modules/tldts-core/dist/es6/src/lookup/fast-path.js [app-route] (ecmascript) <export default as fastPathLookup>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fastPathLookup",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$lookup$2f$fast$2d$path$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tldts$2d$core$2f$dist$2f$es6$2f$src$2f$lookup$2f$fast$2d$path$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tldts-core/dist/es6/src/lookup/fast-path.js [app-route] (ecmascript)");
}),
"[project]/node_modules/tough-cookie/dist/index.cjs [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// lib/cookie/index.ts
var index_exports = {};
__export(index_exports, {
    Cookie: ()=>Cookie,
    CookieJar: ()=>CookieJar,
    MemoryCookieStore: ()=>MemoryCookieStore,
    ParameterError: ()=>ParameterError,
    PrefixSecurityEnum: ()=>PrefixSecurityEnum,
    Store: ()=>Store,
    canonicalDomain: ()=>canonicalDomain,
    cookieCompare: ()=>cookieCompare,
    defaultPath: ()=>defaultPath,
    domainMatch: ()=>domainMatch,
    formatDate: ()=>formatDate,
    fromJSON: ()=>fromJSON2,
    getPublicSuffix: ()=>getPublicSuffix,
    parse: ()=>parse2,
    parseDate: ()=>parseDate,
    pathMatch: ()=>pathMatch,
    permuteDomain: ()=>permuteDomain,
    permutePath: ()=>permutePath,
    version: ()=>version
});
module.exports = __toCommonJS(index_exports);
// lib/pathMatch.ts
function pathMatch(reqPath, cookiePath) {
    if (cookiePath === reqPath) {
        return true;
    }
    const idx = reqPath.indexOf(cookiePath);
    if (idx === 0) {
        if (cookiePath[cookiePath.length - 1] === "/") {
            return true;
        }
        if (reqPath.startsWith(cookiePath) && reqPath[cookiePath.length] === "/") {
            return true;
        }
    }
    return false;
}
// lib/getPublicSuffix.ts
var import_tldts = __turbopack_context__.r("[project]/node_modules/tldts/dist/es6/index.js [app-route] (ecmascript)");
var SPECIAL_USE_DOMAINS = [
    "local",
    "example",
    "invalid",
    "localhost",
    "test"
];
var SPECIAL_TREATMENT_DOMAINS = [
    "localhost",
    "invalid"
];
var defaultGetPublicSuffixOptions = {
    allowSpecialUseDomain: false,
    ignoreError: false
};
function getPublicSuffix(domain, options = {}) {
    options = {
        ...defaultGetPublicSuffixOptions,
        ...options
    };
    const domainParts = domain.split(".");
    const topLevelDomain = domainParts[domainParts.length - 1];
    const allowSpecialUseDomain = !!options.allowSpecialUseDomain;
    const ignoreError = !!options.ignoreError;
    if (allowSpecialUseDomain && topLevelDomain !== void 0 && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
        if (domainParts.length > 1) {
            const secondLevelDomain = domainParts[domainParts.length - 2];
            return `${secondLevelDomain}.${topLevelDomain}`;
        } else if (SPECIAL_TREATMENT_DOMAINS.includes(topLevelDomain)) {
            return topLevelDomain;
        }
    }
    if (!ignoreError && topLevelDomain !== void 0 && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
        throw new Error(`Cookie has domain set to the public suffix "${topLevelDomain}" which is a special use domain. To allow this, configure your CookieJar with {allowSpecialUseDomain: true, rejectPublicSuffixes: false}.`);
    }
    const publicSuffix = (0, import_tldts.getDomain)(domain, {
        allowIcannDomains: true,
        allowPrivateDomains: true
    });
    if (publicSuffix) return publicSuffix;
}
// lib/permuteDomain.ts
function permuteDomain(domain, allowSpecialUseDomain) {
    const pubSuf = getPublicSuffix(domain, {
        allowSpecialUseDomain
    });
    if (!pubSuf) {
        return void 0;
    }
    if (pubSuf == domain) {
        return [
            domain
        ];
    }
    if (domain.slice(-1) == ".") {
        domain = domain.slice(0, -1);
    }
    const prefix = domain.slice(0, -(pubSuf.length + 1));
    const parts = prefix.split(".").reverse();
    let cur = pubSuf;
    const permutations = [
        cur
    ];
    while(parts.length){
        const part = parts.shift();
        cur = `${part}.${cur}`;
        permutations.push(cur);
    }
    return permutations;
}
// lib/store.ts
var Store = class {
    constructor(){
        this.synchronous = false;
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ findCookie(_domain, _path, _key, _callback) {
        throw new Error("findCookie is not implemented");
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ findCookies(_domain, _path, _allowSpecialUseDomain = false, _callback) {
        throw new Error("findCookies is not implemented");
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ putCookie(_cookie, _callback) {
        throw new Error("putCookie is not implemented");
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ updateCookie(_oldCookie, _newCookie, _callback) {
        throw new Error("updateCookie is not implemented");
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ removeCookie(_domain, _path, _key, _callback) {
        throw new Error("removeCookie is not implemented");
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ removeCookies(_domain, _path, _callback) {
        throw new Error("removeCookies is not implemented");
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ removeAllCookies(_callback) {
        throw new Error("removeAllCookies is not implemented");
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ getAllCookies(_callback) {
        throw new Error("getAllCookies is not implemented (therefore jar cannot be serialized)");
    }
};
// lib/utils.ts
var objectToString = (obj)=>Object.prototype.toString.call(obj);
var safeArrayToString = (arr, seenArrays)=>{
    if (typeof arr.join !== "function") return objectToString(arr);
    seenArrays.add(arr);
    const mapped = arr.map((val)=>val === null || val === void 0 || seenArrays.has(val) ? "" : safeToStringImpl(val, seenArrays));
    return mapped.join();
};
var safeToStringImpl = (val, seenArrays = /* @__PURE__ */ new WeakSet())=>{
    if (typeof val !== "object" || val === null) {
        return String(val);
    } else if (typeof val.toString === "function") {
        return Array.isArray(val) ? // Arrays have a weird custom toString that we need to replicate
        safeArrayToString(val, seenArrays) : // eslint-disable-next-line @typescript-eslint/no-base-to-string
        String(val);
    } else {
        return objectToString(val);
    }
};
var safeToString = (val)=>safeToStringImpl(val);
function createPromiseCallback(cb) {
    let callback;
    let resolve;
    let reject;
    const promise = new Promise((_resolve, _reject)=>{
        resolve = _resolve;
        reject = _reject;
    });
    if (typeof cb === "function") {
        callback = (err, result)=>{
            try {
                if (err) cb(err);
                else cb(null, result);
            } catch (e) {
                reject(e instanceof Error ? e : new Error());
            }
        };
    } else {
        callback = (err, result)=>{
            try {
                if (err) reject(err);
                else resolve(result);
            } catch (e) {
                reject(e instanceof Error ? e : new Error());
            }
        };
    }
    return {
        promise,
        callback,
        resolve: (value)=>{
            callback(null, value);
            return promise;
        },
        reject: (error)=>{
            callback(error);
            return promise;
        }
    };
}
function inOperator(k, o) {
    return k in o;
}
// lib/memstore.ts
var MemoryCookieStore = class extends Store {
    /**
   * Create a new {@link MemoryCookieStore}.
   */ constructor(){
        super();
        this.synchronous = true;
        this.idx = /* @__PURE__ */ Object.create(null);
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ findCookie(domain, path, key, callback) {
        const promiseCallback = createPromiseCallback(callback);
        if (domain == null || path == null || key == null) {
            return promiseCallback.resolve(void 0);
        }
        const result = this.idx[domain]?.[path]?.[key];
        return promiseCallback.resolve(result);
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ findCookies(domain, path, allowSpecialUseDomain = false, callback) {
        if (typeof allowSpecialUseDomain === "function") {
            callback = allowSpecialUseDomain;
            allowSpecialUseDomain = true;
        }
        const results = [];
        const promiseCallback = createPromiseCallback(callback);
        if (!domain) {
            return promiseCallback.resolve([]);
        }
        let pathMatcher;
        if (!path) {
            pathMatcher = function matchAll(domainIndex) {
                for(const curPath in domainIndex){
                    const pathIndex = domainIndex[curPath];
                    for(const key in pathIndex){
                        const value = pathIndex[key];
                        if (value) {
                            results.push(value);
                        }
                    }
                }
            };
        } else {
            pathMatcher = function matchRFC(domainIndex) {
                for(const cookiePath in domainIndex){
                    if (pathMatch(path, cookiePath)) {
                        const pathIndex = domainIndex[cookiePath];
                        for(const key in pathIndex){
                            const value = pathIndex[key];
                            if (value) {
                                results.push(value);
                            }
                        }
                    }
                }
            };
        }
        const domains = permuteDomain(domain, allowSpecialUseDomain) || [
            domain
        ];
        const idx = this.idx;
        domains.forEach((curDomain)=>{
            const domainIndex = idx[curDomain];
            if (!domainIndex) {
                return;
            }
            pathMatcher(domainIndex);
        });
        return promiseCallback.resolve(results);
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ putCookie(cookie, callback) {
        const promiseCallback = createPromiseCallback(callback);
        const { domain, path, key } = cookie;
        if (domain == null || path == null || key == null) {
            return promiseCallback.resolve(void 0);
        }
        const domainEntry = this.idx[domain] ?? /* @__PURE__ */ Object.create(null);
        this.idx[domain] = domainEntry;
        const pathEntry = domainEntry[path] ?? /* @__PURE__ */ Object.create(null);
        domainEntry[path] = pathEntry;
        pathEntry[key] = cookie;
        return promiseCallback.resolve(void 0);
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ updateCookie(_oldCookie, newCookie, callback) {
        if (callback) this.putCookie(newCookie, callback);
        else return this.putCookie(newCookie);
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ removeCookie(domain, path, key, callback) {
        const promiseCallback = createPromiseCallback(callback);
        delete this.idx[domain]?.[path]?.[key];
        return promiseCallback.resolve(void 0);
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ removeCookies(domain, path, callback) {
        const promiseCallback = createPromiseCallback(callback);
        const domainEntry = this.idx[domain];
        if (domainEntry) {
            if (path) {
                delete domainEntry[path];
            } else {
                delete this.idx[domain];
            }
        }
        return promiseCallback.resolve(void 0);
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ removeAllCookies(callback) {
        const promiseCallback = createPromiseCallback(callback);
        this.idx = /* @__PURE__ */ Object.create(null);
        return promiseCallback.resolve(void 0);
    }
    /**
   * @internal No doc because this is an overload that supports the implementation
   */ getAllCookies(callback) {
        const promiseCallback = createPromiseCallback(callback);
        const cookies = [];
        const idx = this.idx;
        const domains = Object.keys(idx);
        domains.forEach((domain)=>{
            const domainEntry = idx[domain] ?? {};
            const paths = Object.keys(domainEntry);
            paths.forEach((path)=>{
                const pathEntry = domainEntry[path] ?? {};
                const keys = Object.keys(pathEntry);
                keys.forEach((key)=>{
                    const keyEntry = pathEntry[key];
                    if (keyEntry != null) {
                        cookies.push(keyEntry);
                    }
                });
            });
        });
        cookies.sort((a, b)=>{
            return (a.creationIndex || 0) - (b.creationIndex || 0);
        });
        return promiseCallback.resolve(cookies);
    }
};
// lib/validators.ts
function isNonEmptyString(data) {
    return isString(data) && data !== "";
}
function isEmptyString(data) {
    return data === "" || data instanceof String && data.toString() === "";
}
function isString(data) {
    return typeof data === "string" || data instanceof String;
}
function isObject(data) {
    return objectToString(data) === "[object Object]";
}
function validate(bool, cbOrMessage, message) {
    if (bool) return;
    const cb = typeof cbOrMessage === "function" ? cbOrMessage : void 0;
    let options = typeof cbOrMessage === "function" ? message : cbOrMessage;
    if (!isObject(options)) options = "[object Object]";
    const err = new ParameterError(safeToString(options));
    if (cb) cb(err);
    else throw err;
}
var ParameterError = class extends Error {
};
// lib/version.ts
var version = "6.0.0";
// lib/cookie/constants.ts
var PrefixSecurityEnum = {
    SILENT: "silent",
    STRICT: "strict",
    DISABLED: "unsafe-disabled"
};
Object.freeze(PrefixSecurityEnum);
var IP_V6_REGEX = `
\\[?(?:
(?:[a-fA-F\\d]{1,4}:){7}(?:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,2}|:)|
(?:[a-fA-F\\d]{1,4}:){4}(?:(?::[a-fA-F\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,3}|:)|
(?:[a-fA-F\\d]{1,4}:){3}(?:(?::[a-fA-F\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){2}(?:(?::[a-fA-F\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,5}|:)|
(?:[a-fA-F\\d]{1,4}:){1}(?:(?::[a-fA-F\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,6}|:)|
(?::(?:(?::[a-fA-F\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,7}|:))
)(?:%[0-9a-zA-Z]{1,})?\\]?
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
var IP_V6_REGEX_OBJECT = new RegExp(`^${IP_V6_REGEX}$`);
var IP_V4_REGEX = `(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])`;
var IP_V4_REGEX_OBJECT = new RegExp(`^${IP_V4_REGEX}$`);
// lib/cookie/canonicalDomain.ts
function domainToASCII(domain) {
    return new URL(`http://${domain}`).hostname;
}
function canonicalDomain(domainName) {
    if (domainName == null) {
        return void 0;
    }
    let str = domainName.trim().replace(/^\./, "");
    if (IP_V6_REGEX_OBJECT.test(str)) {
        if (!str.startsWith("[")) {
            str = "[" + str;
        }
        if (!str.endsWith("]")) {
            str = str + "]";
        }
        return domainToASCII(str).slice(1, -1);
    }
    if (/[^\u0001-\u007f]/.test(str)) {
        return domainToASCII(str);
    }
    return str.toLowerCase();
}
// lib/cookie/formatDate.ts
function formatDate(date) {
    return date.toUTCString();
}
// lib/cookie/parseDate.ts
var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;
var MONTH_TO_NUM = {
    jan: 0,
    feb: 1,
    mar: 2,
    apr: 3,
    may: 4,
    jun: 5,
    jul: 6,
    aug: 7,
    sep: 8,
    oct: 9,
    nov: 10,
    dec: 11
};
function parseDigits(token, minDigits, maxDigits, trailingOK) {
    let count = 0;
    while(count < token.length){
        const c = token.charCodeAt(count);
        if (c <= 47 || c >= 58) {
            break;
        }
        count++;
    }
    if (count < minDigits || count > maxDigits) {
        return;
    }
    if (!trailingOK && count != token.length) {
        return;
    }
    return parseInt(token.slice(0, count), 10);
}
function parseTime(token) {
    const parts = token.split(":");
    const result = [
        0,
        0,
        0
    ];
    if (parts.length !== 3) {
        return;
    }
    for(let i = 0; i < 3; i++){
        const trailingOK = i == 2;
        const numPart = parts[i];
        if (numPart === void 0) {
            return;
        }
        const num = parseDigits(numPart, 1, 2, trailingOK);
        if (num === void 0) {
            return;
        }
        result[i] = num;
    }
    return result;
}
function parseMonth(token) {
    token = String(token).slice(0, 3).toLowerCase();
    switch(token){
        case "jan":
            return MONTH_TO_NUM.jan;
        case "feb":
            return MONTH_TO_NUM.feb;
        case "mar":
            return MONTH_TO_NUM.mar;
        case "apr":
            return MONTH_TO_NUM.apr;
        case "may":
            return MONTH_TO_NUM.may;
        case "jun":
            return MONTH_TO_NUM.jun;
        case "jul":
            return MONTH_TO_NUM.jul;
        case "aug":
            return MONTH_TO_NUM.aug;
        case "sep":
            return MONTH_TO_NUM.sep;
        case "oct":
            return MONTH_TO_NUM.oct;
        case "nov":
            return MONTH_TO_NUM.nov;
        case "dec":
            return MONTH_TO_NUM.dec;
        default:
            return;
    }
}
function parseDate(cookieDate) {
    if (!cookieDate) {
        return;
    }
    const tokens = cookieDate.split(DATE_DELIM);
    let hour;
    let minute;
    let second;
    let dayOfMonth;
    let month;
    let year;
    for(let i = 0; i < tokens.length; i++){
        const token = (tokens[i] ?? "").trim();
        if (!token.length) {
            continue;
        }
        if (second === void 0) {
            const result = parseTime(token);
            if (result) {
                hour = result[0];
                minute = result[1];
                second = result[2];
                continue;
            }
        }
        if (dayOfMonth === void 0) {
            const result = parseDigits(token, 1, 2, true);
            if (result !== void 0) {
                dayOfMonth = result;
                continue;
            }
        }
        if (month === void 0) {
            const result = parseMonth(token);
            if (result !== void 0) {
                month = result;
                continue;
            }
        }
        if (year === void 0) {
            const result = parseDigits(token, 2, 4, true);
            if (result !== void 0) {
                year = result;
                if (year >= 70 && year <= 99) {
                    year += 1900;
                } else if (year >= 0 && year <= 69) {
                    year += 2e3;
                }
            }
        }
    }
    if (dayOfMonth === void 0 || month === void 0 || year === void 0 || hour === void 0 || minute === void 0 || second === void 0 || dayOfMonth < 1 || dayOfMonth > 31 || year < 1601 || hour > 23 || minute > 59 || second > 59) {
        return;
    }
    return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
}
// lib/cookie/cookie.ts
var COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;
var PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;
var CONTROL_CHARS = /[\x00-\x1F]/;
var TERMINATORS = [
    "\n",
    "\r",
    "\0"
];
function trimTerminator(str) {
    if (isEmptyString(str)) return str;
    for(let t = 0; t < TERMINATORS.length; t++){
        const terminator = TERMINATORS[t];
        const terminatorIdx = terminator ? str.indexOf(terminator) : -1;
        if (terminatorIdx !== -1) {
            str = str.slice(0, terminatorIdx);
        }
    }
    return str;
}
function parseCookiePair(cookiePair, looseMode) {
    cookiePair = trimTerminator(cookiePair);
    let firstEq = cookiePair.indexOf("=");
    if (looseMode) {
        if (firstEq === 0) {
            cookiePair = cookiePair.substring(1);
            firstEq = cookiePair.indexOf("=");
        }
    } else {
        if (firstEq <= 0) {
            return void 0;
        }
    }
    let cookieName, cookieValue;
    if (firstEq <= 0) {
        cookieName = "";
        cookieValue = cookiePair.trim();
    } else {
        cookieName = cookiePair.slice(0, firstEq).trim();
        cookieValue = cookiePair.slice(firstEq + 1).trim();
    }
    if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
        return void 0;
    }
    const c = new Cookie();
    c.key = cookieName;
    c.value = cookieValue;
    return c;
}
function parse(str, options) {
    if (isEmptyString(str) || !isString(str)) {
        return void 0;
    }
    str = str.trim();
    const firstSemi = str.indexOf(";");
    const cookiePair = firstSemi === -1 ? str : str.slice(0, firstSemi);
    const c = parseCookiePair(cookiePair, options?.loose ?? false);
    if (!c) {
        return void 0;
    }
    if (firstSemi === -1) {
        return c;
    }
    const unparsed = str.slice(firstSemi + 1).trim();
    if (unparsed.length === 0) {
        return c;
    }
    const cookie_avs = unparsed.split(";");
    while(cookie_avs.length){
        const av = (cookie_avs.shift() ?? "").trim();
        if (av.length === 0) {
            continue;
        }
        const av_sep = av.indexOf("=");
        let av_key, av_value;
        if (av_sep === -1) {
            av_key = av;
            av_value = null;
        } else {
            av_key = av.slice(0, av_sep);
            av_value = av.slice(av_sep + 1);
        }
        av_key = av_key.trim().toLowerCase();
        if (av_value) {
            av_value = av_value.trim();
        }
        switch(av_key){
            case "expires":
                if (av_value) {
                    const exp = parseDate(av_value);
                    if (exp) {
                        c.expires = exp;
                    }
                }
                break;
            case "max-age":
                if (av_value) {
                    if (/^-?[0-9]+$/.test(av_value)) {
                        const delta = parseInt(av_value, 10);
                        c.setMaxAge(delta);
                    }
                }
                break;
            case "domain":
                if (av_value) {
                    const domain = av_value.trim().replace(/^\./, "");
                    if (domain) {
                        c.domain = domain.toLowerCase();
                    }
                }
                break;
            case "path":
                c.path = av_value && av_value[0] === "/" ? av_value : null;
                break;
            case "secure":
                c.secure = true;
                break;
            case "httponly":
                c.httpOnly = true;
                break;
            case "samesite":
                switch(av_value ? av_value.toLowerCase() : ""){
                    case "strict":
                        c.sameSite = "strict";
                        break;
                    case "lax":
                        c.sameSite = "lax";
                        break;
                    case "none":
                        c.sameSite = "none";
                        break;
                    default:
                        c.sameSite = void 0;
                        break;
                }
                break;
            default:
                c.extensions = c.extensions || [];
                c.extensions.push(av);
                break;
        }
    }
    return c;
}
function fromJSON(str) {
    if (!str || isEmptyString(str)) {
        return void 0;
    }
    let obj;
    if (typeof str === "string") {
        try {
            obj = JSON.parse(str);
        } catch  {
            return void 0;
        }
    } else {
        obj = str;
    }
    const c = new Cookie();
    Cookie.serializableProperties.forEach((prop)=>{
        if (obj && typeof obj === "object" && inOperator(prop, obj)) {
            const val = obj[prop];
            if (val === void 0) {
                return;
            }
            if (inOperator(prop, cookieDefaults) && val === cookieDefaults[prop]) {
                return;
            }
            switch(prop){
                case "key":
                case "value":
                case "sameSite":
                    if (typeof val === "string") {
                        c[prop] = val;
                    }
                    break;
                case "expires":
                case "creation":
                case "lastAccessed":
                    if (typeof val === "number" || typeof val === "string" || val instanceof Date) {
                        c[prop] = obj[prop] == "Infinity" ? "Infinity" : new Date(val);
                    } else if (val === null) {
                        c[prop] = null;
                    }
                    break;
                case "maxAge":
                    if (typeof val === "number" || val === "Infinity" || val === "-Infinity") {
                        c[prop] = val;
                    }
                    break;
                case "domain":
                case "path":
                    if (typeof val === "string" || val === null) {
                        c[prop] = val;
                    }
                    break;
                case "secure":
                case "httpOnly":
                    if (typeof val === "boolean") {
                        c[prop] = val;
                    }
                    break;
                case "extensions":
                    if (Array.isArray(val) && val.every((item)=>typeof item === "string")) {
                        c[prop] = val;
                    }
                    break;
                case "hostOnly":
                case "pathIsDefault":
                    if (typeof val === "boolean" || val === null) {
                        c[prop] = val;
                    }
                    break;
            }
        }
    });
    return c;
}
var cookieDefaults = {
    // the order in which the RFC has them:
    key: "",
    value: "",
    expires: "Infinity",
    maxAge: null,
    domain: null,
    path: null,
    secure: false,
    httpOnly: false,
    extensions: null,
    // set by the CookieJar:
    hostOnly: null,
    pathIsDefault: null,
    creation: null,
    lastAccessed: null,
    sameSite: void 0
};
var _Cookie = class _Cookie {
    /**
   * Create a new Cookie instance.
   * @public
   * @param options - The attributes to set on the cookie
   */ constructor(options = {}){
        this.key = options.key ?? cookieDefaults.key;
        this.value = options.value ?? cookieDefaults.value;
        this.expires = options.expires ?? cookieDefaults.expires;
        this.maxAge = options.maxAge ?? cookieDefaults.maxAge;
        this.domain = options.domain ?? cookieDefaults.domain;
        this.path = options.path ?? cookieDefaults.path;
        this.secure = options.secure ?? cookieDefaults.secure;
        this.httpOnly = options.httpOnly ?? cookieDefaults.httpOnly;
        this.extensions = options.extensions ?? cookieDefaults.extensions;
        this.creation = options.creation ?? cookieDefaults.creation;
        this.hostOnly = options.hostOnly ?? cookieDefaults.hostOnly;
        this.pathIsDefault = options.pathIsDefault ?? cookieDefaults.pathIsDefault;
        this.lastAccessed = options.lastAccessed ?? cookieDefaults.lastAccessed;
        this.sameSite = options.sameSite ?? cookieDefaults.sameSite;
        this.creation = options.creation ?? /* @__PURE__ */ new Date();
        Object.defineProperty(this, "creationIndex", {
            configurable: false,
            enumerable: false,
            // important for assert.deepEqual checks
            writable: true,
            value: ++_Cookie.cookiesCreated
        });
        this.creationIndex = _Cookie.cookiesCreated;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
        const now = Date.now();
        const hostOnly = this.hostOnly != null ? this.hostOnly.toString() : "?";
        const createAge = this.creation && this.creation !== "Infinity" ? `${String(now - this.creation.getTime())}ms` : "?";
        const accessAge = this.lastAccessed && this.lastAccessed !== "Infinity" ? `${String(now - this.lastAccessed.getTime())}ms` : "?";
        return `Cookie="${this.toString()}; hostOnly=${hostOnly}; aAge=${accessAge}; cAge=${createAge}"`;
    }
    /**
   * For convenience in using `JSON.stringify(cookie)`. Returns a plain-old Object that can be JSON-serialized.
   *
   * @remarks
   * - Any `Date` properties (such as {@link Cookie.expires}, {@link Cookie.creation}, and {@link Cookie.lastAccessed}) are exported in ISO format (`Date.toISOString()`).
   *
   *  - Custom Cookie properties are discarded. In tough-cookie 1.x, since there was no {@link Cookie.toJSON} method explicitly defined, all enumerable properties were captured.
   *      If you want a property to be serialized, add the property name to {@link Cookie.serializableProperties}.
   */ toJSON() {
        const obj = {};
        for (const prop of _Cookie.serializableProperties){
            const val = this[prop];
            if (val === cookieDefaults[prop]) {
                continue;
            }
            switch(prop){
                case "key":
                case "value":
                case "sameSite":
                    if (typeof val === "string") {
                        obj[prop] = val;
                    }
                    break;
                case "expires":
                case "creation":
                case "lastAccessed":
                    if (typeof val === "number" || typeof val === "string" || val instanceof Date) {
                        obj[prop] = val == "Infinity" ? "Infinity" : new Date(val).toISOString();
                    } else if (val === null) {
                        obj[prop] = null;
                    }
                    break;
                case "maxAge":
                    if (typeof val === "number" || val === "Infinity" || val === "-Infinity") {
                        obj[prop] = val;
                    }
                    break;
                case "domain":
                case "path":
                    if (typeof val === "string" || val === null) {
                        obj[prop] = val;
                    }
                    break;
                case "secure":
                case "httpOnly":
                    if (typeof val === "boolean") {
                        obj[prop] = val;
                    }
                    break;
                case "extensions":
                    if (Array.isArray(val)) {
                        obj[prop] = val;
                    }
                    break;
                case "hostOnly":
                case "pathIsDefault":
                    if (typeof val === "boolean" || val === null) {
                        obj[prop] = val;
                    }
                    break;
            }
        }
        return obj;
    }
    /**
   * Does a deep clone of this cookie, implemented exactly as `Cookie.fromJSON(cookie.toJSON())`.
   * @public
   */ clone() {
        return fromJSON(this.toJSON());
    }
    /**
   * Validates cookie attributes for semantic correctness. Useful for "lint" checking any `Set-Cookie` headers you generate.
   * For now, it returns a boolean, but eventually could return a reason string.
   *
   * @remarks
   * Works for a few things, but is by no means comprehensive.
   *
   * @beta
   */ validate() {
        if (!this.value || !COOKIE_OCTETS.test(this.value)) {
            return false;
        }
        if (this.expires != "Infinity" && !(this.expires instanceof Date) && !parseDate(this.expires)) {
            return false;
        }
        if (this.maxAge != null && this.maxAge !== "Infinity" && (this.maxAge === "-Infinity" || this.maxAge <= 0)) {
            return false;
        }
        if (this.path != null && !PATH_VALUE.test(this.path)) {
            return false;
        }
        const cdomain = this.cdomain();
        if (cdomain) {
            if (cdomain.match(/\.$/)) {
                return false;
            }
            const suffix = getPublicSuffix(cdomain);
            if (suffix == null) {
                return false;
            }
        }
        return true;
    }
    /**
   * Sets the 'Expires' attribute on a cookie.
   *
   * @remarks
   * When given a `string` value it will be parsed with {@link parseDate}. If the value can't be parsed as a cookie date
   * then the 'Expires' attribute will be set to `"Infinity"`.
   *
   * @param exp - the new value for the 'Expires' attribute of the cookie.
   */ setExpires(exp) {
        if (exp instanceof Date) {
            this.expires = exp;
        } else {
            this.expires = parseDate(exp) || "Infinity";
        }
    }
    /**
   * Sets the 'Max-Age' attribute (in seconds) on a cookie.
   *
   * @remarks
   * Coerces `-Infinity` to `"-Infinity"` and `Infinity` to `"Infinity"` so it can be serialized to JSON.
   *
   * @param age - the new value for the 'Max-Age' attribute (in seconds).
   */ setMaxAge(age) {
        if (age === Infinity) {
            this.maxAge = "Infinity";
        } else if (age === -Infinity) {
            this.maxAge = "-Infinity";
        } else {
            this.maxAge = age;
        }
    }
    /**
   * Encodes to a `Cookie` header value (specifically, the {@link Cookie.key} and {@link Cookie.value} properties joined with "=").
   * @public
   */ cookieString() {
        const val = this.value || "";
        if (this.key) {
            return `${this.key}=${val}`;
        }
        return val;
    }
    /**
   * Encodes to a `Set-Cookie header` value.
   * @public
   */ toString() {
        let str = this.cookieString();
        if (this.expires != "Infinity") {
            if (this.expires instanceof Date) {
                str += `; Expires=${formatDate(this.expires)}`;
            }
        }
        if (this.maxAge != null && this.maxAge != Infinity) {
            str += `; Max-Age=${String(this.maxAge)}`;
        }
        if (this.domain && !this.hostOnly) {
            str += `; Domain=${this.domain}`;
        }
        if (this.path) {
            str += `; Path=${this.path}`;
        }
        if (this.secure) {
            str += "; Secure";
        }
        if (this.httpOnly) {
            str += "; HttpOnly";
        }
        if (this.sameSite && this.sameSite !== "none") {
            if (this.sameSite.toLowerCase() === _Cookie.sameSiteCanonical.lax.toLowerCase()) {
                str += `; SameSite=${_Cookie.sameSiteCanonical.lax}`;
            } else if (this.sameSite.toLowerCase() === _Cookie.sameSiteCanonical.strict.toLowerCase()) {
                str += `; SameSite=${_Cookie.sameSiteCanonical.strict}`;
            } else {
                str += `; SameSite=${this.sameSite}`;
            }
        }
        if (this.extensions) {
            this.extensions.forEach((ext)=>{
                str += `; ${ext}`;
            });
        }
        return str;
    }
    /**
   * Computes the TTL relative to now (milliseconds).
   *
   * @remarks
   * - `Infinity` is returned for cookies without an explicit expiry
   *
   * - `0` is returned if the cookie is expired.
   *
   * - Otherwise a time-to-live in milliseconds is returned.
   *
   * @param now - passing an explicit value is mostly used for testing purposes since this defaults to the `Date.now()`
   * @public
   */ TTL(now = Date.now()) {
        if (this.maxAge != null && typeof this.maxAge === "number") {
            return this.maxAge <= 0 ? 0 : this.maxAge * 1e3;
        }
        const expires = this.expires;
        if (expires === "Infinity") {
            return Infinity;
        }
        return (expires?.getTime() ?? now) - (now || Date.now());
    }
    /**
   * Computes the absolute unix-epoch milliseconds that this cookie expires.
   *
   * The "Max-Age" attribute takes precedence over "Expires" (as per the RFC). The {@link Cookie.lastAccessed} attribute
   * (or the `now` parameter if given) is used to offset the {@link Cookie.maxAge} attribute.
   *
   * If Expires ({@link Cookie.expires}) is set, that's returned.
   *
   * @param now - can be used to provide a time offset (instead of {@link Cookie.lastAccessed}) to use when calculating the "Max-Age" value
   */ expiryTime(now) {
        if (this.maxAge != null) {
            const relativeTo = now || this.lastAccessed || /* @__PURE__ */ new Date();
            const maxAge = typeof this.maxAge === "number" ? this.maxAge : -Infinity;
            const age = maxAge <= 0 ? -Infinity : maxAge * 1e3;
            if (relativeTo === "Infinity") {
                return Infinity;
            }
            return relativeTo.getTime() + age;
        }
        if (this.expires == "Infinity") {
            return Infinity;
        }
        return this.expires ? this.expires.getTime() : void 0;
    }
    /**
   * Similar to {@link Cookie.expiryTime}, computes the absolute unix-epoch milliseconds that this cookie expires and returns it as a Date.
   *
   * The "Max-Age" attribute takes precedence over "Expires" (as per the RFC). The {@link Cookie.lastAccessed} attribute
   * (or the `now` parameter if given) is used to offset the {@link Cookie.maxAge} attribute.
   *
   * If Expires ({@link Cookie.expires}) is set, that's returned.
   *
   * @param now - can be used to provide a time offset (instead of {@link Cookie.lastAccessed}) to use when calculating the "Max-Age" value
   */ expiryDate(now) {
        const millisec = this.expiryTime(now);
        if (millisec == Infinity) {
            return /* @__PURE__ */ new Date(2147483647e3);
        } else if (millisec == -Infinity) {
            return /* @__PURE__ */ new Date(0);
        } else {
            return millisec == void 0 ? void 0 : new Date(millisec);
        }
    }
    /**
   * Indicates if the cookie has been persisted to a store or not.
   * @public
   */ isPersistent() {
        return this.maxAge != null || this.expires != "Infinity";
    }
    /**
   * Calls {@link canonicalDomain} with the {@link Cookie.domain} property.
   * @public
   */ canonicalizedDomain() {
        return canonicalDomain(this.domain);
    }
    /**
   * Alias for {@link Cookie.canonicalizedDomain}
   * @public
   */ cdomain() {
        return canonicalDomain(this.domain);
    }
    /**
   * Parses a string into a Cookie object.
   *
   * @remarks
   * Note: when parsing a `Cookie` header it must be split by ';' before each Cookie string can be parsed.
   *
   * @example
   * ```
   * // parse a `Set-Cookie` header
   * const setCookieHeader = 'a=bcd; Expires=Tue, 18 Oct 2011 07:05:03 GMT'
   * const cookie = Cookie.parse(setCookieHeader)
   * cookie.key === 'a'
   * cookie.value === 'bcd'
   * cookie.expires === new Date(Date.parse('Tue, 18 Oct 2011 07:05:03 GMT'))
   * ```
   *
   * @example
   * ```
   * // parse a `Cookie` header
   * const cookieHeader = 'name=value; name2=value2; name3=value3'
   * const cookies = cookieHeader.split(';').map(Cookie.parse)
   * cookies[0].name === 'name'
   * cookies[0].value === 'value'
   * cookies[1].name === 'name2'
   * cookies[1].value === 'value2'
   * cookies[2].name === 'name3'
   * cookies[2].value === 'value3'
   * ```
   *
   * @param str - The `Set-Cookie` header or a Cookie string to parse.
   * @param options - Configures `strict` or `loose` mode for cookie parsing
   */ static parse(str, options) {
        return parse(str, options);
    }
    /**
   * Does the reverse of {@link Cookie.toJSON}.
   *
   * @remarks
   * Any Date properties (such as .expires, .creation, and .lastAccessed) are parsed via Date.parse, not tough-cookie's parseDate, since ISO timestamps are being handled at this layer.
   *
   * @example
   * ```
   * const json = JSON.stringify({
   *   key: 'alpha',
   *   value: 'beta',
   *   domain: 'example.com',
   *   path: '/foo',
   *   expires: '2038-01-19T03:14:07.000Z',
   * })
   * const cookie = Cookie.fromJSON(json)
   * cookie.key === 'alpha'
   * cookie.value === 'beta'
   * cookie.domain === 'example.com'
   * cookie.path === '/foo'
   * cookie.expires === new Date(Date.parse('2038-01-19T03:14:07.000Z'))
   * ```
   *
   * @param str - An unparsed JSON string or a value that has already been parsed as JSON
   */ static fromJSON(str) {
        return fromJSON(str);
    }
};
_Cookie.cookiesCreated = 0;
/**
 * @internal
 */ _Cookie.sameSiteLevel = {
    strict: 3,
    lax: 2,
    none: 1
};
/**
 * @internal
 */ _Cookie.sameSiteCanonical = {
    strict: "Strict",
    lax: "Lax"
};
/**
 * Cookie properties that will be serialized when using {@link Cookie.fromJSON} and {@link Cookie.toJSON}.
 * @public
 */ _Cookie.serializableProperties = [
    "key",
    "value",
    "expires",
    "maxAge",
    "domain",
    "path",
    "secure",
    "httpOnly",
    "extensions",
    "hostOnly",
    "pathIsDefault",
    "creation",
    "lastAccessed",
    "sameSite"
];
var Cookie = _Cookie;
// lib/cookie/cookieCompare.ts
var MAX_TIME = 2147483647e3;
function cookieCompare(a, b) {
    let cmp;
    const aPathLen = a.path ? a.path.length : 0;
    const bPathLen = b.path ? b.path.length : 0;
    cmp = bPathLen - aPathLen;
    if (cmp !== 0) {
        return cmp;
    }
    const aTime = a.creation && a.creation instanceof Date ? a.creation.getTime() : MAX_TIME;
    const bTime = b.creation && b.creation instanceof Date ? b.creation.getTime() : MAX_TIME;
    cmp = aTime - bTime;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = (a.creationIndex || 0) - (b.creationIndex || 0);
    return cmp;
}
// lib/cookie/defaultPath.ts
function defaultPath(path) {
    if (!path || path.slice(0, 1) !== "/") {
        return "/";
    }
    if (path === "/") {
        return path;
    }
    const rightSlash = path.lastIndexOf("/");
    if (rightSlash === 0) {
        return "/";
    }
    return path.slice(0, rightSlash);
}
// lib/cookie/domainMatch.ts
var IP_REGEX_LOWERCASE = /(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-f\d]{1,4}:){7}(?:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,2}|:)|(?:[a-f\d]{1,4}:){4}(?:(?::[a-f\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,3}|:)|(?:[a-f\d]{1,4}:){3}(?:(?::[a-f\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,4}|:)|(?:[a-f\d]{1,4}:){2}(?:(?::[a-f\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,5}|:)|(?:[a-f\d]{1,4}:){1}(?:(?::[a-f\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,6}|:)|(?::(?:(?::[a-f\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,7}|:)))$)/;
function domainMatch(domain, cookieDomain, canonicalize) {
    if (domain == null || cookieDomain == null) {
        return void 0;
    }
    let _str;
    let _domStr;
    if (canonicalize !== false) {
        _str = canonicalDomain(domain);
        _domStr = canonicalDomain(cookieDomain);
    } else {
        _str = domain;
        _domStr = cookieDomain;
    }
    if (_str == null || _domStr == null) {
        return void 0;
    }
    if (_str == _domStr) {
        return true;
    }
    const idx = _str.lastIndexOf(_domStr);
    if (idx <= 0) {
        return false;
    }
    if (_str.length !== _domStr.length + idx) {
        return false;
    }
    if (_str.substring(idx - 1, idx) !== ".") {
        return false;
    }
    return !IP_REGEX_LOWERCASE.test(_str);
}
// lib/cookie/secureContext.ts
function isLoopbackV4(address) {
    const octets = address.split(".");
    return octets.length === 4 && octets[0] !== void 0 && parseInt(octets[0], 10) === 127;
}
function isLoopbackV6(address) {
    return address === "::1";
}
function isNormalizedLocalhostTLD(lowerHost) {
    return lowerHost.endsWith(".localhost");
}
function isLocalHostname(host) {
    const lowerHost = host.toLowerCase();
    return lowerHost === "localhost" || isNormalizedLocalhostTLD(lowerHost);
}
function hostNoBrackets(host) {
    if (host.length >= 2 && host.startsWith("[") && host.endsWith("]")) {
        return host.substring(1, host.length - 1);
    }
    return host;
}
function isPotentiallyTrustworthy(inputUrl, allowSecureOnLocal = true) {
    let url;
    if (typeof inputUrl === "string") {
        try {
            url = new URL(inputUrl);
        } catch  {
            return false;
        }
    } else {
        url = inputUrl;
    }
    const scheme = url.protocol.replace(":", "").toLowerCase();
    const hostname = hostNoBrackets(url.hostname).replace(/\.+$/, "");
    if (scheme === "https" || scheme === "wss") {
        return true;
    }
    if (!allowSecureOnLocal) {
        return false;
    }
    if (IP_V4_REGEX_OBJECT.test(hostname)) {
        return isLoopbackV4(hostname);
    }
    if (IP_V6_REGEX_OBJECT.test(hostname)) {
        return isLoopbackV6(hostname);
    }
    return isLocalHostname(hostname);
}
// lib/cookie/cookieJar.ts
var defaultSetCookieOptions = {
    loose: false,
    sameSiteContext: void 0,
    ignoreError: false,
    http: true
};
var defaultGetCookieOptions = {
    http: true,
    expire: true,
    allPaths: false,
    sameSiteContext: void 0,
    sort: void 0
};
var SAME_SITE_CONTEXT_VAL_ERR = 'Invalid sameSiteContext option for getCookies(); expected one of "strict", "lax", or "none"';
function getCookieContext(url) {
    if (url && typeof url === "object" && "hostname" in url && typeof url.hostname === "string" && "pathname" in url && typeof url.pathname === "string" && "protocol" in url && typeof url.protocol === "string") {
        return {
            hostname: url.hostname,
            pathname: url.pathname,
            protocol: url.protocol
        };
    } else if (typeof url === "string") {
        try {
            return new URL(decodeURI(url));
        } catch  {
            return new URL(url);
        }
    } else {
        throw new ParameterError("`url` argument is not a string or URL.");
    }
}
function checkSameSiteContext(value) {
    const context = String(value).toLowerCase();
    if (context === "none" || context === "lax" || context === "strict") {
        return context;
    } else {
        return void 0;
    }
}
function isSecurePrefixConditionMet(cookie) {
    const startsWithSecurePrefix = typeof cookie.key === "string" && cookie.key.startsWith("__Secure-");
    return !startsWithSecurePrefix || cookie.secure;
}
function isHostPrefixConditionMet(cookie) {
    const startsWithHostPrefix = typeof cookie.key === "string" && cookie.key.startsWith("__Host-");
    return !startsWithHostPrefix || Boolean(cookie.secure && cookie.hostOnly && cookie.path != null && cookie.path === "/");
}
function getNormalizedPrefixSecurity(prefixSecurity) {
    const normalizedPrefixSecurity = prefixSecurity.toLowerCase();
    switch(normalizedPrefixSecurity){
        case PrefixSecurityEnum.STRICT:
        case PrefixSecurityEnum.SILENT:
        case PrefixSecurityEnum.DISABLED:
            return normalizedPrefixSecurity;
        default:
            return PrefixSecurityEnum.SILENT;
    }
}
var CookieJar = class _CookieJar {
    /**
   * Creates a new `CookieJar` instance.
   *
   * @remarks
   * - If a custom store is not passed to the constructor, an in-memory store ({@link MemoryCookieStore} will be created and used.
   * - If a boolean value is passed as the `options` parameter, this is equivalent to passing `{ rejectPublicSuffixes: <value> }`
   *
   * @param store - a custom {@link Store} implementation (defaults to {@link MemoryCookieStore})
   * @param options - configures how cookies are processed by the cookie jar
   */ constructor(store, options){
        if (typeof options === "boolean") {
            options = {
                rejectPublicSuffixes: options
            };
        }
        this.rejectPublicSuffixes = options?.rejectPublicSuffixes ?? true;
        this.enableLooseMode = options?.looseMode ?? false;
        this.allowSpecialUseDomain = options?.allowSpecialUseDomain ?? true;
        this.allowSecureOnLocal = options?.allowSecureOnLocal ?? true;
        this.prefixSecurity = getNormalizedPrefixSecurity(options?.prefixSecurity ?? "silent");
        this.store = store ?? new MemoryCookieStore();
    }
    callSync(fn) {
        if (!this.store.synchronous) {
            throw new Error("CookieJar store is not synchronous; use async API instead.");
        }
        let syncErr = null;
        let syncResult = void 0;
        try {
            fn.call(this, (error, result)=>{
                syncErr = error;
                syncResult = result;
            });
        } catch (err) {
            syncErr = err;
        }
        if (syncErr) throw syncErr;
        return syncResult;
    }
    /**
   * @internal No doc because this is the overload implementation
   */ setCookie(cookie, url, options, callback) {
        if (typeof options === "function") {
            callback = options;
            options = void 0;
        }
        const promiseCallback = createPromiseCallback(callback);
        const cb = promiseCallback.callback;
        let context;
        try {
            if (typeof url === "string") {
                validate(isNonEmptyString(url), callback, safeToString(options));
            }
            context = getCookieContext(url);
            if (typeof url === "function") {
                return promiseCallback.reject(new Error("No URL was specified"));
            }
            if (typeof options === "function") {
                options = defaultSetCookieOptions;
            }
            validate(typeof cb === "function", cb);
            if (!isNonEmptyString(cookie) && !isObject(cookie) && cookie instanceof String && cookie.length == 0) {
                return promiseCallback.resolve(void 0);
            }
        } catch (err) {
            return promiseCallback.reject(err);
        }
        const host = canonicalDomain(context.hostname) ?? null;
        const loose = options?.loose || this.enableLooseMode;
        let sameSiteContext = null;
        if (options?.sameSiteContext) {
            sameSiteContext = checkSameSiteContext(options.sameSiteContext);
            if (!sameSiteContext) {
                return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));
            }
        }
        if (typeof cookie === "string" || cookie instanceof String) {
            const parsedCookie = Cookie.parse(cookie.toString(), {
                loose
            });
            if (!parsedCookie) {
                const err = new Error("Cookie failed to parse");
                return options?.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);
            }
            cookie = parsedCookie;
        } else if (!(cookie instanceof Cookie)) {
            const err = new Error("First argument to setCookie must be a Cookie object or string");
            return options?.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);
        }
        const now = options?.now || /* @__PURE__ */ new Date();
        if (this.rejectPublicSuffixes && cookie.domain) {
            try {
                const cdomain = cookie.cdomain();
                const suffix = typeof cdomain === "string" ? getPublicSuffix(cdomain, {
                    allowSpecialUseDomain: this.allowSpecialUseDomain,
                    ignoreError: options?.ignoreError
                }) : null;
                if (suffix == null && !IP_V6_REGEX_OBJECT.test(cookie.domain)) {
                    const err = new Error("Cookie has domain set to a public suffix");
                    return options?.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);
                }
            } catch (err) {
                return options?.ignoreError ? promiseCallback.resolve(void 0) : // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                promiseCallback.reject(err);
            }
        }
        if (cookie.domain) {
            if (!domainMatch(host ?? void 0, cookie.cdomain() ?? void 0, false)) {
                const err = new Error(`Cookie not in this host's domain. Cookie:${cookie.cdomain() ?? "null"} Request:${host ?? "null"}`);
                return options?.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);
            }
            if (cookie.hostOnly == null) {
                cookie.hostOnly = false;
            }
        } else {
            cookie.hostOnly = true;
            cookie.domain = host;
        }
        if (!cookie.path || cookie.path[0] !== "/") {
            cookie.path = defaultPath(context.pathname);
            cookie.pathIsDefault = true;
        }
        if (options?.http === false && cookie.httpOnly) {
            const err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
            return options.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);
        }
        if (cookie.sameSite !== "none" && cookie.sameSite !== void 0 && sameSiteContext) {
            if (sameSiteContext === "none") {
                const err = new Error("Cookie is SameSite but this is a cross-origin request");
                return options?.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);
            }
        }
        const ignoreErrorForPrefixSecurity = this.prefixSecurity === PrefixSecurityEnum.SILENT;
        const prefixSecurityDisabled = this.prefixSecurity === PrefixSecurityEnum.DISABLED;
        if (!prefixSecurityDisabled) {
            let errorFound = false;
            let errorMsg;
            if (!isSecurePrefixConditionMet(cookie)) {
                errorFound = true;
                errorMsg = "Cookie has __Secure prefix but Secure attribute is not set";
            } else if (!isHostPrefixConditionMet(cookie)) {
                errorFound = true;
                errorMsg = "Cookie has __Host prefix but either Secure or HostOnly attribute is not set or Path is not '/'";
            }
            if (errorFound) {
                return options?.ignoreError || ignoreErrorForPrefixSecurity ? promiseCallback.resolve(void 0) : promiseCallback.reject(new Error(errorMsg));
            }
        }
        const store = this.store;
        if (!store.updateCookie) {
            store.updateCookie = async function(_oldCookie, newCookie, cb2) {
                return this.putCookie(newCookie).then(()=>cb2?.(null), (error)=>cb2?.(error));
            };
        }
        const withCookie = function withCookie2(err, oldCookie) {
            if (err) {
                cb(err);
                return;
            }
            const next = function(err2) {
                if (err2) {
                    cb(err2);
                } else if (typeof cookie === "string") {
                    cb(null, void 0);
                } else {
                    cb(null, cookie);
                }
            };
            if (oldCookie) {
                if (options && "http" in options && options.http === false && oldCookie.httpOnly) {
                    err = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
                    if (options.ignoreError) cb(null, void 0);
                    else cb(err);
                    return;
                }
                if (cookie instanceof Cookie) {
                    cookie.creation = oldCookie.creation;
                    cookie.creationIndex = oldCookie.creationIndex;
                    cookie.lastAccessed = now;
                    store.updateCookie(oldCookie, cookie, next);
                }
            } else {
                if (cookie instanceof Cookie) {
                    cookie.creation = cookie.lastAccessed = now;
                    store.putCookie(cookie, next);
                }
            }
        };
        store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
        return promiseCallback.promise;
    }
    /**
   * Synchronously attempt to set the {@link Cookie} in the {@link CookieJar}.
   *
   * <strong>Note:</strong> Only works if the configured {@link Store} is also synchronous.
   *
   * @remarks
   * - If successfully persisted, the {@link Cookie} will have updated
   *     {@link Cookie.creation}, {@link Cookie.lastAccessed} and {@link Cookie.hostOnly}
   *     properties.
   *
   * - As per the RFC, the {@link Cookie.hostOnly} flag is set if there was no `Domain={value}`
   *     attribute on the cookie string. The {@link Cookie.domain} property is set to the
   *     fully-qualified hostname of `currentUrl` in this case. Matching this cookie requires an
   *     exact hostname match (not a {@link domainMatch} as per usual)
   *
   * @param cookie - The cookie object or cookie string to store. A string value will be parsed into a cookie using {@link Cookie.parse}.
   * @param url - The domain to store the cookie with.
   * @param options - Configuration settings to use when storing the cookie.
   * @public
   */ setCookieSync(cookie, url, options) {
        const setCookieFn = options ? this.setCookie.bind(this, cookie, url, options) : this.setCookie.bind(this, cookie, url);
        return this.callSync(setCookieFn);
    }
    /**
   * @internal No doc because this is the overload implementation
   */ getCookies(url, options, callback) {
        if (typeof options === "function") {
            callback = options;
            options = defaultGetCookieOptions;
        } else if (options === void 0) {
            options = defaultGetCookieOptions;
        }
        const promiseCallback = createPromiseCallback(callback);
        const cb = promiseCallback.callback;
        let context;
        try {
            if (typeof url === "string") {
                validate(isNonEmptyString(url), cb, url);
            }
            context = getCookieContext(url);
            validate(isObject(options), cb, safeToString(options));
            validate(typeof cb === "function", cb);
        } catch (parameterError) {
            return promiseCallback.reject(parameterError);
        }
        const host = canonicalDomain(context.hostname);
        const path = context.pathname || "/";
        const potentiallyTrustworthy = isPotentiallyTrustworthy(url, this.allowSecureOnLocal);
        let sameSiteLevel = 0;
        if (options.sameSiteContext) {
            const sameSiteContext = checkSameSiteContext(options.sameSiteContext);
            if (sameSiteContext == null) {
                return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));
            }
            sameSiteLevel = Cookie.sameSiteLevel[sameSiteContext];
            if (!sameSiteLevel) {
                return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));
            }
        }
        const http = options.http ?? true;
        const now = Date.now();
        const expireCheck = options.expire ?? true;
        const allPaths = options.allPaths ?? false;
        const store = this.store;
        function matchingCookie(c) {
            if (c.hostOnly) {
                if (c.domain != host) {
                    return false;
                }
            } else {
                if (!domainMatch(host ?? void 0, c.domain ?? void 0, false)) {
                    return false;
                }
            }
            if (!allPaths && typeof c.path === "string" && !pathMatch(path, c.path)) {
                return false;
            }
            if (c.secure && !potentiallyTrustworthy) {
                return false;
            }
            if (c.httpOnly && !http) {
                return false;
            }
            if (sameSiteLevel) {
                let cookieLevel;
                if (c.sameSite === "lax") {
                    cookieLevel = Cookie.sameSiteLevel.lax;
                } else if (c.sameSite === "strict") {
                    cookieLevel = Cookie.sameSiteLevel.strict;
                } else {
                    cookieLevel = Cookie.sameSiteLevel.none;
                }
                if (cookieLevel > sameSiteLevel) {
                    return false;
                }
            }
            const expiryTime = c.expiryTime();
            if (expireCheck && expiryTime != void 0 && expiryTime <= now) {
                store.removeCookie(c.domain, c.path, c.key, ()=>{});
                return false;
            }
            return true;
        }
        store.findCookies(host, allPaths ? null : path, this.allowSpecialUseDomain, (err, cookies)=>{
            if (err) {
                cb(err);
                return;
            }
            if (cookies == null) {
                cb(null, []);
                return;
            }
            cookies = cookies.filter(matchingCookie);
            if ("sort" in options && options.sort !== false) {
                cookies = cookies.sort(cookieCompare);
            }
            const now2 = /* @__PURE__ */ new Date();
            for (const cookie of cookies){
                cookie.lastAccessed = now2;
            }
            cb(null, cookies);
        });
        return promiseCallback.promise;
    }
    /**
   * Synchronously retrieve the list of cookies that can be sent in a Cookie header for the
   * current URL.
   *
   * <strong>Note</strong>: Only works if the configured Store is also synchronous.
   *
   * @remarks
   * - The array of cookies returned will be sorted according to {@link cookieCompare}.
   *
   * - The {@link Cookie.lastAccessed} property will be updated on all returned cookies.
   *
   * @param url - The domain to store the cookie with.
   * @param options - Configuration settings to use when retrieving the cookies.
   */ getCookiesSync(url, options) {
        return this.callSync(this.getCookies.bind(this, url, options)) ?? [];
    }
    /**
   * @internal No doc because this is the overload implementation
   */ getCookieString(url, options, callback) {
        if (typeof options === "function") {
            callback = options;
            options = void 0;
        }
        const promiseCallback = createPromiseCallback(callback);
        const next = function(err, cookies) {
            if (err) {
                promiseCallback.callback(err);
            } else {
                promiseCallback.callback(null, cookies?.sort(cookieCompare).map((c)=>c.cookieString()).join("; "));
            }
        };
        this.getCookies(url, options, next);
        return promiseCallback.promise;
    }
    /**
   * Synchronous version of `.getCookieString()`. Accepts the same options as `.getCookies()` but returns a string suitable for a
   * `Cookie` header rather than an Array.
   *
   * <strong>Note</strong>: Only works if the configured Store is also synchronous.
   *
   * @param url - The domain to store the cookie with.
   * @param options - Configuration settings to use when retrieving the cookies.
   */ getCookieStringSync(url, options) {
        return this.callSync(options ? this.getCookieString.bind(this, url, options) : this.getCookieString.bind(this, url)) ?? "";
    }
    /**
   * @internal No doc because this is the overload implementation
   */ getSetCookieStrings(url, options, callback) {
        if (typeof options === "function") {
            callback = options;
            options = void 0;
        }
        const promiseCallback = createPromiseCallback(callback);
        const next = function(err, cookies) {
            if (err) {
                promiseCallback.callback(err);
            } else {
                promiseCallback.callback(null, cookies?.map((c)=>{
                    return c.toString();
                }));
            }
        };
        this.getCookies(url, options, next);
        return promiseCallback.promise;
    }
    /**
   * Synchronous version of `.getSetCookieStrings()`. Returns an array of strings suitable for `Set-Cookie` headers.
   * Accepts the same options as `.getCookies()`.
   *
   * <strong>Note</strong>: Only works if the configured Store is also synchronous.
   *
   * @param url - The domain to store the cookie with.
   * @param options - Configuration settings to use when retrieving the cookies.
   */ getSetCookieStringsSync(url, options = {}) {
        return this.callSync(this.getSetCookieStrings.bind(this, url, options)) ?? [];
    }
    /**
   * @internal No doc because this is the overload implementation
   */ serialize(callback) {
        const promiseCallback = createPromiseCallback(callback);
        let type = this.store.constructor.name;
        if (isObject(type)) {
            type = null;
        }
        const serialized = {
            // The version of tough-cookie that serialized this jar. Generally a good
            // practice since future versions can make data import decisions based on
            // known past behavior. When/if this matters, use `semver`.
            version: `tough-cookie@${version}`,
            // add the store type, to make humans happy:
            storeType: type,
            // CookieJar configuration:
            rejectPublicSuffixes: this.rejectPublicSuffixes,
            enableLooseMode: this.enableLooseMode,
            allowSpecialUseDomain: this.allowSpecialUseDomain,
            prefixSecurity: getNormalizedPrefixSecurity(this.prefixSecurity),
            // this gets filled from getAllCookies:
            cookies: []
        };
        if (typeof this.store.getAllCookies !== "function") {
            return promiseCallback.reject(new Error("store does not support getAllCookies and cannot be serialized"));
        }
        this.store.getAllCookies((err, cookies)=>{
            if (err) {
                promiseCallback.callback(err);
                return;
            }
            if (cookies == null) {
                promiseCallback.callback(null, serialized);
                return;
            }
            serialized.cookies = cookies.map((cookie)=>{
                const serializedCookie = cookie.toJSON();
                delete serializedCookie.creationIndex;
                return serializedCookie;
            });
            promiseCallback.callback(null, serialized);
        });
        return promiseCallback.promise;
    }
    /**
   * Serialize the CookieJar if the underlying store supports `.getAllCookies`.
   *
   * <strong>Note</strong>: Only works if the configured Store is also synchronous.
   */ serializeSync() {
        return this.callSync((callback)=>{
            this.serialize(callback);
        });
    }
    /**
   * Alias of {@link CookieJar.serializeSync}. Allows the cookie to be serialized
   * with `JSON.stringify(cookieJar)`.
   */ toJSON() {
        return this.serializeSync();
    }
    /**
   * Use the class method CookieJar.deserialize instead of calling this directly
   * @internal
   */ _importCookies(serialized, callback) {
        let cookies = void 0;
        if (serialized && typeof serialized === "object" && inOperator("cookies", serialized) && Array.isArray(serialized.cookies)) {
            cookies = serialized.cookies;
        }
        if (!cookies) {
            callback(new Error("serialized jar has no cookies array"), void 0);
            return;
        }
        cookies = cookies.slice();
        const putNext = (err)=>{
            if (err) {
                callback(err, void 0);
                return;
            }
            if (Array.isArray(cookies)) {
                if (!cookies.length) {
                    callback(err, this);
                    return;
                }
                let cookie;
                try {
                    cookie = Cookie.fromJSON(cookies.shift());
                } catch (e) {
                    callback(e instanceof Error ? e : new Error(), void 0);
                    return;
                }
                if (cookie === void 0) {
                    putNext(null);
                    return;
                }
                this.store.putCookie(cookie, putNext);
            }
        };
        putNext(null);
    }
    /**
   * @internal
   */ _importCookiesSync(serialized) {
        this.callSync(this._importCookies.bind(this, serialized));
    }
    /**
   * @internal No doc because this is the overload implementation
   */ clone(newStore, callback) {
        if (typeof newStore === "function") {
            callback = newStore;
            newStore = void 0;
        }
        const promiseCallback = createPromiseCallback(callback);
        const cb = promiseCallback.callback;
        this.serialize((err, serialized)=>{
            if (err) {
                return promiseCallback.reject(err);
            }
            return _CookieJar.deserialize(serialized ?? "", newStore, cb);
        });
        return promiseCallback.promise;
    }
    /**
   * @internal
   */ _cloneSync(newStore) {
        const cloneFn = newStore && typeof newStore !== "function" ? this.clone.bind(this, newStore) : this.clone.bind(this);
        return this.callSync((callback)=>{
            cloneFn(callback);
        });
    }
    /**
   * Produces a deep clone of this CookieJar. Modifications to the original do
   * not affect the clone, and vice versa.
   *
   * <strong>Note</strong>: Only works if both the configured Store and destination
   * Store are synchronous.
   *
   * @remarks
   * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.
   *
   * - Transferring between store types is supported so long as the source
   *     implements `.getAllCookies()` and the destination implements `.putCookie()`.
   *
   * @param newStore - The target {@link Store} to clone cookies into.
   */ cloneSync(newStore) {
        if (!newStore) {
            return this._cloneSync();
        }
        if (!newStore.synchronous) {
            throw new Error("CookieJar clone destination store is not synchronous; use async API instead.");
        }
        return this._cloneSync(newStore);
    }
    /**
   * @internal No doc because this is the overload implementation
   */ removeAllCookies(callback) {
        const promiseCallback = createPromiseCallback(callback);
        const cb = promiseCallback.callback;
        const store = this.store;
        if (typeof store.removeAllCookies === "function" && store.removeAllCookies !== Store.prototype.removeAllCookies) {
            store.removeAllCookies(cb);
            return promiseCallback.promise;
        }
        store.getAllCookies((err, cookies)=>{
            if (err) {
                cb(err);
                return;
            }
            if (!cookies) {
                cookies = [];
            }
            if (cookies.length === 0) {
                cb(null, void 0);
                return;
            }
            let completedCount = 0;
            const removeErrors = [];
            const removeCookieCb = function removeCookieCb2(removeErr) {
                if (removeErr) {
                    removeErrors.push(removeErr);
                }
                completedCount++;
                if (completedCount === cookies.length) {
                    if (removeErrors[0]) cb(removeErrors[0]);
                    else cb(null, void 0);
                    return;
                }
            };
            cookies.forEach((cookie)=>{
                store.removeCookie(cookie.domain, cookie.path, cookie.key, removeCookieCb);
            });
        });
        return promiseCallback.promise;
    }
    /**
   * Removes all cookies from the CookieJar.
   *
   * <strong>Note</strong>: Only works if the configured Store is also synchronous.
   *
   * @remarks
   * - This is a new backwards-compatible feature of tough-cookie version 2.5,
   *     so not all Stores will implement it efficiently. For Stores that do not
   *     implement `removeAllCookies`, the fallback is to call `removeCookie` after
   *     `getAllCookies`.
   *
   * - If `getAllCookies` fails or isn't implemented in the Store, an error is returned.
   *
   * - If one or more of the `removeCookie` calls fail, only the first error is returned.
   */ removeAllCookiesSync() {
        this.callSync((callback)=>{
            this.removeAllCookies(callback);
        });
    }
    /**
   * @internal No doc because this is the overload implementation
   */ static deserialize(strOrObj, store, callback) {
        if (typeof store === "function") {
            callback = store;
            store = void 0;
        }
        const promiseCallback = createPromiseCallback(callback);
        let serialized;
        if (typeof strOrObj === "string") {
            try {
                serialized = JSON.parse(strOrObj);
            } catch (e) {
                return promiseCallback.reject(e instanceof Error ? e : new Error());
            }
        } else {
            serialized = strOrObj;
        }
        const readSerializedProperty = (property)=>{
            return serialized && typeof serialized === "object" && inOperator(property, serialized) ? serialized[property] : void 0;
        };
        const readSerializedBoolean = (property)=>{
            const value = readSerializedProperty(property);
            return typeof value === "boolean" ? value : void 0;
        };
        const readSerializedString = (property)=>{
            const value = readSerializedProperty(property);
            return typeof value === "string" ? value : void 0;
        };
        const jar = new _CookieJar(store, {
            rejectPublicSuffixes: readSerializedBoolean("rejectPublicSuffixes"),
            looseMode: readSerializedBoolean("enableLooseMode"),
            allowSpecialUseDomain: readSerializedBoolean("allowSpecialUseDomain"),
            prefixSecurity: getNormalizedPrefixSecurity(readSerializedString("prefixSecurity") ?? "silent")
        });
        jar._importCookies(serialized, (err)=>{
            if (err) {
                promiseCallback.callback(err);
                return;
            }
            promiseCallback.callback(null, jar);
        });
        return promiseCallback.promise;
    }
    /**
   * A new CookieJar is created and the serialized {@link Cookie} values are added to
   * the underlying store. Each {@link Cookie} is added via `store.putCookie(...)` in
   * the order in which they appear in the serialization.
   *
   * <strong>Note</strong>: Only works if the configured Store is also synchronous.
   *
   * @remarks
   * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.
   *
   * - As a convenience, if `strOrObj` is a string, it is passed through `JSON.parse` first.
   *
   * @param strOrObj - A JSON string or object representing the deserialized cookies.
   * @param store - The underlying store to persist the deserialized cookies into.
   */ static deserializeSync(strOrObj, store) {
        const serialized = typeof strOrObj === "string" ? JSON.parse(strOrObj) : strOrObj;
        const readSerializedProperty = (property)=>{
            return serialized && typeof serialized === "object" && inOperator(property, serialized) ? serialized[property] : void 0;
        };
        const readSerializedBoolean = (property)=>{
            const value = readSerializedProperty(property);
            return typeof value === "boolean" ? value : void 0;
        };
        const readSerializedString = (property)=>{
            const value = readSerializedProperty(property);
            return typeof value === "string" ? value : void 0;
        };
        const jar = new _CookieJar(store, {
            rejectPublicSuffixes: readSerializedBoolean("rejectPublicSuffixes"),
            looseMode: readSerializedBoolean("enableLooseMode"),
            allowSpecialUseDomain: readSerializedBoolean("allowSpecialUseDomain"),
            prefixSecurity: getNormalizedPrefixSecurity(readSerializedString("prefixSecurity") ?? "silent")
        });
        if (!jar.store.synchronous) {
            throw new Error("CookieJar store is not synchronous; use async API instead.");
        }
        jar._importCookiesSync(serialized);
        return jar;
    }
    /**
   * Alias of {@link CookieJar.deserializeSync}.
   *
   * @remarks
   * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.
   *
   * - As a convenience, if `strOrObj` is a string, it is passed through `JSON.parse` first.
   *
   * @param jsonString - A JSON string or object representing the deserialized cookies.
   * @param store - The underlying store to persist the deserialized cookies into.
   */ static fromJSON(jsonString, store) {
        return _CookieJar.deserializeSync(jsonString, store);
    }
};
// lib/cookie/permutePath.ts
function permutePath(path) {
    if (path === "/") {
        return [
            "/"
        ];
    }
    const permutations = [
        path
    ];
    while(path.length > 1){
        const lindex = path.lastIndexOf("/");
        if (lindex === 0) {
            break;
        }
        path = path.slice(0, lindex);
        permutations.push(path);
    }
    permutations.push("/");
    return permutations;
}
// lib/cookie/index.ts
function parse2(str, options) {
    return Cookie.parse(str, options);
}
function fromJSON2(str) {
    return Cookie.fromJSON(str);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    Cookie,
    CookieJar,
    MemoryCookieStore,
    ParameterError,
    PrefixSecurityEnum,
    Store,
    canonicalDomain,
    cookieCompare,
    defaultPath,
    domainMatch,
    formatDate,
    fromJSON,
    getPublicSuffix,
    parse,
    parseDate,
    pathMatch,
    permuteDomain,
    permutePath,
    version
}); /*!
 * Copyright (c) 2015-2020, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */  //# sourceMappingURL=index.cjs.map
}),
"[project]/node_modules/sequin/lib/sequin.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Stream = function(sequence, bits) {
    bits = bits || (sequence instanceof Buffer ? 8 : 1);
    var binary = '', b, i, n;
    for(i = 0, n = sequence.length; i < n; i++){
        b = this._get(sequence, i).toString(2);
        while(b.length < bits)b = '0' + b;
        binary = binary + b;
    }
    binary = binary.split('').map(function(b) {
        return parseInt(b, 2);
    });
    this._bases = {
        '2': binary
    };
};
Stream.prototype.generate = function(n, base, inner) {
    base = base || 2;
    var value = n, k = Math.ceil(Math.log(n) / Math.log(base)), r = Math.pow(base, k) - n, chunk;
    loop: while(value >= n){
        chunk = this._shift(base, k);
        if (!chunk) return inner ? n : null;
        value = this._evaluate(chunk, base);
        if (value >= n) {
            if (r === 1) continue loop;
            this._push(r, value - n);
            value = this.generate(n, r, true);
        }
    }
    return value;
};
Stream.prototype._get = function(sequence, i) {
    return sequence.readUInt8 ? sequence.readUInt8(i) : sequence[i];
};
Stream.prototype._evaluate = function(chunk, base) {
    var sum = 0, i = chunk.length;
    while(i--)sum += chunk[i] * Math.pow(base, chunk.length - (i + 1));
    return sum;
};
Stream.prototype._push = function(base, value) {
    this._bases[base] = this._bases[base] || [];
    this._bases[base].push(value);
};
Stream.prototype._shift = function(base, k) {
    var list = this._bases[base];
    if (!list || list.length < k) return null;
    else return list.splice(0, k);
};
module.exports = Stream;
}),
"[project]/node_modules/csprng/lib/csprng.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var DEFAULT_BITS = 128, DEFAULT_RADIX = 16, DIGITS = '0123456789abcdefghijklmnopqrstuvwxyz'.split('');
var crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)"), Seq = __turbopack_context__.r("[project]/node_modules/sequin/lib/sequin.js [app-route] (ecmascript)");
var rand = function(bits, radix) {
    bits = bits || DEFAULT_BITS;
    radix = radix || DEFAULT_RADIX;
    if (radix < 2 || radix > 36) throw new Error('radix argument must be between 2 and 36');
    var length = Math.ceil(bits * Math.log(2) / Math.log(radix)), entropy = crypto.randomBytes(bits), stream = new Seq(entropy), string = '';
    while(string.length < length)string += DIGITS[stream.generate(radix)];
    return string;
};
module.exports = rand;
}),
"[project]/node_modules/websocket-driver/lib/websocket/streams.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**

Streams in a WebSocket connection
---------------------------------

We model a WebSocket as two duplex streams: one stream is for the wire protocol
over an I/O socket, and the other is for incoming/outgoing messages.


                        +----------+      +---------+      +----------+
    [1] write(chunk) -->| ~~~~~~~~ +----->| parse() +----->| ~~~~~~~~ +--> emit('data') [2]
                        |          |      +----+----+      |          |
                        |          |           |           |          |
                        |    IO    |           | [5]       | Messages |
                        |          |           V           |          |
                        |          |      +---------+      |          |
    [4] emit('data') <--+ ~~~~~~~~ |<-----+ frame() |<-----+ ~~~~~~~~ |<-- write(chunk) [3]
                        +----------+      +---------+      +----------+


Message transfer in each direction is simple: IO receives a byte stream [1] and
sends this stream for parsing. The parser will periodically emit a complete
message text on the Messages stream [2]. Similarly, when messages are written
to the Messages stream [3], they are framed using the WebSocket wire format and
emitted via IO [4].

There is a feedback loop via [5] since some input from [1] will be things like
ping, pong and close frames. In these cases the protocol responds by emitting
responses directly back to [4] rather than emitting messages via [2].

For the purposes of flow control, we consider the sources of each Readable
stream to be as follows:

* [2] receives input from [1]
* [4] receives input from [1] and [3]

The classes below express the relationships described above without prescribing
anything about how parse() and frame() work, other than assuming they emit
'data' events to the IO and Messages streams. They will work with any protocol
driver having these two methods.
**/ var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream, util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
var IO = function(driver) {
    this.readable = this.writable = true;
    this._paused = false;
    this._driver = driver;
};
util.inherits(IO, Stream);
// The IO pause() and resume() methods will be called when the socket we are
// piping to gets backed up and drains. Since IO output [4] comes from IO input
// [1] and Messages input [3], we need to tell both of those to return false
// from write() when this stream is paused.
IO.prototype.pause = function() {
    this._paused = true;
    this._driver.messages._paused = true;
};
IO.prototype.resume = function() {
    this._paused = false;
    this.emit('drain');
    var messages = this._driver.messages;
    messages._paused = false;
    messages.emit('drain');
};
// When we receive input from a socket, send it to the parser and tell the
// source whether to back off.
IO.prototype.write = function(chunk) {
    if (!this.writable) return false;
    this._driver.parse(chunk);
    return !this._paused;
};
// The IO end() method will be called when the socket piping into it emits
// 'close' or 'end', i.e. the socket is closed. In this situation the Messages
// stream will not emit any more data so we emit 'end'.
IO.prototype.end = function(chunk) {
    if (!this.writable) return;
    if (chunk !== undefined) this.write(chunk);
    this.writable = false;
    var messages = this._driver.messages;
    if (messages.readable) {
        messages.readable = messages.writable = false;
        messages.emit('end');
    }
};
IO.prototype.destroy = function() {
    this.end();
};
var Messages = function(driver) {
    this.readable = this.writable = true;
    this._paused = false;
    this._driver = driver;
};
util.inherits(Messages, Stream);
// The Messages pause() and resume() methods will be called when the app that's
// processing the messages gets backed up and drains. If we're emitting
// messages too fast we should tell the source to slow down. Message output [2]
// comes from IO input [1].
Messages.prototype.pause = function() {
    this._driver.io._paused = true;
};
Messages.prototype.resume = function() {
    this._driver.io._paused = false;
    this._driver.io.emit('drain');
};
// When we receive messages from the user, send them to the formatter and tell
// the source whether to back off.
Messages.prototype.write = function(message) {
    if (!this.writable) return false;
    if (typeof message === 'string') this._driver.text(message);
    else this._driver.binary(message);
    return !this._paused;
};
// The Messages end() method will be called when a stream piping into it emits
// 'end'. Many streams may be piped into the WebSocket and one of them ending
// does not mean the whole socket is done, so just process the input and move
// on leaving the socket open.
Messages.prototype.end = function(message) {
    if (message !== undefined) this.write(message);
};
Messages.prototype.destroy = function() {};
exports.IO = IO;
exports.Messages = Messages;
}),
"[project]/node_modules/websocket-driver/lib/websocket/driver/headers.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Headers = function() {
    this.clear();
};
Headers.prototype.ALLOWED_DUPLICATES = [
    'set-cookie',
    'set-cookie2',
    'warning',
    'www-authenticate'
];
Headers.prototype.clear = function() {
    this._sent = {};
    this._lines = [];
};
Headers.prototype.set = function(name, value) {
    if (value === undefined) return;
    name = this._strip(name);
    value = this._strip(value);
    var key = name.toLowerCase();
    if (!this._sent.hasOwnProperty(key) || this.ALLOWED_DUPLICATES.indexOf(key) >= 0) {
        this._sent[key] = true;
        this._lines.push(name + ': ' + value + '\r\n');
    }
};
Headers.prototype.toString = function() {
    return this._lines.join('');
};
Headers.prototype._strip = function(string) {
    return string.toString().replace(/^ */, '').replace(/ *$/, '');
};
module.exports = Headers;
}),
"[project]/node_modules/websocket-driver/lib/websocket/driver/stream_reader.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-route] (ecmascript)").Buffer;
var StreamReader = function() {
    this._queue = [];
    this._queueSize = 0;
    this._offset = 0;
};
StreamReader.prototype.put = function(buffer) {
    if (!buffer || buffer.length === 0) return;
    if (!Buffer.isBuffer(buffer)) buffer = Buffer.from(buffer);
    this._queue.push(buffer);
    this._queueSize += buffer.length;
};
StreamReader.prototype.read = function(length) {
    if (length > this._queueSize) return null;
    if (length === 0) return Buffer.alloc(0);
    this._queueSize -= length;
    var queue = this._queue, remain = length, first = queue[0], buffers, buffer;
    if (first.length >= length) {
        if (first.length === length) {
            return queue.shift();
        } else {
            buffer = first.slice(0, length);
            queue[0] = first.slice(length);
            return buffer;
        }
    }
    for(var i = 0, n = queue.length; i < n; i++){
        if (remain < queue[i].length) break;
        remain -= queue[i].length;
    }
    buffers = queue.splice(0, i);
    if (remain > 0 && queue.length > 0) {
        buffers.push(queue[0].slice(0, remain));
        queue[0] = queue[0].slice(remain);
    }
    return Buffer.concat(buffers, length);
};
StreamReader.prototype.eachByte = function(callback, context) {
    var buffer, n, index;
    while(this._queue.length > 0){
        buffer = this._queue[0];
        n = buffer.length;
        while(this._offset < n){
            index = this._offset;
            this._offset += 1;
            callback.call(context, buffer[index]);
        }
        this._offset = 0;
        this._queue.shift();
    }
};
module.exports = StreamReader;
}),
"[project]/node_modules/websocket-driver/lib/websocket/driver/base.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-route] (ecmascript)").Buffer, Emitter = __turbopack_context__.r("[externals]/events [external] (events, cjs)").EventEmitter, util = __turbopack_context__.r("[externals]/util [external] (util, cjs)"), streams = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/streams.js [app-route] (ecmascript)"), Headers = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver/headers.js [app-route] (ecmascript)"), Reader = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver/stream_reader.js [app-route] (ecmascript)");
var Base = function(request, url, options) {
    Emitter.call(this);
    Base.validateOptions(options || {}, [
        'maxLength',
        'masking',
        'requireMasking',
        'protocols'
    ]);
    this._request = request;
    this._reader = new Reader();
    this._options = options || {};
    this._maxLength = this._options.maxLength || this.MAX_LENGTH;
    this._headers = new Headers();
    this.__queue = [];
    this.readyState = 0;
    this.url = url;
    this.io = new streams.IO(this);
    this.messages = new streams.Messages(this);
    this._bindEventListeners();
};
util.inherits(Base, Emitter);
Base.isWebSocket = function(request) {
    var connection = request.headers.connection || '', upgrade = request.headers.upgrade || '';
    return request.method === 'GET' && connection.toLowerCase().split(/ *, */).indexOf('upgrade') >= 0 && upgrade.toLowerCase() === 'websocket';
};
Base.validateOptions = function(options, validKeys) {
    for(var key in options){
        if (validKeys.indexOf(key) < 0) throw new Error('Unrecognized option: ' + key);
    }
};
var instance = {
    // This is 64MB, small enough for an average VPS to handle without
    // crashing from process out of memory
    MAX_LENGTH: 0x3ffffff,
    STATES: [
        'connecting',
        'open',
        'closing',
        'closed'
    ],
    _bindEventListeners: function() {
        var self = this;
        // Protocol errors are informational and do not have to be handled
        this.messages.on('error', function() {});
        this.on('message', function(event) {
            var messages = self.messages;
            if (messages.readable) messages.emit('data', event.data);
        });
        this.on('error', function(error) {
            var messages = self.messages;
            if (messages.readable) messages.emit('error', error);
        });
        this.on('close', function() {
            var messages = self.messages;
            if (!messages.readable) return;
            messages.readable = messages.writable = false;
            messages.emit('end');
        });
    },
    getState: function() {
        return this.STATES[this.readyState] || null;
    },
    addExtension: function(extension) {
        return false;
    },
    setHeader: function(name, value) {
        if (this.readyState > 0) return false;
        this._headers.set(name, value);
        return true;
    },
    start: function() {
        if (this.readyState !== 0) return false;
        if (!Base.isWebSocket(this._request)) return this._failHandshake(new Error('Not a WebSocket request'));
        var response;
        try {
            response = this._handshakeResponse();
        } catch (error) {
            return this._failHandshake(error);
        }
        this._write(response);
        if (this._stage !== -1) this._open();
        return true;
    },
    _failHandshake: function(error) {
        var headers = new Headers();
        headers.set('Content-Type', 'text/plain');
        headers.set('Content-Length', Buffer.byteLength(error.message, 'utf8'));
        headers = [
            'HTTP/1.1 400 Bad Request',
            headers.toString(),
            error.message
        ];
        this._write(Buffer.from(headers.join('\r\n'), 'utf8'));
        this._fail('protocol_error', error.message);
        return false;
    },
    text: function(message) {
        return this.frame(message);
    },
    binary: function(message) {
        return false;
    },
    ping: function() {
        return false;
    },
    pong: function() {
        return false;
    },
    close: function(reason, code) {
        if (this.readyState !== 1) return false;
        this.readyState = 3;
        this.emit('close', new Base.CloseEvent(null, null));
        return true;
    },
    _open: function() {
        this.readyState = 1;
        this.__queue.forEach(function(args) {
            this.frame.apply(this, args);
        }, this);
        this.__queue = [];
        this.emit('open', new Base.OpenEvent());
    },
    _queue: function(message) {
        this.__queue.push(message);
        return true;
    },
    _write: function(chunk) {
        var io = this.io;
        if (io.readable) io.emit('data', chunk);
    },
    _fail: function(type, message) {
        this.readyState = 2;
        this.emit('error', new Error(message));
        this.close();
    }
};
for(var key in instance)Base.prototype[key] = instance[key];
Base.ConnectEvent = function() {};
Base.OpenEvent = function() {};
Base.CloseEvent = function(code, reason) {
    this.code = code;
    this.reason = reason;
};
Base.MessageEvent = function(data) {
    this.data = data;
};
Base.PingEvent = function(data) {
    this.data = data;
};
Base.PongEvent = function(data) {
    this.data = data;
};
module.exports = Base;
}),
"[project]/node_modules/websocket-driver/lib/websocket/http_parser.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var NodeHTTPParser = __turbopack_context__.r("[project]/node_modules/http-parser-js/http-parser.js [app-route] (ecmascript)").HTTPParser, Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-route] (ecmascript)").Buffer;
var TYPES = {
    request: NodeHTTPParser.REQUEST || 'request',
    response: NodeHTTPParser.RESPONSE || 'response'
};
var HttpParser = function(type) {
    this._type = type;
    this._parser = new NodeHTTPParser(TYPES[type]);
    this._complete = false;
    this.headers = {};
    var current = null, self = this;
    this._parser.onHeaderField = function(b, start, length) {
        current = b.toString('utf8', start, start + length).toLowerCase();
    };
    this._parser.onHeaderValue = function(b, start, length) {
        var value = b.toString('utf8', start, start + length);
        if (self.headers.hasOwnProperty(current)) self.headers[current] += ', ' + value;
        else self.headers[current] = value;
    };
    this._parser.onHeadersComplete = this._parser[NodeHTTPParser.kOnHeadersComplete] = function(majorVersion, minorVersion, headers, method, pathname, statusCode) {
        var info = arguments[0];
        if (typeof info === 'object') {
            method = info.method;
            pathname = info.url;
            statusCode = info.statusCode;
            headers = info.headers;
        }
        self.method = typeof method === 'number' ? HttpParser.METHODS[method] : method;
        self.statusCode = statusCode;
        self.url = pathname;
        if (!headers) return;
        for(var i = 0, n = headers.length, key, value; i < n; i += 2){
            key = headers[i].toLowerCase();
            value = headers[i + 1];
            if (self.headers.hasOwnProperty(key)) self.headers[key] += ', ' + value;
            else self.headers[key] = value;
        }
        self._complete = true;
    };
};
HttpParser.METHODS = {
    0: 'DELETE',
    1: 'GET',
    2: 'HEAD',
    3: 'POST',
    4: 'PUT',
    5: 'CONNECT',
    6: 'OPTIONS',
    7: 'TRACE',
    8: 'COPY',
    9: 'LOCK',
    10: 'MKCOL',
    11: 'MOVE',
    12: 'PROPFIND',
    13: 'PROPPATCH',
    14: 'SEARCH',
    15: 'UNLOCK',
    16: 'BIND',
    17: 'REBIND',
    18: 'UNBIND',
    19: 'ACL',
    20: 'REPORT',
    21: 'MKACTIVITY',
    22: 'CHECKOUT',
    23: 'MERGE',
    24: 'M-SEARCH',
    25: 'NOTIFY',
    26: 'SUBSCRIBE',
    27: 'UNSUBSCRIBE',
    28: 'PATCH',
    29: 'PURGE',
    30: 'MKCALENDAR',
    31: 'LINK',
    32: 'UNLINK'
};
var VERSION = process.version ? process.version.match(/[0-9]+/g).map(function(n) {
    return parseInt(n, 10);
}) : [];
if (VERSION[0] === 0 && VERSION[1] === 12) {
    HttpParser.METHODS[16] = 'REPORT';
    HttpParser.METHODS[17] = 'MKACTIVITY';
    HttpParser.METHODS[18] = 'CHECKOUT';
    HttpParser.METHODS[19] = 'MERGE';
    HttpParser.METHODS[20] = 'M-SEARCH';
    HttpParser.METHODS[21] = 'NOTIFY';
    HttpParser.METHODS[22] = 'SUBSCRIBE';
    HttpParser.METHODS[23] = 'UNSUBSCRIBE';
    HttpParser.METHODS[24] = 'PATCH';
    HttpParser.METHODS[25] = 'PURGE';
}
HttpParser.prototype.isComplete = function() {
    return this._complete;
};
HttpParser.prototype.parse = function(chunk) {
    var consumed = this._parser.execute(chunk, 0, chunk.length);
    if (typeof consumed !== 'number') {
        this.error = consumed;
        this._complete = true;
        return;
    }
    if (this._complete) this.body = consumed < chunk.length ? chunk.slice(consumed) : Buffer.alloc(0);
};
module.exports = HttpParser;
}),
"[project]/node_modules/websocket-driver/lib/websocket/driver/hybi/frame.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Frame = function() {};
var instance = {
    final: false,
    rsv1: false,
    rsv2: false,
    rsv3: false,
    opcode: null,
    masked: false,
    maskingKey: null,
    lengthBytes: 1,
    length: 0,
    payload: null
};
for(var key in instance)Frame.prototype[key] = instance[key];
module.exports = Frame;
}),
"[project]/node_modules/websocket-driver/lib/websocket/driver/hybi/message.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-route] (ecmascript)").Buffer;
var Message = function() {
    this.rsv1 = false;
    this.rsv2 = false;
    this.rsv3 = false;
    this.opcode = null;
    this.length = 0;
    this._chunks = [];
};
var instance = {
    read: function() {
        return this.data = this.data || Buffer.concat(this._chunks, this.length);
    },
    pushFrame: function(frame) {
        this.rsv1 = this.rsv1 || frame.rsv1;
        this.rsv2 = this.rsv2 || frame.rsv2;
        this.rsv3 = this.rsv3 || frame.rsv3;
        if (this.opcode === null) this.opcode = frame.opcode;
        this._chunks.push(frame.payload);
        this.length += frame.length;
    }
};
for(var key in instance)Message.prototype[key] = instance[key];
module.exports = Message;
}),
"[project]/node_modules/websocket-driver/lib/websocket/driver/hybi.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-route] (ecmascript)").Buffer, crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)"), util = __turbopack_context__.r("[externals]/util [external] (util, cjs)"), Extensions = __turbopack_context__.r("[project]/node_modules/websocket-extensions/lib/websocket_extensions.js [app-route] (ecmascript)"), Base = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver/base.js [app-route] (ecmascript)"), Frame = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver/hybi/frame.js [app-route] (ecmascript)"), Message = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver/hybi/message.js [app-route] (ecmascript)");
var Hybi = function(request, url, options) {
    Base.apply(this, arguments);
    this._extensions = new Extensions();
    this._stage = 0;
    this._masking = this._options.masking;
    this._protocols = this._options.protocols || [];
    this._requireMasking = this._options.requireMasking;
    this._pingCallbacks = {};
    if (typeof this._protocols === 'string') this._protocols = this._protocols.split(/ *, */);
    if (!this._request) return;
    var protos = this._request.headers['sec-websocket-protocol'], supported = this._protocols;
    if (protos !== undefined) {
        if (typeof protos === 'string') protos = protos.split(/ *, */);
        this.protocol = protos.filter(function(p) {
            return supported.indexOf(p) >= 0;
        })[0];
    }
    this.version = 'hybi-' + Hybi.VERSION;
};
util.inherits(Hybi, Base);
Hybi.VERSION = '13';
Hybi.mask = function(payload, mask, offset) {
    if (!mask || mask.length === 0) return payload;
    offset = offset || 0;
    for(var i = 0, n = payload.length - offset; i < n; i++){
        payload[offset + i] = payload[offset + i] ^ mask[i % 4];
    }
    return payload;
};
Hybi.generateAccept = function(key) {
    var sha1 = crypto.createHash('sha1');
    sha1.update(key + Hybi.GUID);
    return sha1.digest('base64');
};
Hybi.GUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';
var instance = {
    FIN: 0x80,
    MASK: 0x80,
    RSV1: 0x40,
    RSV2: 0x20,
    RSV3: 0x10,
    OPCODE: 0x0F,
    LENGTH: 0x7F,
    OPCODES: {
        continuation: 0,
        text: 1,
        binary: 2,
        close: 8,
        ping: 9,
        pong: 10
    },
    OPCODE_CODES: [
        0,
        1,
        2,
        8,
        9,
        10
    ],
    MESSAGE_OPCODES: [
        0,
        1,
        2
    ],
    OPENING_OPCODES: [
        1,
        2
    ],
    ERRORS: {
        normal_closure: 1000,
        going_away: 1001,
        protocol_error: 1002,
        unacceptable: 1003,
        encoding_error: 1007,
        policy_violation: 1008,
        too_large: 1009,
        extension_error: 1010,
        unexpected_condition: 1011
    },
    ERROR_CODES: [
        1000,
        1001,
        1002,
        1003,
        1007,
        1008,
        1009,
        1010,
        1011
    ],
    DEFAULT_ERROR_CODE: 1000,
    MIN_RESERVED_ERROR: 3000,
    MAX_RESERVED_ERROR: 4999,
    // http://www.w3.org/International/questions/qa-forms-utf-8.en.php
    UTF8_MATCH: /^([\x00-\x7F]|[\xC2-\xDF][\x80-\xBF]|\xE0[\xA0-\xBF][\x80-\xBF]|[\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}|\xED[\x80-\x9F][\x80-\xBF]|\xF0[\x90-\xBF][\x80-\xBF]{2}|[\xF1-\xF3][\x80-\xBF]{3}|\xF4[\x80-\x8F][\x80-\xBF]{2})*$/,
    addExtension: function(extension) {
        this._extensions.add(extension);
        return true;
    },
    parse: function(chunk) {
        this._reader.put(chunk);
        var buffer = true;
        while(buffer){
            switch(this._stage){
                case 0:
                    buffer = this._reader.read(1);
                    if (buffer) this._parseOpcode(buffer[0]);
                    break;
                case 1:
                    buffer = this._reader.read(1);
                    if (buffer) this._parseLength(buffer[0]);
                    break;
                case 2:
                    buffer = this._reader.read(this._frame.lengthBytes);
                    if (buffer) this._parseExtendedLength(buffer);
                    break;
                case 3:
                    buffer = this._reader.read(4);
                    if (buffer) {
                        this._stage = 4;
                        this._frame.maskingKey = buffer;
                    }
                    break;
                case 4:
                    buffer = this._reader.read(this._frame.length);
                    if (buffer) {
                        this._stage = 0;
                        this._emitFrame(buffer);
                    }
                    break;
                default:
                    buffer = null;
            }
        }
    },
    text: function(message) {
        if (this.readyState > 1) return false;
        return this.frame(message, 'text');
    },
    binary: function(message) {
        if (this.readyState > 1) return false;
        return this.frame(message, 'binary');
    },
    ping: function(message, callback) {
        if (this.readyState > 1) return false;
        message = message || '';
        if (callback) this._pingCallbacks[message] = callback;
        return this.frame(message, 'ping');
    },
    pong: function(message) {
        if (this.readyState > 1) return false;
        message = message || '';
        return this.frame(message, 'pong');
    },
    close: function(reason, code) {
        reason = reason || '';
        code = code || this.ERRORS.normal_closure;
        if (this.readyState <= 0) {
            this.readyState = 3;
            this.emit('close', new Base.CloseEvent(code, reason));
            return true;
        } else if (this.readyState === 1) {
            this.readyState = 2;
            this._extensions.close(function() {
                this.frame(reason, 'close', code);
            }, this);
            return true;
        } else {
            return false;
        }
    },
    frame: function(buffer, type, code) {
        if (this.readyState <= 0) return this._queue([
            buffer,
            type,
            code
        ]);
        if (this.readyState > 2) return false;
        if (buffer instanceof Array) buffer = Buffer.from(buffer);
        if (typeof buffer === 'number') buffer = buffer.toString();
        var message = new Message(), isText = typeof buffer === 'string', payload, copy;
        message.rsv1 = message.rsv2 = message.rsv3 = false;
        message.opcode = this.OPCODES[type || (isText ? 'text' : 'binary')];
        payload = isText ? Buffer.from(buffer, 'utf8') : buffer;
        if (code) {
            copy = payload;
            payload = Buffer.allocUnsafe(2 + copy.length);
            payload.writeUInt16BE(code, 0);
            copy.copy(payload, 2);
        }
        message.data = payload;
        var onMessageReady = function(message) {
            var frame = new Frame();
            frame.final = true;
            frame.rsv1 = message.rsv1;
            frame.rsv2 = message.rsv2;
            frame.rsv3 = message.rsv3;
            frame.opcode = message.opcode;
            frame.masked = !!this._masking;
            frame.length = message.data.length;
            frame.payload = message.data;
            if (frame.masked) frame.maskingKey = crypto.randomBytes(4);
            this._sendFrame(frame);
        };
        if (this.MESSAGE_OPCODES.indexOf(message.opcode) >= 0) this._extensions.processOutgoingMessage(message, function(error, message) {
            if (error) return this._fail('extension_error', error.message);
            onMessageReady.call(this, message);
        }, this);
        else onMessageReady.call(this, message);
        return true;
    },
    _sendFrame: function(frame) {
        var length = frame.length, header = length <= 125 ? 2 : length <= 65535 ? 4 : 10, offset = header + (frame.masked ? 4 : 0), buffer = Buffer.allocUnsafe(offset + length), masked = frame.masked ? this.MASK : 0;
        buffer[0] = (frame.final ? this.FIN : 0) | (frame.rsv1 ? this.RSV1 : 0) | (frame.rsv2 ? this.RSV2 : 0) | (frame.rsv3 ? this.RSV3 : 0) | frame.opcode;
        if (length <= 125) {
            buffer[1] = masked | length;
        } else if (length <= 65535) {
            buffer[1] = masked | 126;
            buffer.writeUInt16BE(length, 2);
        } else {
            buffer[1] = masked | 127;
            buffer.writeUInt32BE(Math.floor(length / 0x100000000), 2);
            buffer.writeUInt32BE(length % 0x100000000, 6);
        }
        frame.payload.copy(buffer, offset);
        if (frame.masked) {
            frame.maskingKey.copy(buffer, header);
            Hybi.mask(buffer, frame.maskingKey, offset);
        }
        this._write(buffer);
    },
    _handshakeResponse: function() {
        var secKey = this._request.headers['sec-websocket-key'], version = this._request.headers['sec-websocket-version'];
        if (version !== Hybi.VERSION) throw new Error('Unsupported WebSocket version: ' + version);
        if (typeof secKey !== 'string') throw new Error('Missing handshake request header: Sec-WebSocket-Key');
        this._headers.set('Upgrade', 'websocket');
        this._headers.set('Connection', 'Upgrade');
        this._headers.set('Sec-WebSocket-Accept', Hybi.generateAccept(secKey));
        if (this.protocol) this._headers.set('Sec-WebSocket-Protocol', this.protocol);
        var extensions = this._extensions.generateResponse(this._request.headers['sec-websocket-extensions']);
        if (extensions) this._headers.set('Sec-WebSocket-Extensions', extensions);
        var start = 'HTTP/1.1 101 Switching Protocols', headers = [
            start,
            this._headers.toString(),
            ''
        ];
        return Buffer.from(headers.join('\r\n'), 'utf8');
    },
    _shutdown: function(code, reason, error) {
        delete this._frame;
        delete this._message;
        this._stage = 5;
        var sendCloseFrame = this.readyState === 1;
        this.readyState = 2;
        this._extensions.close(function() {
            if (sendCloseFrame) this.frame(reason, 'close', code);
            this.readyState = 3;
            if (error) this.emit('error', new Error(reason));
            this.emit('close', new Base.CloseEvent(code, reason));
        }, this);
    },
    _fail: function(type, message) {
        if (this.readyState > 1) return;
        this._shutdown(this.ERRORS[type], message, true);
    },
    _parseOpcode: function(octet) {
        var rsvs = [
            this.RSV1,
            this.RSV2,
            this.RSV3
        ].map(function(rsv) {
            return (octet & rsv) === rsv;
        });
        var frame = this._frame = new Frame();
        frame.final = (octet & this.FIN) === this.FIN;
        frame.rsv1 = rsvs[0];
        frame.rsv2 = rsvs[1];
        frame.rsv3 = rsvs[2];
        frame.opcode = octet & this.OPCODE;
        this._stage = 1;
        if (!this._extensions.validFrameRsv(frame)) return this._fail('protocol_error', 'One or more reserved bits are on: reserved1 = ' + (frame.rsv1 ? 1 : 0) + ', reserved2 = ' + (frame.rsv2 ? 1 : 0) + ', reserved3 = ' + (frame.rsv3 ? 1 : 0));
        if (this.OPCODE_CODES.indexOf(frame.opcode) < 0) return this._fail('protocol_error', 'Unrecognized frame opcode: ' + frame.opcode);
        if (this.MESSAGE_OPCODES.indexOf(frame.opcode) < 0 && !frame.final) return this._fail('protocol_error', 'Received fragmented control frame: opcode = ' + frame.opcode);
        if (this._message && this.OPENING_OPCODES.indexOf(frame.opcode) >= 0) return this._fail('protocol_error', 'Received new data frame but previous continuous frame is unfinished');
    },
    _parseLength: function(octet) {
        var frame = this._frame;
        frame.masked = (octet & this.MASK) === this.MASK;
        frame.length = octet & this.LENGTH;
        if (frame.length >= 0 && frame.length <= 125) {
            this._stage = frame.masked ? 3 : 4;
            if (!this._checkFrameLength()) return;
        } else {
            this._stage = 2;
            frame.lengthBytes = frame.length === 126 ? 2 : 8;
        }
        if (this._requireMasking && !frame.masked) return this._fail('unacceptable', 'Received unmasked frame but masking is required');
    },
    _parseExtendedLength: function(buffer) {
        var frame = this._frame;
        frame.length = this._readUInt(buffer);
        this._stage = frame.masked ? 3 : 4;
        if (this.MESSAGE_OPCODES.indexOf(frame.opcode) < 0 && frame.length > 125) return this._fail('protocol_error', 'Received control frame having too long payload: ' + frame.length);
        if (!this._checkFrameLength()) return;
    },
    _checkFrameLength: function() {
        var length = this._message ? this._message.length : 0;
        if (length + this._frame.length > this._maxLength) {
            this._fail('too_large', 'WebSocket frame length too large');
            return false;
        } else {
            return true;
        }
    },
    _emitFrame: function(buffer) {
        var frame = this._frame, payload = frame.payload = Hybi.mask(buffer, frame.maskingKey), opcode = frame.opcode, message, code, reason, callbacks, callback;
        delete this._frame;
        if (opcode === this.OPCODES.continuation) {
            if (!this._message) return this._fail('protocol_error', 'Received unexpected continuation frame');
            this._message.pushFrame(frame);
        }
        if (opcode === this.OPCODES.text || opcode === this.OPCODES.binary) {
            this._message = new Message();
            this._message.pushFrame(frame);
        }
        if (frame.final && this.MESSAGE_OPCODES.indexOf(opcode) >= 0) return this._emitMessage(this._message);
        if (opcode === this.OPCODES.close) {
            code = payload.length >= 2 ? payload.readUInt16BE(0) : null;
            reason = payload.length > 2 ? this._encode(payload.slice(2)) : null;
            if (!(payload.length === 0) && !(code !== null && code >= this.MIN_RESERVED_ERROR && code <= this.MAX_RESERVED_ERROR) && this.ERROR_CODES.indexOf(code) < 0) code = this.ERRORS.protocol_error;
            if (payload.length > 125 || payload.length > 2 && !reason) code = this.ERRORS.protocol_error;
            this._shutdown(code || this.DEFAULT_ERROR_CODE, reason || '');
        }
        if (opcode === this.OPCODES.ping) {
            this.frame(payload, 'pong');
            this.emit('ping', new Base.PingEvent(payload.toString()));
        }
        if (opcode === this.OPCODES.pong) {
            callbacks = this._pingCallbacks;
            message = this._encode(payload);
            callback = callbacks[message];
            delete callbacks[message];
            if (callback) callback();
            this.emit('pong', new Base.PongEvent(payload.toString()));
        }
    },
    _emitMessage: function(message) {
        var message = this._message;
        message.read();
        delete this._message;
        this._extensions.processIncomingMessage(message, function(error, message) {
            if (error) return this._fail('extension_error', error.message);
            var payload = message.data;
            if (message.opcode === this.OPCODES.text) payload = this._encode(payload);
            if (payload === null) return this._fail('encoding_error', 'Could not decode a text frame as UTF-8');
            else this.emit('message', new Base.MessageEvent(payload));
        }, this);
    },
    _encode: function(buffer) {
        try {
            var string = buffer.toString('binary', 0, buffer.length);
            if (!this.UTF8_MATCH.test(string)) return null;
        } catch (e) {}
        return buffer.toString('utf8', 0, buffer.length);
    },
    _readUInt: function(buffer) {
        if (buffer.length === 2) return buffer.readUInt16BE(0);
        return buffer.readUInt32BE(0) * 0x100000000 + buffer.readUInt32BE(4);
    }
};
for(var key in instance)Hybi.prototype[key] = instance[key];
module.exports = Hybi;
}),
"[project]/node_modules/websocket-driver/lib/websocket/driver/proxy.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-route] (ecmascript)").Buffer, Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream, url = __turbopack_context__.r("[externals]/url [external] (url, cjs)"), util = __turbopack_context__.r("[externals]/util [external] (util, cjs)"), Base = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver/base.js [app-route] (ecmascript)"), Headers = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver/headers.js [app-route] (ecmascript)"), HttpParser = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/http_parser.js [app-route] (ecmascript)");
var PORTS = {
    'ws:': 80,
    'wss:': 443
};
var Proxy = function(client, origin, options) {
    this._client = client;
    this._http = new HttpParser('response');
    this._origin = typeof client.url === 'object' ? client.url : url.parse(client.url);
    this._url = typeof origin === 'object' ? origin : url.parse(origin);
    this._options = options || {};
    this._state = 0;
    this.readable = this.writable = true;
    this._paused = false;
    this._headers = new Headers();
    this._headers.set('Host', this._origin.host);
    this._headers.set('Connection', 'keep-alive');
    this._headers.set('Proxy-Connection', 'keep-alive');
    var auth = this._url.auth && Buffer.from(this._url.auth, 'utf8').toString('base64');
    if (auth) this._headers.set('Proxy-Authorization', 'Basic ' + auth);
};
util.inherits(Proxy, Stream);
var instance = {
    setHeader: function(name, value) {
        if (this._state !== 0) return false;
        this._headers.set(name, value);
        return true;
    },
    start: function() {
        if (this._state !== 0) return false;
        this._state = 1;
        var origin = this._origin, port = origin.port || PORTS[origin.protocol], start = 'CONNECT ' + origin.hostname + ':' + port + ' HTTP/1.1';
        var headers = [
            start,
            this._headers.toString(),
            ''
        ];
        this.emit('data', Buffer.from(headers.join('\r\n'), 'utf8'));
        return true;
    },
    pause: function() {
        this._paused = true;
    },
    resume: function() {
        this._paused = false;
        this.emit('drain');
    },
    write: function(chunk) {
        if (!this.writable) return false;
        this._http.parse(chunk);
        if (!this._http.isComplete()) return !this._paused;
        this.statusCode = this._http.statusCode;
        this.headers = this._http.headers;
        if (this.statusCode === 200) {
            this.emit('connect', new Base.ConnectEvent());
        } else {
            var message = "Can't establish a connection to the server at " + this._origin.href;
            this.emit('error', new Error(message));
        }
        this.end();
        return !this._paused;
    },
    end: function(chunk) {
        if (!this.writable) return;
        if (chunk !== undefined) this.write(chunk);
        this.readable = this.writable = false;
        this.emit('close');
        this.emit('end');
    },
    destroy: function() {
        this.end();
    }
};
for(var key in instance)Proxy.prototype[key] = instance[key];
module.exports = Proxy;
}),
"[project]/node_modules/websocket-driver/lib/websocket/driver/client.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-route] (ecmascript)").Buffer, crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)"), url = __turbopack_context__.r("[externals]/url [external] (url, cjs)"), util = __turbopack_context__.r("[externals]/util [external] (util, cjs)"), HttpParser = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/http_parser.js [app-route] (ecmascript)"), Base = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver/base.js [app-route] (ecmascript)"), Hybi = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver/hybi.js [app-route] (ecmascript)"), Proxy = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver/proxy.js [app-route] (ecmascript)");
var Client = function(_url, options) {
    this.version = 'hybi-' + Hybi.VERSION;
    Hybi.call(this, null, _url, options);
    this.readyState = -1;
    this._key = Client.generateKey();
    this._accept = Hybi.generateAccept(this._key);
    this._http = new HttpParser('response');
    var uri = url.parse(this.url), auth = uri.auth && Buffer.from(uri.auth, 'utf8').toString('base64');
    if (this.VALID_PROTOCOLS.indexOf(uri.protocol) < 0) throw new Error(this.url + ' is not a valid WebSocket URL');
    this._pathname = (uri.pathname || '/') + (uri.search || '');
    this._headers.set('Host', uri.host);
    this._headers.set('Upgrade', 'websocket');
    this._headers.set('Connection', 'Upgrade');
    this._headers.set('Sec-WebSocket-Key', this._key);
    this._headers.set('Sec-WebSocket-Version', Hybi.VERSION);
    if (this._protocols.length > 0) this._headers.set('Sec-WebSocket-Protocol', this._protocols.join(', '));
    if (auth) this._headers.set('Authorization', 'Basic ' + auth);
};
util.inherits(Client, Hybi);
Client.generateKey = function() {
    return crypto.randomBytes(16).toString('base64');
};
var instance = {
    VALID_PROTOCOLS: [
        'ws:',
        'wss:'
    ],
    proxy: function(origin, options) {
        return new Proxy(this, origin, options);
    },
    start: function() {
        if (this.readyState !== -1) return false;
        this._write(this._handshakeRequest());
        this.readyState = 0;
        return true;
    },
    parse: function(chunk) {
        if (this.readyState === 3) return;
        if (this.readyState > 0) return Hybi.prototype.parse.call(this, chunk);
        this._http.parse(chunk);
        if (!this._http.isComplete()) return;
        this._validateHandshake();
        if (this.readyState === 3) return;
        this._open();
        this.parse(this._http.body);
    },
    _handshakeRequest: function() {
        var extensions = this._extensions.generateOffer();
        if (extensions) this._headers.set('Sec-WebSocket-Extensions', extensions);
        var start = 'GET ' + this._pathname + ' HTTP/1.1', headers = [
            start,
            this._headers.toString(),
            ''
        ];
        return Buffer.from(headers.join('\r\n'), 'utf8');
    },
    _failHandshake: function(message) {
        message = 'Error during WebSocket handshake: ' + message;
        this.readyState = 3;
        this.emit('error', new Error(message));
        this.emit('close', new Base.CloseEvent(this.ERRORS.protocol_error, message));
    },
    _validateHandshake: function() {
        this.statusCode = this._http.statusCode;
        this.headers = this._http.headers;
        if (this._http.error) return this._failHandshake(this._http.error.message);
        if (this._http.statusCode !== 101) return this._failHandshake('Unexpected response code: ' + this._http.statusCode);
        var headers = this._http.headers, upgrade = headers['upgrade'] || '', connection = headers['connection'] || '', accept = headers['sec-websocket-accept'] || '', protocol = headers['sec-websocket-protocol'] || '';
        if (upgrade === '') return this._failHandshake("'Upgrade' header is missing");
        if (upgrade.toLowerCase() !== 'websocket') return this._failHandshake("'Upgrade' header value is not 'WebSocket'");
        if (connection === '') return this._failHandshake("'Connection' header is missing");
        if (connection.toLowerCase() !== 'upgrade') return this._failHandshake("'Connection' header value is not 'Upgrade'");
        if (accept !== this._accept) return this._failHandshake('Sec-WebSocket-Accept mismatch');
        this.protocol = null;
        if (protocol !== '') {
            if (this._protocols.indexOf(protocol) < 0) return this._failHandshake('Sec-WebSocket-Protocol mismatch');
            else this.protocol = protocol;
        }
        try {
            this._extensions.activate(this.headers['sec-websocket-extensions']);
        } catch (e) {
            return this._failHandshake(e.message);
        }
    }
};
for(var key in instance)Client.prototype[key] = instance[key];
module.exports = Client;
}),
"[project]/node_modules/websocket-driver/lib/websocket/driver/draft75.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-route] (ecmascript)").Buffer, Base = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver/base.js [app-route] (ecmascript)"), util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
var Draft75 = function(request, url, options) {
    Base.apply(this, arguments);
    this._stage = 0;
    this.version = 'hixie-75';
    this._headers.set('Upgrade', 'WebSocket');
    this._headers.set('Connection', 'Upgrade');
    this._headers.set('WebSocket-Origin', this._request.headers.origin);
    this._headers.set('WebSocket-Location', this.url);
};
util.inherits(Draft75, Base);
var instance = {
    close: function() {
        if (this.readyState === 3) return false;
        this.readyState = 3;
        this.emit('close', new Base.CloseEvent(null, null));
        return true;
    },
    parse: function(chunk) {
        if (this.readyState > 1) return;
        this._reader.put(chunk);
        this._reader.eachByte(function(octet) {
            var message;
            switch(this._stage){
                case -1:
                    this._body.push(octet);
                    this._sendHandshakeBody();
                    break;
                case 0:
                    this._parseLeadingByte(octet);
                    break;
                case 1:
                    this._length = (octet & 0x7F) + 128 * this._length;
                    if (this._closing && this._length === 0) {
                        return this.close();
                    } else if ((octet & 0x80) !== 0x80) {
                        if (this._length === 0) {
                            this._stage = 0;
                        } else {
                            this._skipped = 0;
                            this._stage = 2;
                        }
                    }
                    break;
                case 2:
                    if (octet === 0xFF) {
                        this._stage = 0;
                        message = Buffer.from(this._buffer).toString('utf8', 0, this._buffer.length);
                        this.emit('message', new Base.MessageEvent(message));
                    } else {
                        if (this._length) {
                            this._skipped += 1;
                            if (this._skipped === this._length) this._stage = 0;
                        } else {
                            this._buffer.push(octet);
                            if (this._buffer.length > this._maxLength) return this.close();
                        }
                    }
                    break;
            }
        }, this);
    },
    frame: function(buffer) {
        if (this.readyState === 0) return this._queue([
            buffer
        ]);
        if (this.readyState > 1) return false;
        if (typeof buffer !== 'string') buffer = buffer.toString();
        var length = Buffer.byteLength(buffer), frame = Buffer.allocUnsafe(length + 2);
        frame[0] = 0x00;
        frame.write(buffer, 1);
        frame[frame.length - 1] = 0xFF;
        this._write(frame);
        return true;
    },
    _handshakeResponse: function() {
        var start = 'HTTP/1.1 101 Web Socket Protocol Handshake', headers = [
            start,
            this._headers.toString(),
            ''
        ];
        return Buffer.from(headers.join('\r\n'), 'utf8');
    },
    _parseLeadingByte: function(octet) {
        if ((octet & 0x80) === 0x80) {
            this._length = 0;
            this._stage = 1;
        } else {
            delete this._length;
            delete this._skipped;
            this._buffer = [];
            this._stage = 2;
        }
    }
};
for(var key in instance)Draft75.prototype[key] = instance[key];
module.exports = Draft75;
}),
"[project]/node_modules/websocket-driver/lib/websocket/driver/draft76.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-route] (ecmascript)").Buffer, Base = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver/base.js [app-route] (ecmascript)"), Draft75 = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver/draft75.js [app-route] (ecmascript)"), crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)"), util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
var numberFromKey = function(key) {
    return parseInt((key.match(/[0-9]/g) || []).join(''), 10);
};
var spacesInKey = function(key) {
    return (key.match(/ /g) || []).length;
};
var Draft76 = function(request, url, options) {
    Draft75.apply(this, arguments);
    this._stage = -1;
    this._body = [];
    this.version = 'hixie-76';
    this._headers.clear();
    this._headers.set('Upgrade', 'WebSocket');
    this._headers.set('Connection', 'Upgrade');
    this._headers.set('Sec-WebSocket-Origin', this._request.headers.origin);
    this._headers.set('Sec-WebSocket-Location', this.url);
};
util.inherits(Draft76, Draft75);
var instance = {
    BODY_SIZE: 8,
    start: function() {
        if (!Draft75.prototype.start.call(this)) return false;
        this._started = true;
        this._sendHandshakeBody();
        return true;
    },
    close: function() {
        if (this.readyState === 3) return false;
        if (this.readyState === 1) this._write(Buffer.from([
            0xFF,
            0x00
        ]));
        this.readyState = 3;
        this.emit('close', new Base.CloseEvent(null, null));
        return true;
    },
    _handshakeResponse: function() {
        var headers = this._request.headers, key1 = headers['sec-websocket-key1'], key2 = headers['sec-websocket-key2'];
        if (!key1) throw new Error('Missing required header: Sec-WebSocket-Key1');
        if (!key2) throw new Error('Missing required header: Sec-WebSocket-Key2');
        var number1 = numberFromKey(key1), spaces1 = spacesInKey(key1), number2 = numberFromKey(key2), spaces2 = spacesInKey(key2);
        if (number1 % spaces1 !== 0 || number2 % spaces2 !== 0) throw new Error('Client sent invalid Sec-WebSocket-Key headers');
        this._keyValues = [
            number1 / spaces1,
            number2 / spaces2
        ];
        var start = 'HTTP/1.1 101 WebSocket Protocol Handshake', headers = [
            start,
            this._headers.toString(),
            ''
        ];
        return Buffer.from(headers.join('\r\n'), 'binary');
    },
    _handshakeSignature: function() {
        if (this._body.length < this.BODY_SIZE) return null;
        var md5 = crypto.createHash('md5'), buffer = Buffer.allocUnsafe(8 + this.BODY_SIZE);
        buffer.writeUInt32BE(this._keyValues[0], 0);
        buffer.writeUInt32BE(this._keyValues[1], 4);
        Buffer.from(this._body).copy(buffer, 8, 0, this.BODY_SIZE);
        md5.update(buffer);
        return Buffer.from(md5.digest('binary'), 'binary');
    },
    _sendHandshakeBody: function() {
        if (!this._started) return;
        var signature = this._handshakeSignature();
        if (!signature) return;
        this._write(signature);
        this._stage = 0;
        this._open();
        if (this._body.length > this.BODY_SIZE) this.parse(this._body.slice(this.BODY_SIZE));
    },
    _parseLeadingByte: function(octet) {
        if (octet !== 0xFF) return Draft75.prototype._parseLeadingByte.call(this, octet);
        this._closing = true;
        this._length = 0;
        this._stage = 1;
    }
};
for(var key in instance)Draft76.prototype[key] = instance[key];
module.exports = Draft76;
}),
"[project]/node_modules/websocket-driver/lib/websocket/driver/server.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)"), HttpParser = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/http_parser.js [app-route] (ecmascript)"), Base = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver/base.js [app-route] (ecmascript)"), Draft75 = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver/draft75.js [app-route] (ecmascript)"), Draft76 = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver/draft76.js [app-route] (ecmascript)"), Hybi = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver/hybi.js [app-route] (ecmascript)");
var Server = function(options) {
    Base.call(this, null, null, options);
    this._http = new HttpParser('request');
};
util.inherits(Server, Base);
var instance = {
    EVENTS: [
        'open',
        'message',
        'error',
        'close',
        'ping',
        'pong'
    ],
    _bindEventListeners: function() {
        this.messages.on('error', function() {});
        this.on('error', function() {});
    },
    parse: function(chunk) {
        if (this._delegate) return this._delegate.parse(chunk);
        this._http.parse(chunk);
        if (!this._http.isComplete()) return;
        this.method = this._http.method;
        this.url = this._http.url;
        this.headers = this._http.headers;
        this.body = this._http.body;
        var self = this;
        this._delegate = Server.http(this, this._options);
        this._delegate.messages = this.messages;
        this._delegate.io = this.io;
        this._open();
        this.EVENTS.forEach(function(event) {
            this._delegate.on(event, function(e) {
                self.emit(event, e);
            });
        }, this);
        this.protocol = this._delegate.protocol;
        this.version = this._delegate.version;
        this.parse(this._http.body);
        this.emit('connect', new Base.ConnectEvent());
    },
    _open: function() {
        this.__queue.forEach(function(msg) {
            this._delegate[msg[0]].apply(this._delegate, msg[1]);
        }, this);
        this.__queue = [];
    }
};
[
    'addExtension',
    'setHeader',
    'start',
    'frame',
    'text',
    'binary',
    'ping',
    'close'
].forEach(function(method) {
    instance[method] = function() {
        if (this._delegate) {
            return this._delegate[method].apply(this._delegate, arguments);
        } else {
            this.__queue.push([
                method,
                arguments
            ]);
            return true;
        }
    };
});
for(var key in instance)Server.prototype[key] = instance[key];
Server.isSecureRequest = function(request) {
    if (request.connection && request.connection.authorized !== undefined) return true;
    if (request.socket && request.socket.secure) return true;
    var headers = request.headers;
    if (!headers) return false;
    if (headers['https'] === 'on') return true;
    if (headers['x-forwarded-ssl'] === 'on') return true;
    if (headers['x-forwarded-scheme'] === 'https') return true;
    if (headers['x-forwarded-proto'] === 'https') return true;
    return false;
};
Server.determineUrl = function(request) {
    var scheme = this.isSecureRequest(request) ? 'wss:' : 'ws:';
    return scheme + '//' + request.headers.host + request.url;
};
Server.http = function(request, options) {
    options = options || {};
    if (options.requireMasking === undefined) options.requireMasking = true;
    var headers = request.headers, version = headers['sec-websocket-version'], key = headers['sec-websocket-key'], key1 = headers['sec-websocket-key1'], key2 = headers['sec-websocket-key2'], url = this.determineUrl(request);
    if (version || key) return new Hybi(request, url, options);
    else if (key1 || key2) return new Draft76(request, url, options);
    else return new Draft75(request, url, options);
};
module.exports = Server;
}),
"[project]/node_modules/websocket-driver/lib/websocket/driver.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Protocol references:
//
// * http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-75
// * http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-76
// * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17
var Base = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver/base.js [app-route] (ecmascript)"), Client = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver/client.js [app-route] (ecmascript)"), Server = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver/server.js [app-route] (ecmascript)");
var Driver = {
    client: function(url, options) {
        options = options || {};
        if (options.masking === undefined) options.masking = true;
        return new Client(url, options);
    },
    server: function(options) {
        options = options || {};
        if (options.requireMasking === undefined) options.requireMasking = true;
        return new Server(options);
    },
    http: function() {
        return Server.http.apply(Server, arguments);
    },
    isSecureRequest: function(request) {
        return Server.isSecureRequest(request);
    },
    isWebSocket: function(request) {
        return Base.isWebSocket(request);
    },
    validateOptions: function(options, validKeys) {
        Base.validateOptions(options, validKeys);
    }
};
module.exports = Driver;
}),
"[project]/node_modules/http-parser-js/http-parser.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*jshint node:true */ exports.HTTPParser = HTTPParser;
function HTTPParser(type) {
    if (type !== undefined && type !== HTTPParser.REQUEST && type !== HTTPParser.RESPONSE) {
        throw new Error('type must be REQUEST or RESPONSE');
    }
    if (type === undefined) {
    // Node v12+
    } else {
        this.initialize(type);
    }
    this.maxHeaderSize = HTTPParser.maxHeaderSize;
}
HTTPParser.prototype.initialize = function(type, async_resource) {
    if (type !== HTTPParser.REQUEST && type !== HTTPParser.RESPONSE) {
        throw new Error('type must be REQUEST or RESPONSE');
    }
    this.type = type;
    this.state = type + '_LINE';
    this.info = {
        headers: [],
        upgrade: false
    };
    this.trailers = [];
    this.line = '';
    this.isChunked = false;
    this.connection = '';
    this.headerSize = 0; // for preventing too big headers
    this.body_bytes = null;
    this.isUserCall = false;
    this.hadError = false;
};
HTTPParser.encoding = 'ascii';
HTTPParser.maxHeaderSize = 80 * 1024; // maxHeaderSize (in bytes) is configurable, but 80kb by default;
HTTPParser.REQUEST = 'REQUEST';
HTTPParser.RESPONSE = 'RESPONSE';
// Note: *not* starting with kOnHeaders=0 line the Node parser, because any
//   newly added constants (kOnTimeout in Node v12.19.0) will overwrite 0!
var kOnHeaders = HTTPParser.kOnHeaders = 1;
var kOnHeadersComplete = HTTPParser.kOnHeadersComplete = 2;
var kOnBody = HTTPParser.kOnBody = 3;
var kOnMessageComplete = HTTPParser.kOnMessageComplete = 4;
// Some handler stubs, needed for compatibility
HTTPParser.prototype[kOnHeaders] = HTTPParser.prototype[kOnHeadersComplete] = HTTPParser.prototype[kOnBody] = HTTPParser.prototype[kOnMessageComplete] = function() {};
var compatMode0_12 = true;
Object.defineProperty(HTTPParser, 'kOnExecute', {
    get: function() {
        // hack for backward compatibility
        compatMode0_12 = false;
        return 99;
    }
});
var methods = exports.methods = HTTPParser.methods = [
    'DELETE',
    'GET',
    'HEAD',
    'POST',
    'PUT',
    'CONNECT',
    'OPTIONS',
    'TRACE',
    'COPY',
    'LOCK',
    'MKCOL',
    'MOVE',
    'PROPFIND',
    'PROPPATCH',
    'SEARCH',
    'UNLOCK',
    'BIND',
    'REBIND',
    'UNBIND',
    'ACL',
    'REPORT',
    'MKACTIVITY',
    'CHECKOUT',
    'MERGE',
    'M-SEARCH',
    'NOTIFY',
    'SUBSCRIBE',
    'UNSUBSCRIBE',
    'PATCH',
    'PURGE',
    'MKCALENDAR',
    'LINK',
    'UNLINK',
    'SOURCE'
];
var method_connect = methods.indexOf('CONNECT');
HTTPParser.prototype.reinitialize = HTTPParser;
HTTPParser.prototype.close = HTTPParser.prototype.pause = HTTPParser.prototype.resume = HTTPParser.prototype.remove = HTTPParser.prototype.free = function() {};
HTTPParser.prototype._compatMode0_11 = false;
HTTPParser.prototype.getAsyncId = function() {
    return 0;
};
var headerState = {
    REQUEST_LINE: true,
    RESPONSE_LINE: true,
    HEADER: true
};
HTTPParser.prototype.execute = function(chunk, start, length) {
    if (!(this instanceof HTTPParser)) {
        throw new TypeError('not a HTTPParser');
    }
    // backward compat to node < 0.11.4
    // Note: the start and length params were removed in newer version
    start = start || 0;
    length = typeof length === 'number' ? length : chunk.length;
    this.chunk = chunk;
    this.offset = start;
    var end = this.end = start + length;
    try {
        while(this.offset < end){
            if (this[this.state]()) {
                break;
            }
        }
    } catch (err) {
        if (this.isUserCall) {
            throw err;
        }
        this.hadError = true;
        return err;
    }
    this.chunk = null;
    length = this.offset - start;
    if (headerState[this.state]) {
        this.headerSize += length;
        if (this.headerSize > (this.maxHeaderSize || HTTPParser.maxHeaderSize)) {
            return new Error('max header size exceeded');
        }
    }
    return length;
};
var stateFinishAllowed = {
    REQUEST_LINE: true,
    RESPONSE_LINE: true,
    BODY_RAW: true
};
HTTPParser.prototype.finish = function() {
    if (this.hadError) {
        return;
    }
    if (!stateFinishAllowed[this.state]) {
        return new Error('invalid state for EOF');
    }
    if (this.state === 'BODY_RAW') {
        this.userCall()(this[kOnMessageComplete]());
    }
};
// These three methods are used for an internal speed optimization, and it also
// works if theses are noops. Basically consume() asks us to read the bytes
// ourselves, but if we don't do it we get them through execute().
HTTPParser.prototype.consume = HTTPParser.prototype.unconsume = HTTPParser.prototype.getCurrentBuffer = function() {};
//For correct error handling - see HTTPParser#execute
//Usage: this.userCall()(userFunction('arg'));
HTTPParser.prototype.userCall = function() {
    this.isUserCall = true;
    var self = this;
    return function(ret) {
        self.isUserCall = false;
        return ret;
    };
};
HTTPParser.prototype.nextRequest = function() {
    this.userCall()(this[kOnMessageComplete]());
    this.reinitialize(this.type);
};
HTTPParser.prototype.consumeLine = function() {
    var end = this.end, chunk = this.chunk;
    for(var i = this.offset; i < end; i++){
        if (chunk[i] === 0x0a) {
            var line = this.line + chunk.toString(HTTPParser.encoding, this.offset, i);
            if (line.charAt(line.length - 1) === '\r') {
                line = line.substr(0, line.length - 1);
            }
            this.line = '';
            this.offset = i + 1;
            return line;
        }
    }
    //line split over multiple chunks
    this.line += chunk.toString(HTTPParser.encoding, this.offset, this.end);
    this.offset = this.end;
};
var headerExp = /^([^: \t]+):[ \t]*((?:.*[^ \t])|)/;
var headerContinueExp = /^[ \t]+(.*[^ \t])/;
HTTPParser.prototype.parseHeader = function(line, headers) {
    if (line.indexOf('\r') !== -1) {
        throw parseErrorCode('HPE_LF_EXPECTED');
    }
    var match = headerExp.exec(line);
    var k = match && match[1];
    if (k) {
        headers.push(k);
        headers.push(match[2]);
    } else {
        var matchContinue = headerContinueExp.exec(line);
        if (matchContinue && headers.length) {
            if (headers[headers.length - 1]) {
                headers[headers.length - 1] += ' ';
            }
            headers[headers.length - 1] += matchContinue[1];
        }
    }
};
var requestExp = /^([A-Z-]+) ([^ ]+) HTTP\/(\d)\.(\d)$/;
HTTPParser.prototype.REQUEST_LINE = function() {
    var line = this.consumeLine();
    if (!line) {
        return;
    }
    var match = requestExp.exec(line);
    if (match === null) {
        throw parseErrorCode('HPE_INVALID_CONSTANT');
    }
    this.info.method = this._compatMode0_11 ? match[1] : methods.indexOf(match[1]);
    if (this.info.method === -1) {
        throw new Error('invalid request method');
    }
    this.info.url = match[2];
    this.info.versionMajor = +match[3];
    this.info.versionMinor = +match[4];
    this.body_bytes = 0;
    this.state = 'HEADER';
};
var responseExp = /^HTTP\/(\d)\.(\d) (\d{3}) ?(.*)$/;
HTTPParser.prototype.RESPONSE_LINE = function() {
    var line = this.consumeLine();
    if (!line) {
        return;
    }
    var match = responseExp.exec(line);
    if (match === null) {
        throw parseErrorCode('HPE_INVALID_CONSTANT');
    }
    this.info.versionMajor = +match[1];
    this.info.versionMinor = +match[2];
    var statusCode = this.info.statusCode = +match[3];
    this.info.statusMessage = match[4];
    // Implied zero length.
    if ((statusCode / 100 | 0) === 1 || statusCode === 204 || statusCode === 304) {
        this.body_bytes = 0;
    }
    this.state = 'HEADER';
};
HTTPParser.prototype.shouldKeepAlive = function() {
    if (this.info.versionMajor > 0 && this.info.versionMinor > 0) {
        if (this.connection.indexOf('close') !== -1) {
            return false;
        }
    } else if (this.connection.indexOf('keep-alive') === -1) {
        return false;
    }
    if (this.body_bytes !== null || this.isChunked) {
        return true;
    }
    return false;
};
HTTPParser.prototype.HEADER = function() {
    var line = this.consumeLine();
    if (line === undefined) {
        return;
    }
    var info = this.info;
    if (line) {
        this.parseHeader(line, info.headers);
    } else {
        var headers = info.headers;
        var hasContentLength = false;
        var currentContentLengthValue;
        var hasUpgradeHeader = false;
        for(var i = 0; i < headers.length; i += 2){
            switch(headers[i].toLowerCase()){
                case 'transfer-encoding':
                    this.isChunked = headers[i + 1].toLowerCase() === 'chunked';
                    break;
                case 'content-length':
                    currentContentLengthValue = +headers[i + 1];
                    if (hasContentLength) {
                        // Fix duplicate Content-Length header with same values.
                        // Throw error only if values are different.
                        // Known issues:
                        // https://github.com/request/request/issues/2091#issuecomment-328715113
                        // https://github.com/nodejs/node/issues/6517#issuecomment-216263771
                        if (currentContentLengthValue !== this.body_bytes) {
                            throw parseErrorCode('HPE_UNEXPECTED_CONTENT_LENGTH');
                        }
                    } else {
                        hasContentLength = true;
                        this.body_bytes = currentContentLengthValue;
                    }
                    break;
                case 'connection':
                    this.connection += headers[i + 1].toLowerCase();
                    break;
                case 'upgrade':
                    hasUpgradeHeader = true;
                    break;
            }
        }
        // if both isChunked and hasContentLength, isChunked wins
        // This is required so the body is parsed using the chunked method, and matches
        // Chrome's behavior.  We could, maybe, ignore them both (would get chunked
        // encoding into the body), and/or disable shouldKeepAlive to be more
        // resilient.
        if (this.isChunked && hasContentLength) {
            hasContentLength = false;
            this.body_bytes = null;
        }
        // Logic from https://github.com/nodejs/http-parser/blob/921d5585515a153fa00e411cf144280c59b41f90/http_parser.c#L1727-L1737
        // "For responses, "Upgrade: foo" and "Connection: upgrade" are
        //   mandatory only when it is a 101 Switching Protocols response,
        //   otherwise it is purely informational, to announce support.
        if (hasUpgradeHeader && this.connection.indexOf('upgrade') != -1) {
            info.upgrade = this.type === HTTPParser.REQUEST || info.statusCode === 101;
        } else {
            info.upgrade = info.method === method_connect;
        }
        if (this.isChunked && info.upgrade) {
            this.isChunked = false;
        }
        info.shouldKeepAlive = this.shouldKeepAlive();
        //problem which also exists in original node: we should know skipBody before calling onHeadersComplete
        var skipBody;
        if (compatMode0_12) {
            skipBody = this.userCall()(this[kOnHeadersComplete](info));
        } else {
            skipBody = this.userCall()(this[kOnHeadersComplete](info.versionMajor, info.versionMinor, info.headers, info.method, info.url, info.statusCode, info.statusMessage, info.upgrade, info.shouldKeepAlive));
        }
        if (skipBody === 2) {
            this.nextRequest();
            return true;
        } else if (this.isChunked && !skipBody) {
            this.state = 'BODY_CHUNKHEAD';
        } else if (skipBody || this.body_bytes === 0) {
            this.nextRequest();
            // For older versions of node (v6.x and older?), that return skipBody=1 or skipBody=true,
            //   need this "return true;" if it's an upgrade request.
            return info.upgrade;
        } else if (this.body_bytes === null) {
            this.state = 'BODY_RAW';
        } else {
            this.state = 'BODY_SIZED';
        }
    }
};
HTTPParser.prototype.BODY_CHUNKHEAD = function() {
    var line = this.consumeLine();
    if (line === undefined) {
        return;
    }
    this.body_bytes = parseInt(line, 16);
    if (!this.body_bytes) {
        this.state = 'BODY_CHUNKTRAILERS';
    } else {
        this.state = 'BODY_CHUNK';
    }
};
HTTPParser.prototype.BODY_CHUNK = function() {
    var length = Math.min(this.end - this.offset, this.body_bytes);
    // 0, length are for backwards compatibility. See: https://github.com/creationix/http-parser-js/pull/98
    this.userCall()(this[kOnBody](this.chunk.slice(this.offset, this.offset + length), 0, length));
    this.offset += length;
    this.body_bytes -= length;
    if (!this.body_bytes) {
        this.state = 'BODY_CHUNKEMPTYLINE';
    }
};
HTTPParser.prototype.BODY_CHUNKEMPTYLINE = function() {
    var line = this.consumeLine();
    if (line === undefined) {
        return;
    }
    if (line !== '') {
        throw new Error('Expected empty line');
    }
    this.state = 'BODY_CHUNKHEAD';
};
HTTPParser.prototype.BODY_CHUNKTRAILERS = function() {
    var line = this.consumeLine();
    if (line === undefined) {
        return;
    }
    if (line) {
        this.parseHeader(line, this.trailers);
    } else {
        if (this.trailers.length) {
            this.userCall()(this[kOnHeaders](this.trailers, ''));
        }
        this.nextRequest();
    }
};
HTTPParser.prototype.BODY_RAW = function() {
    // 0, length are for backwards compatibility. See: https://github.com/creationix/http-parser-js/pull/98
    this.userCall()(this[kOnBody](this.chunk.slice(this.offset, this.end), 0, this.end - this.offset));
    this.offset = this.end;
};
HTTPParser.prototype.BODY_SIZED = function() {
    var length = Math.min(this.end - this.offset, this.body_bytes);
    // 0, length are for backwards compatibility. See: https://github.com/creationix/http-parser-js/pull/98
    this.userCall()(this[kOnBody](this.chunk.slice(this.offset, this.offset + length), 0, length));
    this.offset += length;
    this.body_bytes -= length;
    if (!this.body_bytes) {
        this.nextRequest();
    }
};
// backward compat to node < 0.11.6
[
    'Headers',
    'HeadersComplete',
    'Body',
    'MessageComplete'
].forEach(function(name) {
    var k = HTTPParser['kOn' + name];
    Object.defineProperty(HTTPParser.prototype, 'on' + name, {
        get: function() {
            return this[k];
        },
        set: function(to) {
            // hack for backward compatibility
            this._compatMode0_11 = true;
            method_connect = 'CONNECT';
            return this[k] = to;
        }
    });
});
function parseErrorCode(code) {
    var err = new Error('Parse Error');
    err.code = code;
    return err;
}
}),
"[project]/node_modules/websocket-extensions/lib/parser.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var TOKEN = /([!#\$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+)/, NOTOKEN = /([^!#\$%&'\*\+\-\.\^_`\|~0-9A-Za-z])/g, QUOTED = /"((?:\\[\x00-\x7f]|[^\x00-\x08\x0a-\x1f\x7f"\\])*)"/, PARAM = new RegExp(TOKEN.source + '(?:=(?:' + TOKEN.source + '|' + QUOTED.source + '))?'), EXT = new RegExp(TOKEN.source + '(?: *; *' + PARAM.source + ')*', 'g'), EXT_LIST = new RegExp('^' + EXT.source + '(?: *, *' + EXT.source + ')*$'), NUMBER = /^-?(0|[1-9][0-9]*)(\.[0-9]+)?$/;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var Parser = {
    parseHeader: function(header) {
        var offers = new Offers();
        if (header === '' || header === undefined) return offers;
        if (!EXT_LIST.test(header)) throw new SyntaxError('Invalid Sec-WebSocket-Extensions header: ' + header);
        var values = header.match(EXT);
        values.forEach(function(value) {
            var params = value.match(new RegExp(PARAM.source, 'g')), name = params.shift(), offer = {};
            params.forEach(function(param) {
                var args = param.match(PARAM), key = args[1], data;
                if (args[2] !== undefined) {
                    data = args[2];
                } else if (args[3] !== undefined) {
                    data = args[3].replace(/\\/g, '');
                } else {
                    data = true;
                }
                if (NUMBER.test(data)) data = parseFloat(data);
                if (hasOwnProperty.call(offer, key)) {
                    offer[key] = [].concat(offer[key]);
                    offer[key].push(data);
                } else {
                    offer[key] = data;
                }
            }, this);
            offers.push(name, offer);
        }, this);
        return offers;
    },
    serializeParams: function(name, params) {
        var values = [];
        var print = function(key, value) {
            if (value instanceof Array) {
                value.forEach(function(v) {
                    print(key, v);
                });
            } else if (value === true) {
                values.push(key);
            } else if (typeof value === 'number') {
                values.push(key + '=' + value);
            } else if (NOTOKEN.test(value)) {
                values.push(key + '="' + value.replace(/"/g, '\\"') + '"');
            } else {
                values.push(key + '=' + value);
            }
        };
        for(var key in params)print(key, params[key]);
        return [
            name
        ].concat(values).join('; ');
    }
};
var Offers = function() {
    this._byName = {};
    this._inOrder = [];
};
Offers.prototype.push = function(name, params) {
    if (!hasOwnProperty.call(this._byName, name)) this._byName[name] = [];
    this._byName[name].push(params);
    this._inOrder.push({
        name: name,
        params: params
    });
};
Offers.prototype.eachOffer = function(callback, context) {
    var list = this._inOrder;
    for(var i = 0, n = list.length; i < n; i++)callback.call(context, list[i].name, list[i].params);
};
Offers.prototype.byName = function(name) {
    return this._byName[name] || [];
};
Offers.prototype.toArray = function() {
    return this._inOrder.slice();
};
module.exports = Parser;
}),
"[project]/node_modules/websocket-extensions/lib/pipeline/ring_buffer.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RingBuffer = function(bufferSize) {
    this._bufferSize = bufferSize;
    this.clear();
};
RingBuffer.prototype.clear = function() {
    this._buffer = new Array(this._bufferSize);
    this._ringOffset = 0;
    this._ringSize = this._bufferSize;
    this._head = 0;
    this._tail = 0;
    this.length = 0;
};
RingBuffer.prototype.push = function(value) {
    var expandBuffer = false, expandRing = false;
    if (this._ringSize < this._bufferSize) {
        expandBuffer = this._tail === 0;
    } else if (this._ringOffset === this._ringSize) {
        expandBuffer = true;
        expandRing = this._tail === 0;
    }
    if (expandBuffer) {
        this._tail = this._bufferSize;
        this._buffer = this._buffer.concat(new Array(this._bufferSize));
        this._bufferSize = this._buffer.length;
        if (expandRing) this._ringSize = this._bufferSize;
    }
    this._buffer[this._tail] = value;
    this.length += 1;
    if (this._tail < this._ringSize) this._ringOffset += 1;
    this._tail = (this._tail + 1) % this._bufferSize;
};
RingBuffer.prototype.peek = function() {
    if (this.length === 0) return void 0;
    return this._buffer[this._head];
};
RingBuffer.prototype.shift = function() {
    if (this.length === 0) return void 0;
    var value = this._buffer[this._head];
    this._buffer[this._head] = void 0;
    this.length -= 1;
    this._ringOffset -= 1;
    if (this._ringOffset === 0 && this.length > 0) {
        this._head = this._ringSize;
        this._ringOffset = this.length;
        this._ringSize = this._bufferSize;
    } else {
        this._head = (this._head + 1) % this._ringSize;
    }
    return value;
};
module.exports = RingBuffer;
}),
"[project]/node_modules/websocket-extensions/lib/pipeline/functor.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RingBuffer = __turbopack_context__.r("[project]/node_modules/websocket-extensions/lib/pipeline/ring_buffer.js [app-route] (ecmascript)");
var Functor = function(session, method) {
    this._session = session;
    this._method = method;
    this._queue = new RingBuffer(Functor.QUEUE_SIZE);
    this._stopped = false;
    this.pending = 0;
};
Functor.QUEUE_SIZE = 8;
Functor.prototype.call = function(error, message, callback, context) {
    if (this._stopped) return;
    var record = {
        error: error,
        message: message,
        callback: callback,
        context: context,
        done: false
    }, called = false, self = this;
    this._queue.push(record);
    if (record.error) {
        record.done = true;
        this._stop();
        return this._flushQueue();
    }
    var handler = function(err, msg) {
        if (!(called ^ (called = true))) return;
        if (err) {
            self._stop();
            record.error = err;
            record.message = null;
        } else {
            record.message = msg;
        }
        record.done = true;
        self._flushQueue();
    };
    try {
        this._session[this._method](message, handler);
    } catch (err) {
        handler(err);
    }
};
Functor.prototype._stop = function() {
    this.pending = this._queue.length;
    this._stopped = true;
};
Functor.prototype._flushQueue = function() {
    var queue = this._queue, record;
    while(queue.length > 0 && queue.peek().done){
        record = queue.shift();
        if (record.error) {
            this.pending = 0;
            queue.clear();
        } else {
            this.pending -= 1;
        }
        record.callback.call(record.context, record.error, record.message);
    }
};
module.exports = Functor;
}),
"[project]/node_modules/websocket-extensions/lib/pipeline/pledge.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RingBuffer = __turbopack_context__.r("[project]/node_modules/websocket-extensions/lib/pipeline/ring_buffer.js [app-route] (ecmascript)");
var Pledge = function() {
    this._complete = false;
    this._callbacks = new RingBuffer(Pledge.QUEUE_SIZE);
};
Pledge.QUEUE_SIZE = 4;
Pledge.all = function(list) {
    var pledge = new Pledge(), pending = list.length, n = pending;
    if (pending === 0) pledge.done();
    while(n--)list[n].then(function() {
        pending -= 1;
        if (pending === 0) pledge.done();
    });
    return pledge;
};
Pledge.prototype.then = function(callback) {
    if (this._complete) callback();
    else this._callbacks.push(callback);
};
Pledge.prototype.done = function() {
    this._complete = true;
    var callbacks = this._callbacks, callback;
    while(callback = callbacks.shift())callback();
};
module.exports = Pledge;
}),
"[project]/node_modules/websocket-extensions/lib/pipeline/cell.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Functor = __turbopack_context__.r("[project]/node_modules/websocket-extensions/lib/pipeline/functor.js [app-route] (ecmascript)"), Pledge = __turbopack_context__.r("[project]/node_modules/websocket-extensions/lib/pipeline/pledge.js [app-route] (ecmascript)");
var Cell = function(tuple) {
    this._ext = tuple[0];
    this._session = tuple[1];
    this._functors = {
        incoming: new Functor(this._session, 'processIncomingMessage'),
        outgoing: new Functor(this._session, 'processOutgoingMessage')
    };
};
Cell.prototype.pending = function(direction) {
    var functor = this._functors[direction];
    if (!functor._stopped) functor.pending += 1;
};
Cell.prototype.incoming = function(error, message, callback, context) {
    this._exec('incoming', error, message, callback, context);
};
Cell.prototype.outgoing = function(error, message, callback, context) {
    this._exec('outgoing', error, message, callback, context);
};
Cell.prototype.close = function() {
    this._closed = this._closed || new Pledge();
    this._doClose();
    return this._closed;
};
Cell.prototype._exec = function(direction, error, message, callback, context) {
    this._functors[direction].call(error, message, function(err, msg) {
        if (err) err.message = this._ext.name + ': ' + err.message;
        callback.call(context, err, msg);
        this._doClose();
    }, this);
};
Cell.prototype._doClose = function() {
    var fin = this._functors.incoming, fout = this._functors.outgoing;
    if (!this._closed || fin.pending + fout.pending !== 0) return;
    if (this._session) this._session.close();
    this._session = null;
    this._closed.done();
};
module.exports = Cell;
}),
"[project]/node_modules/websocket-extensions/lib/pipeline/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Cell = __turbopack_context__.r("[project]/node_modules/websocket-extensions/lib/pipeline/cell.js [app-route] (ecmascript)"), Pledge = __turbopack_context__.r("[project]/node_modules/websocket-extensions/lib/pipeline/pledge.js [app-route] (ecmascript)");
var Pipeline = function(sessions) {
    this._cells = sessions.map(function(session) {
        return new Cell(session);
    });
    this._stopped = {
        incoming: false,
        outgoing: false
    };
};
Pipeline.prototype.processIncomingMessage = function(message, callback, context) {
    if (this._stopped.incoming) return;
    this._loop('incoming', this._cells.length - 1, -1, -1, message, callback, context);
};
Pipeline.prototype.processOutgoingMessage = function(message, callback, context) {
    if (this._stopped.outgoing) return;
    this._loop('outgoing', 0, this._cells.length, 1, message, callback, context);
};
Pipeline.prototype.close = function(callback, context) {
    this._stopped = {
        incoming: true,
        outgoing: true
    };
    var closed = this._cells.map(function(a) {
        return a.close();
    });
    if (callback) Pledge.all(closed).then(function() {
        callback.call(context);
    });
};
Pipeline.prototype._loop = function(direction, start, end, step, message, callback, context) {
    var cells = this._cells, n = cells.length, self = this;
    while(n--)cells[n].pending(direction);
    var pipe = function(index, error, msg) {
        if (index === end) return callback.call(context, error, msg);
        cells[index][direction](error, msg, function(err, m) {
            if (err) self._stopped[direction] = true;
            pipe(index + step, err, m);
        });
    };
    pipe(start, null, message);
};
module.exports = Pipeline;
}),
"[project]/node_modules/websocket-extensions/lib/websocket_extensions.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Parser = __turbopack_context__.r("[project]/node_modules/websocket-extensions/lib/parser.js [app-route] (ecmascript)"), Pipeline = __turbopack_context__.r("[project]/node_modules/websocket-extensions/lib/pipeline/index.js [app-route] (ecmascript)");
var Extensions = function() {
    this._rsv1 = this._rsv2 = this._rsv3 = null;
    this._byName = {};
    this._inOrder = [];
    this._sessions = [];
    this._index = {};
};
Extensions.MESSAGE_OPCODES = [
    1,
    2
];
var instance = {
    add: function(ext) {
        if (typeof ext.name !== 'string') throw new TypeError('extension.name must be a string');
        if (ext.type !== 'permessage') throw new TypeError('extension.type must be "permessage"');
        if (typeof ext.rsv1 !== 'boolean') throw new TypeError('extension.rsv1 must be true or false');
        if (typeof ext.rsv2 !== 'boolean') throw new TypeError('extension.rsv2 must be true or false');
        if (typeof ext.rsv3 !== 'boolean') throw new TypeError('extension.rsv3 must be true or false');
        if (this._byName.hasOwnProperty(ext.name)) throw new TypeError('An extension with name "' + ext.name + '" is already registered');
        this._byName[ext.name] = ext;
        this._inOrder.push(ext);
    },
    generateOffer: function() {
        var sessions = [], offer = [], index = {};
        this._inOrder.forEach(function(ext) {
            var session = ext.createClientSession();
            if (!session) return;
            var record = [
                ext,
                session
            ];
            sessions.push(record);
            index[ext.name] = record;
            var offers = session.generateOffer();
            offers = offers ? [].concat(offers) : [];
            offers.forEach(function(off) {
                offer.push(Parser.serializeParams(ext.name, off));
            }, this);
        }, this);
        this._sessions = sessions;
        this._index = index;
        return offer.length > 0 ? offer.join(', ') : null;
    },
    activate: function(header) {
        var responses = Parser.parseHeader(header), sessions = [];
        responses.eachOffer(function(name, params) {
            var record = this._index[name];
            if (!record) throw new Error('Server sent an extension response for unknown extension "' + name + '"');
            var ext = record[0], session = record[1], reserved = this._reserved(ext);
            if (reserved) throw new Error('Server sent two extension responses that use the RSV' + reserved[0] + ' bit: "' + reserved[1] + '" and "' + ext.name + '"');
            if (session.activate(params) !== true) throw new Error('Server sent unacceptable extension parameters: ' + Parser.serializeParams(name, params));
            this._reserve(ext);
            sessions.push(record);
        }, this);
        this._sessions = sessions;
        this._pipeline = new Pipeline(sessions);
    },
    generateResponse: function(header) {
        var sessions = [], response = [], offers = Parser.parseHeader(header);
        this._inOrder.forEach(function(ext) {
            var offer = offers.byName(ext.name);
            if (offer.length === 0 || this._reserved(ext)) return;
            var session = ext.createServerSession(offer);
            if (!session) return;
            this._reserve(ext);
            sessions.push([
                ext,
                session
            ]);
            response.push(Parser.serializeParams(ext.name, session.generateResponse()));
        }, this);
        this._sessions = sessions;
        this._pipeline = new Pipeline(sessions);
        return response.length > 0 ? response.join(', ') : null;
    },
    validFrameRsv: function(frame) {
        var allowed = {
            rsv1: false,
            rsv2: false,
            rsv3: false
        }, ext;
        if (Extensions.MESSAGE_OPCODES.indexOf(frame.opcode) >= 0) {
            for(var i = 0, n = this._sessions.length; i < n; i++){
                ext = this._sessions[i][0];
                allowed.rsv1 = allowed.rsv1 || ext.rsv1;
                allowed.rsv2 = allowed.rsv2 || ext.rsv2;
                allowed.rsv3 = allowed.rsv3 || ext.rsv3;
            }
        }
        return (allowed.rsv1 || !frame.rsv1) && (allowed.rsv2 || !frame.rsv2) && (allowed.rsv3 || !frame.rsv3);
    },
    processIncomingMessage: function(message, callback, context) {
        this._pipeline.processIncomingMessage(message, callback, context);
    },
    processOutgoingMessage: function(message, callback, context) {
        this._pipeline.processOutgoingMessage(message, callback, context);
    },
    close: function(callback, context) {
        if (!this._pipeline) return callback.call(context);
        this._pipeline.close(callback, context);
    },
    _reserve: function(ext) {
        this._rsv1 = this._rsv1 || ext.rsv1 && ext.name;
        this._rsv2 = this._rsv2 || ext.rsv2 && ext.name;
        this._rsv3 = this._rsv3 || ext.rsv3 && ext.name;
    },
    _reserved: function(ext) {
        if (this._rsv1 && ext.rsv1) return [
            1,
            this._rsv1
        ];
        if (this._rsv2 && ext.rsv2) return [
            2,
            this._rsv2
        ];
        if (this._rsv3 && ext.rsv3) return [
            3,
            this._rsv3
        ];
        return false;
    }
};
for(var key in instance)Extensions.prototype[key] = instance[key];
module.exports = Extensions;
}),
"[project]/node_modules/faye-websocket/lib/faye/websocket/api/event.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Event = function(eventType, options) {
    this.type = eventType;
    for(var key in options)this[key] = options[key];
};
Event.prototype.initEvent = function(eventType, canBubble, cancelable) {
    this.type = eventType;
    this.bubbles = canBubble;
    this.cancelable = cancelable;
};
Event.prototype.stopPropagation = function() {};
Event.prototype.preventDefault = function() {};
Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;
module.exports = Event;
}),
"[project]/node_modules/faye-websocket/lib/faye/websocket/api/event_target.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Event = __turbopack_context__.r("[project]/node_modules/faye-websocket/lib/faye/websocket/api/event.js [app-route] (ecmascript)");
var EventTarget = {
    onopen: null,
    onmessage: null,
    onerror: null,
    onclose: null,
    addEventListener: function(eventType, listener, useCapture) {
        this.on(eventType, listener);
    },
    removeEventListener: function(eventType, listener, useCapture) {
        this.removeListener(eventType, listener);
    },
    dispatchEvent: function(event) {
        event.target = event.currentTarget = this;
        event.eventPhase = Event.AT_TARGET;
        if (this['on' + event.type]) this['on' + event.type](event);
        this.emit(event.type, event);
    }
};
module.exports = EventTarget;
}),
"[project]/node_modules/faye-websocket/lib/faye/websocket/api.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream, util = __turbopack_context__.r("[externals]/util [external] (util, cjs)"), driver = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver.js [app-route] (ecmascript)"), EventTarget = __turbopack_context__.r("[project]/node_modules/faye-websocket/lib/faye/websocket/api/event_target.js [app-route] (ecmascript)"), Event = __turbopack_context__.r("[project]/node_modules/faye-websocket/lib/faye/websocket/api/event.js [app-route] (ecmascript)");
var API = function(options) {
    options = options || {};
    driver.validateOptions(options, [
        'headers',
        'extensions',
        'maxLength',
        'ping',
        'proxy',
        'tls',
        'ca'
    ]);
    this.readable = this.writable = true;
    var headers = options.headers;
    if (headers) {
        for(var name in headers)this._driver.setHeader(name, headers[name]);
    }
    var extensions = options.extensions;
    if (extensions) {
        [].concat(extensions).forEach(this._driver.addExtension, this._driver);
    }
    this._ping = options.ping;
    this._pingId = 0;
    this.readyState = API.CONNECTING;
    this.bufferedAmount = 0;
    this.protocol = '';
    this.url = this._driver.url;
    this.version = this._driver.version;
    var self = this;
    this._driver.on('open', function(e) {
        self._open();
    });
    this._driver.on('message', function(e) {
        self._receiveMessage(e.data);
    });
    this._driver.on('close', function(e) {
        self._beginClose(e.reason, e.code);
    });
    this._driver.on('error', function(error) {
        self._emitError(error.message);
    });
    this.on('error', function() {});
    this._driver.messages.on('drain', function() {
        self.emit('drain');
    });
    if (this._ping) this._pingTimer = setInterval(function() {
        self._pingId += 1;
        self.ping(self._pingId.toString());
    }, this._ping * 1000);
    this._configureStream();
    if (!this._proxy) {
        this._stream.pipe(this._driver.io);
        this._driver.io.pipe(this._stream);
    }
};
util.inherits(API, Stream);
API.CONNECTING = 0;
API.OPEN = 1;
API.CLOSING = 2;
API.CLOSED = 3;
API.CLOSE_TIMEOUT = 30000;
var instance = {
    write: function(data) {
        return this.send(data);
    },
    end: function(data) {
        if (data !== undefined) this.send(data);
        this.close();
    },
    pause: function() {
        return this._driver.messages.pause();
    },
    resume: function() {
        return this._driver.messages.resume();
    },
    send: function(data) {
        if (this.readyState > API.OPEN) return false;
        if (!(data instanceof Buffer)) data = String(data);
        return this._driver.messages.write(data);
    },
    ping: function(message, callback) {
        if (this.readyState > API.OPEN) return false;
        return this._driver.ping(message, callback);
    },
    close: function(code, reason) {
        if (code === undefined) code = 1000;
        if (reason === undefined) reason = '';
        if (code !== 1000 && (code < 3000 || code > 4999)) throw new Error("Failed to execute 'close' on WebSocket: " + "The code must be either 1000, or between 3000 and 4999. " + code + " is neither.");
        if (this.readyState < API.CLOSING) {
            var self = this;
            this._closeTimer = setTimeout(function() {
                self._beginClose('', 1006);
            }, API.CLOSE_TIMEOUT);
        }
        if (this.readyState !== API.CLOSED) this.readyState = API.CLOSING;
        this._driver.close(reason, code);
    },
    _configureStream: function() {
        var self = this;
        this._stream.setTimeout(0);
        this._stream.setNoDelay(true);
        [
            'close',
            'end'
        ].forEach(function(event) {
            this._stream.on(event, function() {
                self._finalizeClose();
            });
        }, this);
        this._stream.on('error', function(error) {
            self._emitError('Network error: ' + self.url + ': ' + error.message);
            self._finalizeClose();
        });
    },
    _open: function() {
        if (this.readyState !== API.CONNECTING) return;
        this.readyState = API.OPEN;
        this.protocol = this._driver.protocol || '';
        var event = new Event('open');
        event.initEvent('open', false, false);
        this.dispatchEvent(event);
    },
    _receiveMessage: function(data) {
        if (this.readyState > API.OPEN) return false;
        if (this.readable) this.emit('data', data);
        var event = new Event('message', {
            data: data
        });
        event.initEvent('message', false, false);
        this.dispatchEvent(event);
    },
    _emitError: function(message) {
        if (this.readyState >= API.CLOSING) return;
        var event = new Event('error', {
            message: message
        });
        event.initEvent('error', false, false);
        this.dispatchEvent(event);
    },
    _beginClose: function(reason, code) {
        if (this.readyState === API.CLOSED) return;
        this.readyState = API.CLOSING;
        this._closeParams = [
            reason,
            code
        ];
        if (this._stream) {
            this._stream.destroy();
            if (!this._stream.readable) this._finalizeClose();
        }
    },
    _finalizeClose: function() {
        if (this.readyState === API.CLOSED) return;
        this.readyState = API.CLOSED;
        if (this._closeTimer) clearTimeout(this._closeTimer);
        if (this._pingTimer) clearInterval(this._pingTimer);
        if (this._stream) this._stream.end();
        if (this.readable) this.emit('end');
        this.readable = this.writable = false;
        var reason = this._closeParams ? this._closeParams[0] : '', code = this._closeParams ? this._closeParams[1] : 1006;
        var event = new Event('close', {
            code: code,
            reason: reason
        });
        event.initEvent('close', false, false);
        this.dispatchEvent(event);
    }
};
for(var method in instance)API.prototype[method] = instance[method];
for(var key in EventTarget)API.prototype[key] = EventTarget[key];
module.exports = API;
}),
"[project]/node_modules/faye-websocket/lib/faye/websocket/client.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)"), net = __turbopack_context__.r("[externals]/net [external] (net, cjs)"), tls = __turbopack_context__.r("[externals]/tls [external] (tls, cjs)"), url = __turbopack_context__.r("[externals]/url [external] (url, cjs)"), driver = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver.js [app-route] (ecmascript)"), API = __turbopack_context__.r("[project]/node_modules/faye-websocket/lib/faye/websocket/api.js [app-route] (ecmascript)"), Event = __turbopack_context__.r("[project]/node_modules/faye-websocket/lib/faye/websocket/api/event.js [app-route] (ecmascript)");
var DEFAULT_PORTS = {
    'http:': 80,
    'https:': 443,
    'ws:': 80,
    'wss:': 443
}, SECURE_PROTOCOLS = [
    'https:',
    'wss:'
];
var Client = function(_url, protocols, options) {
    options = options || {};
    this.url = _url;
    this._driver = driver.client(this.url, {
        maxLength: options.maxLength,
        protocols: protocols
    });
    [
        'open',
        'error'
    ].forEach(function(event) {
        this._driver.on(event, function() {
            self.headers = self._driver.headers;
            self.statusCode = self._driver.statusCode;
        });
    }, this);
    var proxy = options.proxy || {}, endpoint = url.parse(proxy.origin || this.url), port = endpoint.port || DEFAULT_PORTS[endpoint.protocol], secure = SECURE_PROTOCOLS.indexOf(endpoint.protocol) >= 0, onConnect = function() {
        self._onConnect();
    }, netOptions = options.net || {}, originTLS = options.tls || {}, socketTLS = proxy.origin ? proxy.tls || {} : originTLS, self = this;
    netOptions.host = socketTLS.host = endpoint.hostname;
    netOptions.port = socketTLS.port = port;
    originTLS.ca = originTLS.ca || options.ca;
    socketTLS.servername = socketTLS.servername || endpoint.hostname;
    this._stream = secure ? tls.connect(socketTLS, onConnect) : net.connect(netOptions, onConnect);
    if (proxy.origin) this._configureProxy(proxy, originTLS);
    API.call(this, options);
};
util.inherits(Client, API);
Client.prototype._onConnect = function() {
    var worker = this._proxy || this._driver;
    worker.start();
};
Client.prototype._configureProxy = function(proxy, originTLS) {
    var uri = url.parse(this.url), secure = SECURE_PROTOCOLS.indexOf(uri.protocol) >= 0, self = this, name;
    this._proxy = this._driver.proxy(proxy.origin);
    if (proxy.headers) {
        for(name in proxy.headers)this._proxy.setHeader(name, proxy.headers[name]);
    }
    this._proxy.pipe(this._stream, {
        end: false
    });
    this._stream.pipe(this._proxy);
    this._proxy.on('connect', function() {
        if (secure) {
            var options = {
                socket: self._stream,
                servername: uri.hostname
            };
            for(name in originTLS)options[name] = originTLS[name];
            self._stream = tls.connect(options);
            self._configureStream();
        }
        self._driver.io.pipe(self._stream);
        self._stream.pipe(self._driver.io);
        self._driver.start();
    });
    this._proxy.on('error', function(error) {
        self._driver.emit('error', error);
    });
};
module.exports = Client;
}),
"[project]/node_modules/faye-websocket/lib/faye/eventsource.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream, util = __turbopack_context__.r("[externals]/util [external] (util, cjs)"), driver = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver.js [app-route] (ecmascript)"), Headers = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver/headers.js [app-route] (ecmascript)"), API = __turbopack_context__.r("[project]/node_modules/faye-websocket/lib/faye/websocket/api.js [app-route] (ecmascript)"), EventTarget = __turbopack_context__.r("[project]/node_modules/faye-websocket/lib/faye/websocket/api/event_target.js [app-route] (ecmascript)"), Event = __turbopack_context__.r("[project]/node_modules/faye-websocket/lib/faye/websocket/api/event.js [app-route] (ecmascript)");
var EventSource = function(request, response, options) {
    this.writable = true;
    options = options || {};
    this._stream = response.socket;
    this._ping = options.ping || this.DEFAULT_PING;
    this._retry = options.retry || this.DEFAULT_RETRY;
    var scheme = driver.isSecureRequest(request) ? 'https:' : 'http:';
    this.url = scheme + '//' + request.headers.host + request.url;
    this.lastEventId = request.headers['last-event-id'] || '';
    this.readyState = API.CONNECTING;
    var headers = new Headers(), self = this;
    if (options.headers) {
        for(var key in options.headers)headers.set(key, options.headers[key]);
    }
    if (!this._stream || !this._stream.writable) return;
    process.nextTick(function() {
        self._open();
    });
    this._stream.setTimeout(0);
    this._stream.setNoDelay(true);
    var handshake = 'HTTP/1.1 200 OK\r\n' + 'Content-Type: text/event-stream\r\n' + 'Cache-Control: no-cache, no-store\r\n' + 'Connection: close\r\n' + headers.toString() + '\r\n' + 'retry: ' + Math.floor(this._retry * 1000) + '\r\n\r\n';
    this._write(handshake);
    this._stream.on('drain', function() {
        self.emit('drain');
    });
    if (this._ping) this._pingTimer = setInterval(function() {
        self.ping();
    }, this._ping * 1000);
    [
        'error',
        'end'
    ].forEach(function(event) {
        self._stream.on(event, function() {
            self.close();
        });
    });
};
util.inherits(EventSource, Stream);
EventSource.isEventSource = function(request) {
    if (request.method !== 'GET') return false;
    var accept = (request.headers.accept || '').split(/\s*,\s*/);
    return accept.indexOf('text/event-stream') >= 0;
};
var instance = {
    DEFAULT_PING: 10,
    DEFAULT_RETRY: 5,
    _write: function(chunk) {
        if (!this.writable) return false;
        try {
            return this._stream.write(chunk, 'utf8');
        } catch (e) {
            return false;
        }
    },
    _open: function() {
        if (this.readyState !== API.CONNECTING) return;
        this.readyState = API.OPEN;
        var event = new Event('open');
        event.initEvent('open', false, false);
        this.dispatchEvent(event);
    },
    write: function(message) {
        return this.send(message);
    },
    end: function(message) {
        if (message !== undefined) this.write(message);
        this.close();
    },
    send: function(message, options) {
        if (this.readyState > API.OPEN) return false;
        message = String(message).replace(/(\r\n|\r|\n)/g, '$1data: ');
        options = options || {};
        var frame = '';
        if (options.event) frame += 'event: ' + options.event + '\r\n';
        if (options.id) frame += 'id: ' + options.id + '\r\n';
        frame += 'data: ' + message + '\r\n\r\n';
        return this._write(frame);
    },
    ping: function() {
        return this._write(':\r\n\r\n');
    },
    close: function() {
        if (this.readyState > API.OPEN) return false;
        this.readyState = API.CLOSED;
        this.writable = false;
        if (this._pingTimer) clearInterval(this._pingTimer);
        if (this._stream) this._stream.end();
        var event = new Event('close');
        event.initEvent('close', false, false);
        this.dispatchEvent(event);
        return true;
    }
};
for(var method in instance)EventSource.prototype[method] = instance[method];
for(var key in EventTarget)EventSource.prototype[key] = EventTarget[key];
module.exports = EventSource;
}),
"[project]/node_modules/faye-websocket/lib/faye/websocket.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// API references:
//
// * https://html.spec.whatwg.org/multipage/comms.html#network
// * https://dom.spec.whatwg.org/#interface-eventtarget
// * https://dom.spec.whatwg.org/#interface-event
var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)"), driver = __turbopack_context__.r("[project]/node_modules/websocket-driver/lib/websocket/driver.js [app-route] (ecmascript)"), API = __turbopack_context__.r("[project]/node_modules/faye-websocket/lib/faye/websocket/api.js [app-route] (ecmascript)");
var WebSocket = function(request, socket, body, protocols, options) {
    options = options || {};
    this._stream = socket;
    this._driver = driver.http(request, {
        maxLength: options.maxLength,
        protocols: protocols
    });
    var self = this;
    if (!this._stream || !this._stream.writable) return;
    if (!this._stream.readable) return this._stream.end();
    var catchup = function() {
        self._stream.removeListener('data', catchup);
    };
    this._stream.on('data', catchup);
    API.call(this, options);
    process.nextTick(function() {
        self._driver.start();
        self._driver.io.write(body);
    });
};
util.inherits(WebSocket, API);
WebSocket.isWebSocket = function(request) {
    return driver.isWebSocket(request);
};
WebSocket.validateOptions = function(options, validKeys) {
    driver.validateOptions(options, validKeys);
};
WebSocket.WebSocket = WebSocket;
WebSocket.Client = __turbopack_context__.r("[project]/node_modules/faye-websocket/lib/faye/websocket/client.js [app-route] (ecmascript)");
WebSocket.EventSource = __turbopack_context__.r("[project]/node_modules/faye-websocket/lib/faye/eventsource.js [app-route] (ecmascript)");
module.exports = WebSocket;
}),
"[project]/node_modules/tunnel-agent/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var net = __turbopack_context__.r("[externals]/net [external] (net, cjs)"), tls = __turbopack_context__.r("[externals]/tls [external] (tls, cjs)"), http = __turbopack_context__.r("[externals]/http [external] (http, cjs)"), https = __turbopack_context__.r("[externals]/https [external] (https, cjs)"), events = __turbopack_context__.r("[externals]/events [external] (events, cjs)"), assert = __turbopack_context__.r("[externals]/assert [external] (assert, cjs)"), util = __turbopack_context__.r("[externals]/util [external] (util, cjs)"), Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-route] (ecmascript)").Buffer;
exports.httpOverHttp = httpOverHttp;
exports.httpsOverHttp = httpsOverHttp;
exports.httpOverHttps = httpOverHttps;
exports.httpsOverHttps = httpsOverHttps;
function httpOverHttp(options) {
    var agent = new TunnelingAgent(options);
    agent.request = http.request;
    return agent;
}
function httpsOverHttp(options) {
    var agent = new TunnelingAgent(options);
    agent.request = http.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
}
function httpOverHttps(options) {
    var agent = new TunnelingAgent(options);
    agent.request = https.request;
    return agent;
}
function httpsOverHttps(options) {
    var agent = new TunnelingAgent(options);
    agent.request = https.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
}
function TunnelingAgent(options) {
    var self = this;
    self.options = options || {};
    self.proxyOptions = self.options.proxy || {};
    self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
    self.requests = [];
    self.sockets = [];
    self.on('free', function onFree(socket, host, port) {
        for(var i = 0, len = self.requests.length; i < len; ++i){
            var pending = self.requests[i];
            if (pending.host === host && pending.port === port) {
                // Detect the request to connect same origin server,
                // reuse the connection.
                self.requests.splice(i, 1);
                pending.request.onSocket(socket);
                return;
            }
        }
        socket.destroy();
        self.removeSocket(socket);
    });
}
util.inherits(TunnelingAgent, events.EventEmitter);
TunnelingAgent.prototype.addRequest = function addRequest(req, options) {
    var self = this;
    // Legacy API: addRequest(req, host, port, path)
    if (typeof options === 'string') {
        options = {
            host: options,
            port: arguments[2],
            path: arguments[3]
        };
    }
    if (self.sockets.length >= this.maxSockets) {
        // We are over limit so we'll add it to the queue.
        self.requests.push({
            host: options.host,
            port: options.port,
            request: req
        });
        return;
    }
    // If we are under maxSockets create a new one.
    self.createConnection({
        host: options.host,
        port: options.port,
        request: req
    });
};
TunnelingAgent.prototype.createConnection = function createConnection(pending) {
    var self = this;
    self.createSocket(pending, function(socket) {
        socket.on('free', onFree);
        socket.on('close', onCloseOrRemove);
        socket.on('agentRemove', onCloseOrRemove);
        pending.request.onSocket(socket);
        function onFree() {
            self.emit('free', socket, pending.host, pending.port);
        }
        function onCloseOrRemove(err) {
            self.removeSocket(socket);
            socket.removeListener('free', onFree);
            socket.removeListener('close', onCloseOrRemove);
            socket.removeListener('agentRemove', onCloseOrRemove);
        }
    });
};
TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
    var self = this;
    var placeholder = {};
    self.sockets.push(placeholder);
    var connectOptions = mergeOptions({}, self.proxyOptions, {
        method: 'CONNECT',
        path: options.host + ':' + options.port,
        agent: false
    });
    if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {};
        connectOptions.headers['Proxy-Authorization'] = 'Basic ' + Buffer.from(connectOptions.proxyAuth).toString('base64');
    }
    debug('making CONNECT request');
    var connectReq = self.request(connectOptions);
    connectReq.useChunkedEncodingByDefault = false; // for v0.6
    connectReq.once('response', onResponse); // for v0.6
    connectReq.once('upgrade', onUpgrade); // for v0.6
    connectReq.once('connect', onConnect); // for v0.7 or later
    connectReq.once('error', onError);
    connectReq.end();
    function onResponse(res) {
        // Very hacky. This is necessary to avoid http-parser leaks.
        res.upgrade = true;
    }
    function onUpgrade(res, socket, head) {
        // Hacky.
        process.nextTick(function() {
            onConnect(res, socket, head);
        });
    }
    function onConnect(res, socket, head) {
        connectReq.removeAllListeners();
        socket.removeAllListeners();
        if (res.statusCode === 200) {
            assert.equal(head.length, 0);
            debug('tunneling connection has established');
            self.sockets[self.sockets.indexOf(placeholder)] = socket;
            cb(socket);
        } else {
            debug('tunneling socket could not be established, statusCode=%d', res.statusCode);
            var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode);
            error.code = 'ECONNRESET';
            options.request.emit('error', error);
            self.removeSocket(placeholder);
        }
    }
    function onError(cause) {
        connectReq.removeAllListeners();
        debug('tunneling socket could not be established, cause=%s\n', cause.message, cause.stack);
        var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message);
        error.code = 'ECONNRESET';
        options.request.emit('error', error);
        self.removeSocket(placeholder);
    }
};
TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
    var pos = this.sockets.indexOf(socket);
    if (pos === -1) return;
    this.sockets.splice(pos, 1);
    var pending = this.requests.shift();
    if (pending) {
        // If we have pending requests and a socket gets closed a new one
        // needs to be created to take over in the pool for the one that closed.
        this.createConnection(pending);
    }
};
function createSecureSocket(options, cb) {
    var self = this;
    TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
        // 0 is dummy port for v0.6
        var secureSocket = tls.connect(0, mergeOptions({}, self.options, {
            servername: options.host,
            socket: socket
        }));
        self.sockets[self.sockets.indexOf(socket)] = secureSocket;
        cb(secureSocket);
    });
}
function mergeOptions(target) {
    for(var i = 1, len = arguments.length; i < len; ++i){
        var overrides = arguments[i];
        if (typeof overrides === 'object') {
            var keys = Object.keys(overrides);
            for(var j = 0, keyLen = keys.length; j < keyLen; ++j){
                var k = keys[j];
                if (overrides[k] !== undefined) {
                    target[k] = overrides[k];
                }
            }
        }
    }
    return target;
}
var debug;
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
    debug = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === 'string') {
            args[0] = 'TUNNEL: ' + args[0];
        } else {
            args.unshift('TUNNEL:');
        }
        console.error.apply(console, args);
    };
} else {
    debug = function() {};
}
exports.debug = debug; // for test
}),
];

//# sourceMappingURL=node_modules_f8361409._.js.map