{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/ron.feathers/GitHub/LUCI/src/lib/supabase-server.js"],"sourcesContent":["/**\n * Server-side Supabase Client for Next.js\n * Uses the same logic as lib/supabase-client.js but as ES module\n */\n\nexport function getSupabaseClient() {\n  try {\n    const { createClient } = require('@supabase/supabase-js');\n    const supabaseUrl = process.env.SUPABASE_URL;\n    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n    \n    if (supabaseUrl && supabaseServiceKey) {\n      return createClient(supabaseUrl, supabaseServiceKey, {\n        auth: {\n          autoRefreshToken: false,\n          persistSession: false\n        }\n      });\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn('Supabase client not available:', error.message);\n    }\n  }\n  return null;\n}\n\nexport function validateSupabase(supabase) {\n  if (!supabase) {\n    return {\n      valid: false,\n      error: { status: 503, message: 'Database not configured' }\n    };\n  }\n  return { valid: true };\n}\n\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;AAEM,SAAS;IACd,IAAI;QACF,MAAM,EAAE,YAAY,EAAE;QACtB,MAAM,cAAc,QAAQ,GAAG,CAAC,YAAY;QAC5C,MAAM,qBAAqB,QAAQ,GAAG,CAAC,yBAAyB;QAEhE,IAAI,eAAe,oBAAoB;YACrC,OAAO,aAAa,aAAa,oBAAoB;gBACnD,MAAM;oBACJ,kBAAkB;oBAClB,gBAAgB;gBAClB;YACF;QACF;IACF,EAAE,OAAO,OAAO;QACd,wCAA2C;YACzC,QAAQ,IAAI,CAAC,kCAAkC,MAAM,OAAO;QAC9D;IACF;IACA,OAAO;AACT;AAEO,SAAS,iBAAiB,QAAQ;IACvC,IAAI,CAAC,UAAU;QACb,OAAO;YACL,OAAO;YACP,OAAO;gBAAE,QAAQ;gBAAK,SAAS;YAA0B;QAC3D;IACF;IACA,OAAO;QAAE,OAAO;IAAK;AACvB"}},
    {"offset": {"line": 93, "column": 0}, "map": {"version":3,"sources":["file:///Users/ron.feathers/GitHub/LUCI/src/lib/next-api-helpers.js"],"sourcesContent":["/**\n * Next.js API Route Helper Functions\n * \n * Adapters for existing lib/api-helpers.js to work with Next.js\n * Can use require() for existing helpers\n */\n\nimport { NextResponse } from 'next/server';\n\n// Import existing helpers (they work in Next.js via require)\nconst apiHelpers = require('../../../lib/api-helpers');\nconst { MAX_REQUEST_SIZE, REQUEST_TIMEOUT, RATE_LIMIT } = require('../../../lib/constants');\n\n/**\n * Set CORS headers for Next.js Response\n */\nexport function setCORSHeaders(response, methods = ['GET', 'POST', 'OPTIONS']) {\n  response.headers.set('Access-Control-Allow-Origin', '*');\n  response.headers.set('Access-Control-Allow-Methods', methods.join(', '));\n  response.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n  return response;\n}\n\n/**\n * Handle preflight OPTIONS requests for Next.js\n */\nexport async function handlePreflight(request) {\n  if (request.method === 'OPTIONS') {\n    const response = new NextResponse(null, { status: 200 });\n    return setCORSHeaders(response);\n  }\n  return null;\n}\n\n/**\n * Validate request size for Next.js\n */\nexport function validateRequestSize(request, maxSize = MAX_REQUEST_SIZE.DEFAULT) {\n  const contentLength = request.headers.get('content-length');\n  if (contentLength && parseInt(contentLength) > maxSize) {\n    return {\n      valid: false,\n      error: {\n        status: 413,\n        message: 'Request too large',\n      },\n    };\n  }\n  return { valid: true };\n}\n\n/**\n * Send error response for Next.js\n */\nexport function sendErrorResponse(error, statusCode = 500) {\n  const isProd = apiHelpers.isProduction();\n  const sanitized = {\n    error: isProd ? 'An error occurred' : (error?.message || 'An error occurred'),\n    message: isProd ? 'Please try again later or contact support if the problem persists.' : (error?.message || 'An error occurred'),\n  };\n  \n  if (!isProd && error?.stack) {\n    sanitized.stack = error.stack;\n  }\n  \n  const response = NextResponse.json(sanitized, { status: statusCode });\n  return setCORSHeaders(response);\n}\n\n/**\n * Send success response for Next.js\n */\nexport function sendSuccessResponse(data, statusCode = 200) {\n  const response = NextResponse.json(data, { status: statusCode });\n  return setCORSHeaders(response);\n}\n\n/**\n * Get client IP from Next.js Request\n */\nexport function getClientIP(request) {\n  const forwarded = request.headers.get('x-forwarded-for');\n  if (forwarded) {\n    return forwarded.split(',')[0].trim();\n  }\n  return request.headers.get('x-real-ip') || 'unknown';\n}\n\n/**\n * Validate Supabase client for Next.js\n */\nexport function validateSupabase(supabase) {\n  if (!supabase) {\n    return {\n      valid: false,\n      error: { status: 503, message: 'Database not configured' }\n    };\n  }\n  return { valid: true };\n}\n\n/**\n * Check rate limit\n */\nexport function checkRateLimit(ip, windowMs, maxRequests) {\n  return apiHelpers.checkRateLimit(ip, windowMs, maxRequests);\n}\n\n// Re-export other helpers\nexport const log = apiHelpers.log;\nexport const logError = apiHelpers.logError;\nexport const logWarn = apiHelpers.logWarn;\nexport const logDebug = apiHelpers.logDebug;\nexport const isProduction = apiHelpers.isProduction;\n\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAED;;AAEA,6DAA6D;AAC7D,MAAM;;;;;AACN,MAAM,EAAE,gBAAgB,EAAE,eAAe,EAAE,UAAU,EAAE;;;;;AAKhD,SAAS,eAAe,QAAQ,EAAE,UAAU;IAAC;IAAO;IAAQ;CAAU;IAC3E,SAAS,OAAO,CAAC,GAAG,CAAC,+BAA+B;IACpD,SAAS,OAAO,CAAC,GAAG,CAAC,gCAAgC,QAAQ,IAAI,CAAC;IAClE,SAAS,OAAO,CAAC,GAAG,CAAC,gCAAgC;IACrD,OAAO;AACT;AAKO,eAAe,gBAAgB,OAAO;IAC3C,IAAI,QAAQ,MAAM,KAAK,WAAW;QAChC,MAAM,WAAW,IAAI,gJAAY,CAAC,MAAM;YAAE,QAAQ;QAAI;QACtD,OAAO,eAAe;IACxB;IACA,OAAO;AACT;AAKO,SAAS,oBAAoB,OAAO,EAAE,UAAU,iBAAiB,OAAO;IAC7E,MAAM,gBAAgB,QAAQ,OAAO,CAAC,GAAG,CAAC;IAC1C,IAAI,iBAAiB,SAAS,iBAAiB,SAAS;QACtD,OAAO;YACL,OAAO;YACP,OAAO;gBACL,QAAQ;gBACR,SAAS;YACX;QACF;IACF;IACA,OAAO;QAAE,OAAO;IAAK;AACvB;AAKO,SAAS,kBAAkB,KAAK,EAAE,aAAa,GAAG;IACvD,MAAM,SAAS,WAAW,YAAY;IACtC,MAAM,YAAY;QAChB,OAAO,SAAS,sBAAuB,OAAO,WAAW;QACzD,SAAS,SAAS,uEAAwE,OAAO,WAAW;IAC9G;IAEA,IAAI,CAAC,UAAU,OAAO,OAAO;QAC3B,UAAU,KAAK,GAAG,MAAM,KAAK;IAC/B;IAEA,MAAM,WAAW,gJAAY,CAAC,IAAI,CAAC,WAAW;QAAE,QAAQ;IAAW;IACnE,OAAO,eAAe;AACxB;AAKO,SAAS,oBAAoB,IAAI,EAAE,aAAa,GAAG;IACxD,MAAM,WAAW,gJAAY,CAAC,IAAI,CAAC,MAAM;QAAE,QAAQ;IAAW;IAC9D,OAAO,eAAe;AACxB;AAKO,SAAS,YAAY,OAAO;IACjC,MAAM,YAAY,QAAQ,OAAO,CAAC,GAAG,CAAC;IACtC,IAAI,WAAW;QACb,OAAO,UAAU,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI;IACrC;IACA,OAAO,QAAQ,OAAO,CAAC,GAAG,CAAC,gBAAgB;AAC7C;AAKO,SAAS,iBAAiB,QAAQ;IACvC,IAAI,CAAC,UAAU;QACb,OAAO;YACL,OAAO;YACP,OAAO;gBAAE,QAAQ;gBAAK,SAAS;YAA0B;QAC3D;IACF;IACA,OAAO;QAAE,OAAO;IAAK;AACvB;AAKO,SAAS,eAAe,EAAE,EAAE,QAAQ,EAAE,WAAW;IACtD,OAAO,WAAW,cAAc,CAAC,IAAI,UAAU;AACjD;AAGO,MAAM,MAAM,WAAW,GAAG;AAC1B,MAAM,WAAW,WAAW,QAAQ;AACpC,MAAM,UAAU,WAAW,OAAO;AAClC,MAAM,WAAW,WAAW,QAAQ;AACpC,MAAM,eAAe,WAAW,YAAY"}},
    {"offset": {"line": 225, "column": 0}, "map": {"version":3,"sources":["file:///Users/ron.feathers/GitHub/LUCI/lib/supabase-client.js"],"sourcesContent":["/**\n * Shared Supabase Client Utility\n * \n * Provides a consistent way to create Supabase clients across all API functions\n */\n\nfunction getSupabaseClient() {\n  try {\n    const { createClient } = require('@supabase/supabase-js');\n    const supabaseUrl = process.env.SUPABASE_URL;\n    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n    \n    if (supabaseUrl && supabaseServiceKey) {\n      return createClient(supabaseUrl, supabaseServiceKey, {\n        auth: {\n          autoRefreshToken: false,\n          persistSession: false\n        }\n      });\n    }\n  } catch (error) {\n    // Only log in development\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn('Supabase client not available:', error.message);\n    }\n  }\n  return null;\n}\n\nmodule.exports = { getSupabaseClient };\n\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED,SAAS;IACP,IAAI;QACF,MAAM,EAAE,YAAY,EAAE;QACtB,MAAM,cAAc,QAAQ,GAAG,CAAC,YAAY;QAC5C,MAAM,qBAAqB,QAAQ,GAAG,CAAC,yBAAyB;QAEhE,IAAI,eAAe,oBAAoB;YACrC,OAAO,aAAa,aAAa,oBAAoB;gBACnD,MAAM;oBACJ,kBAAkB;oBAClB,gBAAgB;gBAClB;YACF;QACF;IACF,EAAE,OAAO,OAAO;QACd,0BAA0B;QAC1B,wCAA2C;YACzC,QAAQ,IAAI,CAAC,kCAAkC,MAAM,OAAO;QAC9D;IACF;IACA,OAAO;AACT;AAEA,OAAO,OAAO,GAAG;IAAE;AAAkB"}},
    {"offset": {"line": 256, "column": 0}, "map": {"version":3,"sources":["file:///Users/ron.feathers/GitHub/LUCI/lib/constants.js"],"sourcesContent":["/**\n * Shared Constants\n * \n * Centralized constants used across the application\n */\n\n// Request limits\nconst MAX_REQUEST_SIZE = {\n  DEFAULT: 1024 * 1024, // 1MB\n  LARGE: 10 * 1024 * 1024, // 10MB (for sentiment analysis)\n};\n\n// Timeouts\nconst REQUEST_TIMEOUT = 30000; // 30 seconds\n\n// Rate limiting\nconst RATE_LIMIT = {\n  WINDOW: 60 * 1000, // 1 minute\n  MAX_REQUESTS: 10, // 10 requests per minute per IP\n};\n\n// Cache TTL (in hours, except CALENDAR_EVENTS which is in minutes)\nconst CACHE_TTL = {\n  ACCOUNTS: 1, // 1 hour\n  CASES: 1, // 1 hour\n  CONTACTS: 24, // 24 hours\n  TRANSCRIPTIONS: 24, // 24 hours\n  LINKEDIN_PROFILES: 24, // 24 hours\n  CALENDAR_EVENTS: 15, // 15 minutes (calendar events change frequently)\n};\n\n// API Limits\nconst API_LIMITS = {\n  CASES_PER_ACCOUNT: 25,\n  CONTACTS_PER_ACCOUNT: 100,\n  ACCOUNTS_PER_USER: 1000,\n};\n\nmodule.exports = {\n  MAX_REQUEST_SIZE,\n  REQUEST_TIMEOUT,\n  RATE_LIMIT,\n  CACHE_TTL,\n  API_LIMITS,\n};\n\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED,iBAAiB;AACjB,MAAM,mBAAmB;IACvB,SAAS,OAAO;IAChB,OAAO,KAAK,OAAO;AACrB;AAEA,WAAW;AACX,MAAM,kBAAkB,OAAO,aAAa;AAE5C,gBAAgB;AAChB,MAAM,aAAa;IACjB,QAAQ,KAAK;IACb,cAAc;AAChB;AAEA,mEAAmE;AACnE,MAAM,YAAY;IAChB,UAAU;IACV,OAAO;IACP,UAAU;IACV,gBAAgB;IAChB,mBAAmB;IACnB,iBAAiB;AACnB;AAEA,aAAa;AACb,MAAM,aAAa;IACjB,mBAAmB;IACnB,sBAAsB;IACtB,mBAAmB;AACrB;AAEA,OAAO,OAAO,GAAG;IACf;IACA;IACA;IACA;IACA;AACF"}},
    {"offset": {"line": 297, "column": 0}, "map": {"version":3,"sources":["file:///Users/ron.feathers/GitHub/LUCI/lib/api-helpers.js"],"sourcesContent":["/**\n * Shared API Helper Functions\n * \n * Common utilities for Vercel serverless functions\n */\n\nconst { MAX_REQUEST_SIZE, REQUEST_TIMEOUT } = require('./constants');\n\n/**\n * Set standard CORS headers\n */\nfunction setCORSHeaders(res, methods = ['GET', 'POST', 'OPTIONS']) {\n  res.setHeader('Access-Control-Allow-Origin', '*');\n  res.setHeader('Access-Control-Allow-Methods', methods.join(', '));\n  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n}\n\n/**\n * Handle preflight OPTIONS requests\n */\nfunction handlePreflight(req, res) {\n  if (req.method === 'OPTIONS') {\n    setCORSHeaders(res);\n    return res.status(200).end();\n  }\n  return false;\n}\n\n/**\n * Validate request size\n */\nfunction validateRequestSize(req, maxSize = MAX_REQUEST_SIZE.DEFAULT) {\n  const contentLength = req.headers['content-length'];\n  if (contentLength && parseInt(contentLength) > maxSize) {\n    return {\n      valid: false,\n      error: {\n        status: 413,\n        message: 'Request too large',\n      },\n    };\n  }\n  return { valid: true };\n}\n\n/**\n * Sanitize error message for production\n */\nfunction sanitizeError(error, isProduction = false) {\n  if (isProduction) {\n    // In production, don't expose internal error details\n    return {\n      error: 'An error occurred',\n      message: 'Please try again later or contact support if the problem persists.',\n    };\n  }\n  \n  // In development, return full error details\n  return {\n    error: error.message || 'An error occurred',\n    message: error.message,\n    stack: error.stack,\n  };\n}\n\n/**\n * Standard error response\n */\nfunction sendErrorResponse(res, error, statusCode = 500, isProduction = false) {\n  setCORSHeaders(res);\n  const sanitized = sanitizeError(error, isProduction);\n  return res.status(statusCode).json(sanitized);\n}\n\n/**\n * Standard success response\n */\nfunction sendSuccessResponse(res, data, statusCode = 200) {\n  setCORSHeaders(res);\n  return res.status(statusCode).json(data);\n}\n\n/**\n * Get client IP address from request\n */\nfunction getClientIP(req) {\n  return req.headers['x-forwarded-for']?.split(',')[0] || \n         req.headers['x-real-ip'] || \n         req.connection?.remoteAddress || \n         'unknown';\n}\n\n/**\n * Validate Supabase client and return error response if invalid\n * \n * @param {Object|null} supabase - Supabase client instance\n * @param {Object} res - Express response object\n * @returns {boolean} True if valid, false if invalid (response already sent)\n */\nfunction validateSupabase(supabase, res) {\n  if (!supabase) {\n    sendErrorResponse(res, new Error('Database not configured'), 503, isProduction());\n    return false;\n  }\n  return true;\n}\n\n/**\n * Check if environment is production\n */\nfunction isProduction() {\n  return process.env.NODE_ENV === 'production';\n}\n\n/**\n * Structured logging with levels\n */\nfunction formatLog(level, message) {\n  const timestamp = new Date().toISOString();\n  return `[${timestamp}] [${level.toUpperCase()}] ${message}`;\n}\n\n/**\n * Info log (only in non-production)\n */\nfunction log(message, data = null) {\n  if (!isProduction()) {\n    if (data) {\n      console.log(formatLog('info', message), data);\n    } else {\n      console.log(formatLog('info', message));\n    }\n  }\n}\n\n/**\n * Error log (always logs, even in production)\n */\nfunction logError(message, error = null) {\n  if (error) {\n    console.error(formatLog('error', message), error);\n  } else {\n    console.error(formatLog('error', message));\n  }\n}\n\n/**\n * Warning log (only in non-production)\n */\nfunction logWarn(message, data = null) {\n  if (!isProduction()) {\n    if (data) {\n      console.warn(formatLog('warn', message), data);\n    } else {\n      console.warn(formatLog('warn', message));\n    }\n  }\n}\n\n/**\n * Debug log (only in non-production, for verbose debugging)\n */\nfunction logDebug(message, data = null) {\n  if (!isProduction() && process.env.DEBUG === 'true') {\n    if (data) {\n      console.log(formatLog('debug', message), data);\n    } else {\n      console.log(formatLog('debug', message));\n    }\n  }\n}\n\n/**\n * Simple in-memory rate limiter\n * For production, use Redis or similar distributed store\n */\nconst rateLimitStore = new Map();\n\nfunction checkRateLimit(ip, windowMs, maxRequests) {\n  const now = Date.now();\n  const key = ip;\n  \n  if (!rateLimitStore.has(key)) {\n    rateLimitStore.set(key, { count: 1, resetTime: now + windowMs });\n    return true;\n  }\n  \n  const record = rateLimitStore.get(key);\n  \n  // Reset if window expired\n  if (now > record.resetTime) {\n    record.count = 1;\n    record.resetTime = now + windowMs;\n    return true;\n  }\n  \n  // Check if limit exceeded\n  if (record.count >= maxRequests) {\n    return false;\n  }\n  \n  record.count++;\n  return true;\n}\n\n// Clean up old entries periodically\nconst { RATE_LIMIT } = require('./constants');\nsetInterval(() => {\n  const now = Date.now();\n  for (const [key, record] of rateLimitStore.entries()) {\n    if (now > record.resetTime) {\n      rateLimitStore.delete(key);\n    }\n  }\n}, RATE_LIMIT.WINDOW);\n\nmodule.exports = {\n  setCORSHeaders,\n  handlePreflight,\n  validateRequestSize,\n  sanitizeError,\n  sendErrorResponse,\n  sendSuccessResponse,\n  getClientIP,\n  validateSupabase,\n  checkRateLimit,\n  isProduction,\n  log,\n  logError,\n  logWarn,\n  logDebug,\n};\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 629, "column": 0}, "map": {"version":3,"sources":["file:///Users/ron.feathers/GitHub/LUCI/lib/salesforce-client.js"],"sourcesContent":["/**\n * Shared Salesforce Client Utilities\n * \n * Centralized Salesforce authentication and common operations\n */\n\nconst { getSupabaseClient } = require('./supabase-client');\nconst { log, logError, logWarn, isProduction } = require('./api-helpers');\n\n/**\n * Get jsforce client library\n */\nfunction getJsforceClient() {\n  try {\n    const jsforce = require('jsforce');\n    return jsforce;\n  } catch (error) {\n    logWarn('jsforce not available:', error.message);\n    return null;\n  }\n}\n\n/**\n * Authenticate with Salesforce using jsforce\n * \n * @param {Object} supabase - Supabase client instance\n * @returns {Promise<Object>} Connection object with connection, instanceUrl, and accessToken\n */\nasync function authenticateSalesforce(supabase) {\n  // Get Salesforce config from Supabase\n  const { data: config, error: configError } = await supabase\n    .from('salesforce_configs')\n    .select('*')\n    .eq('is_active', true)\n    .single();\n\n  if (configError) {\n    logError('Error fetching Salesforce config:', configError);\n    throw new Error(`Error fetching Salesforce config: ${configError.message}`);\n  }\n  \n  if (!config) {\n    logError('No active Salesforce configuration found in salesforce_configs table');\n    throw new Error('Salesforce configuration not found in Supabase. Please insert credentials into salesforce_configs table.');\n  }\n  \n  const jsforce = getJsforceClient();\n  if (!jsforce) {\n    logError('jsforce library not available');\n    throw new Error('jsforce library not available. Make sure jsforce is installed: npm install jsforce');\n  }\n\n  // Clean login URL (handle custom domains like leandata.my.salesforce.com)\n  let loginUrl = config.login_url || 'https://login.salesforce.com';\n  loginUrl = loginUrl.trim().replace(/\\/$/, '');\n  \n  // For custom domains ending in .my.salesforce.com, keep as-is\n  // jsforce will handle the authentication\n  if (!loginUrl.startsWith('http://') && !loginUrl.startsWith('https://')) {\n    loginUrl = 'https://' + loginUrl;\n  }\n\n  // Create connection\n  const conn = new jsforce.Connection({\n    loginUrl: loginUrl\n  });\n\n  // Authenticate (jsforce handles OAuth internally - no Client ID/Secret needed!)\n  try {\n    await conn.login(config.username, config.password + (config.security_token || ''));\n  } catch (error) {\n    // Try with password only if first attempt fails\n    if (error.message && error.message.includes('INVALID_LOGIN')) {\n      await conn.login(config.username, config.password);\n    } else {\n      throw error;\n    }\n  }\n\n  return {\n    connection: conn,\n    instanceUrl: conn.instanceUrl,\n    accessToken: conn.accessToken,\n  };\n}\n\n/**\n * Escape single quotes in SOQL queries to prevent injection\n * \n * @param {string} str - String to escape\n * @returns {string} Escaped string\n */\nfunction escapeSOQL(str) {\n  if (!str) return '';\n  return str.replace(/'/g, \"\\\\'\");\n}\n\nmodule.exports = {\n  getJsforceClient,\n  authenticateSalesforce,\n  escapeSOQL,\n};\n\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED,MAAM,EAAE,iBAAiB,EAAE;AAC3B,MAAM,EAAE,GAAG,EAAE,QAAQ,EAAE,OAAO,EAAE,YAAY,EAAE;AAE9C;;CAEC,GACD,SAAS;IACP,IAAI;QACF,MAAM;QACN,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,0BAA0B,MAAM,OAAO;QAC/C,OAAO;IACT;AACF;AAEA;;;;;CAKC,GACD,eAAe,uBAAuB,QAAQ;IAC5C,sCAAsC;IACtC,MAAM,EAAE,MAAM,MAAM,EAAE,OAAO,WAAW,EAAE,GAAG,MAAM,SAChD,IAAI,CAAC,sBACL,MAAM,CAAC,KACP,EAAE,CAAC,aAAa,MAChB,MAAM;IAET,IAAI,aAAa;QACf,SAAS,qCAAqC;QAC9C,MAAM,IAAI,MAAM,CAAC,kCAAkC,EAAE,YAAY,OAAO,EAAE;IAC5E;IAEA,IAAI,CAAC,QAAQ;QACX,SAAS;QACT,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,UAAU;IAChB,IAAI,CAAC,SAAS;QACZ,SAAS;QACT,MAAM,IAAI,MAAM;IAClB;IAEA,0EAA0E;IAC1E,IAAI,WAAW,OAAO,SAAS,IAAI;IACnC,WAAW,SAAS,IAAI,GAAG,OAAO,CAAC,OAAO;IAE1C,8DAA8D;IAC9D,yCAAyC;IACzC,IAAI,CAAC,SAAS,UAAU,CAAC,cAAc,CAAC,SAAS,UAAU,CAAC,aAAa;QACvE,WAAW,aAAa;IAC1B;IAEA,oBAAoB;IACpB,MAAM,OAAO,IAAI,QAAQ,UAAU,CAAC;QAClC,UAAU;IACZ;IAEA,gFAAgF;IAChF,IAAI;QACF,MAAM,KAAK,KAAK,CAAC,OAAO,QAAQ,EAAE,OAAO,QAAQ,GAAG,CAAC,OAAO,cAAc,IAAI,EAAE;IAClF,EAAE,OAAO,OAAO;QACd,gDAAgD;QAChD,IAAI,MAAM,OAAO,IAAI,MAAM,OAAO,CAAC,QAAQ,CAAC,kBAAkB;YAC5D,MAAM,KAAK,KAAK,CAAC,OAAO,QAAQ,EAAE,OAAO,QAAQ;QACnD,OAAO;YACL,MAAM;QACR;IACF;IAEA,OAAO;QACL,YAAY;QACZ,aAAa,KAAK,WAAW;QAC7B,aAAa,KAAK,WAAW;IAC/B;AACF;AAEA;;;;;CAKC,GACD,SAAS,WAAW,GAAG;IACrB,IAAI,CAAC,KAAK,OAAO;IACjB,OAAO,IAAI,OAAO,CAAC,MAAM;AAC3B;AAEA,OAAO,OAAO,GAAG;IACf;IACA;IACA;AACF"}},
    {"offset": {"line": 713, "column": 0}, "map": {"version":3,"sources":["file:///Users/ron.feathers/GitHub/LUCI/lib/cache-helpers.js"],"sourcesContent":["/**\n * Shared Cache Helper Functions\n * \n * Common utilities for cache management\n */\n\nconst { CACHE_TTL } = require('./constants');\n\n/**\n * Check if cached data is fresh based on TTL\n * \n * @param {string|Date} lastSyncedAt - Last sync timestamp\n * @param {number} ttlHours - Time to live in hours (or string key from CACHE_TTL)\n * @returns {boolean} True if cache is fresh\n */\nfunction isCacheFresh(lastSyncedAt, ttlHours) {\n  if (!lastSyncedAt) return false;\n  \n  // If ttlHours is a string, look it up in CACHE_TTL\n  const ttl = typeof ttlHours === 'string' ? (CACHE_TTL[ttlHours] || CACHE_TTL.ACCOUNTS) : ttlHours;\n  \n  const now = new Date();\n  const cacheExpiry = ttl * 60 * 60 * 1000;\n  const lastSynced = new Date(lastSyncedAt);\n  \n  if (isNaN(lastSynced.getTime())) return false;\n  \n  return (now - lastSynced) < cacheExpiry;\n}\n\n/**\n * Check if cache is fresh for a given resource type\n * \n * @param {string|Date} lastSyncedAt - Last sync timestamp\n * @param {string} resourceType - Type of resource (ACCOUNTS, CASES, CONTACTS, etc.)\n * @returns {boolean} True if cache is fresh\n */\nfunction isResourceCacheFresh(lastSyncedAt, resourceType) {\n  return isCacheFresh(lastSyncedAt, resourceType);\n}\n\n/**\n * Get cache TTL in milliseconds for a resource type\n * \n * @param {string} resourceType - Type of resource\n * @returns {number} TTL in milliseconds\n */\nfunction getCacheTTLMs(resourceType) {\n  const ttlHours = CACHE_TTL[resourceType] || CACHE_TTL.ACCOUNTS;\n  return ttlHours * 60 * 60 * 1000;\n}\n\n/**\n * Calculate cache age in milliseconds\n * \n * @param {string|Date} lastSyncedAt - Last sync timestamp\n * @returns {number} Age in milliseconds, or null if invalid\n */\nfunction getCacheAge(lastSyncedAt) {\n  if (!lastSyncedAt) return null;\n  \n  const now = new Date();\n  const lastSynced = new Date(lastSyncedAt);\n  \n  if (isNaN(lastSynced.getTime())) return null;\n  \n  return now - lastSynced;\n}\n\nmodule.exports = {\n  isCacheFresh,\n  isResourceCacheFresh,\n  getCacheTTLMs,\n  getCacheAge,\n  CACHE_TTL,\n};\n\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED,MAAM,EAAE,SAAS,EAAE;AAEnB;;;;;;CAMC,GACD,SAAS,aAAa,YAAY,EAAE,QAAQ;IAC1C,IAAI,CAAC,cAAc,OAAO;IAE1B,mDAAmD;IACnD,MAAM,MAAM,OAAO,aAAa,WAAY,SAAS,CAAC,SAAS,IAAI,UAAU,QAAQ,GAAI;IAEzF,MAAM,MAAM,IAAI;IAChB,MAAM,cAAc,MAAM,KAAK,KAAK;IACpC,MAAM,aAAa,IAAI,KAAK;IAE5B,IAAI,MAAM,WAAW,OAAO,KAAK,OAAO;IAExC,OAAO,AAAC,MAAM,aAAc;AAC9B;AAEA;;;;;;CAMC,GACD,SAAS,qBAAqB,YAAY,EAAE,YAAY;IACtD,OAAO,aAAa,cAAc;AACpC;AAEA;;;;;CAKC,GACD,SAAS,cAAc,YAAY;IACjC,MAAM,WAAW,SAAS,CAAC,aAAa,IAAI,UAAU,QAAQ;IAC9D,OAAO,WAAW,KAAK,KAAK;AAC9B;AAEA;;;;;CAKC,GACD,SAAS,YAAY,YAAY;IAC/B,IAAI,CAAC,cAAc,OAAO;IAE1B,MAAM,MAAM,IAAI;IAChB,MAAM,aAAa,IAAI,KAAK;IAE5B,IAAI,MAAM,WAAW,OAAO,KAAK,OAAO;IAExC,OAAO,MAAM;AACf;AAEA,OAAO,OAAO,GAAG;IACf;IACA;IACA;IACA;IACA;AACF"}},
    {"offset": {"line": 775, "column": 0}, "map": {"version":3,"sources":["file:///Users/ron.feathers/GitHub/LUCI/src/app/api/salesforce-accounts/route.js"],"sourcesContent":["/**\n * Next.js App Router API Route for Salesforce Account Fetching\n * \n * Fetches accounts from Salesforce assigned to a user based on their role\n * Uses Supabase to store credentials and account assignments\n * Uses jsforce library (same as SOW-Generator) - no Client ID/Secret needed!\n */\n\nimport { NextRequest } from 'next/server';\nimport { getSupabaseClient } from '../../../lib/supabase-server';\nimport { handlePreflight, validateRequestSize, sendErrorResponse, sendSuccessResponse, validateSupabase, log, logError, logWarn, isProduction } from '../../../lib/next-api-helpers';\n\n// Can use require for lib files in Next.js API routes\nconst { authenticateSalesforce, escapeSOQL } = require('../../../../lib/salesforce-client');\nconst { isCacheFresh } = require('../../../../lib/cache-helpers');\nconst { MAX_REQUEST_SIZE, CACHE_TTL, API_LIMITS } = require('../../../../lib/constants');\n\n/**\n * Query Salesforce for accounts based on user role/ownership\n * Uses standard fields only (custom fields may not exist in all orgs)\n * Note: Salesforce doesn't allow semi-join subqueries with OR, so we query separately and combine\n */\n\nasync function querySalesforceAccounts(conn, userId, userEmail, role, ownerOnly = false) {\n  // First, get the Salesforce User ID for the email (needed for AccountTeamMember query)\n  let salesforceUserId = null;\n  try {\n    const escapedEmail = escapeSOQL(userEmail);\n    const userQuery = `SELECT Id FROM User WHERE Email = '${escapedEmail}' LIMIT 1`;\n    const userResult = await conn.query(userQuery);\n    if (userResult.records && userResult.records.length > 0) {\n      salesforceUserId = userResult.records[0].Id;\n      log(`Found Salesforce User ID: ${salesforceUserId} for email: ${userEmail}`);\n    } else {\n      logWarn(`No Salesforce User found for email: ${userEmail}`);\n    }\n  } catch (error) {\n    logWarn(`Could not find Salesforce User for email ${userEmail}:`, error.message);\n  }\n  \n  // Field selection - try custom fields first, fallback to standard\n  // Using Employee_Band__c for Account Segment (Tier) - confirmed API name\n  // Using Expiring_Revenue__c for Contract Value (Expiring ARR) - confirmed API name\n  // Type is a standard field used to filter out \"Former Customer\" accounts\n  const customFields = `Id, Name, Employee_Band__c, Expiring_Revenue__c, Type, Industry, AnnualRevenue, OwnerId, Owner.Name, Owner.Email`;\n  const standardFields = `Id, Name, Type, Industry, AnnualRevenue, OwnerId, Owner.Name, Owner.Email`;\n  \n  let useCustomFields = true;\n  let allAccounts = [];\n  const accountMap = new Map(); // Use Map to deduplicate by Account Id\n  \n  // If ownerOnly is true, only query accounts owned by the user (ignore role and team member accounts)\n  // Otherwise, use role-based logic\n  if (ownerOnly || role === 'Account Manager' || role === 'Sales Rep') {\n    // Query 1: Accounts owned by user (by Owner.Email)\n    // Filter by Type != 'Former Customer' to exclude former customers\n    try {\n      const escapedEmail = escapeSOQL(userEmail);\n      let ownerQuery = `SELECT ${customFields} FROM Account WHERE Owner.Email = '${escapedEmail}' AND Type != 'Former Customer' ORDER BY Name LIMIT 100`;\n      \n      try {\n        const ownerResult = await conn.query(ownerQuery);\n        if (ownerResult.records) {\n          ownerResult.records.forEach(acc => {\n            accountMap.set(acc.Id, acc);\n          });\n          log(`Found ${ownerResult.records.length} accounts owned by ${userEmail}`);\n        }\n        } catch (error) {\n          if (error.errorCode === 'INVALID_FIELD') {\n            // Log which field is invalid for debugging\n            logWarn('INVALID_FIELD error in Salesforce query', { errorCode: error.errorCode });\n            \n            // Check if error is about Type field\n            const typeError = error.message && error.message.includes('Type');\n            \n            if (typeError) {\n              // Type field doesn't exist or has issues - retry without filter\n              logWarn('Type field issue on Account, querying without Type filter');\n              try {\n                ownerQuery = `SELECT ${customFields} FROM Account WHERE Owner.Email = '${escapedEmail}' ORDER BY Name LIMIT 100`;\n                const ownerResult = await conn.query(ownerQuery);\n                if (ownerResult.records) {\n                  ownerResult.records.forEach(acc => {\n                    accountMap.set(acc.Id, acc);\n                  });\n                  log(`Found ${ownerResult.records.length} accounts owned by ${userEmail} (without Type filter)`);\n                }\n              } catch (retryError) {\n                // If still fails, might be custom fields issue\n                if (retryError.errorCode === 'INVALID_FIELD') {\n                  logWarn('Custom fields not found, trying alternative field names...');\n                  \n                  // Try alternative field names (including Employee_Band__c for tier)\n                  const altCustomFields = `Id, Name, Employee_Band__c, Expiring_Revenue__c, Tier__c, ContractValue__c, Industry, AnnualRevenue, OwnerId, Owner.Name, Owner.Email`;\n                  try {\n                    ownerQuery = `SELECT ${altCustomFields} FROM Account WHERE Owner.Email = '${escapedEmail}' ORDER BY Name LIMIT 100`;\n                    const altResult = await conn.query(ownerQuery);\n                    if (altResult.records) {\n                      altResult.records.forEach(acc => {\n                        accountMap.set(acc.Id, acc);\n                      });\n                      log(`Found ${altResult.records.length} accounts with alternative field names`);\n                    }\n                  } catch (altError) {\n                    // If alternative fields also fail, fall back to standard fields\n                    logWarn('Alternative custom fields also not found, using standard fields only');\n                    useCustomFields = false;\n                    ownerQuery = `SELECT ${standardFields} FROM Account WHERE Owner.Email = '${escapedEmail}' ORDER BY Name LIMIT 100`;\n                    const ownerResult = await conn.query(ownerQuery);\n                    if (ownerResult.records) {\n                      ownerResult.records.forEach(acc => {\n                        accountMap.set(acc.Id, acc);\n                      });\n                      log(`Found ${ownerResult.records.length} accounts owned by ${userEmail} (standard fields only)`);\n                    }\n                  }\n                } else {\n                  throw retryError;\n                }\n              }\n            } else {\n              // Not a Type error, try alternative field names\n              logWarn('Custom fields not found, trying alternative field names...');\n              \n              // Try alternative field names (including Employee_Band__c for tier)\n              const altCustomFields = `Id, Name, Employee_Band__c, Expiring_Revenue__c, Tier__c, ContractValue__c, Type, Industry, AnnualRevenue, OwnerId, Owner.Name, Owner.Email`;\n              try {\n                ownerQuery = `SELECT ${altCustomFields} FROM Account WHERE Owner.Email = '${escapedEmail}' AND Type != 'Former Customer' ORDER BY Name LIMIT 100`;\n                const altResult = await conn.query(ownerQuery);\n                if (altResult.records) {\n                  altResult.records.forEach(acc => {\n                    accountMap.set(acc.Id, acc);\n                  });\n                  log(`Found ${altResult.records.length} accounts with alternative field names`);\n                }\n              } catch (altError) {\n                // If alternative fields also fail, check if it's Type error\n                if (altError.errorCode === 'INVALID_FIELD' && altError.message && altError.message.includes('Type')) {\n                  logWarn('Type field not found, retrying without Type filter');\n                  ownerQuery = `SELECT ${altCustomFields} FROM Account WHERE Owner.Email = '${escapedEmail}' ORDER BY Name LIMIT 100`;\n                  const altResult = await conn.query(ownerQuery);\n                  if (altResult.records) {\n                    altResult.records.forEach(acc => {\n                      accountMap.set(acc.Id, acc);\n                    });\n                  }\n                } else {\n                  // If alternative fields also fail, fall back to standard fields\n                  logWarn('Alternative custom fields also not found, using standard fields only');\n              useCustomFields = false;\n              ownerQuery = `SELECT ${standardFields} FROM Account WHERE Owner.Email = '${escapedEmail}' AND Type != 'Former Customer' ORDER BY Name LIMIT 100`;\n              try {\n                const ownerResult = await conn.query(ownerQuery);\n                if (ownerResult.records) {\n                  ownerResult.records.forEach(acc => {\n                    accountMap.set(acc.Id, acc);\n                  });\n                  log(`Found ${ownerResult.records.length} accounts owned by ${userEmail} (standard fields only)`);\n                }\n              } catch (stdError) {\n                // Last resort: standard fields without Type filter\n                if (stdError.errorCode === 'INVALID_FIELD' && stdError.message && stdError.message.includes('Type')) {\n                  ownerQuery = `SELECT ${standardFields} FROM Account WHERE Owner.Email = '${escapedEmail}' ORDER BY Name LIMIT 100`;\n                      const ownerResult = await conn.query(ownerQuery);\n                      if (ownerResult.records) {\n                        ownerResult.records.forEach(acc => {\n                          accountMap.set(acc.Id, acc);\n                        });\n                      }\n                    } else {\n                      throw stdError;\n                    }\n                  }\n                }\n              }\n            }\n          } else {\n            throw error;\n          }\n        }\n    } catch (error) {\n      logError('Error querying accounts by owner:', error);\n    }\n    \n    // Query 2: Accounts from AccountTeamMember (if we have User ID)\n    // Skip team member accounts if ownerOnly is true\n    if (!ownerOnly && salesforceUserId) {\n      try {\n        // First get Account IDs from AccountTeamMember\n        const teamMemberQuery = `SELECT AccountId FROM AccountTeamMember WHERE UserId = '${salesforceUserId}' LIMIT 100`;\n        const teamResult = await conn.query(teamMemberQuery);\n        \n        if (teamResult.records && teamResult.records.length > 0) {\n          const accountIds = teamResult.records.map(tm => tm.AccountId);\n          \n          // Query accounts by IDs (Salesforce allows up to 200 IDs in IN clause)\n          // Escape IDs to prevent injection (though IDs are typically safe)\n          // Filter by Type != 'Former Customer' to exclude former customers\n          const fields = useCustomFields ? customFields : standardFields;\n          const idsString = accountIds.map(id => `'${escapeSOQL(id)}'`).join(',');\n          const accountQuery = `SELECT ${fields} FROM Account WHERE Id IN (${idsString}) AND Type != 'Former Customer' ORDER BY Name`;\n          \n          try {\n            const accountResult = await conn.query(accountQuery);\n            if (accountResult.records) {\n              accountResult.records.forEach(acc => {\n                accountMap.set(acc.Id, acc);\n              });\n              log(`Found ${accountResult.records.length} accounts from AccountTeamMember`);\n            }\n          } catch (error) {\n            if (error.errorCode === 'INVALID_FIELD' && useCustomFields) {\n              // Retry with standard fields\n              const standardAccountQuery = `SELECT ${standardFields} FROM Account WHERE Id IN (${idsString}) AND Type != 'Former Customer' ORDER BY Name`;\n              const accountResult = await conn.query(standardAccountQuery);\n              if (accountResult.records) {\n                accountResult.records.forEach(acc => {\n                  accountMap.set(acc.Id, acc);\n                });\n                log(`Found ${accountResult.records.length} accounts from AccountTeamMember (standard fields)`);\n              }\n            } else {\n              logError('Error querying accounts from AccountTeamMember:', error);\n            }\n          }\n        }\n        } catch (error) {\n          logError('Error querying AccountTeamMember:', error);\n        }\n    }\n    \n    // Convert Map to array\n    allAccounts = Array.from(accountMap.values());\n    \n  } else {\n    // For admins or other roles, get all accounts\n    // Filter by Type != 'Former Customer' to exclude former customers\n    try {\n      let adminQuery = `SELECT ${customFields} FROM Account WHERE Type != 'Former Customer' ORDER BY Name LIMIT 100`;\n      try {\n        const result = await conn.query(adminQuery);\n        allAccounts = result.records || [];\n      } catch (error) {\n        if (error.errorCode === 'INVALID_FIELD') {\n          logWarn('Custom fields not found, using standard fields only');\n          adminQuery = `SELECT ${standardFields} FROM Account WHERE Type != 'Former Customer' ORDER BY Name LIMIT 100`;\n          const result = await conn.query(adminQuery);\n          allAccounts = result.records || [];\n        } else {\n          throw error;\n        }\n      }\n    } catch (error) {\n      logError('Error querying all accounts:', error);\n      throw error;\n    }\n  }\n  \n  return allAccounts;\n}\n\n/**\n * Search for cached accounts in Supabase by name\n */\nasync function searchCachedAccounts(supabase, searchTerm) {\n  if (!supabase || !searchTerm || searchTerm.trim().length < 2) {\n    return null;\n  }\n\n  const search = searchTerm.trim();\n  \n  // Search in Supabase cache by account name (case-insensitive)\n  const { data: cachedAccounts, error } = await supabase\n    .from('accounts')\n    .select('*')\n    .ilike('name', `%${search}%`)\n    .order('name', { ascending: true })\n    .limit(20);\n\n  if (error || !cachedAccounts || cachedAccounts.length === 0) {\n    return null;\n  }\n\n  // Check if cache is fresh (within TTL)\n  const now = new Date();\n  const cacheExpiry = CACHE_TTL.ACCOUNTS * 60 * 60 * 1000;\n  \n  // Check if all accounts are fresh (within TTL)\n  const allFresh = cachedAccounts.every(acc => {\n    if (!acc.last_synced_at) return false;\n    const lastSynced = new Date(acc.last_synced_at);\n    return (now - lastSynced) < cacheExpiry;\n  });\n\n  return {\n    accounts: cachedAccounts,\n    isFresh: allFresh,\n  };\n}\n\n/**\n * Search for accounts in Salesforce by name\n */\nasync function searchSalesforceAccounts(conn, searchTerm) {\n  if (!searchTerm || searchTerm.trim().length < 2) {\n    return [];\n  }\n\n  const escapedSearch = escapeSOQL(searchTerm.trim());\n  \n  // Field selection - try custom fields first, fallback to standard\n  // Using Employee_Band__c for Account Segment (Tier) - confirmed API name\n  // Using Expiring_Revenue__c for Contract Value (Expiring ARR) - confirmed API name\n  // Type is a standard field used to filter out \"Former Customer\" accounts\n  const customFields = `Id, Name, Employee_Band__c, Expiring_Revenue__c, Type, Industry, AnnualRevenue, OwnerId, Owner.Name, Owner.Email`;\n  const standardFields = `Id, Name, Type, Industry, AnnualRevenue, OwnerId, Owner.Name, Owner.Email`;\n  \n  // Use LIKE for partial matching (case-insensitive)\n  // Filter by Type != 'Former Customer' to exclude former customers\n  let searchQuery = `SELECT ${customFields} FROM Account WHERE Name LIKE '%${escapedSearch}%' AND Type != 'Former Customer' ORDER BY Name LIMIT 20`;\n  \n  try {\n    const result = await conn.query(searchQuery);\n    return result.records || [];\n  } catch (error) {\n    if (error.errorCode === 'INVALID_FIELD') {\n      // Check if error is about Type field\n      const typeError = error.message && error.message.includes('Type');\n      \n      if (typeError) {\n        // Type field doesn't exist or has issues - retry without filter\n        logWarn('Type field issue on Account, searching without Type filter');\n        try {\n          searchQuery = `SELECT ${customFields} FROM Account WHERE Name LIKE '%${escapedSearch}%' ORDER BY Name LIMIT 20`;\n          const result = await conn.query(searchQuery);\n          return result.records || [];\n        } catch (retryError) {\n          // If still fails, might be custom fields issue\n          if (retryError.errorCode === 'INVALID_FIELD') {\n            // Retry with standard fields (without Type filter)\n            searchQuery = `SELECT ${standardFields} FROM Account WHERE Name LIKE '%${escapedSearch}%' ORDER BY Name LIMIT 20`;\n            const result = await conn.query(searchQuery);\n            return result.records || [];\n          } else {\n            throw retryError;\n          }\n        }\n      } else {\n        // Not a Type error, try standard fields with Type filter\n        try {\n          searchQuery = `SELECT ${standardFields} FROM Account WHERE Name LIKE '%${escapedSearch}%' AND Type != 'Former Customer' ORDER BY Name LIMIT 20`;\n          const result = await conn.query(searchQuery);\n          return result.records || [];\n        } catch (stdError) {\n          // If standard fields with Type filter fails, check if it's Type error\n          if (stdError.errorCode === 'INVALID_FIELD' && stdError.message && stdError.message.includes('Type')) {\n            // Last resort: standard fields without Type filter\n            searchQuery = `SELECT ${standardFields} FROM Account WHERE Name LIKE '%${escapedSearch}%' ORDER BY Name LIMIT 20`;\n            const result = await conn.query(searchQuery);\n            return result.records || [];\n          } else {\n            throw stdError;\n          }\n        }\n      }\n    } else {\n      logError('Error searching accounts:', error);\n      throw error;\n    }\n  }\n}\n\n/**\n * Sync accounts from Salesforce to Supabase\n * @param {Object} supabase - Supabase client\n * @param {Array} sfdcAccounts - Accounts from Salesforce\n * @param {string} userId - User ID (optional, only used if createRelationships is true)\n * @param {boolean} createRelationships - Whether to create user_accounts relationships (default: true)\n */\nasync function syncAccountsToSupabase(supabase, sfdcAccounts, userId = null, createRelationships = true) {\n  if (!supabase || !sfdcAccounts || sfdcAccounts.length === 0) {\n    return [];\n  }\n\n  const syncedAccounts = [];\n\n  for (const sfdcAccount of sfdcAccounts) {\n    // Upsert account in Supabase\n    // Handle custom fields that may not exist (they'll be undefined)\n    // Try multiple possible field names for tier and contract value\n    // Primary: Employee_Band__c (Account Segment - matches SOW-Generator)\n    const accountTier = sfdcAccount.Employee_Band__c\n      || sfdcAccount.Account_Segment__c\n      || sfdcAccount.Account_Tier__c \n      || sfdcAccount.Tier__c \n      || sfdcAccount.AccountTier__c\n      || sfdcAccount.Tier\n      || null;\n    \n    // Primary: Expiring_Revenue__c (Expiring ARR - confirmed API name)\n    const contractValue = sfdcAccount.Expiring_Revenue__c\n      || sfdcAccount.Expiring_ARR__c\n      || sfdcAccount.ExpiringARR__c\n      || sfdcAccount.ARR_Expiring__c\n      || sfdcAccount.Contract_Value__c\n      || sfdcAccount.ContractValue__c\n      || sfdcAccount.Contract_Value\n      || sfdcAccount.ContractValue\n      || null;\n    \n    const accountData = {\n      salesforce_id: sfdcAccount.Id,\n      name: sfdcAccount.Name,\n      account_tier: accountTier,\n      contract_value: contractValue,\n      industry: sfdcAccount.Industry || null,\n      annual_revenue: sfdcAccount.AnnualRevenue || null,\n      owner_id: sfdcAccount.OwnerId || null,\n      owner_name: sfdcAccount.Owner?.Name || null,\n      last_synced_at: new Date().toISOString(), // Track when this account was last synced\n    };\n\n    const { data: account, error: accountError } = await supabase\n      .from('accounts')\n      .upsert(accountData, {\n        onConflict: 'salesforce_id',\n        ignoreDuplicates: false,\n      })\n      .select()\n      .single();\n\n    if (accountError) {\n      logError(`Error syncing account ${sfdcAccount.Id}:`, accountError);\n      continue;\n    }\n\n    // Only create user-account relationship if:\n    // 1. createRelationships is true (regular query flow, not search)\n    // 2. userId is provided\n    // 3. The user is actually the owner of this account (verify ownership)\n    if (createRelationships && userId && account) {\n      // Verify that this account should be associated with this user\n      // We'll check ownership when retrieving cached accounts, but we can also verify here\n      // For now, we trust that syncAccountsToSupabase is only called with accounts the user owns/is a team member of\n      const { error: relationError } = await supabase\n        .from('user_accounts')\n        .upsert({\n          user_id: userId,\n          account_id: account.id,\n        }, {\n          onConflict: 'user_id,account_id',\n          ignoreDuplicates: true,\n        });\n\n      if (relationError) {\n        logError(`Error creating user-account relationship:`, relationError);\n      }\n    }\n\n    syncedAccounts.push(account);\n  }\n\n  return syncedAccounts;\n}\n\n/**\n * Get cached accounts from Supabase\n * Returns accounts and whether they need refresh (based on last_synced_at)\n * Only returns accounts where the user is actually the owner (verified by owner_id matching Salesforce User ID)\n */\nasync function getCachedAccounts(supabase, userId, email, role) {\n  if (!supabase) {\n    return { accounts: null, needsRefresh: true };\n  }\n\n  // Get user\n  let user;\n  if (userId) {\n    const { data: userData } = await supabase\n      .from('users')\n      .select('*')\n      .eq('id', userId)\n      .single();\n    user = userData;\n  } else if (email) {\n    const { data: userData } = await supabase\n      .from('users')\n      .select('*')\n      .eq('email', email)\n      .single();\n    user = userData;\n  }\n\n  if (!user) {\n    return { accounts: null, needsRefresh: true };\n  }\n\n  // Get accounts from user_accounts relationships\n  // These should only be accounts the user owns or is a team member of\n  const { data: userAccounts, error: userAccountsError } = await supabase\n    .from('user_accounts')\n    .select(`\n      account_id,\n      accounts (\n        id,\n        salesforce_id,\n        name,\n        account_tier,\n        contract_value,\n        industry,\n        annual_revenue,\n        owner_id,\n        owner_name,\n        last_synced_at\n      )\n    `)\n    .eq('user_id', user.id);\n\n  if (userAccountsError) {\n    logError('Error fetching user_accounts:', userAccountsError);\n    return { accounts: null, needsRefresh: true };\n  }\n\n  if (!userAccounts || userAccounts.length === 0) {\n    return { accounts: null, needsRefresh: true };\n  }\n\n  // Check if any account needs refresh (older than CACHE_TTL_HOURS)\n  const now = new Date();\n  const cacheExpiry = CACHE_TTL.ACCOUNTS * 60 * 60 * 1000; // Convert hours to milliseconds\n  let needsRefresh = false;\n\n  const accounts = userAccounts\n    .filter(ua => ua.accounts) // Filter out any null accounts\n    .map(ua => {\n      const account = ua.accounts;\n      if (!account) return null;\n      \n      const lastSynced = account.last_synced_at ? new Date(account.last_synced_at) : null;\n      \n      // Check if this account needs refresh\n      if (!lastSynced || (now - lastSynced) > cacheExpiry) {\n        needsRefresh = true;\n      }\n\n      return {\n        id: account.salesforce_id || account.id,\n        salesforceId: account.salesforce_id,\n        name: account.name,\n        accountTier: account.account_tier,\n        contractValue: account.contract_value,\n        industry: account.industry,\n        annualRevenue: account.annual_revenue ? parseFloat(account.annual_revenue) : null,\n        ownerId: account.owner_id,\n        ownerName: account.owner_name,\n        lastSyncedAt: account.last_synced_at,\n      };\n    })\n    .filter(acc => acc !== null); // Remove any null entries\n\n  return { accounts, needsRefresh };\n}\n\n// Handle OPTIONS preflight\nexport async function OPTIONS() {\n  return handlePreflight(new NextRequest('http://localhost', { method: 'OPTIONS' }));\n}\n\n// GET /api/salesforce-accounts\nexport async function GET(request) {\n  const preflight = await handlePreflight(request);\n  if (preflight) return preflight;\n\n  const sizeValidation = validateRequestSize(request, MAX_REQUEST_SIZE.DEFAULT);\n  if (!sizeValidation.valid) {\n    return sendErrorResponse(new Error(sizeValidation.error.message), sizeValidation.error.status);\n  }\n\n  const { searchParams } = new URL(request.url);\n  const userId = searchParams.get('userId');\n  const email = searchParams.get('email');\n  const role = searchParams.get('role');\n  const forceRefresh = searchParams.get('forceRefresh');\n  const search = searchParams.get('search');\n  const ownerOnly = searchParams.get('ownerOnly');\n  const cacheOnly = searchParams.get('cacheOnly');\n\n  // Check if this is a search request\n  const isSearch = search && search.trim().length >= 2;\n  \n  // Validate input (skip validation for search requests)\n  if (!isSearch && !userId && !email) {\n    return sendErrorResponse(new Error('Missing required parameter: userId or email (or search term)'), 400);\n  }\n  \n  // Check if we should force refresh (bypass cache)\n  const shouldForceRefresh = forceRefresh === 'true' || forceRefresh === '1';\n\n  try {\n    // Get Supabase client\n    const supabase = getSupabaseClient();\n    const validation = validateSupabase(supabase);\n    \n    if (!validation.valid) {\n      return sendErrorResponse(new Error(validation.error.message), validation.error.status);\n    }\n    \n    // Handle search request (bypasses user assignment logic)\n    if (isSearch) {\n      try {\n        // CACHE-FIRST: Check Supabase cache before querying Salesforce\n        const cachedSearch = await searchCachedAccounts(supabase, search);\n        \n        if (cachedSearch && cachedSearch.isFresh) {\n          // Use cached results (fresh)\n          const accounts = cachedSearch.accounts.map(acc => ({\n            id: acc.salesforce_id || acc.id,\n            salesforceId: acc.salesforce_id,\n            name: acc.name,\n            accountTier: acc.account_tier,\n            contractValue: acc.contract_value,\n            industry: acc.industry,\n            annualRevenue: acc.annual_revenue ? parseFloat(acc.annual_revenue) : null,\n            ownerId: acc.owner_id,\n            ownerName: acc.owner_name,\n            lastSyncedAt: acc.last_synced_at,\n          }));\n          \n          return sendSuccessResponse({\n            accounts: accounts,\n            total: accounts.length,\n            searchTerm: search,\n            isSearch: true,\n            cached: true,\n          });\n        } else {\n          log(`No cache found for search: ${search}, querying Salesforce`);\n        }\n        \n        const sfdcAuth = await authenticateSalesforce(supabase);\n        const searchResults = await searchSalesforceAccounts(sfdcAuth.connection, search);\n        \n        // Sync search results to Supabase (for caching) - but don't create user relationships\n        // Pass createRelationships=false so searched accounts aren't associated with the searching user\n        const syncedAccounts = await syncAccountsToSupabase(supabase, searchResults, null, false);\n        \n        const accounts = syncedAccounts.map(acc => ({\n          id: acc.salesforce_id || acc.id,\n          salesforceId: acc.salesforce_id,\n          name: acc.name,\n          accountTier: acc.account_tier,\n          contractValue: acc.contract_value,\n          industry: acc.industry,\n          annualRevenue: acc.annual_revenue ? parseFloat(acc.annual_revenue) : null,\n          ownerId: acc.owner_id,\n          ownerName: acc.owner_name,\n          lastSyncedAt: acc.last_synced_at,\n        }));\n        \n        return sendSuccessResponse({\n          accounts: accounts,\n          total: accounts.length,\n          searchTerm: search,\n          isSearch: true,\n          cached: false,\n        });\n      } catch (searchError) {\n        logError('Salesforce search error:', searchError);\n        \n        // If Salesforce fails but we have stale cache, use it\n        const staleCache = await searchCachedAccounts(supabase, search);\n        if (staleCache && staleCache.accounts.length > 0) {\n          const accounts = staleCache.accounts.map(acc => ({\n            id: acc.salesforce_id || acc.id,\n            salesforceId: acc.salesforce_id,\n            name: acc.name,\n            accountTier: acc.account_tier,\n            contractValue: acc.contract_value,\n            industry: acc.industry,\n            annualRevenue: acc.annual_revenue ? parseFloat(acc.annual_revenue) : null,\n            ownerId: acc.owner_id,\n            ownerName: acc.owner_name,\n            lastSyncedAt: acc.last_synced_at,\n          }));\n          \n          return sendSuccessResponse({\n            accounts: accounts,\n            total: accounts.length,\n            searchTerm: search,\n            isSearch: true,\n            cached: true,\n            stale: true,\n          });\n        }\n        \n        return sendErrorResponse(searchError, 500);\n      }\n    }\n    \n    // Regular flow: get user's assigned accounts\n    // First, get the user by userId or email\n    let user;\n    try {\n      if (userId) {\n        const { data: userData, error: userError } = await supabase\n          .from('users')\n          .select('*')\n          .eq('id', userId)\n          .single();\n\n        if (userError) {\n          if (userError.code === 'PGRST116') {\n            // User not found\n            user = null;\n          } else {\n            logError('Error fetching user by ID:', userError);\n            throw userError;\n          }\n        } else {\n          user = userData;\n        }\n      } else if (email) {\n        const { data: userData, error: userError } = await supabase\n          .from('users')\n          .select('*')\n          .eq('email', email)\n          .single();\n\n        if (userError) {\n          if (userError.code === 'PGRST116') {\n            // User not found\n            user = null;\n          } else {\n            logError('Error fetching user by email:', userError);\n            throw userError;\n          }\n        } else {\n          user = userData;\n        }\n      }\n\n      if (!user) {\n        return sendErrorResponse(new Error('User not found'), 404);\n      }\n    } catch (userFetchError) {\n      logError('Error in user lookup:', userFetchError);\n      return sendErrorResponse(userFetchError, 500);\n    }\n\n    // Check cache first (unless force refresh is requested)\n    let accounts = [];\n    let useCached = false;\n    let needsRefresh = true;\n\n    if (!shouldForceRefresh) {\n      try {\n        const cacheResult = await getCachedAccounts(supabase, user.id, user.email, user.role);\n        \n        if (cacheResult && cacheResult.accounts && cacheResult.accounts.length > 0) {\n          accounts = cacheResult.accounts;\n          needsRefresh = cacheResult.needsRefresh || false;\n          \n          if (!needsRefresh) {\n            useCached = true;\n          }\n        }\n      } catch (cacheError) {\n        logError('Error getting cached accounts', cacheError);\n        // Continue - will try Salesforce or return empty\n        accounts = [];\n        needsRefresh = true;\n      }\n    }\n\n    // Query Salesforce if cache is stale/missing or force refresh requested\n    // BUT: If we have cached accounts, only try Salesforce if force refresh is explicitly requested\n    // This prevents unnecessary Salesforce calls when we have valid cached data\n    // If cacheOnly is true, never query Salesforce - just return cached accounts (or empty)\n    const shouldTrySalesforce = !(cacheOnly === 'true' || cacheOnly === '1') && \n                                 (needsRefresh || shouldForceRefresh) && \n                                 (shouldForceRefresh || accounts.length === 0);\n    \n    if (shouldTrySalesforce) {\n      try {\n        const sfdcAuth = await authenticateSalesforce(supabase);\n        const sfdcAccounts = await querySalesforceAccounts(\n          sfdcAuth.connection,\n          user.id,\n          user.email,\n          user.role || role,\n          ownerOnly === 'true' || ownerOnly === '1'\n        );\n\n        // Sync accounts to Supabase\n        if (!isProduction()) {\n          log(`Syncing ${sfdcAccounts.length} accounts to Supabase...`);\n        }\n        const syncedAccounts = await syncAccountsToSupabase(supabase, sfdcAccounts, user.id);\n        \n        if (!isProduction()) {\n          log(`Synced ${syncedAccounts.length} accounts to Supabase`);\n        }\n\n        // Transform to expected format\n        accounts = syncedAccounts.map(acc => ({\n          id: acc.salesforce_id || acc.id,\n          salesforceId: acc.salesforce_id,\n          name: acc.name,\n          accountTier: acc.account_tier,\n          contractValue: acc.contract_value,\n          industry: acc.industry,\n          annualRevenue: acc.annual_revenue ? parseFloat(acc.annual_revenue) : null,\n          ownerId: acc.owner_id,\n          ownerName: acc.owner_name,\n          lastSyncedAt: acc.last_synced_at,\n        }));\n        \n        useCached = false;\n      } catch (sfdcError) {\n        logError('Salesforce API error:', sfdcError);\n        logError('Error details:', sfdcError.message);\n        if (sfdcError.stack) {\n          logError('Error stack:', sfdcError.stack);\n        }\n        \n        // If we have cached accounts, use them even if stale\n        if (accounts.length > 0) {\n          logWarn(`Salesforce query failed, using ${accounts.length} cached accounts (may be stale)`);\n          useCached = true;\n        } else {\n          // No cached accounts available\n          // If cacheOnly mode, just return empty array instead of error\n          if (cacheOnly === 'true' || cacheOnly === '1') {\n            log('Cache-only mode: no cached accounts found, returning empty array');\n            return sendSuccessResponse({\n              accounts: [],\n              total: 0,\n              userId: user.id,\n              role: user.role || role || 'Account Manager',\n              cached: false,\n            });\n          }\n          // Otherwise return error\n          logError('No cached accounts available and Salesforce query failed');\n          return sendErrorResponse(new Error('Failed to fetch accounts from Salesforce and no cached accounts available'), 500);\n        }\n      }\n    } else if (accounts.length > 0) {\n      // We have cached accounts and don't need to refresh\n      useCached = true;\n    }\n\n    return sendSuccessResponse({\n      accounts: accounts,\n      total: accounts.length,\n      userId: user.id,\n      role: user.role || role || 'Account Manager',\n      cached: useCached,\n    });\n  } catch (error) {\n    logError('Error in salesforce-accounts function:', error);\n    logError('Error message:', error.message);\n    if (error.stack) {\n      logError('Error stack:', error.stack);\n    }\n    if (error.code) {\n      logError('Error code:', error.code);\n    }\n    if (error.details) {\n      logError('Error details:', error.details);\n    }\n    return sendErrorResponse(error, 500);\n  }\n}\n\n"],"names":[],"mappings":"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"}}]
}